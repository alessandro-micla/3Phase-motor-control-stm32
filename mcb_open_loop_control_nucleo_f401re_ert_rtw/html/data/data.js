var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"mcb_open_loop_control_nucleo_f401re","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'mcb_open_loop_control_nucleo_f401re'.\r\n *\r\n * Model version                  : 9.4\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Feb 16 20:00:16 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"mcb_open_loop_control_nucleo_f401re.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\nvolatile int IsrOverrun = 0;\r\nstatic boolean_T OverrunFlag = 0;\r\nvoid rt_OneStep(void)\r\n{\r\n  /* Check for overrun. Protect OverrunFlag against preemption */\r\n  if (OverrunFlag++) {\r\n    IsrOverrun = 1;\r\n    OverrunFlag--;\r\n    return;\r\n  }\r\n\r\n  __enable_irq();\r\n  mcb_open_loop_control_nucleo_f401re_step();\r\n\r\n  /* Get model outputs here */\r\n  __disable_irq();\r\n  OverrunFlag--;\r\n}\r\n\r\nvolatile boolean_T stopRequested;\r\nvolatile boolean_T runModel;\r\nint main(int argc, char **argv)\r\n{\r\n  float modelBaseRate = 0.2;\r\n  float systemClock = 84.0;\r\n\r\n  /* Initialize variables */\r\n  stopRequested = false;\r\n  runModel = false;\r\n  MW_EnableNVICPeripheral();\r\n\r\n#if !defined(MW_FREERTOS) && defined(MW_MULTI_TASKING_MODE) && (MW_MULTI_TASKING_MODE == 1)\r\n\r\n  MW_ASM (\" SVC #1\");\r\n\r\n#endif\r\n\r\n  ;\r\n\r\n  // Peripheral initialization imported from STM32CubeMX project;\r\n  HAL_Init();\r\n  SystemClock_Config();\r\n  PeriphCommonClock_Config();\r\n  MX_GPIO_Init();\r\n  MX_DMA_Init();\r\n  MX_USART2_UART_Init();\r\n  MX_ADC1_Init();\r\n  MX_TIM1_Init();\r\n  MX_CAN1_Init();\r\n  rtmSetErrorStatus(mcb_open_loop_control_nucleo_M, 0);\r\n  mcb_open_loop_control_nucleo_f401re_configure_interrupts();\r\n  mcb_open_loop_control_nucleo_f401re_initialize();\r\n  __disable_irq();\r\n  ARMCM_SysTick_Config(modelBaseRate);\r\n  runModel =\r\n    rtmGetErrorStatus(mcb_open_loop_control_nucleo_M) == (NULL);\r\n  __enable_irq();\r\n  __enable_irq();\r\n  while (runModel) {\r\n    stopRequested = !(\r\n                      rtmGetErrorStatus(mcb_open_loop_control_nucleo_M) == (NULL));\r\n    if (stopRequested) {\r\n      SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;\r\n    }\r\n\r\n    ;\r\n  }\r\n\r\n  /* Terminate model */\r\n  mcb_open_loop_control_nucleo_f401re_terminate();\r\n\r\n#if !defined(MW_FREERTOS) && !defined(USE_RTX)\r\n\r\n  (void) systemClock;\r\n\r\n#endif\r\n\r\n  ;\r\n  mcb_open_loop_control_nucleo_f401re_unconfigure_interrupts();\r\n  MW_DisableNVICPeripheral();\r\n  __disable_irq();\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"mcb_open_loop_control_nucleo_f401re.c","type":"source","group":"model","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: mcb_open_loop_control_nucleo_f401re.c\r\n *\r\n * Code generated for Simulink model 'mcb_open_loop_control_nucleo_f401re'.\r\n *\r\n * Model version                  : 9.4\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Feb 16 20:00:16 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"mcb_open_loop_control_nucleo_f401re.h\"\r\n#include \"mcb_open_loop_control_nucleo_f401re_types.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"mcb_open_loop_control_nucleo_f401re_private.h\"\r\n#include <math.h>\r\n#include \"arm_math.h\"\r\n#include \"stm_adc_ll.h\"\r\n#include <stddef.h>\r\n#include \"stm_timer_ll.h\"\r\n#include <time.h>\r\n#include <string.h>\r\n#include \"rt_nonfinite.h\"\r\n\r\n/* Block signals (default storage) */\r\nB_mcb_open_loop_control_nucle_T mcb_open_loop_control_nucleo__B;\r\n\r\n/* Block states (default storage) */\r\nDW_mcb_open_loop_control_nucl_T mcb_open_loop_control_nucleo_DW;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_mcb_open_loop_contro_T mcb_open_loop_control_nucleo_M_;\r\nRT_MODEL_mcb_open_loop_contro_T *const mcb_open_loop_control_nucleo_M =\r\n  &mcb_open_loop_control_nucleo_M_;\r\n\r\n/* Forward declaration for local functions */\r\nstatic void mcb_open_lo_PWMOutput_setupImpl(stm32cube_blocks_PWMOutput_mc_T *obj);\r\nstatic void mcb_open_loop__SystemCore_setup(stm32cube_blocks_AnalogInput__T *obj);\r\n\r\n/* Forward declaration for local functions */\r\nstatic real_T mcb_open_loop_control_nucle_now(void);\r\nstatic real_T mcb_open_loop_control_nucle_mod(real_T x);\r\nstatic real_T mcb_open_loop_control_nucl_rand(void);\r\nstatic void mcb_open_lo_PWMOutput_setupImpl(stm32cube_blocks_PWMOutput_mc_T *obj)\r\n{\r\n  TIM_Type_T b;\r\n  boolean_T isSlaveModeTriggerEnabled;\r\n\r\n  /* Start for MATLABSystem: '<S26>/PWM Output' */\r\n  b.PeripheralPtr = TIM1;\r\n  b.isCenterAlignedMode = false;\r\n\r\n  /* Start for MATLABSystem: '<S26>/PWM Output' */\r\n  b.repetitionCounter = 0U;\r\n  obj->TimerHandle = Timer_Handle_Init(&b);\r\n  enableTimerInterrupts(obj->TimerHandle, 0);\r\n  enableTimerChannel1(obj->TimerHandle, ENABLE_CH);\r\n  enableTimerChannel2(obj->TimerHandle, ENABLE_CH);\r\n  enableTimerChannel3(obj->TimerHandle, ENABLE_CH);\r\n  isSlaveModeTriggerEnabled = isSlaveTriggerModeEnabled(obj->TimerHandle);\r\n  if (!isSlaveModeTriggerEnabled) {\r\n    /* Start for MATLABSystem: '<S26>/PWM Output' */\r\n    enableCounter(obj->TimerHandle, false);\r\n  }\r\n}\r\n\r\nstatic void mcb_open_loop__SystemCore_setup(stm32cube_blocks_AnalogInput__T *obj)\r\n{\r\n  ADC_Type_T adcStructLoc;\r\n  obj->isSetupComplete = false;\r\n\r\n  /* Start for MATLABSystem: '<S18>/Analog to Digital Converter' */\r\n  obj->isInitialized = 1;\r\n  adcStructLoc.InternalBufferPtr = (void *)(NULL);\r\n\r\n  /* Start for MATLABSystem: '<S18>/Analog to Digital Converter' */\r\n  adcStructLoc.RegularNoOfConversion = 0U;\r\n  adcStructLoc.peripheralPtr = ADC1;\r\n  adcStructLoc.dmaPeripheralPtr = NULL;\r\n  adcStructLoc.dmastream = 0;\r\n  adcStructLoc.DataTransferMode = ADC_DR_TRANSFER;\r\n  adcStructLoc.DmaTransferMode = ADC_DMA_TRANSFER_LIMITED;\r\n  adcStructLoc.InternalBufferSize = 2U;\r\n  adcStructLoc.InjectedNoOfConversion = 2U;\r\n  obj->ADCHandle = ADC_Handle_Init(&adcStructLoc, ADC_INTERRUPT_MODE, 0,\r\n    ADC_READ, LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS);\r\n  enableADC(obj->ADCHandle);\r\n  startADCConversionForExternalTrigger(obj->ADCHandle, 0);\r\n  obj->isSetupComplete = true;\r\n}\r\n\r\n/* Function for MATLAB Function: '<S49>/MATLAB Function' */\r\nstatic real_T mcb_open_loop_control_nucle_now(void)\r\n{\r\n  time_t rawtime;\r\n  struct tm expl_temp;\r\n  real_T dDateNum;\r\n  int16_T cDaysMonthWise[12];\r\n  cDaysMonthWise[0] = 0;\r\n  cDaysMonthWise[1] = 31;\r\n  cDaysMonthWise[2] = 59;\r\n  cDaysMonthWise[3] = 90;\r\n  cDaysMonthWise[4] = 120;\r\n  cDaysMonthWise[5] = 151;\r\n  cDaysMonthWise[6] = 181;\r\n  cDaysMonthWise[7] = 212;\r\n  cDaysMonthWise[8] = 243;\r\n  cDaysMonthWise[9] = 273;\r\n  cDaysMonthWise[10] = 304;\r\n  cDaysMonthWise[11] = 334;\r\n  time(&rawtime);\r\n  expl_temp = *localtime(&rawtime);\r\n  dDateNum = (((((real_T)(expl_temp.tm_year + 1900) * 365.0 + ceil((real_T)\r\n    (expl_temp.tm_year + 1900) / 4.0)) - ceil((real_T)(expl_temp.tm_year + 1900)\r\n    / 100.0)) + ceil((real_T)(expl_temp.tm_year + 1900) / 400.0)) + (real_T)\r\n              cDaysMonthWise[expl_temp.tm_mon]) + (real_T)expl_temp.tm_mday;\r\n  if (expl_temp.tm_mon + 1 > 2) {\r\n    int32_T r;\r\n    boolean_T guard1;\r\n    if (expl_temp.tm_year + 1900 == 0) {\r\n      r = 0;\r\n    } else {\r\n      r = (int32_T)fmod(expl_temp.tm_year + 1900, 4.0);\r\n      if ((r != 0) && (r < 0)) {\r\n        r += 4;\r\n      }\r\n    }\r\n\r\n    guard1 = false;\r\n    if (r == 0) {\r\n      if (expl_temp.tm_year + 1900 == 0) {\r\n        r = 0;\r\n      } else {\r\n        r = (int32_T)fmod(expl_temp.tm_year + 1900, 100.0);\r\n        if ((r != 0) && (r < 0)) {\r\n          r += 100;\r\n        }\r\n      }\r\n\r\n      if (r != 0) {\r\n        dDateNum++;\r\n      } else {\r\n        guard1 = true;\r\n      }\r\n    } else {\r\n      guard1 = true;\r\n    }\r\n\r\n    if (guard1) {\r\n      if (expl_temp.tm_year + 1900 == 0) {\r\n        r = 0;\r\n      } else {\r\n        r = (int32_T)fmod(expl_temp.tm_year + 1900, 400.0);\r\n        if ((r != 0) && (r < 0)) {\r\n          r += 400;\r\n        }\r\n      }\r\n\r\n      if (r == 0) {\r\n        dDateNum++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return (((real_T)expl_temp.tm_hour * 3600.0 + (real_T)expl_temp.tm_min * 60.0)\r\n          + (real_T)expl_temp.tm_sec) / 86400.0 + dDateNum;\r\n}\r\n\r\n/* Function for MATLAB Function: '<S49>/MATLAB Function' */\r\nstatic real_T mcb_open_loop_control_nucle_mod(real_T x)\r\n{\r\n  real_T r;\r\n  if (rtIsNaN(x)) {\r\n    r = (rtNaN);\r\n  } else if (rtIsInf(x)) {\r\n    r = (rtNaN);\r\n  } else if (x == 0.0) {\r\n    r = 0.0;\r\n  } else {\r\n    r = fmod(x, 2.147483647E+9);\r\n    if (r == 0.0) {\r\n      r = 0.0;\r\n    } else if (r < 0.0) {\r\n      r += 2.147483647E+9;\r\n    }\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\nreal_T rt_roundd_snf(real_T u)\r\n{\r\n  real_T y;\r\n  if (fabs(u) < 4.503599627370496E+15) {\r\n    if (u >= 0.5) {\r\n      y = floor(u + 0.5);\r\n    } else if (u > -0.5) {\r\n      y = u * 0.0;\r\n    } else {\r\n      y = ceil(u - 0.5);\r\n    }\r\n  } else {\r\n    y = u;\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Function for MATLAB Function: '<S49>/MATLAB Function' */\r\nstatic real_T mcb_open_loop_control_nucl_rand(void)\r\n{\r\n  real_T r;\r\n  int32_T k;\r\n  int32_T kk;\r\n  uint32_T b_u[2];\r\n  switch (mcb_open_loop_control_nucleo_DW.method) {\r\n   case 4U:\r\n    {\r\n      uint32_T mti;\r\n      uint32_T y;\r\n      k = (int32_T)(mcb_open_loop_control_nucleo_DW.state_k / 127773U);\r\n      mti = (mcb_open_loop_control_nucleo_DW.state_k - (uint32_T)k * 127773U) *\r\n        16807U;\r\n      y = 2836U * (uint32_T)k;\r\n      if (mti < y) {\r\n        mcb_open_loop_control_nucleo_DW.state_k = ~(y - mti) & 2147483647U;\r\n      } else {\r\n        mcb_open_loop_control_nucleo_DW.state_k = mti - y;\r\n      }\r\n\r\n      r = (real_T)mcb_open_loop_control_nucleo_DW.state_k *\r\n        4.6566128752457969E-10;\r\n    }\r\n    break;\r\n\r\n   case 5U:\r\n    {\r\n      uint32_T mti;\r\n      uint32_T y;\r\n      mti = 69069U * mcb_open_loop_control_nucleo_DW.state_e[0] + 1234567U;\r\n      y = mcb_open_loop_control_nucleo_DW.state_e[1] << 13 ^\r\n        mcb_open_loop_control_nucleo_DW.state_e[1];\r\n      y ^= y >> 17;\r\n      y ^= y << 5;\r\n      mcb_open_loop_control_nucleo_DW.state_e[0] = mti;\r\n      mcb_open_loop_control_nucleo_DW.state_e[1] = y;\r\n      r = (real_T)(mti + y) * 2.328306436538696E-10;\r\n    }\r\n    break;\r\n\r\n   default:\r\n    {\r\n      uint32_T mti;\r\n      uint32_T y;\r\n\r\n      /* ========================= COPYRIGHT NOTICE ============================ */\r\n      /*  This is a uniform (0,1) pseudorandom number generator based on: */\r\n      /*  */\r\n      /*  A C-program for MT19937, with initialization improved 2002/1/26. */\r\n      /*  Coded by Takuji Nishimura and Makoto Matsumoto. */\r\n      /*  */\r\n      /*  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura, */\r\n      /*  All rights reserved. */\r\n      /*  */\r\n      /*  Redistribution and use in source and binary forms, with or without */\r\n      /*  modification, are permitted provided that the following conditions */\r\n      /*  are met: */\r\n      /*  */\r\n      /*    1. Redistributions of source code must retain the above copyright */\r\n      /*       notice, this list of conditions and the following disclaimer. */\r\n      /*  */\r\n      /*    2. Redistributions in binary form must reproduce the above copyright */\r\n      /*       notice, this list of conditions and the following disclaimer */\r\n      /*       in the documentation and/or other materials provided with the */\r\n      /*       distribution. */\r\n      /*  */\r\n      /*    3. The names of its contributors may not be used to endorse or */\r\n      /*       promote products derived from this software without specific */\r\n      /*       prior written permission. */\r\n      /*  */\r\n      /*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS */\r\n      /*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT */\r\n      /*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR */\r\n      /*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT */\r\n      /*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, */\r\n      /*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT */\r\n      /*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, */\r\n      /*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY */\r\n      /*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT */\r\n      /*  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE */\r\n      /*  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\r\n      /*  */\r\n      /* =============================   END   ================================= */\r\n      int32_T exitg1;\r\n      do {\r\n        exitg1 = 0;\r\n        for (k = 0; k < 2; k++) {\r\n          mti = mcb_open_loop_control_nucleo_DW.state[624] + 1U;\r\n          if (mcb_open_loop_control_nucleo_DW.state[624] + 1U >= 625U) {\r\n            for (kk = 0; kk < 227; kk++) {\r\n              mti = (mcb_open_loop_control_nucleo_DW.state[kk + 1] & 2147483647U)\r\n                | (mcb_open_loop_control_nucleo_DW.state[kk] & 2147483648U);\r\n              if ((mti & 1U) == 0U) {\r\n                mti >>= 1U;\r\n              } else {\r\n                mti = mti >> 1U ^ 2567483615U;\r\n              }\r\n\r\n              mcb_open_loop_control_nucleo_DW.state[kk] =\r\n                mcb_open_loop_control_nucleo_DW.state[kk + 397] ^ mti;\r\n            }\r\n\r\n            for (kk = 0; kk < 396; kk++) {\r\n              mti = (mcb_open_loop_control_nucleo_DW.state[kk + 227] &\r\n                     2147483648U) | (mcb_open_loop_control_nucleo_DW.state[kk +\r\n                228] & 2147483647U);\r\n              if ((mti & 1U) == 0U) {\r\n                mti >>= 1U;\r\n              } else {\r\n                mti = mti >> 1U ^ 2567483615U;\r\n              }\r\n\r\n              mcb_open_loop_control_nucleo_DW.state[kk + 227] =\r\n                mcb_open_loop_control_nucleo_DW.state[kk] ^ mti;\r\n            }\r\n\r\n            mti = (mcb_open_loop_control_nucleo_DW.state[623] & 2147483648U) |\r\n              (mcb_open_loop_control_nucleo_DW.state[0] & 2147483647U);\r\n            if ((mti & 1U) == 0U) {\r\n              mti >>= 1U;\r\n            } else {\r\n              mti = mti >> 1U ^ 2567483615U;\r\n            }\r\n\r\n            mcb_open_loop_control_nucleo_DW.state[623] =\r\n              mcb_open_loop_control_nucleo_DW.state[396] ^ mti;\r\n            mti = 1U;\r\n          }\r\n\r\n          y = mcb_open_loop_control_nucleo_DW.state[(int32_T)mti - 1];\r\n          mcb_open_loop_control_nucleo_DW.state[624] = mti;\r\n          y ^= y >> 11U;\r\n          y ^= y << 7U & 2636928640U;\r\n          y ^= y << 15U & 4022730752U;\r\n          b_u[k] = y >> 18U ^ y;\r\n        }\r\n\r\n        mti = b_u[0] >> 5U;\r\n        y = b_u[1] >> 6U;\r\n        if ((mti == 0U) && (y == 0U)) {\r\n          boolean_T b_isvalid;\r\n          b_isvalid = ((mcb_open_loop_control_nucleo_DW.state[624] >= 1U) &&\r\n                       (mcb_open_loop_control_nucleo_DW.state[624] < 625U));\r\n          if (b_isvalid) {\r\n            boolean_T exitg2;\r\n            b_isvalid = false;\r\n            k = 1;\r\n            exitg2 = false;\r\n            while ((!exitg2) && (k < 625)) {\r\n              if (mcb_open_loop_control_nucleo_DW.state[k - 1] == 0U) {\r\n                k++;\r\n              } else {\r\n                b_isvalid = true;\r\n                exitg2 = true;\r\n              }\r\n            }\r\n          }\r\n\r\n          if (!b_isvalid) {\r\n            mti = 5489U;\r\n            mcb_open_loop_control_nucleo_DW.state[0] = 5489U;\r\n            for (k = 0; k < 623; k++) {\r\n              mti = ((mti >> 30U ^ mti) * 1812433253U + (uint32_T)k) + 1U;\r\n              mcb_open_loop_control_nucleo_DW.state[k + 1] = mti;\r\n            }\r\n\r\n            mcb_open_loop_control_nucleo_DW.state[624] = 624U;\r\n          }\r\n        } else {\r\n          exitg1 = 1;\r\n        }\r\n      } while (exitg1 == 0);\r\n\r\n      r = ((real_T)mti * 6.7108864E+7 + (real_T)y) * 1.1102230246251565E-16;\r\n    }\r\n    break;\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\n/* Model step function */\r\nvoid mcb_open_loop_control_nucleo_f401re_step(void)\r\n{\r\n  time_t b_eTime;\r\n  time_t eTime;\r\n  real_T b_y;\r\n  real_T y;\r\n  int32_T b_r;\r\n  int32_T exitg1;\r\n  int32_T t;\r\n  uint32_T r;\r\n  int16_T rtb_Switch_a;\r\n  uint8_T rtb_TmpSignalConversionAtCANWri[4];\r\n  uint8_T rtb_ByteUnpack;\r\n  uint8_T rtb_ByteUnpack1;\r\n  uint8_T rtb_ByteUnpack2;\r\n  uint8_T rtb_ByteUnpack3;\r\n  boolean_T rtb_DataTypeConversion1_d;\r\n\r\n  /* MATLABSystem: '<S1>/CAN Read' */\r\n  MW_CAN_ReceiveMessage(mcb_open_loop_control_nucleo_DW.obj.MW_CAN_HANDLE, 0,\r\n                        &mcb_open_loop_control_nucleo__B.CANRead.Data[0],\r\n                        &mcb_open_loop_control_nucleo__B.CANRead.ID,\r\n                        &mcb_open_loop_control_nucleo__B.CANRead.Extended,\r\n                        &mcb_open_loop_control_nucleo__B.CANRead.Remote,\r\n                        &mcb_open_loop_control_nucleo__B.CANRead.Length, 1U, &r);\r\n  mcb_open_loop_control_nucleo__B.CANRead.Error = 0U;\r\n  mcb_open_loop_control_nucleo__B.CANRead.Timestamp = 0.0;\r\n\r\n  /* S-Function (scanunpack): '<S1>/CAN Unpack' */\r\n  {\r\n    /* S-Function (scanunpack): '<S1>/CAN Unpack' */\r\n    if ((4 == mcb_open_loop_control_nucleo__B.CANRead.Length) &&\r\n        (mcb_open_loop_control_nucleo__B.CANRead.ID != INVALID_CAN_ID) ) {\r\n      if ((544 == mcb_open_loop_control_nucleo__B.CANRead.ID) && (0U ==\r\n           mcb_open_loop_control_nucleo__B.CANRead.Extended) ) {\r\n        (void) memcpy(&mcb_open_loop_control_nucleo__B.CANUnpack[0],\r\n                      mcb_open_loop_control_nucleo__B.CANRead.Data,\r\n                      4 * sizeof(uint8_T));\r\n      }\r\n    }\r\n  }\r\n\r\n  /* SignalConversion generated from: '<S2>/CAN Write' incorporates:\r\n   *  ArithShift: '<S6>/Shift Arithmetic'\r\n   *  Constant: '<Root>/Number ID ECU1'\r\n   *  DataTypeConversion: '<S6>/Data Type Conversion3'\r\n   */\r\n  rtb_TmpSignalConversionAtCANWri[0] = (uint8_T)\r\n    (mcb_open_loop_control_nucleo__P.NumberIDECU1_Value >> 8);\r\n\r\n  /* S-Function (byte2any_svd): '<S1>/Byte Unpack1' */\r\n\r\n  /* Unpack: <S1>/Byte Unpack1 */\r\n  {\r\n    uint32_T MW_inputPortOffset = 0U;\r\n    uint16_T MW_outputPortWidth = 0U;\r\n\r\n    /* Packed input data type - uint8_T */\r\n    void* unpackData = &mcb_open_loop_control_nucleo__B.CANUnpack[1];\r\n\r\n    /* Unpacking the values to output 1 */\r\n    /* Output data type - uint8_T, size - 1 */\r\n    {\r\n      MW_outputPortWidth = sizeof(uint8_T);\r\n      memcpy((void*)&rtb_ByteUnpack1, (void *)&(((uint8_T *)unpackData)\r\n              [MW_inputPortOffset]), MW_outputPortWidth);\r\n    }\r\n  }\r\n\r\n  /* S-Function (byte2any_svd): '<S1>/Byte Unpack3' */\r\n\r\n  /* Unpack: <S1>/Byte Unpack3 */\r\n  {\r\n    uint32_T MW_inputPortOffset = 0U;\r\n    uint16_T MW_outputPortWidth = 0U;\r\n\r\n    /* Packed input data type - uint8_T */\r\n    void* unpackData = &mcb_open_loop_control_nucleo__B.CANUnpack[2];\r\n\r\n    /* Unpacking the values to output 1 */\r\n    /* Output data type - uint8_T, size - 1 */\r\n    {\r\n      MW_outputPortWidth = sizeof(uint8_T);\r\n      memcpy((void*)&rtb_ByteUnpack3, (void *)&(((uint8_T *)unpackData)\r\n              [MW_inputPortOffset]), MW_outputPortWidth);\r\n    }\r\n  }\r\n\r\n  /* S-Function (byte2any_svd): '<S1>/Byte Unpack' */\r\n\r\n  /* Unpack: <S1>/Byte Unpack */\r\n  {\r\n    uint32_T MW_inputPortOffset = 0U;\r\n    uint16_T MW_outputPortWidth = 0U;\r\n\r\n    /* Packed input data type - uint8_T */\r\n    void* unpackData = &mcb_open_loop_control_nucleo__B.CANUnpack[0];\r\n\r\n    /* Unpacking the values to output 1 */\r\n    /* Output data type - uint8_T, size - 1 */\r\n    {\r\n      MW_outputPortWidth = sizeof(uint8_T);\r\n      memcpy((void*)&rtb_ByteUnpack, (void *)&(((uint8_T *)unpackData)\r\n              [MW_inputPortOffset]), MW_outputPortWidth);\r\n    }\r\n  }\r\n\r\n  /* S-Function (byte2any_svd): '<S1>/Byte Unpack2' */\r\n\r\n  /* Unpack: <S1>/Byte Unpack2 */\r\n  {\r\n    uint32_T MW_inputPortOffset = 0U;\r\n    uint16_T MW_outputPortWidth = 0U;\r\n\r\n    /* Packed input data type - uint8_T */\r\n    void* unpackData = &mcb_open_loop_control_nucleo__B.CANUnpack[3];\r\n\r\n    /* Unpacking the values to output 1 */\r\n    /* Output data type - uint8_T, size - 1 */\r\n    {\r\n      MW_outputPortWidth = sizeof(uint8_T);\r\n      memcpy((void*)&rtb_ByteUnpack2, (void *)&(((uint8_T *)unpackData)\r\n              [MW_inputPortOffset]), MW_outputPortWidth);\r\n    }\r\n  }\r\n\r\n  /* MATLAB Function: '<S49>/MATLAB Function' */\r\n  if (!mcb_open_loop_control_nucleo_DW.r_not_empty) {\r\n    y = mcb_open_loop_control_nucle_now() * 8.64E+6;\r\n    y = mcb_open_loop_control_nucle_mod(floor(y));\r\n    eTime = time(NULL);\r\n    do {\r\n      exitg1 = 0;\r\n      b_eTime = time(NULL);\r\n      if ((int32_T)b_eTime <= (int32_T)eTime + 1) {\r\n        b_y = mcb_open_loop_control_nucle_now() * 8.64E+6;\r\n        b_y = floor(b_y);\r\n        if (y != mcb_open_loop_control_nucle_mod(b_y)) {\r\n          exitg1 = 1;\r\n        }\r\n      } else {\r\n        exitg1 = 1;\r\n      }\r\n    } while (exitg1 == 0);\r\n\r\n    y = rt_roundd_snf(y);\r\n    if (y < 4.294967296E+9) {\r\n      if (y >= 0.0) {\r\n        r = (uint32_T)y;\r\n      } else {\r\n        r = 0U;\r\n      }\r\n    } else {\r\n      r = MAX_uint32_T;\r\n    }\r\n\r\n    switch (mcb_open_loop_control_nucleo_DW.method) {\r\n     case 7U:\r\n      mcb_open_loop_control_nucleo_DW.state[0] = r;\r\n      for (b_r = 0; b_r < 623; b_r++) {\r\n        r = ((r >> 30U ^ r) * 1812433253U + (uint32_T)b_r) + 1U;\r\n        mcb_open_loop_control_nucleo_DW.state[b_r + 1] = r;\r\n      }\r\n\r\n      mcb_open_loop_control_nucleo_DW.state[624] = 624U;\r\n      break;\r\n\r\n     case 5U:\r\n      mcb_open_loop_control_nucleo_DW.state_e[0] = 362436069U;\r\n      mcb_open_loop_control_nucleo_DW.state_e[1] = r;\r\n      if (mcb_open_loop_control_nucleo_DW.state_e[1] == 0U) {\r\n        mcb_open_loop_control_nucleo_DW.state_e[1] = 521288629U;\r\n      }\r\n      break;\r\n\r\n     case 4U:\r\n      b_r = (int32_T)(r >> 16U);\r\n      t = (int32_T)(r & 32768U);\r\n      mcb_open_loop_control_nucleo_DW.state_k = (uint32_T)b_r << 16U;\r\n      mcb_open_loop_control_nucleo_DW.state_k = r -\r\n        mcb_open_loop_control_nucleo_DW.state_k;\r\n      mcb_open_loop_control_nucleo_DW.state_k -= (uint32_T)t;\r\n      mcb_open_loop_control_nucleo_DW.state_k <<= 16U;\r\n      mcb_open_loop_control_nucleo_DW.state_k += (uint32_T)t;\r\n      mcb_open_loop_control_nucleo_DW.state_k += (uint32_T)b_r;\r\n      if (mcb_open_loop_control_nucleo_DW.state_k < 1U) {\r\n        mcb_open_loop_control_nucleo_DW.state_k = 1144108930U;\r\n      } else if (mcb_open_loop_control_nucleo_DW.state_k > 2147483646U) {\r\n        mcb_open_loop_control_nucleo_DW.state_k = 2147483646U;\r\n      }\r\n      break;\r\n    }\r\n\r\n    y = mcb_open_loop_control_nucl_rand();\r\n    mcb_open_loop_control_nucleo_DW.r = floor(y * 201.0);\r\n    mcb_open_loop_control_nucleo_DW.r_not_empty = true;\r\n  }\r\n\r\n  /* SignalConversion generated from: '<S2>/CAN Write' incorporates:\r\n   *  Constant: '<Root>/Number Control Safety'\r\n   *  Constant: '<Root>/Number ID ECU1'\r\n   *  DataTypeConversion: '<S49>/Data Type Conversion'\r\n   *  DataTypeConversion: '<S6>/Data Type Conversion2'\r\n   *  MATLAB Function: '<S49>/MATLAB Function'\r\n   *  S-Function (sfix_bitop): '<S6>/Bitwise OR'\r\n   *  Sum: '<S49>/Sum'\r\n   */\r\n  rtb_TmpSignalConversionAtCANWri[1] = (uint8_T)((uint32_T)\r\n    mcb_open_loop_control_nucleo__P.NumberIDECU1_Value &\r\n    mcb_open_loop_control_nucleo__P.BitwiseOR_BitMask);\r\n  rtb_TmpSignalConversionAtCANWri[2] = (uint8_T)\r\n    mcb_open_loop_control_nucleo_DW.r;\r\n  rtb_TmpSignalConversionAtCANWri[3] = (uint8_T)((uint8_T)\r\n    mcb_open_loop_control_nucleo_DW.r +\r\n    mcb_open_loop_control_nucleo__P.NumberControlSafety_Value);\r\n\r\n  /* MATLABSystem: '<S2>/CAN Write' */\r\n  MW_CAN_TransmitMessage(mcb_open_loop_control_nucleo_DW.obj_h.MW_CAN_HANDLE,\r\n    &rtb_TmpSignalConversionAtCANWri[0], 545U, 0, 0, 4, 100U, &r);\r\n\r\n  /* DataTypeConversion: '<S1>/Data Type Conversion1' incorporates:\r\n   *  DataTypeConversion: '<S8>/Extract Desired Bits'\r\n   */\r\n  rtb_DataTypeConversion1_d = ((rtb_ByteUnpack & 1U) != 0U);\r\n\r\n  /* RateTransition generated from: '<S1>/Data Type Conversion1' */\r\n  mcb_open_loop_control_nucleo_DW.TmpRTBAtDataTypeConversion1Outp =\r\n    rtb_DataTypeConversion1_d;\r\n\r\n  /* Switch: '<S3>/Switch' incorporates:\r\n   *  BitConcat: '<S7>/BitConcat2'\r\n   *  DataTypeConversion: '<S1>/Data Type Conversion2'\r\n   *  DataTypeConversion: '<S9>/Extract Desired Bits'\r\n   *  Gain: '<S3>/Gain'\r\n   */\r\n  if ((rtb_ByteUnpack2 & 1U) != 0U) {\r\n    rtb_Switch_a = (int16_T)(rtb_ByteUnpack1 << 8 | rtb_ByteUnpack3);\r\n  } else {\r\n    rtb_Switch_a = (int16_T)((uint16_T)(rtb_ByteUnpack1 << 8 | rtb_ByteUnpack3) *\r\n      mcb_open_loop_control_nucleo__P.Gain_Gain_m);\r\n  }\r\n\r\n  /* End of Switch: '<S3>/Switch' */\r\n\r\n  /* RateTransition generated from: '<Root>/Open Loop Control' */\r\n  mcb_open_loop_control_nucleo_DW.TmpRTBAtOpenLoopControlInport2_ = rtb_Switch_a;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid mcb_open_loop_control_nucleo_f401re_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize error status */\r\n  rtmSetErrorStatus(mcb_open_loop_control_nucleo_M, (NULL));\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) &mcb_open_loop_control_nucleo__B), 0,\r\n                sizeof(B_mcb_open_loop_control_nucle_T));\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&mcb_open_loop_control_nucleo_DW, 0,\r\n                sizeof(DW_mcb_open_loop_control_nucl_T));\r\n\r\n  {\r\n    static const uint32_T tmp[625] = { 5489U, 1301868182U, 2938499221U,\r\n      2950281878U, 1875628136U, 751856242U, 944701696U, 2243192071U, 694061057U,\r\n      219885934U, 2066767472U, 3182869408U, 485472502U, 2336857883U, 1071588843U,\r\n      3418470598U, 951210697U, 3693558366U, 2923482051U, 1793174584U,\r\n      2982310801U, 1586906132U, 1951078751U, 1808158765U, 1733897588U,\r\n      431328322U, 4202539044U, 530658942U, 1714810322U, 3025256284U, 3342585396U,\r\n      1937033938U, 2640572511U, 1654299090U, 3692403553U, 4233871309U,\r\n      3497650794U, 862629010U, 2943236032U, 2426458545U, 1603307207U,\r\n      1133453895U, 3099196360U, 2208657629U, 2747653927U, 931059398U, 761573964U,\r\n      3157853227U, 785880413U, 730313442U, 124945756U, 2937117055U, 3295982469U,\r\n      1724353043U, 3021675344U, 3884886417U, 4010150098U, 4056961966U,\r\n      699635835U, 2681338818U, 1339167484U, 720757518U, 2800161476U, 2376097373U,\r\n      1532957371U, 3902664099U, 1238982754U, 3725394514U, 3449176889U,\r\n      3570962471U, 4287636090U, 4087307012U, 3603343627U, 202242161U,\r\n      2995682783U, 1620962684U, 3704723357U, 371613603U, 2814834333U,\r\n      2111005706U, 624778151U, 2094172212U, 4284947003U, 1211977835U, 991917094U,\r\n      1570449747U, 2962370480U, 1259410321U, 170182696U, 146300961U, 2836829791U,\r\n      619452428U, 2723670296U, 1881399711U, 1161269684U, 1675188680U,\r\n      4132175277U, 780088327U, 3409462821U, 1036518241U, 1834958505U,\r\n      3048448173U, 161811569U, 618488316U, 44795092U, 3918322701U, 1924681712U,\r\n      3239478144U, 383254043U, 4042306580U, 2146983041U, 3992780527U,\r\n      3518029708U, 3545545436U, 3901231469U, 1896136409U, 2028528556U,\r\n      2339662006U, 501326714U, 2060962201U, 2502746480U, 561575027U, 581893337U,\r\n      3393774360U, 1778912547U, 3626131687U, 2175155826U, 319853231U, 986875531U,\r\n      819755096U, 2915734330U, 2688355739U, 3482074849U, 2736559U, 2296975761U,\r\n      1029741190U, 2876812646U, 690154749U, 579200347U, 4027461746U, 1285330465U,\r\n      2701024045U, 4117700889U, 759495121U, 3332270341U, 2313004527U,\r\n      2277067795U, 4131855432U, 2722057515U, 1264804546U, 3848622725U,\r\n      2211267957U, 4100593547U, 959123777U, 2130745407U, 3194437393U, 486673947U,\r\n      1377371204U, 17472727U, 352317554U, 3955548058U, 159652094U, 1232063192U,\r\n      3835177280U, 49423123U, 3083993636U, 733092U, 2120519771U, 2573409834U,\r\n      1112952433U, 3239502554U, 761045320U, 1087580692U, 2540165110U, 641058802U,\r\n      1792435497U, 2261799288U, 1579184083U, 627146892U, 2165744623U,\r\n      2200142389U, 2167590760U, 2381418376U, 1793358889U, 3081659520U,\r\n      1663384067U, 2009658756U, 2689600308U, 739136266U, 2304581039U,\r\n      3529067263U, 591360555U, 525209271U, 3131882996U, 294230224U, 2076220115U,\r\n      3113580446U, 1245621585U, 1386885462U, 3203270426U, 123512128U, 12350217U,\r\n      354956375U, 4282398238U, 3356876605U, 3888857667U, 157639694U, 2616064085U,\r\n      1563068963U, 2762125883U, 4045394511U, 4180452559U, 3294769488U,\r\n      1684529556U, 1002945951U, 3181438866U, 22506664U, 691783457U, 2685221343U,\r\n      171579916U, 3878728600U, 2475806724U, 2030324028U, 3331164912U,\r\n      1708711359U, 1970023127U, 2859691344U, 2588476477U, 2748146879U,\r\n      136111222U, 2967685492U, 909517429U, 2835297809U, 3206906216U, 3186870716U,\r\n      341264097U, 2542035121U, 3353277068U, 548223577U, 3170936588U, 1678403446U,\r\n      297435620U, 2337555430U, 466603495U, 1132321815U, 1208589219U, 696392160U,\r\n      894244439U, 2562678859U, 470224582U, 3306867480U, 201364898U, 2075966438U,\r\n      1767227936U, 2929737987U, 3674877796U, 2654196643U, 3692734598U,\r\n      3528895099U, 2796780123U, 3048728353U, 842329300U, 191554730U, 2922459673U,\r\n      3489020079U, 3979110629U, 1022523848U, 2202932467U, 3583655201U,\r\n      3565113719U, 587085778U, 4176046313U, 3013713762U, 950944241U, 396426791U,\r\n      3784844662U, 3477431613U, 3594592395U, 2782043838U, 3392093507U,\r\n      3106564952U, 2829419931U, 1358665591U, 2206918825U, 3170783123U, 31522386U,\r\n      2988194168U, 1782249537U, 1105080928U, 843500134U, 1225290080U,\r\n      1521001832U, 3605886097U, 2802786495U, 2728923319U, 3996284304U,\r\n      903417639U, 1171249804U, 1020374987U, 2824535874U, 423621996U, 1988534473U,\r\n      2493544470U, 1008604435U, 1756003503U, 1488867287U, 1386808992U,\r\n      732088248U, 1780630732U, 2482101014U, 976561178U, 1543448953U, 2602866064U,\r\n      2021139923U, 1952599828U, 2360242564U, 2117959962U, 2753061860U,\r\n      2388623612U, 4138193781U, 2962920654U, 2284970429U, 766920861U,\r\n      3457264692U, 2879611383U, 815055854U, 2332929068U, 1254853997U,\r\n      3740375268U, 3799380844U, 4091048725U, 2006331129U, 1982546212U,\r\n      686850534U, 1907447564U, 2682801776U, 2780821066U, 998290361U, 1342433871U,\r\n      4195430425U, 607905174U, 3902331779U, 2454067926U, 1708133115U,\r\n      1170874362U, 2008609376U, 3260320415U, 2211196135U, 433538229U,\r\n      2728786374U, 2189520818U, 262554063U, 1182318347U, 3710237267U,\r\n      1221022450U, 715966018U, 2417068910U, 2591870721U, 2870691989U,\r\n      3418190842U, 4238214053U, 1540704231U, 1575580968U, 2095917976U,\r\n      4078310857U, 2313532447U, 2110690783U, 4056346629U, 4061784526U,\r\n      1123218514U, 551538993U, 597148360U, 4120175196U, 3581618160U, 3181170517U,\r\n      422862282U, 3227524138U, 1713114790U, 662317149U, 1230418732U, 928171837U,\r\n      1324564878U, 1928816105U, 1786535431U, 2878099422U, 3290185549U,\r\n      539474248U, 1657512683U, 552370646U, 1671741683U, 3655312128U, 1552739510U,\r\n      2605208763U, 1441755014U, 181878989U, 3124053868U, 1447103986U,\r\n      3183906156U, 1728556020U, 3502241336U, 3055466967U, 1013272474U,\r\n      818402132U, 1715099063U, 2900113506U, 397254517U, 4194863039U, 1009068739U,\r\n      232864647U, 2540223708U, 2608288560U, 2415367765U, 478404847U, 3455100648U,\r\n      3182600021U, 2115988978U, 434269567U, 4117179324U, 3461774077U, 887256537U,\r\n      3545801025U, 286388911U, 3451742129U, 1981164769U, 786667016U, 3310123729U,\r\n      3097811076U, 2224235657U, 2959658883U, 3370969234U, 2514770915U,\r\n      3345656436U, 2677010851U, 2206236470U, 271648054U, 2342188545U,\r\n      4292848611U, 3646533909U, 3754009956U, 3803931226U, 4160647125U,\r\n      1477814055U, 4043852216U, 1876372354U, 3133294443U, 3871104810U,\r\n      3177020907U, 2074304428U, 3479393793U, 759562891U, 164128153U, 1839069216U,\r\n      2114162633U, 3989947309U, 3611054956U, 1333547922U, 835429831U, 494987340U,\r\n      171987910U, 1252001001U, 370809172U, 3508925425U, 2535703112U, 1276855041U,\r\n      1922855120U, 835673414U, 3030664304U, 613287117U, 171219893U, 3423096126U,\r\n      3376881639U, 2287770315U, 1658692645U, 1262815245U, 3957234326U,\r\n      1168096164U, 2968737525U, 2655813712U, 2132313144U, 3976047964U,\r\n      326516571U, 353088456U, 3679188938U, 3205649712U, 2654036126U, 1249024881U,\r\n      880166166U, 691800469U, 2229503665U, 1673458056U, 4032208375U, 1851778863U,\r\n      2563757330U, 376742205U, 1794655231U, 340247333U, 1505873033U, 396524441U,\r\n      879666767U, 3335579166U, 3260764261U, 3335999539U, 506221798U, 4214658741U,\r\n      975887814U, 2080536343U, 3360539560U, 571586418U, 138896374U, 4234352651U,\r\n      2737620262U, 3928362291U, 1516365296U, 38056726U, 3599462320U, 3585007266U,\r\n      3850961033U, 471667319U, 1536883193U, 2310166751U, 1861637689U,\r\n      2530999841U, 4139843801U, 2710569485U, 827578615U, 2012334720U,\r\n      2907369459U, 3029312804U, 2820112398U, 1965028045U, 35518606U, 2478379033U,\r\n      643747771U, 1924139484U, 4123405127U, 3811735531U, 3429660832U,\r\n      3285177704U, 1948416081U, 1311525291U, 1183517742U, 1739192232U,\r\n      3979815115U, 2567840007U, 4116821529U, 213304419U, 4125718577U,\r\n      1473064925U, 2442436592U, 1893310111U, 4195361916U, 3747569474U,\r\n      828465101U, 2991227658U, 750582866U, 1205170309U, 1409813056U, 678418130U,\r\n      1171531016U, 3821236156U, 354504587U, 4202874632U, 3882511497U,\r\n      1893248677U, 1903078632U, 26340130U, 2069166240U, 3657122492U, 3725758099U,\r\n      831344905U, 811453383U, 3447711422U, 2434543565U, 4166886888U, 3358210805U,\r\n      4142984013U, 2988152326U, 3527824853U, 982082992U, 2809155763U, 190157081U,\r\n      3340214818U, 2365432395U, 2548636180U, 2894533366U, 3474657421U,\r\n      2372634704U, 2845748389U, 43024175U, 2774226648U, 1987702864U, 3186502468U,\r\n      453610222U, 4204736567U, 1392892630U, 2471323686U, 2470534280U,\r\n      3541393095U, 4269885866U, 3909911300U, 759132955U, 1482612480U, 667715263U,\r\n      1795580598U, 2337923983U, 3390586366U, 581426223U, 1515718634U, 476374295U,\r\n      705213300U, 363062054U, 2084697697U, 2407503428U, 2292957699U, 2426213835U,\r\n      2199989172U, 1987356470U, 4026755612U, 2147252133U, 270400031U,\r\n      1367820199U, 2369854699U, 2844269403U, 79981964U, 624U };\r\n\r\n    /* Start for S-Function (scanunpack): '<S1>/CAN Unpack' */\r\n\r\n    /*-----------S-Function Block: <S1>/CAN Unpack -----------------*/\r\n\r\n    /* InitializeConditions for RateTransition generated from: '<S1>/Data Type Conversion1' */\r\n    mcb_open_loop_control_nucleo_DW.TmpRTBAtDataTypeConversion1Outp =\r\n      mcb_open_loop_control_nucleo__P.TmpRTBAtDataTypeConversion1Outp;\r\n\r\n    /* InitializeConditions for RateTransition generated from: '<Root>/Open Loop Control' */\r\n    mcb_open_loop_control_nucleo_DW.TmpRTBAtOpenLoopControlInport2_ =\r\n      mcb_open_loop_control_nucleo__P.TmpRTBAtOpenLoopControlInport2_;\r\n\r\n    /* SystemInitialize for S-Function (HardwareInterrupt_sfun): '<S11>/Hardware Interrupt' incorporates:\r\n     *  SubSystem: '<Root>/Open Loop Control'\r\n     */\r\n\r\n    /* System initialize for function-call system: '<Root>/Open Loop Control' */\r\n\r\n    /* InitializeConditions for DiscreteIntegrator: '<S29>/Ramp Generator' */\r\n    mcb_open_loop_control_nucleo_DW.RampGenerator_DSTATE =\r\n      mcb_open_loop_control_nucleo__P.RampGenerator_IC;\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S31>/Accumulate' */\r\n    /* InitializeConditions for Delay: '<S47>/Delay' */\r\n    mcb_open_loop_control_nucleo_DW.Delay_DSTATE =\r\n      mcb_open_loop_control_nucleo__P.Delay_InitialCondition;\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S47>/Subsystem' */\r\n    /* SystemInitialize for SignalConversion generated from: '<S48>/Input' incorporates:\r\n     *  Outport: '<S48>/Out1'\r\n     */\r\n    mcb_open_loop_control_nucleo__B.Input =\r\n      mcb_open_loop_control_nucleo__P.Out1_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S47>/Subsystem' */\r\n\r\n    /* SystemInitialize for Outport: '<S47>/theta_e' incorporates:\r\n     *  Sum: '<S47>/Add1'\r\n     *  UnitDelay: '<S31>/Unit Delay'\r\n     */\r\n    mcb_open_loop_control_nucleo_DW.UnitDelay_DSTATE =\r\n      mcb_open_loop_control_nucleo__P.theta_e_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S31>/Accumulate' */\r\n\r\n    /* Start for MATLABSystem: '<S26>/PWM Output' */\r\n    mcb_open_loop_control_nucleo_DW.obj_f.matlabCodegenIsDeleted = false;\r\n    mcb_open_loop_control_nucleo_DW.obj_f.isSetupComplete = false;\r\n    mcb_open_loop_control_nucleo_DW.obj_f.isInitialized = 1;\r\n    mcb_open_lo_PWMOutput_setupImpl(&mcb_open_loop_control_nucleo_DW.obj_f);\r\n    mcb_open_loop_control_nucleo_DW.obj_f.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<S18>/Analog to Digital Converter' */\r\n    mcb_open_loop_control_nucleo_DW.obj_k.isInitialized = 0;\r\n    mcb_open_loop_control_nucleo_DW.obj_k.matlabCodegenIsDeleted = false;\r\n    mcb_open_loop__SystemCore_setup(&mcb_open_loop_control_nucleo_DW.obj_k);\r\n\r\n    /* End of SystemInitialize for S-Function (HardwareInterrupt_sfun): '<S11>/Hardware Interrupt' */\r\n\r\n    /* SystemInitialize for MATLAB Function: '<S49>/MATLAB Function' */\r\n    memcpy(&mcb_open_loop_control_nucleo_DW.state[0], &tmp[0], 625U * sizeof\r\n           (uint32_T));\r\n    mcb_open_loop_control_nucleo_DW.r_not_empty = false;\r\n    mcb_open_loop_control_nucleo_DW.method = 7U;\r\n    mcb_open_loop_control_nucleo_DW.state_e[0] = 362436069U;\r\n    mcb_open_loop_control_nucleo_DW.state_e[1] = 521288629U;\r\n    mcb_open_loop_control_nucleo_DW.state_k = 1144108930U;\r\n\r\n    /* Start for MATLABSystem: '<S1>/CAN Read' */\r\n    mcb_open_loop_control_nucleo_DW.obj.matlabCodegenIsDeleted = false;\r\n    mcb_open_loop_control_nucleo_DW.obj.isInitialized = 1;\r\n    mcb_open_loop_control_nucleo_DW.obj.MW_CAN_HANDLE = MW_CAN_Initialize(0);\r\n    MW_configureCANFilter(mcb_open_loop_control_nucleo_DW.obj.MW_CAN_HANDLE, 0,\r\n                          0, 0, 0, 0, 0, 0, 0, 1, 1);\r\n    mcb_open_loop_control_nucleo_DW.obj.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<S2>/CAN Write' */\r\n    mcb_open_loop_control_nucleo_DW.obj_h.matlabCodegenIsDeleted = false;\r\n    mcb_open_loop_control_nucleo_DW.obj_h.isInitialized = 1;\r\n    mcb_open_loop_control_nucleo_DW.obj_h.MW_CAN_HANDLE = MW_CAN_Initialize(0);\r\n    MW_configureCANFilter(mcb_open_loop_control_nucleo_DW.obj_h.MW_CAN_HANDLE, 0,\r\n                          0, 0, 0, 0, 0, 0, 0, 1, 1);\r\n    mcb_open_loop_control_nucleo_DW.obj_h.isSetupComplete = true;\r\n  }\r\n}\r\n\r\n/* Model terminate function */\r\nvoid mcb_open_loop_control_nucleo_f401re_terminate(void)\r\n{\r\n  /* Terminate for MATLABSystem: '<S1>/CAN Read' */\r\n  if (!mcb_open_loop_control_nucleo_DW.obj.matlabCodegenIsDeleted) {\r\n    mcb_open_loop_control_nucleo_DW.obj.matlabCodegenIsDeleted = true;\r\n    if ((mcb_open_loop_control_nucleo_DW.obj.isInitialized == 1) &&\r\n        mcb_open_loop_control_nucleo_DW.obj.isSetupComplete) {\r\n      MW_CAN_Close(mcb_open_loop_control_nucleo_DW.obj.MW_CAN_HANDLE);\r\n    }\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<S1>/CAN Read' */\r\n  /* End of Terminate for S-Function (HardwareInterrupt_sfun): '<S11>/Hardware Interrupt' */\r\n\r\n  /* Terminate for S-Function (HardwareInterrupt_sfun): '<S11>/Hardware Interrupt' incorporates:\r\n   *  SubSystem: '<Root>/Open Loop Control'\r\n   */\r\n  /* Termination for function-call system: '<Root>/Open Loop Control' */\r\n\r\n  /* Terminate for MATLABSystem: '<S26>/PWM Output' */\r\n  if (!mcb_open_loop_control_nucleo_DW.obj_f.matlabCodegenIsDeleted) {\r\n    mcb_open_loop_control_nucleo_DW.obj_f.matlabCodegenIsDeleted = true;\r\n    if ((mcb_open_loop_control_nucleo_DW.obj_f.isInitialized == 1) &&\r\n        mcb_open_loop_control_nucleo_DW.obj_f.isSetupComplete) {\r\n      disableCounter(mcb_open_loop_control_nucleo_DW.obj_f.TimerHandle);\r\n      disableTimerInterrupts(mcb_open_loop_control_nucleo_DW.obj_f.TimerHandle,\r\n        0);\r\n      disableTimerChannel1(mcb_open_loop_control_nucleo_DW.obj_f.TimerHandle,\r\n                           ENABLE_CH);\r\n      disableTimerChannel2(mcb_open_loop_control_nucleo_DW.obj_f.TimerHandle,\r\n                           ENABLE_CH);\r\n      disableTimerChannel3(mcb_open_loop_control_nucleo_DW.obj_f.TimerHandle,\r\n                           ENABLE_CH);\r\n    }\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<S26>/PWM Output' */\r\n\r\n  /* Terminate for MATLABSystem: '<S18>/Analog to Digital Converter' */\r\n  if (!mcb_open_loop_control_nucleo_DW.obj_k.matlabCodegenIsDeleted) {\r\n    mcb_open_loop_control_nucleo_DW.obj_k.matlabCodegenIsDeleted = true;\r\n    if ((mcb_open_loop_control_nucleo_DW.obj_k.isInitialized == 1) &&\r\n        mcb_open_loop_control_nucleo_DW.obj_k.isSetupComplete) {\r\n      ADC_Handle_Deinit(mcb_open_loop_control_nucleo_DW.obj_k.ADCHandle,\r\n                        ADC_INTERRUPT_MODE, 0);\r\n    }\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<S18>/Analog to Digital Converter' */\r\n\r\n  /* End of Terminate for S-Function (HardwareInterrupt_sfun): '<S11>/Hardware Interrupt' */\r\n\r\n  /* Terminate for MATLABSystem: '<S2>/CAN Write' */\r\n  if (!mcb_open_loop_control_nucleo_DW.obj_h.matlabCodegenIsDeleted) {\r\n    mcb_open_loop_control_nucleo_DW.obj_h.matlabCodegenIsDeleted = true;\r\n    if ((mcb_open_loop_control_nucleo_DW.obj_h.isInitialized == 1) &&\r\n        mcb_open_loop_control_nucleo_DW.obj_h.isSetupComplete) {\r\n      MW_CAN_Close(mcb_open_loop_control_nucleo_DW.obj_h.MW_CAN_HANDLE);\r\n    }\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<S2>/CAN Write' */\r\n}\r\n\r\nvoid mcb_open_loop_control_nucleo_f401re_configure_interrupts(void)\r\n{\r\n  /* Register interrupt service routine */\r\n  MW_NVIC_ConfigureIRQ(33,&ADC_IRQHandler,2);\r\n  MW_NVIC_EnableIRQ(33);\r\n}\r\n\r\n/* Hardware Interrupt Block: '<S11>/Hardware Interrupt' */\r\nvoid ADC_IRQHandler(void)\r\n{\r\n  /* Event: ADC1 Inj EoCS */\r\n  /* Check event ADC1 Inj EoCS occurred */\r\n  if (0 != (\r\n#if defined(MW_ADC1_ENABLED) && (defined(MW_ADC1_INJ_IRQ_ENABLED) && (MW_ADC1_INJ_IRQ_ENABLED==1))\r\n            (0 != LL_ADC_IsEnabledIT_JEOS(ADC1)) && (0 != ADC_IsActiveFlagJEOS\r\n        (&(MW_ADC1_VAR)))\r\n#else\r\n            (0 != LL_ADC_IsEnabledIT_JEOS(ADC1)) && (0 !=\r\n        LL_ADC_IsActiveFlag_JEOS(ADC1))\r\n#endif\r\n            )) {\r\n    /* Clear occurred ADC1 Inj EoCS event */\r\n    LL_ADC_ClearFlag_JEOS(ADC1);\r\n    if (1 == runModel) {\r\n      {\r\n        /* RateTransition generated from: '<S1>/Data Type Conversion1' */\r\n        mcb_open_loop_control_nucleo__B.TmpRTBAtDataTypeConversion1Outp =\r\n          mcb_open_loop_control_nucleo_DW.TmpRTBAtDataTypeConversion1Outp;\r\n\r\n        /* RateTransition generated from: '<Root>/Open Loop Control' */\r\n        mcb_open_loop_control_nucleo__B.TmpRTBAtOpenLoopControlInport2 =\r\n          mcb_open_loop_control_nucleo_DW.TmpRTBAtOpenLoopControlInport2_;\r\n\r\n        /* S-Function (HardwareInterrupt_sfun): '<S11>/Hardware Interrupt' */\r\n\r\n        /* Output and update for function-call system: '<Root>/Open Loop Control' */\r\n        {\r\n          GPIO_TypeDef * portNameLoc;\r\n          int32_T pinWriteLoc;\r\n          int32_T tmp_e;\r\n          int32_T tmp_p;\r\n          real32_T rtb_Product1;\r\n          real32_T rtb_Product1_d;\r\n          real32_T rtb_Product_h;\r\n          real32_T rtb_Switch4_idx_2;\r\n          real32_T rtb_algDD_o2;\r\n          real32_T rtb_sum_beta;\r\n          real32_T tmp_m;\r\n          uint16_T tmp[2];\r\n          boolean_T tmp_i;\r\n\r\n          /* MATLABSystem: '<S23>/Digital Port Write' */\r\n          portNameLoc = GPIOC;\r\n\r\n          /* Switch: '<S19>/Switch' incorporates:\r\n           *  Constant: '<S19>/Constant1'\r\n           *  Logic: '<S19>/NOT'\r\n           */\r\n          if (mcb_open_loop_control_nucleo__P.Constant1_Value_a >\r\n              mcb_open_loop_control_nucleo__P.Switch_Threshold_g) {\r\n            tmp_i =\r\n              mcb_open_loop_control_nucleo__B.TmpRTBAtDataTypeConversion1Outp;\r\n          } else {\r\n            tmp_i =\r\n              !mcb_open_loop_control_nucleo__B.TmpRTBAtDataTypeConversion1Outp;\r\n          }\r\n\r\n          /* MATLABSystem: '<S23>/Digital Port Write' incorporates:\r\n           *  Switch: '<S19>/Switch'\r\n           */\r\n          if (tmp_i) {\r\n            pinWriteLoc = 1024;\r\n            tmp_p = 2048;\r\n            tmp_e = 4096;\r\n          } else {\r\n            pinWriteLoc = 0;\r\n            tmp_p = 0;\r\n            tmp_e = 0;\r\n          }\r\n\r\n          pinWriteLoc = (int32_T)((uint32_T)pinWriteLoc | (uint32_T)tmp_p |\r\n            (uint32_T)tmp_e);\r\n          LL_GPIO_SetOutputPin(portNameLoc, (uint32_T)pinWriteLoc);\r\n          LL_GPIO_ResetOutputPin(portNameLoc, ~(uint32_T)pinWriteLoc & 7168U);\r\n\r\n          /* DiscreteIntegrator: '<S29>/Ramp Generator' incorporates:\r\n           *  Logic: '<S29>/NOT'\r\n           */\r\n          if (!mcb_open_loop_control_nucleo__B.TmpRTBAtDataTypeConversion1Outp)\r\n          {\r\n            mcb_open_loop_control_nucleo_DW.RampGenerator_DSTATE =\r\n              mcb_open_loop_control_nucleo__P.RampGenerator_IC;\r\n          }\r\n\r\n          /* Product: '<S27>/Product' incorporates:\r\n           *  DiscreteIntegrator: '<S29>/Ramp Generator'\r\n           *  Gain: '<S27>/rpm2freq'\r\n           */\r\n          rtb_Product_h = (real32_T)\r\n            mcb_open_loop_control_nucleo__P.rpm2freq_Gain * 3.81469727E-6F *\r\n            (real32_T)\r\n            mcb_open_loop_control_nucleo__B.TmpRTBAtOpenLoopControlInport2 *\r\n            mcb_open_loop_control_nucleo_DW.RampGenerator_DSTATE;\r\n\r\n          /* Gain: '<S28>/Correction_Factor_sinePWM' incorporates:\r\n           *  Abs: '<S28>/Abs'\r\n           *  Gain: '<S28>/V-by-f'\r\n           */\r\n          rtb_Product1 = mcb_open_loop_control_nucleo__P.Vbyf_Gain * fabsf\r\n            (rtb_Product_h) *\r\n            mcb_open_loop_control_nucleo__P.Correction_Factor_sinePWM_Gain;\r\n\r\n          /* Switch: '<S32>/Switch' incorporates:\r\n           *  Constant: '<S5>/Boost Voltage'\r\n           *  RelationalOperator: '<S32>/Relational Operator'\r\n           */\r\n          if (rtb_Product1 > mcb_open_loop_control_nucleo__P.BoostVoltage_Value)\r\n          {\r\n            rtb_Product1_d = rtb_Product1;\r\n          } else {\r\n            rtb_Product1_d = mcb_open_loop_control_nucleo__P.BoostVoltage_Value;\r\n          }\r\n\r\n          /* End of Switch: '<S32>/Switch' */\r\n\r\n          /* Outputs for Enabled SubSystem: '<S31>/Accumulate' incorporates:\r\n           *  EnablePort: '<S47>/Enable'\r\n           */\r\n          /* Logic: '<S31>/NOT' incorporates:\r\n           *  Constant: '<S31>/Constant_Reset'\r\n           *  Delay: '<S47>/Delay'\r\n           */\r\n          if (!mcb_open_loop_control_nucleo__P.Constant_Reset_Value) {\r\n            /* Outputs for Enabled SubSystem: '<S47>/Subsystem' incorporates:\r\n             *  EnablePort: '<S48>/Enable'\r\n             */\r\n            if (mcb_open_loop_control_nucleo_DW.Delay_DSTATE) {\r\n              /* SignalConversion generated from: '<S48>/Input' incorporates:\r\n               *  Gain: '<S28>/position_increment'\r\n               *  Gain: '<S31>/scaleIn'\r\n               */\r\n              mcb_open_loop_control_nucleo__B.Input =\r\n                mcb_open_loop_control_nucleo__P.position_increment_Gain *\r\n                rtb_Product_h * mcb_open_loop_control_nucleo__P.scaleIn_Gain;\r\n            }\r\n\r\n            /* End of Outputs for SubSystem: '<S47>/Subsystem' */\r\n\r\n            /* Sum: '<S47>/Add' incorporates:\r\n             *  Delay: '<S47>/Delay'\r\n             *  UnitDelay: '<S31>/Unit Delay'\r\n             */\r\n            rtb_Product_h = mcb_open_loop_control_nucleo__B.Input +\r\n              mcb_open_loop_control_nucleo_DW.UnitDelay_DSTATE;\r\n\r\n            /* Sum: '<S47>/Add1' incorporates:\r\n             *  DataTypeConversion: '<S47>/Data Type Conversion'\r\n             *  DataTypeConversion: '<S47>/Data Type Conversion1'\r\n             *  UnitDelay: '<S31>/Unit Delay'\r\n             */\r\n            mcb_open_loop_control_nucleo_DW.UnitDelay_DSTATE = rtb_Product_h -\r\n              (real32_T)(int16_T)floorf(rtb_Product_h);\r\n\r\n            /* Update for Delay: '<S47>/Delay' incorporates:\r\n             *  Constant: '<S47>/Constant'\r\n             */\r\n            mcb_open_loop_control_nucleo_DW.Delay_DSTATE =\r\n              mcb_open_loop_control_nucleo__P.Constant_Value_a;\r\n          }\r\n\r\n          /* End of Logic: '<S31>/NOT' */\r\n          /* End of Outputs for SubSystem: '<S31>/Accumulate' */\r\n\r\n          /* Gain: '<S41>/convert_pu' incorporates:\r\n           *  Gain: '<S31>/scaleOut'\r\n           *  UnitDelay: '<S31>/Unit Delay'\r\n           */\r\n          rtb_Product_h = mcb_open_loop_control_nucleo__P.scaleOut_Gain *\r\n            mcb_open_loop_control_nucleo_DW.UnitDelay_DSTATE *\r\n            mcb_open_loop_control_nucleo__P.convert_pu_Gain;\r\n\r\n          /* If: '<S41>/If' incorporates:\r\n           *  Constant: '<S43>/Constant'\r\n           *  DataTypeConversion: '<S44>/Convert_back'\r\n           *  DataTypeConversion: '<S44>/Convert_uint16'\r\n           *  DataTypeConversion: '<S45>/Convert_back'\r\n           *  DataTypeConversion: '<S45>/Convert_uint16'\r\n           *  Gain: '<S39>/indexing'\r\n           *  RelationalOperator: '<S43>/Compare'\r\n           *  Sum: '<S44>/Sum'\r\n           *  Sum: '<S45>/Sum'\r\n           */\r\n          if (rtb_Product_h < mcb_open_loop_control_nucleo__P.Constant_Value_h)\r\n          {\r\n            /* Outputs for IfAction SubSystem: '<S41>/If Action Subsystem' incorporates:\r\n             *  ActionPort: '<S44>/Action Port'\r\n             */\r\n            rtb_Switch4_idx_2 = rtb_Product_h - (real32_T)(int16_T)floorf\r\n              (rtb_Product_h);\r\n\r\n            /* End of Outputs for SubSystem: '<S41>/If Action Subsystem' */\r\n          } else {\r\n            /* Outputs for IfAction SubSystem: '<S41>/If Action Subsystem1' incorporates:\r\n             *  ActionPort: '<S45>/Action Port'\r\n             */\r\n            rtb_Switch4_idx_2 = rtb_Product_h - (real32_T)(int16_T)rtb_Product_h;\r\n\r\n            /* End of Outputs for SubSystem: '<S41>/If Action Subsystem1' */\r\n          }\r\n\r\n          rtb_Product1 = mcb_open_loop_control_nucleo__P.indexing_Gain *\r\n            rtb_Switch4_idx_2;\r\n\r\n          /* End of If: '<S41>/If' */\r\n\r\n          /* Sum: '<S39>/Sum2' incorporates:\r\n           *  DataTypeConversion: '<S39>/Data Type Conversion1'\r\n           *  DataTypeConversion: '<S39>/Get_Integer'\r\n           */\r\n          rtb_sum_beta = rtb_Product1 - (real32_T)(uint16_T)rtb_Product1;\r\n\r\n          /* Saturate: '<S32>/Saturation' */\r\n          if (rtb_Product1_d >\r\n              mcb_open_loop_control_nucleo__P.Saturation_UpperSat) {\r\n            rtb_Product1_d = mcb_open_loop_control_nucleo__P.Saturation_UpperSat;\r\n          } else if (rtb_Product1_d <\r\n                     mcb_open_loop_control_nucleo__P.Saturation_LowerSat) {\r\n            rtb_Product1_d = mcb_open_loop_control_nucleo__P.Saturation_LowerSat;\r\n          }\r\n\r\n          /* Selector: '<S39>/Lookup' incorporates:\r\n           *  Constant: '<S39>/offset'\r\n           *  Constant: '<S39>/sine_table_values'\r\n           *  DataTypeConversion: '<S39>/Get_Integer'\r\n           *  Sum: '<S39>/Sum'\r\n           *  Sum: '<S40>/Sum3'\r\n           *  Sum: '<S40>/Sum5'\r\n           */\r\n          rtb_Switch4_idx_2 =\r\n            mcb_open_loop_control_nucleo__P.sine_table_values_Value[(int32_T)\r\n            ((uint32_T)mcb_open_loop_control_nucleo__P.offset_Value[1] +\r\n             (uint16_T)rtb_Product1)];\r\n          tmp_m = mcb_open_loop_control_nucleo__P.sine_table_values_Value\r\n            [(int32_T)((uint32_T)mcb_open_loop_control_nucleo__P.offset_Value[3]\r\n                       + (uint16_T)rtb_Product1)];\r\n\r\n          /* Outputs for Atomic SubSystem: '<S34>/Two inputs CRL' */\r\n          /* AlgorithmDescriptorDelegate generated from: '<S37>/a16' incorporates:\r\n           *  Constant: '<S30>/Constant'\r\n           *  Constant: '<S39>/offset'\r\n           *  Constant: '<S39>/sine_table_values'\r\n           *  DataTypeConversion: '<S39>/Get_Integer'\r\n           *  Product: '<S40>/Product'\r\n           *  Product: '<S40>/Product1'\r\n           *  Saturate: '<S32>/Saturation'\r\n           *  Selector: '<S39>/Lookup'\r\n           *  Sum: '<S39>/Sum'\r\n           *  Sum: '<S40>/Sum3'\r\n           *  Sum: '<S40>/Sum4'\r\n           *  Sum: '<S40>/Sum5'\r\n           *  Sum: '<S40>/Sum6'\r\n           *  UnaryMinus: '<S30>/Unary Minus'\r\n           */\r\n          arm_inv_park_f32(mcb_open_loop_control_nucleo__P.Constant_Value_g,\r\n                           -rtb_Product1_d, &rtb_Product_h, &rtb_algDD_o2,\r\n                           (mcb_open_loop_control_nucleo__P.sine_table_values_Value\r\n                            [(int32_T)((uint32_T)\r\n            mcb_open_loop_control_nucleo__P.offset_Value[0] + (uint16_T)\r\n            rtb_Product1)] - rtb_Switch4_idx_2) * rtb_sum_beta +\r\n                           rtb_Switch4_idx_2,\r\n                           (mcb_open_loop_control_nucleo__P.sine_table_values_Value\r\n                            [(int32_T)((uint32_T)\r\n            mcb_open_loop_control_nucleo__P.offset_Value[2] + (uint16_T)\r\n            rtb_Product1)] - tmp_m) * rtb_sum_beta + tmp_m);\r\n\r\n          /* End of Outputs for SubSystem: '<S34>/Two inputs CRL' */\r\n\r\n          /* Switch: '<S20>/Switch4' incorporates:\r\n           *  Constant: '<S15>/Constant'\r\n           *  Constant: '<S15>/Constant1'\r\n           *  Constant: '<S20>/stop'\r\n           *  Gain: '<S15>/Gain'\r\n           *  Gain: '<S36>/Ka'\r\n           *  Gain: '<S36>/Kb'\r\n           *  Gain: '<S36>/Kc'\r\n           *  Product: '<S15>/Product'\r\n           *  Sum: '<S15>/Sum'\r\n           *  Sum: '<S36>/add_b'\r\n           *  Sum: '<S36>/add_c'\r\n           */\r\n          if (mcb_open_loop_control_nucleo__B.TmpRTBAtDataTypeConversion1Outp) {\r\n            /* Gain: '<S36>/sqrt3_by_two' */\r\n            rtb_Switch4_idx_2 =\r\n              mcb_open_loop_control_nucleo__P.sqrt3_by_two_Gain * rtb_algDD_o2;\r\n\r\n            /* Gain: '<S36>/one_by_two' */\r\n            rtb_Product1 = mcb_open_loop_control_nucleo__P.one_by_two_Gain *\r\n              rtb_Product_h;\r\n            rtb_Product1_d = (mcb_open_loop_control_nucleo__P.Ka_Gain *\r\n                              rtb_Product_h +\r\n                              mcb_open_loop_control_nucleo__P.Constant_Value) *\r\n              mcb_open_loop_control_nucleo__P.Gain_Gain *\r\n              mcb_open_loop_control_nucleo__P.Constant1_Value;\r\n            rtb_Product_h = ((rtb_Switch4_idx_2 - rtb_Product1) *\r\n                             mcb_open_loop_control_nucleo__P.Kb_Gain +\r\n                             mcb_open_loop_control_nucleo__P.Constant_Value) *\r\n              mcb_open_loop_control_nucleo__P.Gain_Gain *\r\n              mcb_open_loop_control_nucleo__P.Constant1_Value;\r\n            rtb_Switch4_idx_2 = (((0.0F - rtb_Product1) - rtb_Switch4_idx_2) *\r\n                                 mcb_open_loop_control_nucleo__P.Kc_Gain +\r\n                                 mcb_open_loop_control_nucleo__P.Constant_Value)\r\n              * mcb_open_loop_control_nucleo__P.Gain_Gain *\r\n              mcb_open_loop_control_nucleo__P.Constant1_Value;\r\n          } else {\r\n            rtb_Product1_d = mcb_open_loop_control_nucleo__P.stop_Value;\r\n            rtb_Product_h = mcb_open_loop_control_nucleo__P.stop_Value;\r\n            rtb_Switch4_idx_2 = mcb_open_loop_control_nucleo__P.stop_Value;\r\n          }\r\n\r\n          /* End of Switch: '<S20>/Switch4' */\r\n\r\n          /* MATLABSystem: '<S26>/PWM Output' */\r\n          setDutyCycleInPercentageChannel1\r\n            (mcb_open_loop_control_nucleo_DW.obj_f.TimerHandle, rtb_Product1_d);\r\n          setDutyCycleInPercentageChannel2\r\n            (mcb_open_loop_control_nucleo_DW.obj_f.TimerHandle, rtb_Product_h);\r\n          setDutyCycleInPercentageChannel3\r\n            (mcb_open_loop_control_nucleo_DW.obj_f.TimerHandle,\r\n             rtb_Switch4_idx_2);\r\n\r\n          /* MATLABSystem: '<S18>/Analog to Digital Converter' */\r\n          injectedReadADCIntr(mcb_open_loop_control_nucleo_DW.obj_k.ADCHandle,\r\n                              ADC_READ, &tmp[0]);\r\n\r\n          /* Update for DiscreteIntegrator: '<S29>/Ramp Generator' incorporates:\r\n           *  Constant: '<S27>/Ramp_Time (sec)'\r\n           *  Constant: '<S29>/One'\r\n           *  Gain: '<S29>/Sample_Time'\r\n           *  Product: '<S29>/Divide'\r\n           */\r\n          mcb_open_loop_control_nucleo_DW.RampGenerator_DSTATE +=\r\n            mcb_open_loop_control_nucleo__P.One_Value /\r\n            mcb_open_loop_control_nucleo__P.Ramp_Timesec_Value *\r\n            mcb_open_loop_control_nucleo__P.Ts *\r\n            mcb_open_loop_control_nucleo__P.RampGenerator_gainval;\r\n          if (mcb_open_loop_control_nucleo_DW.RampGenerator_DSTATE >\r\n              mcb_open_loop_control_nucleo__P.RampGenerator_UpperSat) {\r\n            mcb_open_loop_control_nucleo_DW.RampGenerator_DSTATE =\r\n              mcb_open_loop_control_nucleo__P.RampGenerator_UpperSat;\r\n          } else if (mcb_open_loop_control_nucleo_DW.RampGenerator_DSTATE <\r\n                     mcb_open_loop_control_nucleo__P.RampGenerator_LowerSat) {\r\n            mcb_open_loop_control_nucleo_DW.RampGenerator_DSTATE =\r\n              mcb_open_loop_control_nucleo__P.RampGenerator_LowerSat;\r\n          }\r\n\r\n          /* End of Update for DiscreteIntegrator: '<S29>/Ramp Generator' */\r\n        }\r\n\r\n        /* End of Outputs for S-Function (HardwareInterrupt_sfun): '<S11>/Hardware Interrupt' */\r\n      }\r\n    }\r\n  }\r\n\r\n  __ISB();\r\n  __DSB();\r\n}\r\n\r\nvoid mcb_open_loop_control_nucleo_f401re_unconfigure_interrupts (void)\r\n{\r\n  MW_NVIC_DisableIRQ(33);\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"mcb_open_loop_control_nucleo_f401re.h","type":"header","group":"model","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: mcb_open_loop_control_nucleo_f401re.h\r\n *\r\n * Code generated for Simulink model 'mcb_open_loop_control_nucleo_f401re'.\r\n *\r\n * Model version                  : 9.4\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Feb 16 20:00:16 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef mcb_open_loop_control_nucleo_f401re_h_\r\n#define mcb_open_loop_control_nucleo_f401re_h_\r\n#ifndef mcb_open_loop_control_nucleo_f401re_COMMON_INCLUDES_\r\n#define mcb_open_loop_control_nucleo_f401re_COMMON_INCLUDES_\r\n#include <time.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"math.h\"\r\n#include \"string.h\"\r\n#include \"stm_can_hal.h\"\r\n#include \"main.h\"\r\n#endif                /* mcb_open_loop_control_nucleo_f401re_COMMON_INCLUDES_ */\r\n\r\n#include \"mw_stm32_nvic.h\"\r\n#include \"mcb_open_loop_control_nucleo_f401re_types.h\"\r\n#include <string.h>\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"can_message.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#define mcb_open_loop_control_nucleo_f401re_M (mcb_open_loop_control_nucleo_M)\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  CANMsg CANRead;                      /* '<S1>/CAN Read' */\r\n  real32_T Input;                      /* '<S48>/Input' */\r\n  int16_T TmpRTBAtOpenLoopControlInport2;/* '<Root>/CONTROL RPM AND DIRECTION' */\r\n  uint8_T CANUnpack[4];                /* '<S1>/CAN Unpack' */\r\n  boolean_T TmpRTBAtDataTypeConversion1Outp;/* '<S1>/Data Type Conversion1' */\r\n} B_mcb_open_loop_control_nucle_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  stm32cube_blocks_CANRead_mcb__T obj; /* '<S1>/CAN Read' */\r\n  stm32cube_blocks_CANWrite_mcb_T obj_h;/* '<S2>/CAN Write' */\r\n  stm32cube_blocks_AnalogInput__T obj_k;/* '<S18>/Analog to Digital Converter' */\r\n  stm32cube_blocks_PWMOutput_mc_T obj_f;/* '<S26>/PWM Output' */\r\n  real_T r;                            /* '<S49>/MATLAB Function' */\r\n  real32_T RampGenerator_DSTATE;       /* '<S29>/Ramp Generator' */\r\n  real32_T UnitDelay_DSTATE;           /* '<S31>/Unit Delay' */\r\n  uint32_T method;                     /* '<S49>/MATLAB Function' */\r\n  uint32_T state[625];                 /* '<S49>/MATLAB Function' */\r\n  uint32_T state_e[2];                 /* '<S49>/MATLAB Function' */\r\n  uint32_T state_k;                    /* '<S49>/MATLAB Function' */\r\n  int_T CANUnpack_ModeSignalID;        /* '<S1>/CAN Unpack' */\r\n  int_T CANUnpack_StatusPortID;        /* '<S1>/CAN Unpack' */\r\n  volatile int16_T TmpRTBAtOpenLoopControlInport2_;/* synthesized block */\r\n  boolean_T Delay_DSTATE;              /* '<S47>/Delay' */\r\n  volatile boolean_T TmpRTBAtDataTypeConversion1Outp;/* synthesized block */\r\n  boolean_T r_not_empty;               /* '<S49>/MATLAB Function' */\r\n} DW_mcb_open_loop_control_nucl_T;\r\n\r\n/* Parameters (default storage) */\r\nstruct P_mcb_open_loop_control_nucle_T_ {\r\n  real32_T Ts;                         /* Variable: Ts\r\n                                        * Referenced by: '<S29>/Sample_Time'\r\n                                        */\r\n  uint16_T BitwiseOR_BitMask;          /* Mask Parameter: BitwiseOR_BitMask\r\n                                        * Referenced by: '<S6>/Bitwise OR'\r\n                                        */\r\n  real32_T Constant1_Value;            /* Expression: single(100)\r\n                                        * Referenced by: '<S15>/Constant1'\r\n                                        */\r\n  real32_T Constant_Value;             /* Computed Parameter: Constant_Value\r\n                                        * Referenced by: '<S15>/Constant'\r\n                                        */\r\n  real32_T sqrt3_by_two_Gain;          /* Computed Parameter: sqrt3_by_two_Gain\r\n                                        * Referenced by: '<S36>/sqrt3_by_two'\r\n                                        */\r\n  real32_T one_by_two_Gain;            /* Computed Parameter: one_by_two_Gain\r\n                                        * Referenced by: '<S36>/one_by_two'\r\n                                        */\r\n  real32_T Kc_Gain;                    /* Computed Parameter: Kc_Gain\r\n                                        * Referenced by: '<S36>/Kc'\r\n                                        */\r\n  real32_T Kb_Gain;                    /* Computed Parameter: Kb_Gain\r\n                                        * Referenced by: '<S36>/Kb'\r\n                                        */\r\n  real32_T Ka_Gain;                    /* Computed Parameter: Ka_Gain\r\n                                        * Referenced by: '<S36>/Ka'\r\n                                        */\r\n  real32_T Gain_Gain;                  /* Computed Parameter: Gain_Gain\r\n                                        * Referenced by: '<S15>/Gain'\r\n                                        */\r\n  real32_T stop_Value;                 /* Computed Parameter: stop_Value\r\n                                        * Referenced by: '<S20>/stop'\r\n                                        */\r\n  real32_T Out1_Y0;                    /* Computed Parameter: Out1_Y0\r\n                                        * Referenced by: '<S48>/Out1'\r\n                                        */\r\n  real32_T theta_e_Y0;                 /* Computed Parameter: theta_e_Y0\r\n                                        * Referenced by: '<S47>/theta_e'\r\n                                        */\r\n  real32_T Vabc_PU_Y0;                 /* Computed Parameter: Vabc_PU_Y0\r\n                                        * Referenced by: '<S5>/Vabc_PU'\r\n                                        */\r\n  real32_T Constant_Value_h;           /* Computed Parameter: Constant_Value_h\r\n                                        * Referenced by: '<S43>/Constant'\r\n                                        */\r\n  real32_T Constant_Value_g;           /* Computed Parameter: Constant_Value_g\r\n                                        * Referenced by: '<S30>/Constant'\r\n                                        */\r\n  real32_T RampGenerator_gainval;   /* Computed Parameter: RampGenerator_gainval\r\n                                     * Referenced by: '<S29>/Ramp Generator'\r\n                                     */\r\n  real32_T RampGenerator_IC;           /* Computed Parameter: RampGenerator_IC\r\n                                        * Referenced by: '<S29>/Ramp Generator'\r\n                                        */\r\n  real32_T RampGenerator_UpperSat; /* Computed Parameter: RampGenerator_UpperSat\r\n                                    * Referenced by: '<S29>/Ramp Generator'\r\n                                    */\r\n  real32_T RampGenerator_LowerSat; /* Computed Parameter: RampGenerator_LowerSat\r\n                                    * Referenced by: '<S29>/Ramp Generator'\r\n                                    */\r\n  real32_T Vbyf_Gain;                  /* Computed Parameter: Vbyf_Gain\r\n                                        * Referenced by: '<S28>/V-by-f'\r\n                                        */\r\n  real32_T Correction_Factor_sinePWM_Gain;\r\n                           /* Computed Parameter: Correction_Factor_sinePWM_Gain\r\n                            * Referenced by: '<S28>/Correction_Factor_sinePWM'\r\n                            */\r\n  real32_T BoostVoltage_Value;         /* Computed Parameter: BoostVoltage_Value\r\n                                        * Referenced by: '<S5>/Boost Voltage'\r\n                                        */\r\n  real32_T Saturation_UpperSat;       /* Computed Parameter: Saturation_UpperSat\r\n                                       * Referenced by: '<S32>/Saturation'\r\n                                       */\r\n  real32_T Saturation_LowerSat;       /* Computed Parameter: Saturation_LowerSat\r\n                                       * Referenced by: '<S32>/Saturation'\r\n                                       */\r\n  real32_T sine_table_values_Value[1002];\r\n                                  /* Computed Parameter: sine_table_values_Value\r\n                                   * Referenced by: '<S39>/sine_table_values'\r\n                                   */\r\n  real32_T position_increment_Gain;\r\n                                  /* Computed Parameter: position_increment_Gain\r\n                                   * Referenced by: '<S28>/position_increment'\r\n                                   */\r\n  real32_T scaleIn_Gain;               /* Computed Parameter: scaleIn_Gain\r\n                                        * Referenced by: '<S31>/scaleIn'\r\n                                        */\r\n  real32_T UnitDelay_InitialCondition;\r\n                               /* Computed Parameter: UnitDelay_InitialCondition\r\n                                * Referenced by: '<S31>/Unit Delay'\r\n                                */\r\n  real32_T scaleOut_Gain;              /* Computed Parameter: scaleOut_Gain\r\n                                        * Referenced by: '<S31>/scaleOut'\r\n                                        */\r\n  real32_T convert_pu_Gain;            /* Computed Parameter: convert_pu_Gain\r\n                                        * Referenced by: '<S41>/convert_pu'\r\n                                        */\r\n  real32_T indexing_Gain;              /* Computed Parameter: indexing_Gain\r\n                                        * Referenced by: '<S39>/indexing'\r\n                                        */\r\n  real32_T One_Value;                  /* Computed Parameter: One_Value\r\n                                        * Referenced by: '<S29>/One'\r\n                                        */\r\n  real32_T Ramp_Timesec_Value;         /* Computed Parameter: Ramp_Timesec_Value\r\n                                        * Referenced by: '<S27>/Ramp_Time (sec)'\r\n                                        */\r\n  int16_T Gain_Gain_m;                 /* Computed Parameter: Gain_Gain_m\r\n                                        * Referenced by: '<S3>/Gain'\r\n                                        */\r\n  int16_T offset_Value[4];             /* Computed Parameter: offset_Value\r\n                                        * Referenced by: '<S39>/offset'\r\n                                        */\r\n  int16_T TmpRTBAtOpenLoopControlInport2_;\r\n                          /* Computed Parameter: TmpRTBAtOpenLoopControlInport2_\r\n                           * Referenced by:\r\n                           */\r\n  int16_T rpm2freq_Gain;               /* Computed Parameter: rpm2freq_Gain\r\n                                        * Referenced by: '<S27>/rpm2freq'\r\n                                        */\r\n  uint16_T Offset_Value;               /* Computed Parameter: Offset_Value\r\n                                        * Referenced by: '<S38>/Offset'\r\n                                        */\r\n  uint16_T Switch_Threshold;           /* Computed Parameter: Switch_Threshold\r\n                                        * Referenced by: '<S38>/Switch'\r\n                                        */\r\n  uint16_T Constant1_Value_a;          /* Expression: inverter.EnableLogic\r\n                                        * Referenced by: '<S19>/Constant1'\r\n                                        */\r\n  uint16_T Switch_Threshold_g;         /* Computed Parameter: Switch_Threshold_g\r\n                                        * Referenced by: '<S19>/Switch'\r\n                                        */\r\n  uint16_T NumberIDECU1_Value;         /* Computed Parameter: NumberIDECU1_Value\r\n                                        * Referenced by: '<Root>/Number ID ECU1'\r\n                                        */\r\n  boolean_T Delay_InitialCondition;/* Computed Parameter: Delay_InitialCondition\r\n                                    * Referenced by: '<S47>/Delay'\r\n                                    */\r\n  boolean_T Constant_Value_a;          /* Computed Parameter: Constant_Value_a\r\n                                        * Referenced by: '<S47>/Constant'\r\n                                        */\r\n  boolean_T Constant_Reset_Value;    /* Computed Parameter: Constant_Reset_Value\r\n                                      * Referenced by: '<S31>/Constant_Reset'\r\n                                      */\r\n  boolean_T TmpRTBAtDataTypeConversion1Outp;\r\n                          /* Computed Parameter: TmpRTBAtDataTypeConversion1Outp\r\n                           * Referenced by:\r\n                           */\r\n  uint8_T NumberControlSafety_Value;\r\n                                /* Computed Parameter: NumberControlSafety_Value\r\n                                 * Referenced by: '<Root>/Number Control Safety'\r\n                                 */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_mcb_open_loop_control_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\nextern CAN_DATATYPE CAN_DATATYPE_GROUND;\r\n\r\n/* Block parameters (default storage) */\r\nextern P_mcb_open_loop_control_nucle_T mcb_open_loop_control_nucleo__P;\r\n\r\n/* Block signals (default storage) */\r\nextern B_mcb_open_loop_control_nucle_T mcb_open_loop_control_nucleo__B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_mcb_open_loop_control_nucl_T mcb_open_loop_control_nucleo_DW;\r\n\r\n/* Model entry point functions */\r\nextern void mcb_open_loop_control_nucleo_f401re_initialize(void);\r\nextern void mcb_open_loop_control_nucleo_f401re_step(void);\r\nextern void mcb_open_loop_control_nucleo_f401re_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_mcb_open_loop_contro_T *const mcb_open_loop_control_nucleo_M;\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n#ifdef __cpluscplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  void ADC_IRQHandler(void);\r\n  void mcb_open_loop_control_nucleo_f401re_configure_interrupts (void);\r\n  void mcb_open_loop_control_nucleo_f401re_unconfigure_interrupts (void);\r\n\r\n#ifdef __cpluscplus\r\n\r\n}\r\n\r\n#endif\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S8>/DTProp1' : Unused code path elimination\r\n * Block '<S8>/DTProp2' : Unused code path elimination\r\n * Block '<S9>/DTProp1' : Unused code path elimination\r\n * Block '<S9>/DTProp2' : Unused code path elimination\r\n * Block '<S30>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S36>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S37>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S37>/Data Type Duplicate1' : Unused code path elimination\r\n * Block '<S39>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S39>/Data Type Propagation' : Unused code path elimination\r\n * Block '<S44>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S45>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S31>/Data Type Duplicate2' : Unused code path elimination\r\n * Block '<S5>/Data Type Conversion' : Unused code path elimination\r\n * Block '<S16>/Base Speed' : Unused code path elimination\r\n * Block '<S16>/Data Type' : Unused code path elimination\r\n * Block '<S16>/Inverter' : Unused code path elimination\r\n * Block '<S16>/Number of pole pairs' : Unused code path elimination\r\n * Block '<S16>/PWM Frequency' : Unused code path elimination\r\n * Block '<S49>/Display' : Unused code path elimination\r\n * Block '<S8>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S9>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S39>/Get_FractionVal' : Eliminate redundant data type conversion\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'mcb_open_loop_control_nucleo_f401re'\r\n * '<S1>'   : 'mcb_open_loop_control_nucleo_f401re/CAN-BUS READ'\r\n * '<S2>'   : 'mcb_open_loop_control_nucleo_f401re/CAN-BUS WRITE'\r\n * '<S3>'   : 'mcb_open_loop_control_nucleo_f401re/CONTROL RPM AND DIRECTION'\r\n * '<S4>'   : 'mcb_open_loop_control_nucleo_f401re/Hardware Interrupt'\r\n * '<S5>'   : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control'\r\n * '<S6>'   : 'mcb_open_loop_control_nucleo_f401re/Subsystem'\r\n * '<S7>'   : 'mcb_open_loop_control_nucleo_f401re/CAN-BUS READ/Bit Concat'\r\n * '<S8>'   : 'mcb_open_loop_control_nucleo_f401re/CAN-BUS READ/Extract Bits'\r\n * '<S9>'   : 'mcb_open_loop_control_nucleo_f401re/CAN-BUS READ/Extract Bits1'\r\n * '<S10>'  : 'mcb_open_loop_control_nucleo_f401re/Hardware Interrupt/ECSoC'\r\n * '<S11>'  : 'mcb_open_loop_control_nucleo_f401re/Hardware Interrupt/ECSoC/ECSimCodegen'\r\n * '<S12>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Analog to Digital Converter'\r\n * '<S13>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Codegen'\r\n * '<S14>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System'\r\n * '<S15>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Output Scaling'\r\n * '<S16>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Parameters'\r\n * '<S17>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Analog to Digital Converter/ECSoC'\r\n * '<S18>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Analog to Digital Converter/ECSoC/ECSimCodegen'\r\n * '<S19>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Codegen/Hardware Initialization'\r\n * '<S20>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Codegen/PWM Output'\r\n * '<S21>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Codegen/Hardware Initialization/Digital Port Write'\r\n * '<S22>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Codegen/Hardware Initialization/Digital Port Write/ECSoC'\r\n * '<S23>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Codegen/Hardware Initialization/Digital Port Write/ECSoC/ECSimCodegen'\r\n * '<S24>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Codegen/PWM Output/PWM Output1'\r\n * '<S25>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Codegen/PWM Output/PWM Output1/ECSoC'\r\n * '<S26>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Codegen/PWM Output/PWM Output1/ECSoC/ECSimCodegen'\r\n * '<S27>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/SpeedRefToFreq'\r\n * '<S28>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc'\r\n * '<S29>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/SpeedRefToFreq/Ramp Generator'\r\n * '<S30>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator'\r\n * '<S31>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/Position Generator'\r\n * '<S32>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/Saturate output to limits'\r\n * '<S33>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator/Inverse Clarke Transform'\r\n * '<S34>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator/Inverse Park Transform'\r\n * '<S35>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator/Sine-Cosine Lookup'\r\n * '<S36>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator/Inverse Clarke Transform/Two phase input'\r\n * '<S37>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator/Inverse Park Transform/Two inputs CRL'\r\n * '<S38>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator/Inverse Park Transform/Two inputs CRL/Switch_Axis'\r\n * '<S39>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup'\r\n * '<S40>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup/Interpolation'\r\n * '<S41>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup/WrapUp'\r\n * '<S42>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup/datatype'\r\n * '<S43>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup/WrapUp/Compare To Zero'\r\n * '<S44>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup/WrapUp/If Action Subsystem'\r\n * '<S45>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup/WrapUp/If Action Subsystem1'\r\n * '<S46>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup/datatype/datatype no change'\r\n * '<S47>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/Position Generator/Accumulate'\r\n * '<S48>'  : 'mcb_open_loop_control_nucleo_f401re/Open Loop Control/Control_System/VabcCalc/Position Generator/Accumulate/Subsystem'\r\n * '<S49>'  : 'mcb_open_loop_control_nucleo_f401re/Subsystem/Safety code generator'\r\n * '<S50>'  : 'mcb_open_loop_control_nucleo_f401re/Subsystem/Safety code generator/MATLAB Function'\r\n */\r\n#endif                              /* mcb_open_loop_control_nucleo_f401re_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"mcb_open_loop_control_nucleo_f401re_private.h","type":"header","group":"model","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: mcb_open_loop_control_nucleo_f401re_private.h\r\n *\r\n * Code generated for Simulink model 'mcb_open_loop_control_nucleo_f401re'.\r\n *\r\n * Model version                  : 9.4\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Feb 16 20:00:16 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef mcb_open_loop_control_nucleo_f401re_private_h_\r\n#define mcb_open_loop_control_nucleo_f401re_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"mcb_open_loop_control_nucleo_f401re_types.h\"\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFU) ) || ( LONG_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n/* Skipping ulong_long/long_long check: insufficient preprocessor integer range. */\r\nextern real_T rt_roundd_snf(real_T u);\r\n\r\n#endif                      /* mcb_open_loop_control_nucleo_f401re_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"mcb_open_loop_control_nucleo_f401re_types.h","type":"header","group":"model","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: mcb_open_loop_control_nucleo_f401re_types.h\r\n *\r\n * Code generated for Simulink model 'mcb_open_loop_control_nucleo_f401re'.\r\n *\r\n * Model version                  : 9.4\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Feb 16 20:00:16 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef mcb_open_loop_control_nucleo_f401re_types_h_\r\n#define mcb_open_loop_control_nucleo_f401re_types_h_\r\n#include \"rtwtypes.h\"\r\n#include \"stm_timer_ll.h\"\r\n#include \"stm_adc_ll.h\"\r\n#include \"stm_can_hal.h\"\r\n#ifndef DEFINED_TYPEDEF_FOR_CANMsg_\r\n#define DEFINED_TYPEDEF_FOR_CANMsg_\r\n\r\ntypedef struct {\r\n  uint8_T Extended;\r\n  uint8_T Length;\r\n  uint8_T Remote;\r\n  uint8_T Error;\r\n  uint32_T ID;\r\n  real_T Timestamp;\r\n  uint8_T Data[8];\r\n} CANMsg;\r\n\r\n#endif\r\n\r\n/* Custom Type definition for MATLABSystem: '<S18>/Analog to Digital Converter' */\r\n#include \"stm_adc_ll.h\"\r\n#include \"stm_adc_ll.h\"\r\n#ifndef struct_tag_tsKyPuhWUdS8zBSeRGR2aC\r\n#define struct_tag_tsKyPuhWUdS8zBSeRGR2aC\r\n\r\nstruct tag_tsKyPuhWUdS8zBSeRGR2aC\r\n{\r\n  int32_T isInitialized;\r\n};\r\n\r\n#endif                                 /* struct_tag_tsKyPuhWUdS8zBSeRGR2aC */\r\n\r\n#ifndef typedef_stm32cube_blocks_DigitalPortW_T\r\n#define typedef_stm32cube_blocks_DigitalPortW_T\r\n\r\ntypedef struct tag_tsKyPuhWUdS8zBSeRGR2aC stm32cube_blocks_DigitalPortW_T;\r\n\r\n#endif                             /* typedef_stm32cube_blocks_DigitalPortW_T */\r\n\r\n/* Custom Type definition for MATLABSystem: '<S26>/PWM Output' */\r\n#include \"stm_timer_ll.h\"\r\n#include \"stm_timer_ll.h\"\r\n#ifndef struct_tag_0RzKA0TA5eXyA1b3sjyvMG\r\n#define struct_tag_0RzKA0TA5eXyA1b3sjyvMG\r\n\r\nstruct tag_0RzKA0TA5eXyA1b3sjyvMG\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  TIM_Type_T* TimerHandle;\r\n};\r\n\r\n#endif                                 /* struct_tag_0RzKA0TA5eXyA1b3sjyvMG */\r\n\r\n#ifndef typedef_stm32cube_blocks_PWMOutput_mc_T\r\n#define typedef_stm32cube_blocks_PWMOutput_mc_T\r\n\r\ntypedef struct tag_0RzKA0TA5eXyA1b3sjyvMG stm32cube_blocks_PWMOutput_mc_T;\r\n\r\n#endif                             /* typedef_stm32cube_blocks_PWMOutput_mc_T */\r\n\r\n#ifndef struct_tag_UjrdchBSJr9uXrLnGNh2HB\r\n#define struct_tag_UjrdchBSJr9uXrLnGNh2HB\r\n\r\nstruct tag_UjrdchBSJr9uXrLnGNh2HB\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  ADC_Type_T* ADCHandle;\r\n};\r\n\r\n#endif                                 /* struct_tag_UjrdchBSJr9uXrLnGNh2HB */\r\n\r\n#ifndef typedef_stm32cube_blocks_AnalogInput__T\r\n#define typedef_stm32cube_blocks_AnalogInput__T\r\n\r\ntypedef struct tag_UjrdchBSJr9uXrLnGNh2HB stm32cube_blocks_AnalogInput__T;\r\n\r\n#endif                             /* typedef_stm32cube_blocks_AnalogInput__T */\r\n\r\n/* Custom Type definition for MATLABSystem: '<S2>/CAN Write' */\r\n#include \"stm_can_hal.h\"\r\n#ifndef struct_tag_SnSgtQYxxl9kKF1a4KngUE\r\n#define struct_tag_SnSgtQYxxl9kKF1a4KngUE\r\n\r\nstruct tag_SnSgtQYxxl9kKF1a4KngUE\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  CAN_Type_T * MW_CAN_HANDLE;\r\n};\r\n\r\n#endif                                 /* struct_tag_SnSgtQYxxl9kKF1a4KngUE */\r\n\r\n#ifndef typedef_stm32cube_blocks_CANRead_mcb__T\r\n#define typedef_stm32cube_blocks_CANRead_mcb__T\r\n\r\ntypedef struct tag_SnSgtQYxxl9kKF1a4KngUE stm32cube_blocks_CANRead_mcb__T;\r\n\r\n#endif                             /* typedef_stm32cube_blocks_CANRead_mcb__T */\r\n\r\n#ifndef struct_tag_PntCqqci1qldtb9wcAzzPH\r\n#define struct_tag_PntCqqci1qldtb9wcAzzPH\r\n\r\nstruct tag_PntCqqci1qldtb9wcAzzPH\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  CAN_Type_T * MW_CAN_HANDLE;\r\n};\r\n\r\n#endif                                 /* struct_tag_PntCqqci1qldtb9wcAzzPH */\r\n\r\n#ifndef typedef_stm32cube_blocks_CANWrite_mcb_T\r\n#define typedef_stm32cube_blocks_CANWrite_mcb_T\r\n\r\ntypedef struct tag_PntCqqci1qldtb9wcAzzPH stm32cube_blocks_CANWrite_mcb_T;\r\n\r\n#endif                             /* typedef_stm32cube_blocks_CANWrite_mcb_T */\r\n\r\n/* Custom Type definition for MATLAB Function: '<S49>/MATLAB Function' */\r\n#include <time.h>\r\n#include <time.h>\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_mcb_open_loop_control_nucle_T_ P_mcb_open_loop_control_nucle_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_mcb_open_loop_control_T RT_MODEL_mcb_open_loop_contro_T;\r\n\r\n#endif                        /* mcb_open_loop_control_nucleo_f401re_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"mcb_open_loop_control_nucleo_f401re_data.c","type":"source","group":"data","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: mcb_open_loop_control_nucleo_f401re_data.c\r\n *\r\n * Code generated for Simulink model 'mcb_open_loop_control_nucleo_f401re'.\r\n *\r\n * Model version                  : 9.4\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Feb 16 20:00:16 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"mcb_open_loop_control_nucleo_f401re.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_mcb_open_loop_control_nucle_T mcb_open_loop_control_nucleo__P = {\r\n  /* Variable: Ts\r\n   * Referenced by: '<S29>/Sample_Time'\r\n   */\r\n  5.0E-5F,\r\n\r\n  /* Mask Parameter: BitwiseOR_BitMask\r\n   * Referenced by: '<S6>/Bitwise OR'\r\n   */\r\n  255U,\r\n\r\n  /* Expression: single(100)\r\n   * Referenced by: '<S15>/Constant1'\r\n   */\r\n  100.0F,\r\n\r\n  /* Computed Parameter: Constant_Value\r\n   * Referenced by: '<S15>/Constant'\r\n   */\r\n  1.0F,\r\n\r\n  /* Computed Parameter: sqrt3_by_two_Gain\r\n   * Referenced by: '<S36>/sqrt3_by_two'\r\n   */\r\n  0.866025388F,\r\n\r\n  /* Computed Parameter: one_by_two_Gain\r\n   * Referenced by: '<S36>/one_by_two'\r\n   */\r\n  0.5F,\r\n\r\n  /* Computed Parameter: Kc_Gain\r\n   * Referenced by: '<S36>/Kc'\r\n   */\r\n  1.0F,\r\n\r\n  /* Computed Parameter: Kb_Gain\r\n   * Referenced by: '<S36>/Kb'\r\n   */\r\n  1.0F,\r\n\r\n  /* Computed Parameter: Ka_Gain\r\n   * Referenced by: '<S36>/Ka'\r\n   */\r\n  1.0F,\r\n\r\n  /* Computed Parameter: Gain_Gain\r\n   * Referenced by: '<S15>/Gain'\r\n   */\r\n  0.5F,\r\n\r\n  /* Computed Parameter: stop_Value\r\n   * Referenced by: '<S20>/stop'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: Out1_Y0\r\n   * Referenced by: '<S48>/Out1'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: theta_e_Y0\r\n   * Referenced by: '<S47>/theta_e'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: Vabc_PU_Y0\r\n   * Referenced by: '<S5>/Vabc_PU'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: Constant_Value_h\r\n   * Referenced by: '<S43>/Constant'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: Constant_Value_g\r\n   * Referenced by: '<S30>/Constant'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: RampGenerator_gainval\r\n   * Referenced by: '<S29>/Ramp Generator'\r\n   */\r\n  1.0F,\r\n\r\n  /* Computed Parameter: RampGenerator_IC\r\n   * Referenced by: '<S29>/Ramp Generator'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: RampGenerator_UpperSat\r\n   * Referenced by: '<S29>/Ramp Generator'\r\n   */\r\n  1.0F,\r\n\r\n  /* Computed Parameter: RampGenerator_LowerSat\r\n   * Referenced by: '<S29>/Ramp Generator'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: Vbyf_Gain\r\n   * Referenced by: '<S28>/V-by-f'\r\n   */\r\n  0.00375F,\r\n\r\n  /* Computed Parameter: Correction_Factor_sinePWM_Gain\r\n   * Referenced by: '<S28>/Correction_Factor_sinePWM'\r\n   */\r\n  1.15470052F,\r\n\r\n  /* Computed Parameter: BoostVoltage_Value\r\n   * Referenced by: '<S5>/Boost Voltage'\r\n   */\r\n  0.2F,\r\n\r\n  /* Computed Parameter: Saturation_UpperSat\r\n   * Referenced by: '<S32>/Saturation'\r\n   */\r\n  0.95F,\r\n\r\n  /* Computed Parameter: Saturation_LowerSat\r\n   * Referenced by: '<S32>/Saturation'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: sine_table_values_Value\r\n   * Referenced by: '<S39>/sine_table_values'\r\n   */\r\n  { 0.0F, 0.00785390101F, 0.0157073177F, 0.023559764F, 0.0314107575F,\r\n    0.0392598175F, 0.0471064523F, 0.0549501814F, 0.0627905205F, 0.070626989F,\r\n    0.0784591F, 0.086286366F, 0.0941083133F, 0.101924457F, 0.109734312F,\r\n    0.117537394F, 0.125333235F, 0.133121341F, 0.140901238F, 0.148672432F,\r\n    0.156434461F, 0.16418685F, 0.171929106F, 0.179660752F, 0.187381312F,\r\n    0.195090324F, 0.202787295F, 0.210471764F, 0.21814324F, 0.225801274F,\r\n    0.233445361F, 0.241075054F, 0.24868989F, 0.256289363F, 0.263873041F,\r\n    0.271440446F, 0.278991103F, 0.286524564F, 0.294040322F, 0.301537961F,\r\n    0.309017F, 0.316476971F, 0.323917419F, 0.331337899F, 0.338737935F,\r\n    0.346117049F, 0.353474855F, 0.360810816F, 0.368124545F, 0.375415564F,\r\n    0.382683426F, 0.389927685F, 0.397147894F, 0.404343605F, 0.411514372F,\r\n    0.418659747F, 0.425779283F, 0.432872593F, 0.439939171F, 0.446978629F,\r\n    0.453990489F, 0.460974365F, 0.46792981F, 0.474856377F, 0.481753677F,\r\n    0.488621235F, 0.495458663F, 0.502265513F, 0.509041429F, 0.515785873F,\r\n    0.522498548F, 0.529179F, 0.535826802F, 0.542441547F, 0.549022794F,\r\n    0.555570245F, 0.562083364F, 0.568561852F, 0.575005233F, 0.581413209F,\r\n    0.587785244F, 0.594121039F, 0.600420237F, 0.60668236F, 0.612907052F,\r\n    0.619093955F, 0.625242651F, 0.631352782F, 0.637424F, 0.643455863F,\r\n    0.649448037F, 0.655400157F, 0.661311865F, 0.667182744F, 0.673012495F,\r\n    0.678800762F, 0.684547126F, 0.690251231F, 0.695912778F, 0.70153141F,\r\n    0.707106769F, 0.712638497F, 0.718126297F, 0.723569751F, 0.72896862F,\r\n    0.734322488F, 0.739631116F, 0.744894F, 0.750111043F, 0.755281806F,\r\n    0.760405958F, 0.765483201F, 0.770513237F, 0.775495768F, 0.780430436F,\r\n    0.785316944F, 0.790155F, 0.794944346F, 0.799684644F, 0.804375648F, 0.809017F,\r\n    0.813608468F, 0.818149745F, 0.822640538F, 0.827080548F, 0.831469595F,\r\n    0.835807383F, 0.840093553F, 0.844327927F, 0.848510206F, 0.852640152F,\r\n    0.856717527F, 0.860742033F, 0.86471343F, 0.868631542F, 0.872496F,\r\n    0.876306653F, 0.880063295F, 0.883765638F, 0.887413442F, 0.891006529F,\r\n    0.894544661F, 0.898027599F, 0.901455104F, 0.904827058F, 0.908143163F,\r\n    0.911403298F, 0.914607167F, 0.91775465F, 0.920845509F, 0.923879504F,\r\n    0.926856577F, 0.92977649F, 0.932639F, 0.935444057F, 0.938191354F,\r\n    0.940880775F, 0.943512142F, 0.946085334F, 0.948600173F, 0.95105654F,\r\n    0.953454196F, 0.955793F, 0.958072901F, 0.96029371F, 0.962455213F,\r\n    0.964557409F, 0.96660012F, 0.968583167F, 0.970506489F, 0.972369909F,\r\n    0.974173367F, 0.975916743F, 0.977599919F, 0.979222834F, 0.980785251F,\r\n    0.982287228F, 0.983728647F, 0.985109329F, 0.986429274F, 0.987688363F,\r\n    0.988886476F, 0.990023673F, 0.991099775F, 0.992114723F, 0.993068457F,\r\n    0.993961F, 0.994792163F, 0.995561957F, 0.996270359F, 0.996917307F,\r\n    0.997502804F, 0.998026729F, 0.998489082F, 0.998889863F, 0.999229F,\r\n    0.999506533F, 0.999722421F, 0.999876618F, 0.999969184F, 1.0F, 0.999969184F,\r\n    0.999876618F, 0.999722421F, 0.999506533F, 0.999229F, 0.998889863F,\r\n    0.998489082F, 0.998026729F, 0.997502804F, 0.996917307F, 0.996270359F,\r\n    0.995561957F, 0.994792163F, 0.993961F, 0.993068457F, 0.992114723F,\r\n    0.991099775F, 0.990023673F, 0.988886476F, 0.987688363F, 0.986429274F,\r\n    0.985109329F, 0.983728647F, 0.982287228F, 0.980785251F, 0.979222834F,\r\n    0.977599919F, 0.975916743F, 0.974173367F, 0.972369909F, 0.970506489F,\r\n    0.968583167F, 0.96660012F, 0.964557409F, 0.962455213F, 0.96029371F,\r\n    0.958072901F, 0.955793F, 0.953454196F, 0.95105654F, 0.948600173F,\r\n    0.946085334F, 0.943512142F, 0.940880775F, 0.938191354F, 0.935444057F,\r\n    0.932639F, 0.92977649F, 0.926856577F, 0.923879504F, 0.920845509F,\r\n    0.91775465F, 0.914607167F, 0.911403298F, 0.908143163F, 0.904827058F,\r\n    0.901455104F, 0.898027599F, 0.894544661F, 0.891006529F, 0.887413442F,\r\n    0.883765638F, 0.880063295F, 0.876306653F, 0.872496F, 0.868631542F,\r\n    0.86471343F, 0.860742033F, 0.856717527F, 0.852640152F, 0.848510206F,\r\n    0.844327927F, 0.840093553F, 0.835807383F, 0.831469595F, 0.827080548F,\r\n    0.822640538F, 0.818149745F, 0.813608468F, 0.809017F, 0.804375648F,\r\n    0.799684644F, 0.794944346F, 0.790155F, 0.785316944F, 0.780430436F,\r\n    0.775495768F, 0.770513237F, 0.765483201F, 0.760405958F, 0.755281806F,\r\n    0.750111043F, 0.744894F, 0.739631116F, 0.734322488F, 0.72896862F,\r\n    0.723569751F, 0.718126297F, 0.712638497F, 0.707106769F, 0.70153141F,\r\n    0.695912778F, 0.690251231F, 0.684547126F, 0.678800762F, 0.673012495F,\r\n    0.667182744F, 0.661311865F, 0.655400157F, 0.649448037F, 0.643455863F,\r\n    0.637424F, 0.631352782F, 0.625242651F, 0.619093955F, 0.612907052F,\r\n    0.60668236F, 0.600420237F, 0.594121039F, 0.587785244F, 0.581413209F,\r\n    0.575005233F, 0.568561852F, 0.562083364F, 0.555570245F, 0.549022794F,\r\n    0.542441547F, 0.535826802F, 0.529179F, 0.522498548F, 0.515785873F,\r\n    0.509041429F, 0.502265513F, 0.495458663F, 0.488621235F, 0.481753677F,\r\n    0.474856377F, 0.46792981F, 0.460974365F, 0.453990489F, 0.446978629F,\r\n    0.439939171F, 0.432872593F, 0.425779283F, 0.418659747F, 0.411514372F,\r\n    0.404343605F, 0.397147894F, 0.389927685F, 0.382683426F, 0.375415564F,\r\n    0.368124545F, 0.360810816F, 0.353474855F, 0.346117049F, 0.338737935F,\r\n    0.331337899F, 0.323917419F, 0.316476971F, 0.309017F, 0.301537961F,\r\n    0.294040322F, 0.286524564F, 0.278991103F, 0.271440446F, 0.263873041F,\r\n    0.256289363F, 0.24868989F, 0.241075054F, 0.233445361F, 0.225801274F,\r\n    0.21814324F, 0.210471764F, 0.202787295F, 0.195090324F, 0.187381312F,\r\n    0.179660752F, 0.171929106F, 0.16418685F, 0.156434461F, 0.148672432F,\r\n    0.140901238F, 0.133121341F, 0.125333235F, 0.117537394F, 0.109734312F,\r\n    0.101924457F, 0.0941083133F, 0.086286366F, 0.0784591F, 0.070626989F,\r\n    0.0627905205F, 0.0549501814F, 0.0471064523F, 0.0392598175F, 0.0314107575F,\r\n    0.023559764F, 0.0157073177F, 0.00785390101F, 1.22464685E-16F,\r\n    -0.00785390101F, -0.0157073177F, -0.023559764F, -0.0314107575F,\r\n    -0.0392598175F, -0.0471064523F, -0.0549501814F, -0.0627905205F,\r\n    -0.070626989F, -0.0784591F, -0.086286366F, -0.0941083133F, -0.101924457F,\r\n    -0.109734312F, -0.117537394F, -0.125333235F, -0.133121341F, -0.140901238F,\r\n    -0.148672432F, -0.156434461F, -0.16418685F, -0.171929106F, -0.179660752F,\r\n    -0.187381312F, -0.195090324F, -0.202787295F, -0.210471764F, -0.21814324F,\r\n    -0.225801274F, -0.233445361F, -0.241075054F, -0.24868989F, -0.256289363F,\r\n    -0.263873041F, -0.271440446F, -0.278991103F, -0.286524564F, -0.294040322F,\r\n    -0.301537961F, -0.309017F, -0.316476971F, -0.323917419F, -0.331337899F,\r\n    -0.338737935F, -0.346117049F, -0.353474855F, -0.360810816F, -0.368124545F,\r\n    -0.375415564F, -0.382683426F, -0.389927685F, -0.397147894F, -0.404343605F,\r\n    -0.411514372F, -0.418659747F, -0.425779283F, -0.432872593F, -0.439939171F,\r\n    -0.446978629F, -0.453990489F, -0.460974365F, -0.46792981F, -0.474856377F,\r\n    -0.481753677F, -0.488621235F, -0.495458663F, -0.502265513F, -0.509041429F,\r\n    -0.515785873F, -0.522498548F, -0.529179F, -0.535826802F, -0.542441547F,\r\n    -0.549022794F, -0.555570245F, -0.562083364F, -0.568561852F, -0.575005233F,\r\n    -0.581413209F, -0.587785244F, -0.594121039F, -0.600420237F, -0.60668236F,\r\n    -0.612907052F, -0.619093955F, -0.625242651F, -0.631352782F, -0.637424F,\r\n    -0.643455863F, -0.649448037F, -0.655400157F, -0.661311865F, -0.667182744F,\r\n    -0.673012495F, -0.678800762F, -0.684547126F, -0.690251231F, -0.695912778F,\r\n    -0.70153141F, -0.707106769F, -0.712638497F, -0.718126297F, -0.723569751F,\r\n    -0.72896862F, -0.734322488F, -0.739631116F, -0.744894F, -0.750111043F,\r\n    -0.755281806F, -0.760405958F, -0.765483201F, -0.770513237F, -0.775495768F,\r\n    -0.780430436F, -0.785316944F, -0.790155F, -0.794944346F, -0.799684644F,\r\n    -0.804375648F, -0.809017F, -0.813608468F, -0.818149745F, -0.822640538F,\r\n    -0.827080548F, -0.831469595F, -0.835807383F, -0.840093553F, -0.844327927F,\r\n    -0.848510206F, -0.852640152F, -0.856717527F, -0.860742033F, -0.86471343F,\r\n    -0.868631542F, -0.872496F, -0.876306653F, -0.880063295F, -0.883765638F,\r\n    -0.887413442F, -0.891006529F, -0.894544661F, -0.898027599F, -0.901455104F,\r\n    -0.904827058F, -0.908143163F, -0.911403298F, -0.914607167F, -0.91775465F,\r\n    -0.920845509F, -0.923879504F, -0.926856577F, -0.92977649F, -0.932639F,\r\n    -0.935444057F, -0.938191354F, -0.940880775F, -0.943512142F, -0.946085334F,\r\n    -0.948600173F, -0.95105654F, -0.953454196F, -0.955793F, -0.958072901F,\r\n    -0.96029371F, -0.962455213F, -0.964557409F, -0.96660012F, -0.968583167F,\r\n    -0.970506489F, -0.972369909F, -0.974173367F, -0.975916743F, -0.977599919F,\r\n    -0.979222834F, -0.980785251F, -0.982287228F, -0.983728647F, -0.985109329F,\r\n    -0.986429274F, -0.987688363F, -0.988886476F, -0.990023673F, -0.991099775F,\r\n    -0.992114723F, -0.993068457F, -0.993961F, -0.994792163F, -0.995561957F,\r\n    -0.996270359F, -0.996917307F, -0.997502804F, -0.998026729F, -0.998489082F,\r\n    -0.998889863F, -0.999229F, -0.999506533F, -0.999722421F, -0.999876618F,\r\n    -0.999969184F, -1.0F, -0.999969184F, -0.999876618F, -0.999722421F,\r\n    -0.999506533F, -0.999229F, -0.998889863F, -0.998489082F, -0.998026729F,\r\n    -0.997502804F, -0.996917307F, -0.996270359F, -0.995561957F, -0.994792163F,\r\n    -0.993961F, -0.993068457F, -0.992114723F, -0.991099775F, -0.990023673F,\r\n    -0.988886476F, -0.987688363F, -0.986429274F, -0.985109329F, -0.983728647F,\r\n    -0.982287228F, -0.980785251F, -0.979222834F, -0.977599919F, -0.975916743F,\r\n    -0.974173367F, -0.972369909F, -0.970506489F, -0.968583167F, -0.96660012F,\r\n    -0.964557409F, -0.962455213F, -0.96029371F, -0.958072901F, -0.955793F,\r\n    -0.953454196F, -0.95105654F, -0.948600173F, -0.946085334F, -0.943512142F,\r\n    -0.940880775F, -0.938191354F, -0.935444057F, -0.932639F, -0.92977649F,\r\n    -0.926856577F, -0.923879504F, -0.920845509F, -0.91775465F, -0.914607167F,\r\n    -0.911403298F, -0.908143163F, -0.904827058F, -0.901455104F, -0.898027599F,\r\n    -0.894544661F, -0.891006529F, -0.887413442F, -0.883765638F, -0.880063295F,\r\n    -0.876306653F, -0.872496F, -0.868631542F, -0.86471343F, -0.860742033F,\r\n    -0.856717527F, -0.852640152F, -0.848510206F, -0.844327927F, -0.840093553F,\r\n    -0.835807383F, -0.831469595F, -0.827080548F, -0.822640538F, -0.818149745F,\r\n    -0.813608468F, -0.809017F, -0.804375648F, -0.799684644F, -0.794944346F,\r\n    -0.790155F, -0.785316944F, -0.780430436F, -0.775495768F, -0.770513237F,\r\n    -0.765483201F, -0.760405958F, -0.755281806F, -0.750111043F, -0.744894F,\r\n    -0.739631116F, -0.734322488F, -0.72896862F, -0.723569751F, -0.718126297F,\r\n    -0.712638497F, -0.707106769F, -0.70153141F, -0.695912778F, -0.690251231F,\r\n    -0.684547126F, -0.678800762F, -0.673012495F, -0.667182744F, -0.661311865F,\r\n    -0.655400157F, -0.649448037F, -0.643455863F, -0.637424F, -0.631352782F,\r\n    -0.625242651F, -0.619093955F, -0.612907052F, -0.60668236F, -0.600420237F,\r\n    -0.594121039F, -0.587785244F, -0.581413209F, -0.575005233F, -0.568561852F,\r\n    -0.562083364F, -0.555570245F, -0.549022794F, -0.542441547F, -0.535826802F,\r\n    -0.529179F, -0.522498548F, -0.515785873F, -0.509041429F, -0.502265513F,\r\n    -0.495458663F, -0.488621235F, -0.481753677F, -0.474856377F, -0.46792981F,\r\n    -0.460974365F, -0.453990489F, -0.446978629F, -0.439939171F, -0.432872593F,\r\n    -0.425779283F, -0.418659747F, -0.411514372F, -0.404343605F, -0.397147894F,\r\n    -0.389927685F, -0.382683426F, -0.375415564F, -0.368124545F, -0.360810816F,\r\n    -0.353474855F, -0.346117049F, -0.338737935F, -0.331337899F, -0.323917419F,\r\n    -0.316476971F, -0.309017F, -0.301537961F, -0.294040322F, -0.286524564F,\r\n    -0.278991103F, -0.271440446F, -0.263873041F, -0.256289363F, -0.24868989F,\r\n    -0.241075054F, -0.233445361F, -0.225801274F, -0.21814324F, -0.210471764F,\r\n    -0.202787295F, -0.195090324F, -0.187381312F, -0.179660752F, -0.171929106F,\r\n    -0.16418685F, -0.156434461F, -0.148672432F, -0.140901238F, -0.133121341F,\r\n    -0.125333235F, -0.117537394F, -0.109734312F, -0.101924457F, -0.0941083133F,\r\n    -0.086286366F, -0.0784591F, -0.070626989F, -0.0627905205F, -0.0549501814F,\r\n    -0.0471064523F, -0.0392598175F, -0.0314107575F, -0.023559764F,\r\n    -0.0157073177F, -0.00785390101F, -2.44929371E-16F, 0.00785390101F,\r\n    0.0157073177F, 0.023559764F, 0.0314107575F, 0.0392598175F, 0.0471064523F,\r\n    0.0549501814F, 0.0627905205F, 0.070626989F, 0.0784591F, 0.086286366F,\r\n    0.0941083133F, 0.101924457F, 0.109734312F, 0.117537394F, 0.125333235F,\r\n    0.133121341F, 0.140901238F, 0.148672432F, 0.156434461F, 0.16418685F,\r\n    0.171929106F, 0.179660752F, 0.187381312F, 0.195090324F, 0.202787295F,\r\n    0.210471764F, 0.21814324F, 0.225801274F, 0.233445361F, 0.241075054F,\r\n    0.24868989F, 0.256289363F, 0.263873041F, 0.271440446F, 0.278991103F,\r\n    0.286524564F, 0.294040322F, 0.301537961F, 0.309017F, 0.316476971F,\r\n    0.323917419F, 0.331337899F, 0.338737935F, 0.346117049F, 0.353474855F,\r\n    0.360810816F, 0.368124545F, 0.375415564F, 0.382683426F, 0.389927685F,\r\n    0.397147894F, 0.404343605F, 0.411514372F, 0.418659747F, 0.425779283F,\r\n    0.432872593F, 0.439939171F, 0.446978629F, 0.453990489F, 0.460974365F,\r\n    0.46792981F, 0.474856377F, 0.481753677F, 0.488621235F, 0.495458663F,\r\n    0.502265513F, 0.509041429F, 0.515785873F, 0.522498548F, 0.529179F,\r\n    0.535826802F, 0.542441547F, 0.549022794F, 0.555570245F, 0.562083364F,\r\n    0.568561852F, 0.575005233F, 0.581413209F, 0.587785244F, 0.594121039F,\r\n    0.600420237F, 0.60668236F, 0.612907052F, 0.619093955F, 0.625242651F,\r\n    0.631352782F, 0.637424F, 0.643455863F, 0.649448037F, 0.655400157F,\r\n    0.661311865F, 0.667182744F, 0.673012495F, 0.678800762F, 0.684547126F,\r\n    0.690251231F, 0.695912778F, 0.70153141F, 0.707106769F, 0.712638497F,\r\n    0.718126297F, 0.723569751F, 0.72896862F, 0.734322488F, 0.739631116F,\r\n    0.744894F, 0.750111043F, 0.755281806F, 0.760405958F, 0.765483201F,\r\n    0.770513237F, 0.775495768F, 0.780430436F, 0.785316944F, 0.790155F,\r\n    0.794944346F, 0.799684644F, 0.804375648F, 0.809017F, 0.813608468F,\r\n    0.818149745F, 0.822640538F, 0.827080548F, 0.831469595F, 0.835807383F,\r\n    0.840093553F, 0.844327927F, 0.848510206F, 0.852640152F, 0.856717527F,\r\n    0.860742033F, 0.86471343F, 0.868631542F, 0.872496F, 0.876306653F,\r\n    0.880063295F, 0.883765638F, 0.887413442F, 0.891006529F, 0.894544661F,\r\n    0.898027599F, 0.901455104F, 0.904827058F, 0.908143163F, 0.911403298F,\r\n    0.914607167F, 0.91775465F, 0.920845509F, 0.923879504F, 0.926856577F,\r\n    0.92977649F, 0.932639F, 0.935444057F, 0.938191354F, 0.940880775F,\r\n    0.943512142F, 0.946085334F, 0.948600173F, 0.95105654F, 0.953454196F,\r\n    0.955793F, 0.958072901F, 0.96029371F, 0.962455213F, 0.964557409F,\r\n    0.96660012F, 0.968583167F, 0.970506489F, 0.972369909F, 0.974173367F,\r\n    0.975916743F, 0.977599919F, 0.979222834F, 0.980785251F, 0.982287228F,\r\n    0.983728647F, 0.985109329F, 0.986429274F, 0.987688363F, 0.988886476F,\r\n    0.990023673F, 0.991099775F, 0.992114723F, 0.993068457F, 0.993961F,\r\n    0.994792163F, 0.995561957F, 0.996270359F, 0.996917307F, 0.997502804F,\r\n    0.998026729F, 0.998489082F, 0.998889863F, 0.999229F, 0.999506533F,\r\n    0.999722421F, 0.999876618F, 0.999969184F, 1.0F, 0.999969184F },\r\n\r\n  /* Computed Parameter: position_increment_Gain\r\n   * Referenced by: '<S28>/position_increment'\r\n   */\r\n  0.000314159261F,\r\n\r\n  /* Computed Parameter: scaleIn_Gain\r\n   * Referenced by: '<S31>/scaleIn'\r\n   */\r\n  0.159154937F,\r\n\r\n  /* Computed Parameter: UnitDelay_InitialCondition\r\n   * Referenced by: '<S31>/Unit Delay'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: scaleOut_Gain\r\n   * Referenced by: '<S31>/scaleOut'\r\n   */\r\n  6.28318548F,\r\n\r\n  /* Computed Parameter: convert_pu_Gain\r\n   * Referenced by: '<S41>/convert_pu'\r\n   */\r\n  0.159154937F,\r\n\r\n  /* Computed Parameter: indexing_Gain\r\n   * Referenced by: '<S39>/indexing'\r\n   */\r\n  800.0F,\r\n\r\n  /* Computed Parameter: One_Value\r\n   * Referenced by: '<S29>/One'\r\n   */\r\n  1.0F,\r\n\r\n  /* Computed Parameter: Ramp_Timesec_Value\r\n   * Referenced by: '<S27>/Ramp_Time (sec)'\r\n   */\r\n  3.0F,\r\n\r\n  /* Computed Parameter: Gain_Gain_m\r\n   * Referenced by: '<S3>/Gain'\r\n   */\r\n  -1,\r\n\r\n  /* Computed Parameter: offset_Value\r\n   * Referenced by: '<S39>/offset'\r\n   */\r\n  { 1, 0, 201, 200 },\r\n\r\n  /* Computed Parameter: TmpRTBAtOpenLoopControlInport2_\r\n   * Referenced by:\r\n   */\r\n  0,\r\n\r\n  /* Computed Parameter: rpm2freq_Gain\r\n   * Referenced by: '<S27>/rpm2freq'\r\n   */\r\n  17476,\r\n\r\n  /* Computed Parameter: Offset_Value\r\n   * Referenced by: '<S38>/Offset'\r\n   */\r\n  0U,\r\n\r\n  /* Computed Parameter: Switch_Threshold\r\n   * Referenced by: '<S38>/Switch'\r\n   */\r\n  1U,\r\n\r\n  /* Expression: inverter.EnableLogic\r\n   * Referenced by: '<S19>/Constant1'\r\n   */\r\n  1U,\r\n\r\n  /* Computed Parameter: Switch_Threshold_g\r\n   * Referenced by: '<S19>/Switch'\r\n   */\r\n  0U,\r\n\r\n  /* Computed Parameter: NumberIDECU1_Value\r\n   * Referenced by: '<Root>/Number ID ECU1'\r\n   */\r\n  2598U,\r\n\r\n  /* Computed Parameter: Delay_InitialCondition\r\n   * Referenced by: '<S47>/Delay'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: Constant_Value_a\r\n   * Referenced by: '<S47>/Constant'\r\n   */\r\n  true,\r\n\r\n  /* Computed Parameter: Constant_Reset_Value\r\n   * Referenced by: '<S31>/Constant_Reset'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: TmpRTBAtDataTypeConversion1Outp\r\n   * Referenced by:\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: NumberControlSafety_Value\r\n   * Referenced by: '<Root>/Number Control Safety'\r\n   */\r\n  55U\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.c\r\n *\r\n * Code generated for Simulink model 'mcb_open_loop_control_nucleo_f401re'.\r\n *\r\n * Model version                  : 9.4\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Feb 16 20:00:16 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n\r\n/* Return rtNaN needed by the generated code. */\r\nreal_T rtGetNaN(void)\r\n{\r\n  return rtNaN;\r\n}\r\n\r\n/* Return rtNaNF needed by the generated code. */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  return rtNaNF;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.h\r\n *\r\n * Code generated for Simulink model 'mcb_open_loop_control_nucleo_f401re'.\r\n *\r\n * Model version                  : 9.4\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Feb 16 20:00:16 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtGetNaN_h_\r\n#define rtGetNaN_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* rtGetNaN_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.c\r\n *\r\n * Code generated for Simulink model 'mcb_open_loop_control_nucleo_f401re'.\r\n *\r\n * Model version                  : 9.4\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Feb 16 20:00:16 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"math.h\"\r\n\r\nreal_T rtNaN = -(real_T)NAN;\r\nreal_T rtInf = (real_T)INFINITY;\r\nreal_T rtMinusInf = -(real_T)INFINITY;\r\nreal32_T rtNaNF = -(real32_T)NAN;\r\nreal32_T rtInfF = (real32_T)INFINITY;\r\nreal32_T rtMinusInfF = -(real32_T)INFINITY;\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)isinf(value);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)isinf(value);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  return (boolean_T)(isnan(value) != 0);\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  return (boolean_T)(isnan(value) != 0);\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.h\r\n *\r\n * Code generated for Simulink model 'mcb_open_loop_control_nucleo_f401re'.\r\n *\r\n * Model version                  : 9.4\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Feb 16 20:00:16 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rt_nonfinite_h_\r\n#define rt_nonfinite_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\n\r\n#endif                                 /* rt_nonfinite_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'mcb_open_loop_control_nucleo_f401re'.\r\n *\r\n * Model version                  : 9.4\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Feb 16 20:00:16 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32    long long:  64\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'mcb_open_loop_control_nucleo_f401re'.\r\n *\r\n * Model version                  : 9.4\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Sun Feb 16 20:00:16 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtmodel_h_\r\n#define rtmodel_h_\r\n#include \"mcb_open_loop_control_nucleo_f401re.h\"\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"mw_stm32_board_header.h\"\n#include \"SysTickScheduler.h\"\n#include \"arm_cortex_m_multitasking.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE STM32F4xx Based\n#define MW_CONNECTIONINFO_SERIAL_BAUDRATE stm32cube.codegen.getConnectivityBaudrate(hCS)\n#define MW_CONNECTIONINFO_SERIAL_COMPORT stm32cube.codegen.getConnectivityCOMPort(hCS)\n#define MW_CONNECTIONINFO_SERIAL_VERBOSE 1\n#define MW_CONNECTIONINFO_TCPIP_IPADDRESS stm32cube.parameters.EthernetConfigIPAddressExternalMode\n#define MW_CONNECTIONINFO_TCPIP_PORT 17725\n#define MW_CONNECTIONINFO_TCPIP_VERBOSE 1\n#define MW_CONNECTIONINFO_CAN_CANVENDOR matlab:stm32cube.codegen.getXCPonCANConnectivity(hCS,'Vendor')\n#define MW_CONNECTIONINFO_CAN_CANDEVICE matlab:stm32cube.codegen.getXCPonCANConnectivity(hCS,'Device')\n#define MW_CONNECTIONINFO_CAN_CANCHANNEL stm32cube.codegen.getXCPonCANConnectivity(hCS,'Channel')\n#define MW_CONNECTIONINFO_CAN_BUSSPEED stm32cube.codegen.getXCPonCANConnectivity(hCS,'Baudrate')\n#define MW_CONNECTIONINFO_CAN_CANIDCOMMAND stm32cube.codegen.getXCPonCANConnectivity(hCS,'CANIDCommand')\n#define MW_CONNECTIONINFO_CAN_CANIDRESPONSE stm32cube.codegen.getXCPonCANConnectivity(hCS,'CANIDResponse')\n#define MW_CONNECTIONINFO_CAN_ISCANIDEXTENDED stm32cube.codegen.getXCPonCANConnectivity(hCS,'IsCANIDExtended')\n#define MW_CONNECTIONINFO_CAN_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION Serial\n#define MW_EXTMODE_SIGNALBUFFERSIZE 16384.000000\n#define MW_EXTMODE_USEREALTIMESTAMPLOGGING 1\n#define MW_RTOS Baremetal\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 0\n#define MW_RUNTIME_RUNTIMELIBRARY 0\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_STM32CUBEMX_PROJECTFILEBUTTON \n#define MW_STM32CUBEMX_CREATEPROJECTFILEBUTTON \n#define MW_STM32CUBEMX_LAUNCHPROJECTFILEBUTTON \n#define MW_STM32CUBEMX_PROJECTFILE C:/Users/aferreira/Documents/MATLAB/Examples/R2024b/stm32f4discovery/OpenLoopControlUsingSTM32F4xxBasedExample/stm32g446re_pmsm_example/stm32g446re_pmsm_example.ioc\n#define MW_STM32CUBEMX_DEVICEID STM32F446R(C-E)Tx\n#define MW_STM32CUBEMX_FAMILY STM32F4\n#define MW_STM32CUBEMX_CONNECTIVITYMODE 0\n#define MW_STM32CUBEMX_AUTODETECTBOARD 1\n#define MW_STM32CUBEMX_DEVICELIST -1\n#define MW_STM32CUBEMX_CONNECTIONPORT 0\n#define MW_STM32CUBEMX_MODE 0\n#define MW_STM32CUBEMX_ACCESSPORT 0\n#define MW_STM32CUBEMX_RESETMODE 0\n#define MW_STM32CUBEMX_DEVICELISTREFRESH \n#define MW_CLOCKING_CPUCLOCKRATEMHZ 84.000000\n#define MW_CONNECTION_SERIALMODULE 1\n#define MW_CONNECTION_SERIALPORT COM5\n#define MW_CONNECTION_ETHERNETPORT 17725.000000\n#define MW_CONNECTION_SERIALCONFIGUREMODULE 48\n#define MW_CONNECTION_ETHERNETCONFIGUREMODULE 48\n#define MW_CONNECTION_CANCONFIGUREMODULE 48\n#define MW_CONNECTION_CANMODULE 0\n#define MW_CONNECTION_BAUDRATE 250000\n#define MW_CONNECTION_CANREADSOURCE 0\n#define MW_CONNECTION_CANVENDOR -1\n#define MW_CONNECTION_CANDEVICE -1\n#define MW_CONNECTION_CANCHANNEL -1\n#define MW_CONNECTION_ISCANIDEXTENDED 48\n#define MW_CONNECTION_CANIDCOMMAND 2\n#define MW_CONNECTION_CANIDRESPONSE 3\n#define MW_ADC1_USEDMA 0\n#define MW_ADC1_USEWATCHDOG 0\n#define MW_ADC1_EOCENABLEINTERRUPT 1\n#define MW_ADC1_JEOCENABLEINTERRUPT 1\n#define MW_ADC1_OVRENABLEINTERRUPT 48\n#define MW_ADC1_PROJECTFILEBUTTON \n#define MW_ADC2_USEDMA 0\n#define MW_ADC2_USEWATCHDOG 0\n#define MW_ADC2_EOCENABLEINTERRUPT 0\n#define MW_ADC2_JEOCENABLEINTERRUPT 48\n#define MW_ADC2_OVRENABLEINTERRUPT 48\n#define MW_ADC2_PROJECTFILEBUTTON \n#define MW_ADC3_USEDMA 0\n#define MW_ADC3_USEWATCHDOG 0\n#define MW_ADC3_EOCENABLEINTERRUPT 0\n#define MW_ADC3_JEOCENABLEINTERRUPT 48\n#define MW_ADC3_OVRENABLEINTERRUPT 48\n#define MW_ADC3_PROJECTFILEBUTTON \n#define MW_TIM1_TRIGGERINTERRUPT 48\n#define MW_TIM1_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM1_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM1_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM1_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM1_UPDATEINTERRUPT 0\n#define MW_TIM1_BREAKINTERRUPT 48\n#define MW_TIM1_STARTTIMER 49\n#define MW_TIM1_COMINTERRUPT 48\n#define MW_TIM2_TRIGGERINTERRUPT 48\n#define MW_TIM2_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM2_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM2_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM2_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM2_UPDATEINTERRUPT 48\n#define MW_TIM2_STARTTIMER 49\n#define MW_TIM3_TRIGGERINTERRUPT 48\n#define MW_TIM3_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM3_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM3_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM3_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM3_UPDATEINTERRUPT 48\n#define MW_TIM3_STARTTIMER 49\n#define MW_TIM4_TRIGGERINTERRUPT 48\n#define MW_TIM4_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM4_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM4_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM4_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM4_UPDATEINTERRUPT 48\n#define MW_TIM4_STARTTIMER 49\n#define MW_TIM5_TRIGGERINTERRUPT 48\n#define MW_TIM5_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM5_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM5_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM5_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM5_UPDATEINTERRUPT 48\n#define MW_TIM5_STARTTIMER 49\n#define MW_TIM8_TRIGGERINTERRUPT 48\n#define MW_TIM8_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM8_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM8_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM8_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM8_UPDATEINTERRUPT 48\n#define MW_TIM8_BREAKINTERRUPT 48\n#define MW_TIM8_STARTTIMER 49\n#define MW_TIM8_COMINTERRUPT 48\n#define MW_TIM9_TRIGGERINTERRUPT 0\n#define MW_TIM9_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM9_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM9_UPDATEINTERRUPT 48\n#define MW_TIM9_STARTTIMER 49\n#define MW_TIM10_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM10_UPDATEINTERRUPT 48\n#define MW_TIM10_STARTTIMER 49\n#define MW_TIM10_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM11_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM11_UPDATEINTERRUPT 48\n#define MW_TIM11_STARTTIMER 49\n#define MW_TIM12_TRIGGERINTERRUPT 48\n#define MW_TIM12_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM12_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM12_UPDATEINTERRUPT 48\n#define MW_TIM12_STARTTIMER 49\n#define MW_TIM13_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM13_UPDATEINTERRUPT 48\n#define MW_TIM13_STARTTIMER 49\n#define MW_TIM14_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM14_UPDATEINTERRUPT 48\n#define MW_TIM14_STARTTIMER 49\n#define MW_DATAVERSION 2016.02\n#define MW_STM32_PWMOUTPUT_ID 3775:1523\n#define MW_STM32_ANALOGINPUT_ID 3774:462\n#define MW_STM32_HARDWAREINTERRUPT_ID 3773\n#define MW_STM32_DIGITALPORTREAD_ID 3777:318\n#define MW_STM32_DIGITALPORTWRITE_ID 3779:334\n#define MW_USART_USART1CONFIGUREMODULE 48\n#define MW_USART_USART1TRANSMITMODE 0\n#define MW_USART_USART1RECEIVEMODE 0\n#define MW_USART_USART1TRANSMITBUFFERLENGTH 128\n#define MW_USART_USART1RECEIVEBUFFERLENGTH 128\n#define MW_USART_USART1DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_USART2CONFIGUREMODULE 48\n#define MW_USART_USART2TRANSMITMODE 0\n#define MW_USART_USART2RECEIVEMODE 0\n#define MW_USART_USART2TRANSMITBUFFERLENGTH 128\n#define MW_USART_USART2RECEIVEBUFFERLENGTH 128\n#define MW_USART_USART2DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_USART3CONFIGUREMODULE 48\n#define MW_USART_USART3TRANSMITMODE 0\n#define MW_USART_USART3RECEIVEMODE 0\n#define MW_USART_USART3TRANSMITBUFFERLENGTH 128\n#define MW_USART_USART3RECEIVEBUFFERLENGTH 128\n#define MW_USART_USART3DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_UART4CONFIGUREMODULE 48\n#define MW_USART_UART4TRANSMITMODE 0\n#define MW_USART_UART4RECEIVEMODE 0\n#define MW_USART_UART4TRANSMITBUFFERLENGTH 128\n#define MW_USART_UART4RECEIVEBUFFERLENGTH 128\n#define MW_USART_UART4DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_UART5CONFIGUREMODULE 48\n#define MW_USART_UART5TRANSMITMODE 0\n#define MW_USART_UART5RECEIVEMODE 0\n#define MW_USART_UART5TRANSMITBUFFERLENGTH 128\n#define MW_USART_UART5RECEIVEBUFFERLENGTH 128\n#define MW_USART_UART5DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_USART6CONFIGUREMODULE 48\n#define MW_USART_USART6TRANSMITMODE 0\n#define MW_USART_USART6RECEIVEMODE 0\n#define MW_USART_USART6TRANSMITBUFFERLENGTH 128\n#define MW_USART_USART6RECEIVEBUFFERLENGTH 128\n#define MW_USART_USART6DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_UART7CONFIGUREMODULE 48\n#define MW_USART_UART7TRANSMITMODE 0\n#define MW_USART_UART7RECEIVEMODE 0\n#define MW_USART_UART7TRANSMITBUFFERLENGTH 128\n#define MW_USART_UART7RECEIVEBUFFERLENGTH 128\n#define MW_USART_UART7DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_UART8CONFIGUREMODULE 48\n#define MW_USART_UART8TRANSMITMODE 0\n#define MW_USART_UART8RECEIVEMODE 0\n#define MW_USART_UART8TRANSMITBUFFERLENGTH 128\n#define MW_USART_UART8RECEIVEBUFFERLENGTH 128\n#define MW_USART_UART8DISABLEDMAINTERRUPTONERROR 48\n#define MW_RTOSBASERATETASKPRIORITY 40\n#define MW_ETHERNET_HOSTNAME STM32F4xx\n#define MW_ETHERNET_MACADDR 00:80:E1:00:00:00\n#define MW_ETHERNET_DHCPENABLED 1\n#define MW_ETHERNET_LOCALIPADDRESS 0.0.0.0\n#define MW_ETHERNET_SUBNETMASK 0.0.0.0\n#define MW_ETHERNET_GATEWAY 0.0.0.0\n#define MW_SPI_SPIMODULESELECT 0\n#define MW_SPI_SPI1TXFIFOINTERRUPT 0.000000\n#define MW_SPI_SPI1RXFIFOINTERRUPT 0\n#define MW_SPI_SPI1ERRORINTERRUPT 0\n#define MW_SPI_SPI2TXFIFOINTERRUPT 0.000000\n#define MW_SPI_SPI2RXFIFOINTERRUPT 0\n#define MW_SPI_SPI2ERRORINTERRUPT 0\n#define MW_SPI_SPI3TXFIFOINTERRUPT 0.000000\n#define MW_SPI_SPI3RXFIFOINTERRUPT 0\n#define MW_SPI_SPI3ERRORINTERRUPT 0\n#define MW_SPI_SPI4TXFIFOINTERRUPT 0.000000\n#define MW_SPI_SPI4RXFIFOINTERRUPT 0\n#define MW_SPI_SPI4ERRORINTERRUPT 0\n#define MW_SPI_SPI5TXFIFOINTERRUPT 0.000000\n#define MW_SPI_SPI5RXFIFOINTERRUPT 0\n#define MW_SPI_SPI5ERRORINTERRUPT 0\n#define MW_TIMER_TIMERGROUP 0\n#define MW_TIMER_TIM1CONFIGUREMODULE 48\n#define MW_TIMER_TIM8CONFIGUREMODULE 48\n#define MW_TIMER_TIM2CONFIGUREMODULE 48\n#define MW_TIMER_TIM3CONFIGUREMODULE 48\n#define MW_TIMER_TIM4CONFIGUREMODULE 48\n#define MW_TIMER_TIM5CONFIGUREMODULE 48\n#define MW_TIMER_TIM6CONFIGUREMODULE 48\n#define MW_TIMER_TIM7CONFIGUREMODULE 48\n#define MW_TIMER_TIM9CONFIGUREMODULE 48\n#define MW_TIMER_TIM10CONFIGUREMODULE 48\n#define MW_TIMER_TIM11CONFIGUREMODULE 48\n#define MW_TIMER_TIM12CONFIGUREMODULE 48\n#define MW_TIMER_TIM13CONFIGUREMODULE 48\n#define MW_TIMER_TIM14CONFIGUREMODULE 48\n#define MW_TIM6_STARTTIMER 49\n#define MW_TIM6_UPDATEINTERRUPT 48\n#define MW_TIM7_STARTTIMER 49\n#define MW_TIM7_UPDATEINTERRUPT 48\n#define MW_CAN_MODULE 0\n#define MW_CAN1_BAUDRATE 250000\n#define MW_CAN1_CONFIGUREINTENRX 0\n#define MW_CAN1_CONFIGUREINTFIFO0RX 0\n#define MW_CAN1_ENABLEFIFO0MSGPENDINGINTR 0\n#define MW_CAN1_ENABLEFIFO0FULLINTR 0\n#define MW_CAN1_ENABLEFIFO0OVRINTR 0\n#define MW_CAN1_CONFIGUREINTFIFO1RX 0\n#define MW_CAN1_ENABLEFIFO1MSGPENDINGINTR 0\n#define MW_CAN1_ENABLEFIFO1FULLINTR 0\n#define MW_CAN1_ENABLEFIFO1OVRINTR 0\n#define MW_CAN1_CONFIGUREINTENTX 0\n#define MW_CAN1_ENABLETXMAILBOXEMPTYINTR 0\n#define MW_CAN1_CONFIGUREINTENOTHER 0\n#define MW_CAN1_ENABLEERRWARNINTR 0\n#define MW_CAN1_ENABLEERRPASSIVEINTR 0\n#define MW_CAN1_ENABLEBUSOFFINTR 0\n#define MW_CAN1_ENABLELASTERRCODEINTR 0\n#define MW_CAN1_ENABLEWAKEUPINTR 0\n#define MW_CAN1_ENABLESLEEPACKINTR 0\n#define MW_CAN1_ACCEPTALLMESSAGES 1\n#define MW_CAN1_FILTERBANKNUMBER 0\n#define MW_CAN1_ENABLEFILTERBANK00 0\n#define MW_CAN1_SCALE00 0\n#define MW_CAN1_MODE00 0\n#define MW_CAN1_FIFOASSIGNMENT00 0\n#define MW_CAN1_IDTYPE00 0\n#define MW_CAN1_ID1_00 0\n#define MW_CAN1_MASK1_00 0\n#define MW_CAN1_ID2_00 0\n#define MW_CAN1_MASK2_00 0\n#define MW_CAN1_ID3_00 0\n#define MW_CAN1_ID4_00 0\n#define MW_CAN1_ENABLEFILTERBANK01 0\n#define MW_CAN1_SCALE01 0\n#define MW_CAN1_MODE01 0\n#define MW_CAN1_FIFOASSIGNMENT01 0\n#define MW_CAN1_IDTYPE01 0\n#define MW_CAN1_ID1_01 0\n#define MW_CAN1_MASK1_01 0\n#define MW_CAN1_ID2_01 0\n#define MW_CAN1_MASK2_01 0\n#define MW_CAN1_ID3_01 0\n#define MW_CAN1_ID4_01 0\n#define MW_CAN1_ENABLEFILTERBANK02 0\n#define MW_CAN1_SCALE02 0\n#define MW_CAN1_MODE02 0\n#define MW_CAN1_FIFOASSIGNMENT02 0\n#define MW_CAN1_IDTYPE02 0\n#define MW_CAN1_ID1_02 0\n#define MW_CAN1_MASK1_02 0\n#define MW_CAN1_ID2_02 0\n#define MW_CAN1_MASK2_02 0\n#define MW_CAN1_ID3_02 0\n#define MW_CAN1_ID4_02 0\n#define MW_CAN1_ENABLEFILTERBANK03 0\n#define MW_CAN1_SCALE03 0\n#define MW_CAN1_MODE03 0\n#define MW_CAN1_FIFOASSIGNMENT03 0\n#define MW_CAN1_IDTYPE03 0\n#define MW_CAN1_ID1_03 0\n#define MW_CAN1_MASK1_03 0\n#define MW_CAN1_ID2_03 0\n#define MW_CAN1_MASK2_03 0\n#define MW_CAN1_ID3_03 0\n#define MW_CAN1_ID4_03 0\n#define MW_CAN1_ENABLEFILTERBANK04 0\n#define MW_CAN1_SCALE04 0\n#define MW_CAN1_MODE04 0\n#define MW_CAN1_FIFOASSIGNMENT04 0\n#define MW_CAN1_IDTYPE04 0\n#define MW_CAN1_ID1_04 0\n#define MW_CAN1_MASK1_04 0\n#define MW_CAN1_ID2_04 0\n#define MW_CAN1_MASK2_04 0\n#define MW_CAN1_ID3_04 0\n#define MW_CAN1_ID4_04 0\n#define MW_CAN1_ENABLEFILTERBANK05 0\n#define MW_CAN1_SCALE05 0\n#define MW_CAN1_MODE05 0\n#define MW_CAN1_FIFOASSIGNMENT05 0\n#define MW_CAN1_IDTYPE05 0\n#define MW_CAN1_ID1_05 0\n#define MW_CAN1_MASK1_05 0\n#define MW_CAN1_ID2_05 0\n#define MW_CAN1_MASK2_05 0\n#define MW_CAN1_ID3_05 0\n#define MW_CAN1_ID4_05 0\n#define MW_CAN1_ENABLEFILTERBANK06 0\n#define MW_CAN1_SCALE06 0\n#define MW_CAN1_MODE06 0\n#define MW_CAN1_FIFOASSIGNMENT06 0\n#define MW_CAN1_IDTYPE06 0\n#define MW_CAN1_ID1_06 0\n#define MW_CAN1_MASK1_06 0\n#define MW_CAN1_ID2_06 0\n#define MW_CAN1_MASK2_06 0\n#define MW_CAN1_ID3_06 0\n#define MW_CAN1_ID4_06 0\n#define MW_CAN1_ENABLEFILTERBANK07 0\n#define MW_CAN1_SCALE07 0\n#define MW_CAN1_MODE07 0\n#define MW_CAN1_FIFOASSIGNMENT07 0\n#define MW_CAN1_IDTYPE07 0\n#define MW_CAN1_ID1_07 0\n#define MW_CAN1_MASK1_07 0\n#define MW_CAN1_ID2_07 0\n#define MW_CAN1_MASK2_07 0\n#define MW_CAN1_ID3_07 0\n#define MW_CAN1_ID4_07 0\n#define MW_CAN1_ENABLEFILTERBANK08 0\n#define MW_CAN1_SCALE08 0\n#define MW_CAN1_MODE08 0\n#define MW_CAN1_FIFOASSIGNMENT08 0\n#define MW_CAN1_IDTYPE08 0\n#define MW_CAN1_ID1_08 0\n#define MW_CAN1_MASK1_08 0\n#define MW_CAN1_ID2_08 0\n#define MW_CAN1_MASK2_08 0\n#define MW_CAN1_ID3_08 0\n#define MW_CAN1_ID4_08 0\n#define MW_CAN1_ENABLEFILTERBANK09 0\n#define MW_CAN1_SCALE09 0\n#define MW_CAN1_MODE09 0\n#define MW_CAN1_FIFOASSIGNMENT09 0\n#define MW_CAN1_IDTYPE09 0\n#define MW_CAN1_ID1_09 0\n#define MW_CAN1_MASK1_09 0\n#define MW_CAN1_ID2_09 0\n#define MW_CAN1_MASK2_09 0\n#define MW_CAN1_ID3_09 0\n#define MW_CAN1_ID4_09 0\n#define MW_CAN1_ENABLEFILTERBANK10 0\n#define MW_CAN1_SCALE10 0\n#define MW_CAN1_MODE10 0\n#define MW_CAN1_FIFOASSIGNMENT10 0\n#define MW_CAN1_IDTYPE10 0\n#define MW_CAN1_ID1_10 0\n#define MW_CAN1_MASK1_10 0\n#define MW_CAN1_ID2_10 0\n#define MW_CAN1_MASK2_10 0\n#define MW_CAN1_ID3_10 0\n#define MW_CAN1_ID4_10 0\n#define MW_CAN1_ENABLEFILTERBANK11 0\n#define MW_CAN1_SCALE11 0\n#define MW_CAN1_MODE11 0\n#define MW_CAN1_FIFOASSIGNMENT11 0\n#define MW_CAN1_IDTYPE11 0\n#define MW_CAN1_ID1_11 0\n#define MW_CAN1_MASK1_11 0\n#define MW_CAN1_ID2_11 0\n#define MW_CAN1_MASK2_11 0\n#define MW_CAN1_ID3_11 0\n#define MW_CAN1_ID4_11 0\n#define MW_CAN1_ENABLEFILTERBANK12 0\n#define MW_CAN1_SCALE12 0\n#define MW_CAN1_MODE12 0\n#define MW_CAN1_FIFOASSIGNMENT12 0\n#define MW_CAN1_IDTYPE12 0\n#define MW_CAN1_ID1_12 0\n#define MW_CAN1_MASK1_12 0\n#define MW_CAN1_ID2_12 0\n#define MW_CAN1_MASK2_12 0\n#define MW_CAN1_ID3_12 0\n#define MW_CAN1_ID4_12 0\n#define MW_CAN1_ENABLEFILTERBANK13 0\n#define MW_CAN1_SCALE13 0\n#define MW_CAN1_MODE13 0\n#define MW_CAN1_FIFOASSIGNMENT13 0\n#define MW_CAN1_IDTYPE13 0\n#define MW_CAN1_ID1_13 0\n#define MW_CAN1_MASK1_13 0\n#define MW_CAN1_ID2_13 0\n#define MW_CAN1_MASK2_13 0\n#define MW_CAN1_ID3_13 0\n#define MW_CAN1_ID4_13 0\n#define MW_CAN2_BAUDRATE 1000000\n#define MW_CAN2_CONFIGUREINTENRX 0\n#define MW_CAN2_CONFIGUREINTFIFO0RX 0\n#define MW_CAN2_ENABLEFIFO0MSGPENDINGINTR 0\n#define MW_CAN2_ENABLEFIFO0FULLINTR 0\n#define MW_CAN2_ENABLEFIFO0OVRINTR 0\n#define MW_CAN2_CONFIGUREINTFIFO1RX 0\n#define MW_CAN2_ENABLEFIFO1MSGPENDINGINTR 0\n#define MW_CAN2_ENABLEFIFO1FULLINTR 0\n#define MW_CAN2_ENABLEFIFO1OVRINTR 0\n#define MW_CAN2_CONFIGUREINTENTX 0\n#define MW_CAN2_ENABLETXMAILBOXEMPTYINTR 0\n#define MW_CAN2_CONFIGUREINTENOTHER 0\n#define MW_CAN2_ENABLEERRWARNINTR 0\n#define MW_CAN2_ENABLEERRPASSIVEINTR 0\n#define MW_CAN2_ENABLEBUSOFFINTR 0\n#define MW_CAN2_ENABLELASTERRCODEINTR 0\n#define MW_CAN2_ENABLEWAKEUPINTR 0\n#define MW_CAN2_ENABLESLEEPACKINTR 0\n#define MW_CAN2_ACCEPTALLMESSAGES 1\n#define MW_CAN2_FILTERBANKNUMBER 0\n#define MW_CAN2_ENABLEFILTERBANK00 0\n#define MW_CAN2_SCALE00 0\n#define MW_CAN2_MODE00 0\n#define MW_CAN2_FIFOASSIGNMENT00 0\n#define MW_CAN2_IDTYPE00 0\n#define MW_CAN2_ID1_00 0\n#define MW_CAN2_MASK1_00 0\n#define MW_CAN2_ID2_00 0\n#define MW_CAN2_MASK2_00 0\n#define MW_CAN2_ID3_00 0\n#define MW_CAN2_ID4_00 0\n#define MW_CAN2_ENABLEFILTERBANK01 0\n#define MW_CAN2_SCALE01 0\n#define MW_CAN2_MODE01 0\n#define MW_CAN2_FIFOASSIGNMENT01 0\n#define MW_CAN2_IDTYPE01 0\n#define MW_CAN2_ID1_01 0\n#define MW_CAN2_MASK1_01 0\n#define MW_CAN2_ID2_01 0\n#define MW_CAN2_MASK2_01 0\n#define MW_CAN2_ID3_01 0\n#define MW_CAN2_ID4_01 0\n#define MW_CAN2_ENABLEFILTERBANK02 0\n#define MW_CAN2_SCALE02 0\n#define MW_CAN2_MODE02 0\n#define MW_CAN2_FIFOASSIGNMENT02 0\n#define MW_CAN2_IDTYPE02 0\n#define MW_CAN2_ID1_02 0\n#define MW_CAN2_MASK1_02 0\n#define MW_CAN2_ID2_02 0\n#define MW_CAN2_MASK2_02 0\n#define MW_CAN2_ID3_02 0\n#define MW_CAN2_ID4_02 0\n#define MW_CAN2_ENABLEFILTERBANK03 0\n#define MW_CAN2_SCALE03 0\n#define MW_CAN2_MODE03 0\n#define MW_CAN2_FIFOASSIGNMENT03 0\n#define MW_CAN2_IDTYPE03 0\n#define MW_CAN2_ID1_03 0\n#define MW_CAN2_MASK1_03 0\n#define MW_CAN2_ID2_03 0\n#define MW_CAN2_MASK2_03 0\n#define MW_CAN2_ID3_03 0\n#define MW_CAN2_ID4_03 0\n#define MW_CAN2_ENABLEFILTERBANK04 0\n#define MW_CAN2_SCALE04 0\n#define MW_CAN2_MODE04 0\n#define MW_CAN2_FIFOASSIGNMENT04 0\n#define MW_CAN2_IDTYPE04 0\n#define MW_CAN2_ID1_04 0\n#define MW_CAN2_MASK1_04 0\n#define MW_CAN2_ID2_04 0\n#define MW_CAN2_MASK2_04 0\n#define MW_CAN2_ID3_04 0\n#define MW_CAN2_ID4_04 0\n#define MW_CAN2_ENABLEFILTERBANK05 0\n#define MW_CAN2_SCALE05 0\n#define MW_CAN2_MODE05 0\n#define MW_CAN2_FIFOASSIGNMENT05 0\n#define MW_CAN2_IDTYPE05 0\n#define MW_CAN2_ID1_05 0\n#define MW_CAN2_MASK1_05 0\n#define MW_CAN2_ID2_05 0\n#define MW_CAN2_MASK2_05 0\n#define MW_CAN2_ID3_05 0\n#define MW_CAN2_ID4_05 0\n#define MW_CAN2_ENABLEFILTERBANK06 0\n#define MW_CAN2_SCALE06 0\n#define MW_CAN2_MODE06 0\n#define MW_CAN2_FIFOASSIGNMENT06 0\n#define MW_CAN2_IDTYPE06 0\n#define MW_CAN2_ID1_06 0\n#define MW_CAN2_MASK1_06 0\n#define MW_CAN2_ID2_06 0\n#define MW_CAN2_MASK2_06 0\n#define MW_CAN2_ID3_06 0\n#define MW_CAN2_ID4_06 0\n#define MW_CAN2_ENABLEFILTERBANK07 0\n#define MW_CAN2_SCALE07 0\n#define MW_CAN2_MODE07 0\n#define MW_CAN2_FIFOASSIGNMENT07 0\n#define MW_CAN2_IDTYPE07 0\n#define MW_CAN2_ID1_07 0\n#define MW_CAN2_MASK1_07 0\n#define MW_CAN2_ID2_07 0\n#define MW_CAN2_MASK2_07 0\n#define MW_CAN2_ID3_07 0\n#define MW_CAN2_ID4_07 0\n#define MW_CAN2_ENABLEFILTERBANK08 0\n#define MW_CAN2_SCALE08 0\n#define MW_CAN2_MODE08 0\n#define MW_CAN2_FIFOASSIGNMENT08 0\n#define MW_CAN2_IDTYPE08 0\n#define MW_CAN2_ID1_08 0\n#define MW_CAN2_MASK1_08 0\n#define MW_CAN2_ID2_08 0\n#define MW_CAN2_MASK2_08 0\n#define MW_CAN2_ID3_08 0\n#define MW_CAN2_ID4_08 0\n#define MW_CAN2_ENABLEFILTERBANK09 0\n#define MW_CAN2_SCALE09 0\n#define MW_CAN2_MODE09 0\n#define MW_CAN2_FIFOASSIGNMENT09 0\n#define MW_CAN2_IDTYPE09 0\n#define MW_CAN2_ID1_09 0\n#define MW_CAN2_MASK1_09 0\n#define MW_CAN2_ID2_09 0\n#define MW_CAN2_MASK2_09 0\n#define MW_CAN2_ID3_09 0\n#define MW_CAN2_ID4_09 0\n#define MW_CAN2_ENABLEFILTERBANK10 0\n#define MW_CAN2_SCALE10 0\n#define MW_CAN2_MODE10 0\n#define MW_CAN2_FIFOASSIGNMENT10 0\n#define MW_CAN2_IDTYPE10 0\n#define MW_CAN2_ID1_10 0\n#define MW_CAN2_MASK1_10 0\n#define MW_CAN2_ID2_10 0\n#define MW_CAN2_MASK2_10 0\n#define MW_CAN2_ID3_10 0\n#define MW_CAN2_ID4_10 0\n#define MW_CAN2_ENABLEFILTERBANK11 0\n#define MW_CAN2_SCALE11 0\n#define MW_CAN2_MODE11 0\n#define MW_CAN2_FIFOASSIGNMENT11 0\n#define MW_CAN2_IDTYPE11 0\n#define MW_CAN2_ID1_11 0\n#define MW_CAN2_MASK1_11 0\n#define MW_CAN2_ID2_11 0\n#define MW_CAN2_MASK2_11 0\n#define MW_CAN2_ID3_11 0\n#define MW_CAN2_ID4_11 0\n#define MW_CAN2_ENABLEFILTERBANK12 0\n#define MW_CAN2_SCALE12 0\n#define MW_CAN2_MODE12 0\n#define MW_CAN2_FIFOASSIGNMENT12 0\n#define MW_CAN2_IDTYPE12 0\n#define MW_CAN2_ID1_12 0\n#define MW_CAN2_MASK1_12 0\n#define MW_CAN2_ID2_12 0\n#define MW_CAN2_MASK2_12 0\n#define MW_CAN2_ID3_12 0\n#define MW_CAN2_ID4_12 0\n#define MW_CAN2_ENABLEFILTERBANK13 0\n#define MW_CAN2_SCALE13 0\n#define MW_CAN2_MODE13 0\n#define MW_CAN2_FIFOASSIGNMENT13 0\n#define MW_CAN2_IDTYPE13 0\n#define MW_CAN2_ID1_13 0\n#define MW_CAN2_MASK1_13 0\n#define MW_CAN2_ID2_13 0\n#define MW_CAN2_MASK2_13 0\n#define MW_CAN2_ID3_13 0\n#define MW_CAN2_ID4_13 0\n#define MW_PIL_INTERFACE 0\n#define MW_EXTMODEPROTOCOLINFO_CAN_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_CAN_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_CAN_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_CAN_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_CAN_MAXCONTIGSAMPLES 10\n#define MW_CONNECTIVITY_REFRESH \n#define MW_SIMULINKIO_MODELTRANSPORTDATAFCN stm32cube.connectedIO.getConfigSetInfo\n#define MW_SIMULINKIO_SERVERDEPLOYFCN stm32cube.connectedIO.updateServer\n#define MW_SIMULINKIO_VALIDATESERVERFCN stm32cube.connectedIO.validateIoServer\n#define MW_SIMULINKIO_INTERFACE 0\n#define MW_SIMULINKIO_VALIDATEBEFORECONNECTFCN stm32cube.connectedIO.connectedIOModelValidation\n#define MW_CAN3_BAUDRATE 1000000\n#define MW_CAN3_CONFIGUREINTENRX 0\n#define MW_CAN3_CONFIGUREINTFIFO0RX 0\n#define MW_CAN3_ENABLEFIFO0MSGPENDINGINTR 0\n#define MW_CAN3_ENABLEFIFO0FULLINTR 0\n#define MW_CAN3_ENABLEFIFO0OVRINTR 0\n#define MW_CAN3_CONFIGUREINTFIFO1RX 0\n#define MW_CAN3_ENABLEFIFO1MSGPENDINGINTR 0\n#define MW_CAN3_ENABLEFIFO1FULLINTR 0\n#define MW_CAN3_ENABLEFIFO1OVRINTR 0\n#define MW_CAN3_CONFIGUREINTENTX 0\n#define MW_CAN3_ENABLETXMAILBOXEMPTYINTR 0\n#define MW_CAN3_CONFIGUREINTENOTHER 0\n#define MW_CAN3_ENABLEERRWARNINTR 0\n#define MW_CAN3_ENABLEERRPASSIVEINTR 0\n#define MW_CAN3_ENABLEBUSOFFINTR 0\n#define MW_CAN3_ENABLELASTERRCODEINTR 0\n#define MW_CAN3_ENABLEWAKEUPINTR 0\n#define MW_CAN3_ENABLESLEEPACKINTR 0\n#define MW_CAN3_ACCEPTALLMESSAGES 1\n#define MW_CAN3_FILTERBANKNUMBER 0\n#define MW_CAN3_ENABLEFILTERBANK00 0\n#define MW_CAN3_SCALE00 0\n#define MW_CAN3_MODE00 0\n#define MW_CAN3_FIFOASSIGNMENT00 0\n#define MW_CAN3_IDTYPE00 0\n#define MW_CAN3_ID1_00 0\n#define MW_CAN3_MASK1_00 0\n#define MW_CAN3_ID2_00 0\n#define MW_CAN3_MASK2_00 0\n#define MW_CAN3_ID3_00 0\n#define MW_CAN3_ID4_00 0\n#define MW_CAN3_ENABLEFILTERBANK01 0\n#define MW_CAN3_SCALE01 0\n#define MW_CAN3_MODE01 0\n#define MW_CAN3_FIFOASSIGNMENT01 0\n#define MW_CAN3_IDTYPE01 0\n#define MW_CAN3_ID1_01 0\n#define MW_CAN3_MASK1_01 0\n#define MW_CAN3_ID2_01 0\n#define MW_CAN3_MASK2_01 0\n#define MW_CAN3_ID3_01 0\n#define MW_CAN3_ID4_01 0\n#define MW_CAN3_ENABLEFILTERBANK02 0\n#define MW_CAN3_SCALE02 0\n#define MW_CAN3_MODE02 0\n#define MW_CAN3_FIFOASSIGNMENT02 0\n#define MW_CAN3_IDTYPE02 0\n#define MW_CAN3_ID1_02 0\n#define MW_CAN3_MASK1_02 0\n#define MW_CAN3_ID2_02 0\n#define MW_CAN3_MASK2_02 0\n#define MW_CAN3_ID3_02 0\n#define MW_CAN3_ID4_02 0\n#define MW_CAN3_ENABLEFILTERBANK03 0\n#define MW_CAN3_SCALE03 0\n#define MW_CAN3_MODE03 0\n#define MW_CAN3_FIFOASSIGNMENT03 0\n#define MW_CAN3_IDTYPE03 0\n#define MW_CAN3_ID1_03 0\n#define MW_CAN3_MASK1_03 0\n#define MW_CAN3_ID2_03 0\n#define MW_CAN3_MASK2_03 0\n#define MW_CAN3_ID3_03 0\n#define MW_CAN3_ID4_03 0\n#define MW_CAN3_ENABLEFILTERBANK04 0\n#define MW_CAN3_SCALE04 0\n#define MW_CAN3_MODE04 0\n#define MW_CAN3_FIFOASSIGNMENT04 0\n#define MW_CAN3_IDTYPE04 0\n#define MW_CAN3_ID1_04 0\n#define MW_CAN3_MASK1_04 0\n#define MW_CAN3_ID2_04 0\n#define MW_CAN3_MASK2_04 0\n#define MW_CAN3_ID3_04 0\n#define MW_CAN3_ID4_04 0\n#define MW_CAN3_ENABLEFILTERBANK05 0\n#define MW_CAN3_SCALE05 0\n#define MW_CAN3_MODE05 0\n#define MW_CAN3_FIFOASSIGNMENT05 0\n#define MW_CAN3_IDTYPE05 0\n#define MW_CAN3_ID1_05 0\n#define MW_CAN3_MASK1_05 0\n#define MW_CAN3_ID2_05 0\n#define MW_CAN3_MASK2_05 0\n#define MW_CAN3_ID3_05 0\n#define MW_CAN3_ID4_05 0\n#define MW_CAN3_ENABLEFILTERBANK06 0\n#define MW_CAN3_SCALE06 0\n#define MW_CAN3_MODE06 0\n#define MW_CAN3_FIFOASSIGNMENT06 0\n#define MW_CAN3_IDTYPE06 0\n#define MW_CAN3_ID1_06 0\n#define MW_CAN3_MASK1_06 0\n#define MW_CAN3_ID2_06 0\n#define MW_CAN3_MASK2_06 0\n#define MW_CAN3_ID3_06 0\n#define MW_CAN3_ID4_06 0\n#define MW_CAN3_ENABLEFILTERBANK07 0\n#define MW_CAN3_SCALE07 0\n#define MW_CAN3_MODE07 0\n#define MW_CAN3_FIFOASSIGNMENT07 0\n#define MW_CAN3_IDTYPE07 0\n#define MW_CAN3_ID1_07 0\n#define MW_CAN3_MASK1_07 0\n#define MW_CAN3_ID2_07 0\n#define MW_CAN3_MASK2_07 0\n#define MW_CAN3_ID3_07 0\n#define MW_CAN3_ID4_07 0\n#define MW_CAN3_ENABLEFILTERBANK08 0\n#define MW_CAN3_SCALE08 0\n#define MW_CAN3_MODE08 0\n#define MW_CAN3_FIFOASSIGNMENT08 0\n#define MW_CAN3_IDTYPE08 0\n#define MW_CAN3_ID1_08 0\n#define MW_CAN3_MASK1_08 0\n#define MW_CAN3_ID2_08 0\n#define MW_CAN3_MASK2_08 0\n#define MW_CAN3_ID3_08 0\n#define MW_CAN3_ID4_08 0\n#define MW_CAN3_ENABLEFILTERBANK09 0\n#define MW_CAN3_SCALE09 0\n#define MW_CAN3_MODE09 0\n#define MW_CAN3_FIFOASSIGNMENT09 0\n#define MW_CAN3_IDTYPE09 0\n#define MW_CAN3_ID1_09 0\n#define MW_CAN3_MASK1_09 0\n#define MW_CAN3_ID2_09 0\n#define MW_CAN3_MASK2_09 0\n#define MW_CAN3_ID3_09 0\n#define MW_CAN3_ID4_09 0\n#define MW_CAN3_ENABLEFILTERBANK10 0\n#define MW_CAN3_SCALE10 0\n#define MW_CAN3_MODE10 0\n#define MW_CAN3_FIFOASSIGNMENT10 0\n#define MW_CAN3_IDTYPE10 0\n#define MW_CAN3_ID1_10 0\n#define MW_CAN3_MASK1_10 0\n#define MW_CAN3_ID2_10 0\n#define MW_CAN3_MASK2_10 0\n#define MW_CAN3_ID3_10 0\n#define MW_CAN3_ID4_10 0\n#define MW_CAN3_ENABLEFILTERBANK11 0\n#define MW_CAN3_SCALE11 0\n#define MW_CAN3_MODE11 0\n#define MW_CAN3_FIFOASSIGNMENT11 0\n#define MW_CAN3_IDTYPE11 0\n#define MW_CAN3_ID1_11 0\n#define MW_CAN3_MASK1_11 0\n#define MW_CAN3_ID2_11 0\n#define MW_CAN3_MASK2_11 0\n#define MW_CAN3_ID3_11 0\n#define MW_CAN3_ID4_11 0\n#define MW_CAN3_ENABLEFILTERBANK12 0\n#define MW_CAN3_SCALE12 0\n#define MW_CAN3_MODE12 0\n#define MW_CAN3_FIFOASSIGNMENT12 0\n#define MW_CAN3_IDTYPE12 0\n#define MW_CAN3_ID1_12 0\n#define MW_CAN3_MASK1_12 0\n#define MW_CAN3_ID2_12 0\n#define MW_CAN3_MASK2_12 0\n#define MW_CAN3_ID3_12 0\n#define MW_CAN3_ID4_12 0\n#define MW_CAN3_ENABLEFILTERBANK13 0\n#define MW_CAN3_SCALE13 0\n#define MW_CAN3_MODE13 0\n#define MW_CAN3_FIFOASSIGNMENT13 0\n#define MW_CAN3_IDTYPE13 0\n#define MW_CAN3_ID1_13 0\n#define MW_CAN3_MASK1_13 0\n#define MW_CAN3_ID2_13 0\n#define MW_CAN3_MASK2_13 0\n#define MW_CAN3_ID3_13 0\n#define MW_CAN3_ID4_13 0\n#define MW_I2S_I2SPDMFILTERCUBEMXCONFIGUREMODULE 0\n#define MW_I2S_I2S1PDMCONFIGUREMODULE 0\n#define MW_I2S_I2S1PDM_CHANNELS_1 1\n#define MW_I2S_I2S1PDM_CHANNELS_2 2\n#define MW_I2S_I2S2PDMCONFIGUREMODULE 0\n#define MW_I2S_I2S2PDM_CHANNELS_1 1\n#define MW_I2S_I2S2PDM_CHANNELS_2 2\n#define MW_I2S_I2S3PDMCONFIGUREMODULE 0\n#define MW_I2S_I2S3PDM_CHANNELS_1 1\n#define MW_I2S_I2S3PDM_CHANNELS_2 2\n#define MW_SDCLOG_ENABLELOGGING 0\n#define MW_SDCLOG_INTERFACE 0\n#define MW_SDCLOG_ENABLELOGGINGSTATUS 0\n#define MW_SDCLOG_LOGGINGSTATUSGPIOGROUP 0\n#define MW_SDCLOG_LOGGINGSTATUSGPIOPIN 1\n#define MW_IOBLOCKSMODE deployed\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"SysTickScheduler.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\target\\shared\\armcortexmbase\\scheduler\\src","tag":"","groupDisplay":"Other files","code":"/* SysTick scheduler\n * \n * Copyright 2013-2023 The MathWorks, Inc.\n */\n \n#include \"arm_cortex_m_multitasking.h\"\n\nunsigned long schdl_counter;\nunsigned long schdl_counter_max;\n\nextern volatile uint32_t taskToSchedule;\n\nstatic void SysTick_Isr(void)\n{\n    __DSB();\n    __ISB();\n\t\n\tif (schdl_counter >= schdl_counter_max)\n\t{\n\t\tschdl_counter = 0;\n\t}\n\t\n    if (0 == schdl_counter++)\t/* Compare with zero before increment */\n\t{\n\t\t/* The rt_OneStep() function expects interrupts to be disabled. \n           Hence disable interrupt before rt_OneStep(). */\n        __disable_irq();\n        rt_OneStep();\n        /* The rt_OneStep() function disables interrupt. \n           Hence enable interrupt immediately after rt_OneStep(). */\n        __enable_irq();\n\t}\n}\n\n#if (MW_ARMv6M_AND_PLUS == 0)\n    void SysTick_Handler(){\n    SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;\n}\n#else\nMW_RENTRANT_ISR_FUNCTION_BEGIN(SysTick_Handler, -1)\n    MW_CALL_ISR_FUNCTION(SysTick_Isr);\nMW_RENTRANT_ISR_FUNCTION_END()\n#endif\n\nvoid ARMCM_SysTick_Config(float modelBaseRate)\n{\n#if !defined(MW_DONT_USE_SYSTICK)    \n#if defined(MW_SCHEDULER_INTERRUPT_SOURCE) && (MW_SCHEDULER_INTERRUPT_SOURCE == 0)\n\t/* SysTick Scheduler is selected */\n\tunsigned long tick_counter;\n\t\n\ttick_counter = (unsigned long)(SystemCoreClock * modelBaseRate);\n\t\n\tif (tick_counter > SysTick_LOAD_RELOAD_Msk)\n\t{\n\t\tschdl_counter_max = (unsigned long)((float)tick_counter / (float)SysTick_LOAD_RELOAD_Msk) + 1;\n\t\tSysTick_Config(tick_counter/schdl_counter_max);\t\t\n\t}\n\telse\n\t{\n\t\tschdl_counter_max = 0;\n\t\tSysTick_Config(tick_counter);\n\t}\n\t\n\tschdl_counter = 0;\n\t\n\t/* Set the SysTick priority */\n\t#ifdef MW_SCHEDULER_PRIORITY\n\t\tNVIC_SetPriority((IRQn_Type)(-1), MW_SCHEDULER_PRIORITY);\n\t#endif\n    #if (MW_ARMv6M_AND_PLUS == 0)\n        taskToSchedule = (uint32_t) SysTick_Isr;\n    #endif\n#endif\n#endif\n    NVIC_SetPriority((IRQn_Type)(-5), MW_MAX_PRIORITY_VALUE);\n    NVIC_SetPriority((IRQn_Type)(-2), MW_MAX_PRIORITY_VALUE);\n}\n\nvoid ARMCM_SysTick_Stop(void)\n{\n#if !defined(MW_DONT_USE_SYSTICK)    \n#if defined(MW_SCHEDULER_INTERRUPT_SOURCE) && (MW_SCHEDULER_INTERRUPT_SOURCE == 0)\n\t/* SysTick Scheduler is Stopped */\n\tSysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;\n#endif\n#endif\n}"},{"name":"can_datatype_ground.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"can_message.h\"\r\n\r\nconst CAN_DATATYPE CAN_DATATYPE_GROUND = { 0, 0, 0, 0, 0, 0.0, { 0, 0, 0, 0, 0,\r\n    0, 0, 0 } };\r\n"},{"name":"m3m4m4f_multitasking.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\target\\shared\\armcortexmbase\\scheduler\\src","tag":"","groupDisplay":"Other files","code":"/* Wrapper for Multi tasking.\n * \n * Copyright 2013-2020 The MathWorks, Inc.\n */\n\n\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#include \"MW_target_hardware_resources.h\"\n#endif\n\n#ifndef __NVIC_PRIO_BITS\n#error \"__NVIC_PRIO_BITS is undefined.  The __NVIC_PRIO_BITS is defined in hardware definition header file.\"\n#endif\n\n#include \"mw_force_no_optimization.h\"\n#include \"arm_cortex_m_multitasking.h\"\n\nvolatile uint32_t taskToSchedule;\n\n__attribute__ ((naked,aligned(4))) void PendSV_Handler() {\n    __asm volatile (\n    \"   MRS R0, APSR                            \\n\"\n    \"   PUSH {R0, LR}                           \\n\"\n    \"   MRS R0, BASEPRI                         \\n\"\n    \"   PUSH {R0, R1}                           \\n\"\n    );\n#if (defined(__FPU_PRESENT) && (__FPU_PRESENT == 1)) && (defined(__FPU_USED) && (__FPU_USED == 1))\n    __asm volatile (\n    \"   TST LR, #0x10                           \\n\"\n    \"   IT EQ                                   \\n\"\n    \"   VMOVEQ S0, S0                           \\n\"\n    );\n#endif\n    __asm volatile (\n    \"   LDR R0, =taskToSchedule                 \\n\"\n    \"   LDR R0, [R0]                            \\n\"\n    \"   PUSH {R0, R1}                           \\n\"\n    \"   SUB SP, SP, #0x20                       \\n\"\n    \"   ADR R0,Call_isr_routine_in_thread_mode \\n\"\n    \"   STR R0,[SP, #24]                        \\n\"\n    \"   MOV R0,#0x01000000                      \\n\"\n    \"   STR R0,[SP, #28]                        \\n\"\n    \"   MVN R0,#0x06                            \\n\"\n    \"   MOV LR, R0                              \\n\"\n    \"   BX LR                                   \\n\"\n    \"Call_isr_routine_in_thread_mode:           \\n\"\n    \"   POP {R0, R1}                            \\n\"\n    \"   BLX R0                                  \\n\"\n    \"   ISB                                     \\n\"\n    \"   SVC #0                                  \\n\"\n    \"Unknown_Execution:                         \\n\"\n    \"   B Unknown_Execution                     \\n\"\n    );\n}\n\n/* SVC Interrupt service routine to restore the context: SVC_Handler*/\n__attribute__ ((naked,aligned(4))) void SVC_Handler(void) {\n#if (defined(__FPU_PRESENT) && (__FPU_PRESENT == 1)) && (defined(__FPU_USED) && (__FPU_USED == 1))\n    __asm volatile (\n    \"   TST  LR, #0x10      \\n\"\n    \"   IT EQ               \\n\"\n    \"   VMOVEQ.F32 S0, S0   \\n\"\n    );\n#endif\n    __asm volatile (\n    \"   TST LR, #0x4            \\n\"\n    \"   ITE EQ                  \\n\"\n    \"   MRSEQ R0, MSP           \\n\"\n    \"   MRSNE R0, PSP           \\n\"\n    \"   LDR R1, [R0, #24]       \\n\"\n    \"   LDRB R0, [R1, #-2]      \\n\"\n    \"   CBZ R0, svc_service_0   \\n\"\n    \"   CMP R0, #1              \\n\"\n    \"   BEQ svc_service_1       \\n\"\n    \"   B Unknown_SVC_Request   \\n\"\n    \"svc_service_0:             \\n\"\n    );\n#if (defined(__FPU_PRESENT) && (__FPU_PRESENT == 1)) && (defined(__FPU_USED) && (__FPU_USED == 1))\n     __asm volatile (\n    \"   TST LR, #0x10       \\n\"\n    \"   ITE EQ              \\n\"\n    \"   ADDEQ SP, SP, #104  \\n\"\n    \"   ADDNE SP, SP, #32   \\n\"\n     );\n#else\n     __asm volatile (\"     ADD SP, SP, #32\");\n#endif\n     __asm volatile (\n    \"     POP {R0, R1}              \\n\"\n    \"     MSR BASEPRI, R0           \\n\"\n    \"     POP {R0, R1}              \\n\"\n    \"     MSR APSR_nzcvq, R0        \\n\"\n    \"     BX R1                     \\n\"\n    \"Unknown_SVC_Request:           \\n\"\n    \"     B Unknown_SVC_Request     \\n\"\n    \"svc_service_1:                 \\n\"\n    \"     MOVW R1, #0x0000ED14      \\n\"\n    \"     MOVT R1, #0xE000          \\n\"\n    \"     LDR R2,[R1]               \\n\"\n    \"     ORR R2, #1                \\n\"\n    \"     STR R2,[R1]               \\n\"\n    \"     BX LR                     \\n\"\n    \"     B Unknown_SVC_Request     \\n\"\n    );\n}\n\n/* LocalWords:  NVIC PRIO TST VMOVEQ ADR isr MOV MVNS asm cpsie chaing arival VMOV MVN\n * LocalWords:  BLX ISB SVC ITE MRSEQ MSP MRSNE PSP LDR LDRB CBZ svc CMP BEQ\n * LocalWords:  ADDEQ ADDNE MSR BASEPRI xff APSR nzcvq MOVW MOVT\n */\n"},{"name":"main.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Core\\Src","tag":"","groupDisplay":"Other files","code":"/* USER CODE BEGIN Header */\r\n/**\r\n  ******************************************************************************\r\n  * @file           : main.c\r\n  * @brief          : Main program body\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2024 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* USER CODE END Header */\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"main.h\"\r\n\r\n/* Private includes ----------------------------------------------------------*/\r\n/* USER CODE BEGIN Includes */\r\n\r\n/* USER CODE END Includes */\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* USER CODE BEGIN PTD */\r\n\r\n/* USER CODE END PTD */\r\n\r\n/* Private define ------------------------------------------------------------*/\r\n/* USER CODE BEGIN PD */\r\n/* USER CODE END PD */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* USER CODE BEGIN PM */\r\n\r\n/* USER CODE END PM */\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n\r\nCAN_HandleTypeDef hcan1;\r\n\r\n/* USER CODE BEGIN PV */\r\n\r\n/* USER CODE END PV */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\nvoid SystemClock_Config(void);\r\n/* USER CODE BEGIN PFP */\r\n\r\n/* USER CODE END PFP */\r\n\r\n/* Private user code ---------------------------------------------------------*/\r\n/* USER CODE BEGIN 0 */\r\n\r\n/* USER CODE END 0 */\r\n\r\n/**\r\n  * @brief  The application entry point.\r\n  * @retval int\r\n  */\r\n\r\n/**\r\n  * @brief System Clock Configuration\r\n  * @retval None\r\n  */\r\nvoid SystemClock_Config(void)\r\n{\r\n  LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);\r\n  while(LL_FLASH_GetLatency()!= LL_FLASH_LATENCY_2)\r\n  {\r\n  }\r\n  LL_PWR_SetRegulVoltageScaling(LL_PWR_REGU_VOLTAGE_SCALE3);\r\n  LL_PWR_DisableOverDriveMode();\r\n  LL_RCC_HSI_SetCalibTrimming(16);\r\n  LL_RCC_HSI_Enable();\r\n\r\n   /* Wait till HSI is ready */\r\n  while(LL_RCC_HSI_IsReady() != 1)\r\n  {\r\n\r\n  }\r\n  LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, LL_RCC_PLLM_DIV_16, 336, LL_RCC_PLLP_DIV_4);\r\n  LL_RCC_PLL_Enable();\r\n\r\n   /* Wait till PLL is ready */\r\n  while(LL_RCC_PLL_IsReady() != 1)\r\n  {\r\n\r\n  }\r\n  LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);\r\n  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_2);\r\n  LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_1);\r\n  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);\r\n\r\n   /* Wait till System clock is ready */\r\n  while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)\r\n  {\r\n\r\n  }\r\n  LL_SetSystemCoreClock(84000000);\r\n\r\n   /* Update the time base */\r\n  if (HAL_InitTick (TICK_INT_PRIORITY) != HAL_OK)\r\n  {\r\n    Error_Handler();\r\n  }\r\n  LL_RCC_SetTIMPrescaler(LL_RCC_TIM_PRESCALER_TWICE);\r\n}\r\n\r\n/**\r\n  * @brief ADC1 Initialization Function\r\n  * @param None\r\n  * @retval None\r\n  */\r\nvoid MX_ADC1_Init(void)\r\n{\r\n\r\n  /* USER CODE BEGIN ADC1_Init 0 */\r\n\r\n  /* USER CODE END ADC1_Init 0 */\r\n\r\n  LL_ADC_InitTypeDef ADC_InitStruct = {0};\r\n  LL_ADC_REG_InitTypeDef ADC_REG_InitStruct = {0};\r\n  LL_ADC_CommonInitTypeDef ADC_CommonInitStruct = {0};\r\n  LL_ADC_INJ_InitTypeDef ADC_INJ_InitStruct = {0};\r\n\r\n  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};\r\n\r\n  /* Peripheral clock enable */\r\n  LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_ADC1);\r\n\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOB);\r\n  /**ADC1 GPIO Configuration\r\n  PC0   ------> ADC1_IN10\r\n  PC1   ------> ADC1_IN11\r\n  PC2   ------> ADC1_IN12\r\n  PA0-WKUP   ------> ADC1_IN0\r\n  PA1   ------> ADC1_IN1\r\n  PB1   ------> ADC1_IN9\r\n  */\r\n  GPIO_InitStruct.Pin = LL_GPIO_PIN_0|LL_GPIO_PIN_1|LL_GPIO_PIN_2;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);\r\n\r\n  GPIO_InitStruct.Pin = LL_GPIO_PIN_0|LL_GPIO_PIN_1;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);\r\n\r\n  GPIO_InitStruct.Pin = LL_GPIO_PIN_1;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);\r\n\r\n  /* USER CODE BEGIN ADC1_Init 1 */\r\n\r\n  /* USER CODE END ADC1_Init 1 */\r\n  /** Common config\r\n  */\r\n  ADC_InitStruct.Resolution = LL_ADC_RESOLUTION_12B;\r\n  ADC_InitStruct.DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;\r\n  ADC_InitStruct.SequencersScanMode = LL_ADC_SEQ_SCAN_ENABLE;\r\n  LL_ADC_Init(ADC1, &ADC_InitStruct);\r\n  ADC_REG_InitStruct.TriggerSource = LL_ADC_REG_TRIG_SOFTWARE;\r\n  ADC_REG_InitStruct.SequencerLength = LL_ADC_REG_SEQ_SCAN_DISABLE;\r\n  ADC_REG_InitStruct.SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;\r\n  ADC_REG_InitStruct.ContinuousMode = LL_ADC_REG_CONV_SINGLE;\r\n  ADC_REG_InitStruct.DMATransfer = LL_ADC_REG_DMA_TRANSFER_NONE;\r\n  LL_ADC_REG_Init(ADC1, &ADC_REG_InitStruct);\r\n  LL_ADC_REG_SetFlagEndOfConversion(ADC1, LL_ADC_REG_FLAG_EOC_UNITARY_CONV);\r\n  ADC_CommonInitStruct.CommonClock = LL_ADC_CLOCK_SYNC_PCLK_DIV4;\r\n  ADC_CommonInitStruct.Multimode = LL_ADC_MULTI_INDEPENDENT;\r\n  LL_ADC_CommonInit(__LL_ADC_COMMON_INSTANCE(ADC1), &ADC_CommonInitStruct);\r\n  /** Configure Regular Channel\r\n  */\r\n  LL_ADC_REG_SetSequencerRanks(ADC1, LL_ADC_REG_RANK_1, LL_ADC_CHANNEL_9);\r\n  LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_9, LL_ADC_SAMPLINGTIME_3CYCLES);\r\n  /** Configure Injected Channel\r\n  */\r\n  ADC_INJ_InitStruct.TriggerSource = LL_ADC_INJ_TRIG_EXT_TIM1_TRGO;\r\n  ADC_INJ_InitStruct.SequencerLength = LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS;\r\n  ADC_INJ_InitStruct.SequencerDiscont = LL_ADC_INJ_SEQ_DISCONT_DISABLE;\r\n  ADC_INJ_InitStruct.TrigAuto = LL_ADC_INJ_TRIG_INDEPENDENT;\r\n  LL_ADC_INJ_Init(ADC1, &ADC_INJ_InitStruct);\r\n  LL_ADC_INJ_SetSequencerRanks(ADC1, LL_ADC_INJ_RANK_1, LL_ADC_CHANNEL_0);\r\n  LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_0, LL_ADC_SAMPLINGTIME_3CYCLES);\r\n  LL_ADC_INJ_SetOffset(ADC1, LL_ADC_INJ_RANK_1, 0);\r\n  LL_ADC_INJ_StartConversionExtTrig(ADC1, LL_ADC_INJ_TRIG_EXT_RISING);\r\n  LL_ADC_DisableIT_JEOS(ADC1);\r\n  /** Configure Injected Channel\r\n  */\r\n  LL_ADC_INJ_Init(ADC1, &ADC_INJ_InitStruct);\r\n  LL_ADC_INJ_SetSequencerRanks(ADC1, LL_ADC_INJ_RANK_2, LL_ADC_CHANNEL_11);\r\n  LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_11, LL_ADC_SAMPLINGTIME_3CYCLES);\r\n  LL_ADC_INJ_SetOffset(ADC1, LL_ADC_INJ_RANK_2, 0);\r\n  LL_ADC_INJ_StartConversionExtTrig(ADC1, LL_ADC_INJ_TRIG_EXT_RISING);\r\n  LL_ADC_DisableIT_JEOS(ADC1);\r\n  /* USER CODE BEGIN ADC1_Init 2 */\r\n\r\n  /* USER CODE END ADC1_Init 2 */\r\n\r\n}\r\n\r\n/**\r\n  * @brief CAN1 Initialization Function\r\n  * @param None\r\n  * @retval None\r\n  */\r\nvoid MX_CAN1_Init(void)\r\n{\r\n\r\n  /* USER CODE BEGIN CAN1_Init 0 */\r\n\r\n  /* USER CODE END CAN1_Init 0 */\r\n\r\n  /* USER CODE BEGIN CAN1_Init 1 */\r\n\r\n  /* USER CODE END CAN1_Init 1 */\r\n  hcan1.Instance = CAN1;\r\n  hcan1.Init.Prescaler = 12;\r\n  hcan1.Init.Mode = CAN_MODE_NORMAL;\r\n  hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;\r\n  hcan1.Init.TimeSeg1 = CAN_BS1_11TQ;\r\n  hcan1.Init.TimeSeg2 = CAN_BS2_2TQ;\r\n  hcan1.Init.TimeTriggeredMode = DISABLE;\r\n  hcan1.Init.AutoBusOff = DISABLE;\r\n  hcan1.Init.AutoWakeUp = DISABLE;\r\n  hcan1.Init.AutoRetransmission = DISABLE;\r\n  hcan1.Init.ReceiveFifoLocked = DISABLE;\r\n  hcan1.Init.TransmitFifoPriority = DISABLE;\r\n  if (HAL_CAN_Init(&hcan1) != HAL_OK)\r\n  {\r\n    Error_Handler();\r\n  }\r\n  /* USER CODE BEGIN CAN1_Init 2 */\r\n\r\n  /* USER CODE END CAN1_Init 2 */\r\n\r\n}\r\n\r\n/**\r\n  * @brief TIM1 Initialization Function\r\n  * @param None\r\n  * @retval None\r\n  */\r\nvoid MX_TIM1_Init(void)\r\n{\r\n\r\n  /* USER CODE BEGIN TIM1_Init 0 */\r\n\r\n  /* USER CODE END TIM1_Init 0 */\r\n\r\n  LL_TIM_InitTypeDef TIM_InitStruct = {0};\r\n  LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};\r\n  LL_TIM_BDTR_InitTypeDef TIM_BDTRInitStruct = {0};\r\n\r\n  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};\r\n\r\n  /* Peripheral clock enable */\r\n  LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_TIM1);\r\n\r\n  /* USER CODE BEGIN TIM1_Init 1 */\r\n\r\n  /* USER CODE END TIM1_Init 1 */\r\n  TIM_InitStruct.Prescaler = 0;\r\n  TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_CENTER_UP;\r\n  TIM_InitStruct.Autoreload = 2100;\r\n  TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;\r\n  TIM_InitStruct.RepetitionCounter = 1;\r\n  LL_TIM_Init(TIM1, &TIM_InitStruct);\r\n  LL_TIM_EnableARRPreload(TIM1);\r\n  LL_TIM_OC_EnablePreload(TIM1, LL_TIM_CHANNEL_CH1);\r\n  TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM1;\r\n  TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;\r\n  TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;\r\n  TIM_OC_InitStruct.CompareValue = 0;\r\n  TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;\r\n  TIM_OC_InitStruct.OCNPolarity = LL_TIM_OCPOLARITY_HIGH;\r\n  TIM_OC_InitStruct.OCIdleState = LL_TIM_OCIDLESTATE_LOW;\r\n  TIM_OC_InitStruct.OCNIdleState = LL_TIM_OCIDLESTATE_LOW;\r\n  LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);\r\n  LL_TIM_OC_DisableFast(TIM1, LL_TIM_CHANNEL_CH1);\r\n  LL_TIM_OC_EnablePreload(TIM1, LL_TIM_CHANNEL_CH2);\r\n  LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH2, &TIM_OC_InitStruct);\r\n  LL_TIM_OC_DisableFast(TIM1, LL_TIM_CHANNEL_CH2);\r\n  LL_TIM_OC_EnablePreload(TIM1, LL_TIM_CHANNEL_CH3);\r\n  LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH3, &TIM_OC_InitStruct);\r\n  LL_TIM_OC_DisableFast(TIM1, LL_TIM_CHANNEL_CH3);\r\n  LL_TIM_SetTriggerOutput(TIM1, LL_TIM_TRGO_UPDATE);\r\n  LL_TIM_EnableMasterSlaveMode(TIM1);\r\n  TIM_BDTRInitStruct.OSSRState = LL_TIM_OSSR_DISABLE;\r\n  TIM_BDTRInitStruct.OSSIState = LL_TIM_OSSI_DISABLE;\r\n  TIM_BDTRInitStruct.LockLevel = LL_TIM_LOCKLEVEL_OFF;\r\n  TIM_BDTRInitStruct.DeadTime = 0;\r\n  TIM_BDTRInitStruct.BreakState = LL_TIM_BREAK_DISABLE;\r\n  TIM_BDTRInitStruct.BreakPolarity = LL_TIM_BREAK_POLARITY_HIGH;\r\n  TIM_BDTRInitStruct.AutomaticOutput = LL_TIM_AUTOMATICOUTPUT_DISABLE;\r\n  LL_TIM_BDTR_Init(TIM1, &TIM_BDTRInitStruct);\r\n  /* USER CODE BEGIN TIM1_Init 2 */\r\n\r\n  /* USER CODE END TIM1_Init 2 */\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);\r\n  /**TIM1 GPIO Configuration\r\n  PA8   ------> TIM1_CH1\r\n  PA9   ------> TIM1_CH2\r\n  PA10   ------> TIM1_CH3\r\n  */\r\n  GPIO_InitStruct.Pin = LL_GPIO_PIN_8|LL_GPIO_PIN_9|LL_GPIO_PIN_10;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct.Alternate = LL_GPIO_AF_1;\r\n  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);\r\n\r\n}\r\n\r\n/**\r\n  * @brief USART2 Initialization Function\r\n  * @param None\r\n  * @retval None\r\n  */\r\nvoid MX_USART2_UART_Init(void)\r\n{\r\n\r\n  /* USER CODE BEGIN USART2_Init 0 */\r\n\r\n  /* USER CODE END USART2_Init 0 */\r\n\r\n  LL_USART_InitTypeDef USART_InitStruct = {0};\r\n\r\n  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};\r\n\r\n  /* Peripheral clock enable */\r\n  LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_USART2);\r\n\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);\r\n  /**USART2 GPIO Configuration\r\n  PA2   ------> USART2_TX\r\n  PA3   ------> USART2_RX\r\n  */\r\n  GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct.Alternate = LL_GPIO_AF_7;\r\n  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);\r\n\r\n  /* USART2 DMA Init */\r\n\r\n  /* USART2_RX Init */\r\n  LL_DMA_SetChannelSelection(DMA1, LL_DMA_STREAM_5, LL_DMA_CHANNEL_4);\r\n\r\n  LL_DMA_SetDataTransferDirection(DMA1, LL_DMA_STREAM_5, LL_DMA_DIRECTION_PERIPH_TO_MEMORY);\r\n\r\n  LL_DMA_SetStreamPriorityLevel(DMA1, LL_DMA_STREAM_5, LL_DMA_PRIORITY_LOW);\r\n\r\n  LL_DMA_SetMode(DMA1, LL_DMA_STREAM_5, LL_DMA_MODE_NORMAL);\r\n\r\n  LL_DMA_SetPeriphIncMode(DMA1, LL_DMA_STREAM_5, LL_DMA_PERIPH_NOINCREMENT);\r\n\r\n  LL_DMA_SetMemoryIncMode(DMA1, LL_DMA_STREAM_5, LL_DMA_MEMORY_INCREMENT);\r\n\r\n  LL_DMA_SetPeriphSize(DMA1, LL_DMA_STREAM_5, LL_DMA_PDATAALIGN_BYTE);\r\n\r\n  LL_DMA_SetMemorySize(DMA1, LL_DMA_STREAM_5, LL_DMA_MDATAALIGN_BYTE);\r\n\r\n  LL_DMA_DisableFifoMode(DMA1, LL_DMA_STREAM_5);\r\n\r\n  /* USER CODE BEGIN USART2_Init 1 */\r\n\r\n  /* USER CODE END USART2_Init 1 */\r\n  USART_InitStruct.BaudRate = 115200;\r\n  USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;\r\n  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;\r\n  USART_InitStruct.Parity = LL_USART_PARITY_NONE;\r\n  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;\r\n  USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;\r\n  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;\r\n  LL_USART_Init(USART2, &USART_InitStruct);\r\n  LL_USART_ConfigAsyncMode(USART2);\r\n  LL_USART_Enable(USART2);\r\n  /* USER CODE BEGIN USART2_Init 2 */\r\n\r\n  /* USER CODE END USART2_Init 2 */\r\n\r\n}\r\n\r\n/**\r\n  * Enable DMA controller clock\r\n  */\r\nvoid MX_DMA_Init(void)\r\n{\r\n\r\n  /* Init with LL driver */\r\n  /* DMA controller clock enable */\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_DMA1);\r\n\r\n  /* DMA interrupt init */\r\n  /* DMA1_Stream5_IRQn interrupt configuration */\r\n  NVIC_SetPriority(DMA1_Stream5_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\r\n  NVIC_EnableIRQ(DMA1_Stream5_IRQn);\r\n\r\n}\r\n\r\n/**\r\n  * @brief GPIO Initialization Function\r\n  * @param None\r\n  * @retval None\r\n  */\r\nvoid MX_GPIO_Init(void)\r\n{\r\n  LL_EXTI_InitTypeDef EXTI_InitStruct = {0};\r\n  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};\r\n\r\n  /* GPIO Ports Clock Enable */\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOH);\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);\r\n  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOB);\r\n\r\n  /**/\r\n  LL_GPIO_ResetOutputPin(LD2_GPIO_Port, LD2_Pin);\r\n\r\n  /**/\r\n  LL_GPIO_ResetOutputPin(GPIOC, LL_GPIO_PIN_10|LL_GPIO_PIN_11|LL_GPIO_PIN_12);\r\n\r\n  /**/\r\n  LL_SYSCFG_SetEXTISource(LL_SYSCFG_EXTI_PORTC, LL_SYSCFG_EXTI_LINE13);\r\n\r\n  /**/\r\n  EXTI_InitStruct.Line_0_31 = LL_EXTI_LINE_13;\r\n  EXTI_InitStruct.LineCommand = ENABLE;\r\n  EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;\r\n  EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_FALLING;\r\n  LL_EXTI_Init(&EXTI_InitStruct);\r\n\r\n  /**/\r\n  LL_GPIO_SetPinPull(B1_GPIO_Port, B1_Pin, LL_GPIO_PULL_NO);\r\n\r\n  /**/\r\n  LL_GPIO_SetPinMode(B1_GPIO_Port, B1_Pin, LL_GPIO_MODE_INPUT);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = LD2_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = LL_GPIO_PIN_7;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = LL_GPIO_PIN_10|LL_GPIO_PIN_11|LL_GPIO_PIN_12;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);\r\n\r\n}\r\n\r\n/* USER CODE BEGIN 4 */\r\n\r\n/* USER CODE END 4 */\r\n\r\n/**\r\n  * @brief  Period elapsed callback in non blocking mode\r\n  * @note   This function is called  when TIM5 interrupt took place, inside\r\n  * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment\r\n  * a global variable \"uwTick\" used as application time base.\r\n  * @param  htim : TIM handle\r\n  * @retval None\r\n  */\r\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* USER CODE BEGIN Callback 0 */\r\n\r\n  /* USER CODE END Callback 0 */\r\n  if (htim->Instance == TIM5) {\r\n    HAL_IncTick();\r\n  }\r\n  /* USER CODE BEGIN Callback 1 */\r\n\r\n  /* USER CODE END Callback 1 */\r\n}\r\n\r\n/**\r\n  * @brief  This function is executed in case of error occurrence.\r\n  * @retval None\r\n  */\r\nvoid Error_Handler(void)\r\n{\r\n  /* USER CODE BEGIN Error_Handler_Debug */\r\n  /* User can add his own implementation to report the HAL error return state */\r\n  __disable_irq();\r\n  while (1)\r\n  {\r\n  }\r\n  /* USER CODE END Error_Handler_Debug */\r\n}\r\n\r\n#ifdef  USE_FULL_ASSERT\r\n/**\r\n  * @brief  Reports the name of the source file and the source line number\r\n  *         where the assert_param error has occurred.\r\n  * @param  file: pointer to the source file name\r\n  * @param  line: assert_param error line source number\r\n  * @retval None\r\n  */\r\nvoid assert_failed(uint8_t *file, uint32_t line)\r\n{\r\n  /* USER CODE BEGIN 6 */\r\n  /* User can add his own implementation to report the file name and line number,\r\n     ex: printf(\"Wrong parameters value: file %s on line %d\\r\\n\", file, line) */\r\n  /* USER CODE END 6 */\r\n}\r\n#endif /* USE_FULL_ASSERT */\r\n\r\n\n/*SimulinkGeneratedCode*/\n"},{"name":"mw_stm32_nvic.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\shared\\supportpackages\\stm32\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2021-2023 The MathWorks, Inc. */\n#include \"rtwtypes.h\"\n#include \"main.h\"\n#include \"mw_stm32_nvic.h\"\n#include <string.h>\n\n#if defined (MW_RELOCATE_VECT_TABLE) && (MW_RELOCATE_VECT_TABLE == 1)\nextern void (*g_pfnVectors[256]); \nvoid (*mw_relocateVectorTable[256])(void) __attribute__((section(\"vTable\")));\n#endif\n\nvoid MW_NVIC_ConfigureIRQ(uint32_T IRQNumber, void (*irqFcn)(void), uint32_T irqPriority)\n{\n    #if defined (MW_RELOCATE_VECT_TABLE) && (MW_RELOCATE_VECT_TABLE == 1)\n    static uint8_t relocateVectorTable = 0;\n    uint32_t adjustedIRQNumber =0;\n\n    // /* Copy default vector teable to relocated vector table address */\n    if (0 == relocateVectorTable)\n    {      \n        memcpy(&mw_relocateVectorTable[0],g_pfnVectors, sizeof(g_pfnVectors)); \n        __disable_irq();\n        SCB->VTOR = (uint32_t)&mw_relocateVectorTable;\n        __DSB();\n        __enable_irq();\n        relocateVectorTable = 1;\n    }\n    adjustedIRQNumber = IRQNumber-15;\n    NVIC_SetVector(adjustedIRQNumber,(uint32_t)irqFcn);\n    #endif\n\n    MW_NVIC_SetPriority(IRQNumber,irqPriority);\n}\n\nuint32_T MW_HWI_MaskInterrupt(void)\n{\n    uint32_T status;\n    status = __get_PRIMASK();\n    __set_PRIMASK(1);\n    return status;\n}\n//void MW_HWI_UnMaskInterrupt(old_maskStatus); __set_PRIMASK(1);\n"},{"name":"overrideHALDelay.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\shared\\supportpackages\\stm32\\src","tag":"","groupDisplay":"Other files","code":"/* Removing min 1ms wait from HAL_Delay */\n#include \"rtwtypes.h\"\n#include \"main.h\"\n\nvoid HAL_Delay(uint32_t Delay)\n{\n  uint32_t tickstart = HAL_GetTick();\n  uint32_t wait = Delay;\n\n  /* Add a freq to guarantee minimum wait */\n /* if (wait < HAL_MAX_DELAY)\n  {\n    wait += (uint32_t)(uwTickFreq);\n  }*/\n\n  while((HAL_GetTick() - tickstart) < wait)\n  {\n  }\n}"},{"name":"platform_timer.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\shared\\supportpackages\\stm32\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2021-2024 The MathWorks, Inc. */\n\n#include \"mw_stm32_types.h\"\n#include \"main.h\"\n#define MW_StringifyDefine(x) MW_StringifyDefineExpanded(x)\n#define MW_StringifyDefineExpanded(x)  #x\n\n#define MW_StringifyDefineHeader(x) MW_StringifyDefineHeaderExpand(x)\n#define MW_StringifyDefineHeaderExpand(x)  x.h\n\n\nstatic volatile uint32_T timestampInitialized = 0;\nstatic volatile uint32_T timestampStartTime = 0;\n\n__weak void PeriphCommonClock_Config(void){};\n\n__attribute__((optimize(\"O3\"))) uint32_T getCurrentTimestampInMicros(void)\n{\n    uint32_T currentTime;\n    __IO uint32_T timeInMs;\n    __IO uint32_T timeInMicroTick;\n    \n    timeInMicroTick = (uint32_t)(MW_TIMEBASESOURCE->CNT);\n    timeInMs = GET_CURRENT_TIME();\n\n    /* Check timer is overrun before calculating time in micros */\n    if (timeInMicroTick > (uint32_t)((MW_TIMEBASESOURCE)->CNT))\n    {\n        currentTime = GET_CURRENT_TIME()*1000 + (uint32_t)((MW_TIMEBASESOURCE)->CNT);\n    }\n    else\n    {\n        currentTime = timeInMs*1000 + timeInMicroTick;\n    }\n\n    return currentTime;\n}\n\n__attribute__((optimize(\"O3\"))) uint32_T returnTimeElapsed(uint32_T timestampStartTime, boolean_T isTimeInMS)\n{\n    uint32_T currentTime;\n    uint32_T ret = 0;\n    \n    if(0 == isTimeInMS)\n    {\n        currentTime = getCurrentTimestampInMicros();\n    }\n    else\n    {\n        currentTime = GET_CURRENT_TIME();\n    }\n    \n    if (currentTime >= timestampStartTime)\n    {\n        ret = (uint32_T) (currentTime - timestampStartTime);\n    }\n    else\n    {\n        ret = (uint32_T) (UINT32_MAX - timestampStartTime + currentTime);\n    }\n    return ret ;\n}\n\n#if defined(EXT_MODE) && (EXT_MODE == 1) && !defined(XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME)\n#include MW_StringifyDefine(MW_StringifyDefineHeader(MODEL))\nstatic void timestampInit(void)\n{\n    if (0 == timestampInitialized)\n    {\n        timestampStartTime =  GET_CURRENT_TIME_IN_US();\n        timestampInitialized = 1;\n    }\n}\n\n__attribute__((optimize(\"O3\"))) uint32_t getCurrentTimestamp(void)\n{\n    uint32_T ret = 0;\n    if ((1 == runModel) || (1 == timestampInitialized))\n    {\n        if (0 == timestampInitialized)\n        {\n            timestampInit();\n        }\n        ret = returnTimeElapsed(timestampStartTime, 0);\n    }\n    else\n    {\n        timestampStartTime =  GET_CURRENT_TIME_IN_US();\n    }\n    return ret;\n}\n#endif\n\n/* LocalWords:  TIMEBASESOURCE\n */\n"},{"name":"startup_stm32f446retx.s","type":"other","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\STM32CubeIDE\\Application\\User\\Startup","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file      startup_stm32f446xx.s\r\n  * @author    MCD Application Team\r\n  * @brief     STM32F446xx Devices vector table for GCC based toolchains. \r\n  *            This module performs:\r\n  *                - Set the initial SP\r\n  *                - Set the initial PC == Reset_Handler,\r\n  *                - Set the vector table entries with the exceptions ISR address\r\n  *                - Branches to main in the C library (which eventually\r\n  *                  calls main()).\r\n  *            After Reset the Cortex-M4 processor is in Thread mode,\r\n  *            priority is Privileged, and the Stack is set to Main.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n    \r\n  .syntax unified\r\n  .cpu cortex-m4\r\n  .fpu softvfp\r\n  .thumb\r\n\r\n.global  g_pfnVectors\r\n.global  Default_Handler\r\n\r\n/* start address for the initialization values of the .data section. \r\ndefined in linker script */\r\n.word  _sidata\r\n/* start address for the .data section. defined in linker script */  \r\n.word  _sdata\r\n/* end address for the .data section. defined in linker script */\r\n.word  _edata\r\n/* start address for the .bss section. defined in linker script */\r\n.word  _sbss\r\n/* end address for the .bss section. defined in linker script */\r\n.word  _ebss\r\n/* stack used for SystemInit_ExtMemCtl; always internal RAM used */\r\n\r\n/**\r\n * @brief  This is the code that gets called when the processor first\r\n *          starts execution following a reset event. Only the absolutely\r\n *          necessary set is performed, after which the application\r\n *          supplied main() routine is called. \r\n * @param  None\r\n * @retval : None\r\n*/\r\n\r\n    .section  .text.Reset_Handler\r\n  .weak  Reset_Handler\r\n  .type  Reset_Handler, %function\r\nReset_Handler:  \r\n  ldr   sp, =_estack      /* set stack pointer */\r\n\r\n/* Copy the data segment initializers from flash to SRAM */  \r\n  ldr r0, =_sdata\r\n  ldr r1, =_edata\r\n  ldr r2, =_sidata\r\n  movs r3, #0\r\n  b LoopCopyDataInit\r\n\r\nCopyDataInit:\r\n  ldr r4, [r2, r3]\r\n  str r4, [r0, r3]\r\n  adds r3, r3, #4\r\n\r\nLoopCopyDataInit:\r\n  adds r4, r0, r3\r\n  cmp r4, r1\r\n  bcc CopyDataInit\r\n  \r\n/* Zero fill the bss segment. */\r\n  ldr r2, =_sbss\r\n  ldr r4, =_ebss\r\n  movs r3, #0\r\n  b LoopFillZerobss\r\n\r\nFillZerobss:\r\n  str  r3, [r2]\r\n  adds r2, r2, #4\r\n\r\nLoopFillZerobss:\r\n  cmp r2, r4\r\n  bcc FillZerobss\r\n\r\n/* Call the clock system intitialization function.*/\r\n  bl  SystemInit   \r\n/* Call static constructors */\r\n    bl __libc_init_array\r\n/* Call the application's entry point.*/\r\n  bl  main\r\n  bx  lr    \r\n.size  Reset_Handler, .-Reset_Handler\r\n\r\n/**\r\n * @brief  This is the code that gets called when the processor receives an \r\n *         unexpected interrupt.  This simply enters an infinite loop, preserving\r\n *         the system state for examination by a debugger.\r\n * @param  None     \r\n * @retval None       \r\n*/\r\n    .section  .text.Default_Handler,\"ax\",%progbits\r\nDefault_Handler:\r\nInfinite_Loop:\r\n  b  Infinite_Loop\r\n  .size  Default_Handler, .-Default_Handler\r\n/******************************************************************************\r\n*\r\n* The minimal vector table for a Cortex M3. Note that the proper constructs\r\n* must be placed on this to ensure that it ends up at physical address\r\n* 0x0000.0000.\r\n* \r\n*******************************************************************************/\r\n   .section  .isr_vector,\"a\",%progbits\r\n  .type  g_pfnVectors, %object\r\n  .size  g_pfnVectors, .-g_pfnVectors\r\n   \r\n   \r\ng_pfnVectors:\r\n  .word  _estack\r\n  .word  Reset_Handler\r\n\r\n  .word  NMI_Handler\r\n  .word  HardFault_Handler\r\n  .word  MemManage_Handler\r\n  .word  BusFault_Handler\r\n  .word  UsageFault_Handler\r\n  .word  0\r\n  .word  0\r\n  .word  0\r\n  .word  0\r\n  .word  SVC_Handler\r\n  .word  DebugMon_Handler\r\n  .word  0\r\n  .word  PendSV_Handler\r\n  .word  SysTick_Handler\r\n  \r\n  /* External Interrupts */\r\n  .word     WWDG_IRQHandler                   /* Window WatchDog              */                                        \r\n  .word     PVD_IRQHandler                    /* PVD through EXTI Line detection */                        \r\n  .word     TAMP_STAMP_IRQHandler             /* Tamper and TimeStamps through the EXTI line */            \r\n  .word     RTC_WKUP_IRQHandler               /* RTC Wakeup through the EXTI line */                      \r\n  .word     FLASH_IRQHandler                  /* FLASH                        */                                          \r\n  .word     RCC_IRQHandler                    /* RCC                          */                                            \r\n  .word     EXTI0_IRQHandler                  /* EXTI Line0                   */                        \r\n  .word     EXTI1_IRQHandler                  /* EXTI Line1                   */                          \r\n  .word     EXTI2_IRQHandler                  /* EXTI Line2                   */                          \r\n  .word     EXTI3_IRQHandler                  /* EXTI Line3                   */                          \r\n  .word     EXTI4_IRQHandler                  /* EXTI Line4                   */                          \r\n  .word     DMA1_Stream0_IRQHandler           /* DMA1 Stream 0                */                  \r\n  .word     DMA1_Stream1_IRQHandler           /* DMA1 Stream 1                */                   \r\n  .word     DMA1_Stream2_IRQHandler           /* DMA1 Stream 2                */                   \r\n  .word     DMA1_Stream3_IRQHandler           /* DMA1 Stream 3                */                   \r\n  .word     DMA1_Stream4_IRQHandler           /* DMA1 Stream 4                */                   \r\n  .word     DMA1_Stream5_IRQHandler           /* DMA1 Stream 5                */                   \r\n  .word     DMA1_Stream6_IRQHandler           /* DMA1 Stream 6                */                   \r\n  .word     ADC_IRQHandler                    /* ADC1, ADC2 and ADC3s         */                   \r\n  .word     CAN1_TX_IRQHandler                /* CAN1 TX                      */                         \r\n  .word     CAN1_RX0_IRQHandler               /* CAN1 RX0                     */                          \r\n  .word     CAN1_RX1_IRQHandler               /* CAN1 RX1                     */                          \r\n  .word     CAN1_SCE_IRQHandler               /* CAN1 SCE                     */                          \r\n  .word     EXTI9_5_IRQHandler                /* External Line[9:5]s          */                          \r\n  .word     TIM1_BRK_TIM9_IRQHandler          /* TIM1 Break and TIM9          */         \r\n  .word     TIM1_UP_TIM10_IRQHandler          /* TIM1 Update and TIM10        */         \r\n  .word     TIM1_TRG_COM_TIM11_IRQHandler     /* TIM1 Trigger and Commutation and TIM11 */\r\n  .word     TIM1_CC_IRQHandler                /* TIM1 Capture Compare         */                          \r\n  .word     TIM2_IRQHandler                   /* TIM2                         */                   \r\n  .word     TIM3_IRQHandler                   /* TIM3                         */                   \r\n  .word     TIM4_IRQHandler                   /* TIM4                         */                   \r\n  .word     I2C1_EV_IRQHandler                /* I2C1 Event                   */                          \r\n  .word     I2C1_ER_IRQHandler                /* I2C1 Error                   */                          \r\n  .word     I2C2_EV_IRQHandler                /* I2C2 Event                   */                          \r\n  .word     I2C2_ER_IRQHandler                /* I2C2 Error                   */                            \r\n  .word     SPI1_IRQHandler                   /* SPI1                         */                   \r\n  .word     SPI2_IRQHandler                   /* SPI2                         */                   \r\n  .word     USART1_IRQHandler                 /* USART1                       */                   \r\n  .word     USART2_IRQHandler                 /* USART2                       */                   \r\n  .word     USART3_IRQHandler                 /* USART3                       */                   \r\n  .word     EXTI15_10_IRQHandler              /* External Line[15:10]s        */                          \r\n  .word     RTC_Alarm_IRQHandler              /* RTC Alarm (A and B) through EXTI Line */                 \r\n  .word     OTG_FS_WKUP_IRQHandler            /* USB OTG FS Wakeup through EXTI line */                       \r\n  .word     TIM8_BRK_TIM12_IRQHandler         /* TIM8 Break and TIM12         */         \r\n  .word     TIM8_UP_TIM13_IRQHandler          /* TIM8 Update and TIM13        */         \r\n  .word     TIM8_TRG_COM_TIM14_IRQHandler     /* TIM8 Trigger and Commutation and TIM14 */\r\n  .word     TIM8_CC_IRQHandler                /* TIM8 Capture Compare         */                          \r\n  .word     DMA1_Stream7_IRQHandler           /* DMA1 Stream7                 */                          \r\n  .word     FMC_IRQHandler                    /* FMC                          */                   \r\n  .word     SDIO_IRQHandler                   /* SDIO                         */                   \r\n  .word     TIM5_IRQHandler                   /* TIM5                         */                   \r\n  .word     SPI3_IRQHandler                   /* SPI3                         */                   \r\n  .word     UART4_IRQHandler                  /* UART4                        */                   \r\n  .word     UART5_IRQHandler                  /* UART5                        */                   \r\n  .word     TIM6_DAC_IRQHandler               /* TIM6 and DAC1&2 underrun errors */                   \r\n  .word     TIM7_IRQHandler                   /* TIM7                         */\r\n  .word     DMA2_Stream0_IRQHandler           /* DMA2 Stream 0                */                   \r\n  .word     DMA2_Stream1_IRQHandler           /* DMA2 Stream 1                */                   \r\n  .word     DMA2_Stream2_IRQHandler           /* DMA2 Stream 2                */                   \r\n  .word     DMA2_Stream3_IRQHandler           /* DMA2 Stream 3                */                   \r\n  .word     DMA2_Stream4_IRQHandler           /* DMA2 Stream 4                */                   \r\n  .word     0                                 /* Reserved                     */                   \r\n  .word     0                                 /* Reserved                     */                     \r\n  .word     CAN2_TX_IRQHandler                /* CAN2 TX                      */                          \r\n  .word     CAN2_RX0_IRQHandler               /* CAN2 RX0                     */                          \r\n  .word     CAN2_RX1_IRQHandler               /* CAN2 RX1                     */                          \r\n  .word     CAN2_SCE_IRQHandler               /* CAN2 SCE                     */                          \r\n  .word     OTG_FS_IRQHandler                 /* USB OTG FS                   */                   \r\n  .word     DMA2_Stream5_IRQHandler           /* DMA2 Stream 5                */                   \r\n  .word     DMA2_Stream6_IRQHandler           /* DMA2 Stream 6                */                   \r\n  .word     DMA2_Stream7_IRQHandler           /* DMA2 Stream 7                */                   \r\n  .word     USART6_IRQHandler                 /* USART6                       */                    \r\n  .word     I2C3_EV_IRQHandler                /* I2C3 event                   */                          \r\n  .word     I2C3_ER_IRQHandler                /* I2C3 error                   */                          \r\n  .word     OTG_HS_EP1_OUT_IRQHandler         /* USB OTG HS End Point 1 Out   */                   \r\n  .word     OTG_HS_EP1_IN_IRQHandler          /* USB OTG HS End Point 1 In    */                   \r\n  .word     OTG_HS_WKUP_IRQHandler            /* USB OTG HS Wakeup through EXTI */                         \r\n  .word     OTG_HS_IRQHandler                 /* USB OTG HS                   */                   \r\n  .word     DCMI_IRQHandler                   /* DCMI                         */                   \r\n  .word     0                                 /* Reserved                     */                   \r\n  .word     0                                 /* Reserved                     */\r\n  .word     FPU_IRQHandler                    /* FPU                          */\r\n  .word     0                                 /* Reserved                     */\r\n  .word     0                                 /* Reserved                     */\r\n  .word     SPI4_IRQHandler                   /* SPI4                         */\r\n  .word     0                                 /* Reserved                     */\r\n  .word     0                                 /* Reserved                     */\r\n  .word     SAI1_IRQHandler                   /* SAI1                         */\r\n  .word     0                                 /* Reserved                     */\r\n  .word     0                                 /* Reserved                     */\r\n  .word     0                                 /* Reserved                     */\r\n  .word     SAI2_IRQHandler                   /* SAI2                         */\r\n  .word     QUADSPI_IRQHandler                /* QuadSPI                      */\r\n  .word     CEC_IRQHandler                    /* CEC                          */\r\n  .word     SPDIF_RX_IRQHandler               /* SPDIF RX                     */\r\n  .word     FMPI2C1_EV_IRQHandler          /* FMPI2C 1 Event               */\r\n  .word     FMPI2C1_ER_IRQHandler          /* FMPI2C 1 Error               */\r\n  \r\n/*******************************************************************************\r\n*\r\n* Provide weak aliases for each Exception handler to the Default_Handler. \r\n* As they are weak aliases, any function with the same name will override \r\n* this definition.\r\n* \r\n*******************************************************************************/\r\n   .weak      NMI_Handler\r\n   .thumb_set NMI_Handler,Default_Handler\r\n  \r\n   .weak      HardFault_Handler\r\n   .thumb_set HardFault_Handler,Default_Handler\r\n  \r\n   .weak      MemManage_Handler\r\n   .thumb_set MemManage_Handler,Default_Handler\r\n  \r\n   .weak      BusFault_Handler\r\n   .thumb_set BusFault_Handler,Default_Handler\r\n\r\n   .weak      UsageFault_Handler\r\n   .thumb_set UsageFault_Handler,Default_Handler\r\n\r\n   .weak      SVC_Handler\r\n   .thumb_set SVC_Handler,Default_Handler\r\n\r\n   .weak      DebugMon_Handler\r\n   .thumb_set DebugMon_Handler,Default_Handler\r\n\r\n   .weak      PendSV_Handler\r\n   .thumb_set PendSV_Handler,Default_Handler\r\n\r\n   .weak      SysTick_Handler\r\n   .thumb_set SysTick_Handler,Default_Handler              \r\n  \r\n   .weak      WWDG_IRQHandler                   \r\n   .thumb_set WWDG_IRQHandler,Default_Handler      \r\n                  \r\n   .weak      PVD_IRQHandler      \r\n   .thumb_set PVD_IRQHandler,Default_Handler\r\n               \r\n   .weak      TAMP_STAMP_IRQHandler            \r\n   .thumb_set TAMP_STAMP_IRQHandler,Default_Handler\r\n            \r\n   .weak      RTC_WKUP_IRQHandler                  \r\n   .thumb_set RTC_WKUP_IRQHandler,Default_Handler\r\n            \r\n   .weak      FLASH_IRQHandler         \r\n   .thumb_set FLASH_IRQHandler,Default_Handler\r\n                  \r\n   .weak      RCC_IRQHandler      \r\n   .thumb_set RCC_IRQHandler,Default_Handler\r\n                  \r\n   .weak      EXTI0_IRQHandler         \r\n   .thumb_set EXTI0_IRQHandler,Default_Handler\r\n                  \r\n   .weak      EXTI1_IRQHandler         \r\n   .thumb_set EXTI1_IRQHandler,Default_Handler\r\n                     \r\n   .weak      EXTI2_IRQHandler         \r\n   .thumb_set EXTI2_IRQHandler,Default_Handler \r\n                 \r\n   .weak      EXTI3_IRQHandler         \r\n   .thumb_set EXTI3_IRQHandler,Default_Handler\r\n                        \r\n   .weak      EXTI4_IRQHandler         \r\n   .thumb_set EXTI4_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA1_Stream0_IRQHandler               \r\n   .thumb_set DMA1_Stream0_IRQHandler,Default_Handler\r\n         \r\n   .weak      DMA1_Stream1_IRQHandler               \r\n   .thumb_set DMA1_Stream1_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA1_Stream2_IRQHandler               \r\n   .thumb_set DMA1_Stream2_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA1_Stream3_IRQHandler               \r\n   .thumb_set DMA1_Stream3_IRQHandler,Default_Handler \r\n                 \r\n   .weak      DMA1_Stream4_IRQHandler              \r\n   .thumb_set DMA1_Stream4_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA1_Stream5_IRQHandler               \r\n   .thumb_set DMA1_Stream5_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA1_Stream6_IRQHandler               \r\n   .thumb_set DMA1_Stream6_IRQHandler,Default_Handler\r\n                  \r\n   .weak      ADC_IRQHandler      \r\n   .thumb_set ADC_IRQHandler,Default_Handler\r\n               \r\n   .weak      CAN1_TX_IRQHandler   \r\n   .thumb_set CAN1_TX_IRQHandler,Default_Handler\r\n            \r\n   .weak      CAN1_RX0_IRQHandler                  \r\n   .thumb_set CAN1_RX0_IRQHandler,Default_Handler\r\n                           \r\n   .weak      CAN1_RX1_IRQHandler                  \r\n   .thumb_set CAN1_RX1_IRQHandler,Default_Handler\r\n            \r\n   .weak      CAN1_SCE_IRQHandler                  \r\n   .thumb_set CAN1_SCE_IRQHandler,Default_Handler\r\n            \r\n   .weak      EXTI9_5_IRQHandler   \r\n   .thumb_set EXTI9_5_IRQHandler,Default_Handler\r\n            \r\n   .weak      TIM1_BRK_TIM9_IRQHandler            \r\n   .thumb_set TIM1_BRK_TIM9_IRQHandler,Default_Handler\r\n            \r\n   .weak      TIM1_UP_TIM10_IRQHandler            \r\n   .thumb_set TIM1_UP_TIM10_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM1_TRG_COM_TIM11_IRQHandler      \r\n   .thumb_set TIM1_TRG_COM_TIM11_IRQHandler,Default_Handler\r\n      \r\n   .weak      TIM1_CC_IRQHandler   \r\n   .thumb_set TIM1_CC_IRQHandler,Default_Handler\r\n                  \r\n   .weak      TIM2_IRQHandler            \r\n   .thumb_set TIM2_IRQHandler,Default_Handler\r\n                  \r\n   .weak      TIM3_IRQHandler            \r\n   .thumb_set TIM3_IRQHandler,Default_Handler\r\n                  \r\n   .weak      TIM4_IRQHandler            \r\n   .thumb_set TIM4_IRQHandler,Default_Handler\r\n                  \r\n   .weak      I2C1_EV_IRQHandler   \r\n   .thumb_set I2C1_EV_IRQHandler,Default_Handler\r\n                     \r\n   .weak      I2C1_ER_IRQHandler   \r\n   .thumb_set I2C1_ER_IRQHandler,Default_Handler\r\n                     \r\n   .weak      I2C2_EV_IRQHandler   \r\n   .thumb_set I2C2_EV_IRQHandler,Default_Handler\r\n                  \r\n   .weak      I2C2_ER_IRQHandler   \r\n   .thumb_set I2C2_ER_IRQHandler,Default_Handler\r\n                           \r\n   .weak      SPI1_IRQHandler            \r\n   .thumb_set SPI1_IRQHandler,Default_Handler\r\n                        \r\n   .weak      SPI2_IRQHandler            \r\n   .thumb_set SPI2_IRQHandler,Default_Handler\r\n                  \r\n   .weak      USART1_IRQHandler      \r\n   .thumb_set USART1_IRQHandler,Default_Handler\r\n                     \r\n   .weak      USART2_IRQHandler      \r\n   .thumb_set USART2_IRQHandler,Default_Handler\r\n                     \r\n   .weak      USART3_IRQHandler      \r\n   .thumb_set USART3_IRQHandler,Default_Handler\r\n                  \r\n   .weak      EXTI15_10_IRQHandler               \r\n   .thumb_set EXTI15_10_IRQHandler,Default_Handler\r\n               \r\n   .weak      RTC_Alarm_IRQHandler               \r\n   .thumb_set RTC_Alarm_IRQHandler,Default_Handler\r\n            \r\n   .weak      OTG_FS_WKUP_IRQHandler         \r\n   .thumb_set OTG_FS_WKUP_IRQHandler,Default_Handler\r\n            \r\n   .weak      TIM8_BRK_TIM12_IRQHandler         \r\n   .thumb_set TIM8_BRK_TIM12_IRQHandler,Default_Handler\r\n         \r\n   .weak      TIM8_UP_TIM13_IRQHandler            \r\n   .thumb_set TIM8_UP_TIM13_IRQHandler,Default_Handler\r\n         \r\n   .weak      TIM8_TRG_COM_TIM14_IRQHandler      \r\n   .thumb_set TIM8_TRG_COM_TIM14_IRQHandler,Default_Handler\r\n      \r\n   .weak      TIM8_CC_IRQHandler   \r\n   .thumb_set TIM8_CC_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA1_Stream7_IRQHandler               \r\n   .thumb_set DMA1_Stream7_IRQHandler,Default_Handler\r\n                     \r\n   .weak      FMC_IRQHandler            \r\n   .thumb_set FMC_IRQHandler,Default_Handler\r\n                     \r\n   .weak      SDIO_IRQHandler            \r\n   .thumb_set SDIO_IRQHandler,Default_Handler\r\n                     \r\n   .weak      TIM5_IRQHandler            \r\n   .thumb_set TIM5_IRQHandler,Default_Handler\r\n                     \r\n   .weak      SPI3_IRQHandler            \r\n   .thumb_set SPI3_IRQHandler,Default_Handler\r\n                     \r\n   .weak      UART4_IRQHandler         \r\n   .thumb_set UART4_IRQHandler,Default_Handler\r\n                  \r\n   .weak      UART5_IRQHandler         \r\n   .thumb_set UART5_IRQHandler,Default_Handler\r\n                  \r\n   .weak      TIM6_DAC_IRQHandler                  \r\n   .thumb_set TIM6_DAC_IRQHandler,Default_Handler\r\n               \r\n   .weak      TIM7_IRQHandler            \r\n   .thumb_set TIM7_IRQHandler,Default_Handler\r\n         \r\n   .weak      DMA2_Stream0_IRQHandler               \r\n   .thumb_set DMA2_Stream0_IRQHandler,Default_Handler\r\n               \r\n   .weak      DMA2_Stream1_IRQHandler               \r\n   .thumb_set DMA2_Stream1_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA2_Stream2_IRQHandler               \r\n   .thumb_set DMA2_Stream2_IRQHandler,Default_Handler\r\n            \r\n   .weak      DMA2_Stream3_IRQHandler               \r\n   .thumb_set DMA2_Stream3_IRQHandler,Default_Handler\r\n            \r\n   .weak      DMA2_Stream4_IRQHandler               \r\n   .thumb_set DMA2_Stream4_IRQHandler,Default_Handler\r\n\r\n   .weak      CAN2_TX_IRQHandler   \r\n   .thumb_set CAN2_TX_IRQHandler,Default_Handler\r\n                           \r\n   .weak      CAN2_RX0_IRQHandler                  \r\n   .thumb_set CAN2_RX0_IRQHandler,Default_Handler\r\n                           \r\n   .weak      CAN2_RX1_IRQHandler                  \r\n   .thumb_set CAN2_RX1_IRQHandler,Default_Handler\r\n                           \r\n   .weak      CAN2_SCE_IRQHandler                  \r\n   .thumb_set CAN2_SCE_IRQHandler,Default_Handler\r\n                           \r\n   .weak      OTG_FS_IRQHandler      \r\n   .thumb_set OTG_FS_IRQHandler,Default_Handler\r\n                     \r\n   .weak      DMA2_Stream5_IRQHandler               \r\n   .thumb_set DMA2_Stream5_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA2_Stream6_IRQHandler               \r\n   .thumb_set DMA2_Stream6_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DMA2_Stream7_IRQHandler               \r\n   .thumb_set DMA2_Stream7_IRQHandler,Default_Handler\r\n                  \r\n   .weak      USART6_IRQHandler      \r\n   .thumb_set USART6_IRQHandler,Default_Handler\r\n                        \r\n   .weak      I2C3_EV_IRQHandler   \r\n   .thumb_set I2C3_EV_IRQHandler,Default_Handler\r\n                        \r\n   .weak      I2C3_ER_IRQHandler   \r\n   .thumb_set I2C3_ER_IRQHandler,Default_Handler\r\n                        \r\n   .weak      OTG_HS_EP1_OUT_IRQHandler         \r\n   .thumb_set OTG_HS_EP1_OUT_IRQHandler,Default_Handler\r\n               \r\n   .weak      OTG_HS_EP1_IN_IRQHandler            \r\n   .thumb_set OTG_HS_EP1_IN_IRQHandler,Default_Handler\r\n               \r\n   .weak      OTG_HS_WKUP_IRQHandler         \r\n   .thumb_set OTG_HS_WKUP_IRQHandler,Default_Handler\r\n            \r\n   .weak      OTG_HS_IRQHandler      \r\n   .thumb_set OTG_HS_IRQHandler,Default_Handler\r\n                  \r\n   .weak      DCMI_IRQHandler            \r\n   .thumb_set DCMI_IRQHandler,Default_Handler  \r\n\r\n   .weak      FPU_IRQHandler                  \r\n   .thumb_set FPU_IRQHandler,Default_Handler  \r\n\r\n   .weak      SPI4_IRQHandler            \r\n   .thumb_set SPI4_IRQHandler,Default_Handler\r\n\r\n   .weak      SAI1_IRQHandler            \r\n   .thumb_set SAI1_IRQHandler,Default_Handler\r\n\r\n   .weak      SAI2_IRQHandler            \r\n   .thumb_set SAI2_IRQHandler,Default_Handler\r\n   \r\n   .weak      QUADSPI_IRQHandler            \r\n   .thumb_set QUADSPI_IRQHandler,Default_Handler\r\n \r\n   .weak      CEC_IRQHandler            \r\n   .thumb_set CEC_IRQHandler,Default_Handler\r\n   \r\n   .weak      SPDIF_RX_IRQHandler            \r\n   .thumb_set SPDIF_RX_IRQHandler,Default_Handler \r\n \r\n   .weak      FMPI2C1_EV_IRQHandler            \r\n   .thumb_set FMPI2C1_EV_IRQHandler,Default_Handler\r\n   \r\n   .weak      FMPI2C1_ER_IRQHandler            \r\n   .thumb_set FMPI2C1_ER_IRQHandler,Default_Handler \r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/        \r\n \r\n"},{"name":"stm32f4xx_hal.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal.c\r\n  * @author  MCD Application Team\r\n  * @brief   HAL module driver.\r\n  *          This is the common part of the HAL initialization\r\n  *\r\n  @verbatim\r\n  ==============================================================================\r\n                     ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n    The common HAL driver contains a set of generic and common APIs that can be\r\n    used by the PPP peripheral drivers and the user to start using the HAL. \r\n    [..]\r\n    The HAL contains two APIs' categories: \r\n         (+) Common HAL APIs\r\n         (+) Services HAL APIs\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */ \r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup HAL HAL\r\n  * @brief HAL module driver.\r\n  * @{\r\n  */\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup HAL_Private_Constants\r\n  * @{\r\n  */\r\n/**\r\n  * @brief STM32F4xx HAL Driver version number V1.7.13\r\n  */\r\n#define __STM32F4xx_HAL_VERSION_MAIN   (0x01U) /*!< [31:24] main version */\r\n#define __STM32F4xx_HAL_VERSION_SUB1   (0x07U) /*!< [23:16] sub1 version */\r\n#define __STM32F4xx_HAL_VERSION_SUB2   (0x0DU) /*!< [15:8]  sub2 version */\r\n#define __STM32F4xx_HAL_VERSION_RC     (0x00U) /*!< [7:0]  release candidate */ \r\n#define __STM32F4xx_HAL_VERSION         ((__STM32F4xx_HAL_VERSION_MAIN << 24U)\\\r\n                                        |(__STM32F4xx_HAL_VERSION_SUB1 << 16U)\\\r\n                                        |(__STM32F4xx_HAL_VERSION_SUB2 << 8U )\\\r\n                                        |(__STM32F4xx_HAL_VERSION_RC))\r\n                                        \r\n#define IDCODE_DEVID_MASK    0x00000FFFU\r\n\r\n/* ------------ RCC registers bit address in the alias region ----------- */\r\n#define SYSCFG_OFFSET             (SYSCFG_BASE - PERIPH_BASE)\r\n/* ---  MEMRMP Register ---*/ \r\n/* Alias word address of UFB_MODE bit */ \r\n#define MEMRMP_OFFSET             SYSCFG_OFFSET \r\n#define UFB_MODE_BIT_NUMBER       SYSCFG_MEMRMP_UFB_MODE_Pos\r\n#define UFB_MODE_BB               (uint32_t)(PERIPH_BB_BASE + (MEMRMP_OFFSET * 32U) + (UFB_MODE_BIT_NUMBER * 4U)) \r\n\r\n/* ---  CMPCR Register ---*/ \r\n/* Alias word address of CMP_PD bit */ \r\n#define CMPCR_OFFSET              (SYSCFG_OFFSET + 0x20U) \r\n#define CMP_PD_BIT_NUMBER         SYSCFG_CMPCR_CMP_PD_Pos\r\n#define CMPCR_CMP_PD_BB           (uint32_t)(PERIPH_BB_BASE + (CMPCR_OFFSET * 32U) + (CMP_PD_BIT_NUMBER * 4U))\r\n\r\n/* ---  MCHDLYCR Register ---*/ \r\n/* Alias word address of BSCKSEL bit */ \r\n#define MCHDLYCR_OFFSET            (SYSCFG_OFFSET + 0x30U) \r\n#define BSCKSEL_BIT_NUMBER         SYSCFG_MCHDLYCR_BSCKSEL_Pos\r\n#define MCHDLYCR_BSCKSEL_BB        (uint32_t)(PERIPH_BB_BASE + (MCHDLYCR_OFFSET * 32U) + (BSCKSEL_BIT_NUMBER * 4U))\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/** @addtogroup HAL_Private_Variables\r\n  * @{\r\n  */\r\n__IO uint32_t uwTick;\r\nuint32_t uwTickPrio   = (1UL << __NVIC_PRIO_BITS); /* Invalid PRIO */\r\nHAL_TickFreqTypeDef uwTickFreq = HAL_TICK_FREQ_DEFAULT;  /* 1KHz */\r\n/**\r\n  * @}\r\n  */\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/** @defgroup HAL_Exported_Functions HAL Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup HAL_Exported_Functions_Group1 Initialization and de-initialization Functions \r\n *  @brief    Initialization and de-initialization functions\r\n *\r\n@verbatim    \r\n ===============================================================================\r\n              ##### Initialization and Configuration functions #####\r\n ===============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) Initializes the Flash interface the NVIC allocation and initial clock \r\n          configuration. It initializes the systick also when timeout is needed \r\n          and the backup domain when enabled.\r\n      (+) De-Initializes common part of the HAL.\r\n      (+) Configure the time base source to have 1ms time base with a dedicated \r\n          Tick interrupt priority. \r\n        (++) SysTick timer is used by default as source of time base, but user\r\n             can eventually implement his proper time base source (a general purpose \r\n             timer for example or other time source), keeping in mind that Time base \r\n             duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and \r\n             handled in milliseconds basis.\r\n        (++) Time base configuration function (HAL_InitTick ()) is called automatically \r\n             at the beginning of the program after reset by HAL_Init() or at any time \r\n             when clock is configured, by HAL_RCC_ClockConfig(). \r\n        (++) Source of time base is configured  to generate interrupts at regular \r\n             time intervals. Care must be taken if HAL_Delay() is called from a \r\n             peripheral ISR process, the Tick interrupt line must have higher priority \r\n            (numerically lower) than the peripheral interrupt. Otherwise the caller \r\n            ISR process will be blocked. \r\n       (++) functions affecting time base configurations are declared as __weak  \r\n             to make  override possible  in case of other  implementations in user file.\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  This function is used to initialize the HAL Library; it must be the first \r\n  *         instruction to be executed in the main program (before to call any other\r\n  *         HAL function), it performs the following:\r\n  *           Configure the Flash prefetch, instruction and Data caches.\r\n  *           Configures the SysTick to generate an interrupt each 1 millisecond,\r\n  *           which is clocked by the HSI (at this stage, the clock is not yet\r\n  *           configured and thus the system is running from the internal HSI at 16 MHz).\r\n  *           Set NVIC Group Priority to 4.\r\n  *           Calls the HAL_MspInit() callback function defined in user file \r\n  *           \"stm32f4xx_hal_msp.c\" to do the global low level hardware initialization \r\n  *            \r\n  * @note   SysTick is used as time base for the HAL_Delay() function, the application\r\n  *         need to ensure that the SysTick time base is always set to 1 millisecond\r\n  *         to have correct HAL operation.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_Init(void)\r\n{\r\n  /* Configure Flash prefetch, Instruction cache, Data cache */ \r\n#if (INSTRUCTION_CACHE_ENABLE != 0U)\r\n  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();\r\n#endif /* INSTRUCTION_CACHE_ENABLE */\r\n\r\n#if (DATA_CACHE_ENABLE != 0U)\r\n  __HAL_FLASH_DATA_CACHE_ENABLE();\r\n#endif /* DATA_CACHE_ENABLE */\r\n\r\n#if (PREFETCH_ENABLE != 0U)\r\n  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();\r\n#endif /* PREFETCH_ENABLE */\r\n\r\n  /* Set Interrupt Group Priority */\r\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\r\n\r\n  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */\r\n  HAL_InitTick(TICK_INT_PRIORITY);\r\n\r\n  /* Init the low level hardware */\r\n  HAL_MspInit();\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  This function de-Initializes common part of the HAL and stops the systick.\r\n  *         This function is optional.   \r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DeInit(void)\r\n{\r\n  /* Reset of all peripherals */\r\n  __HAL_RCC_APB1_FORCE_RESET();\r\n  __HAL_RCC_APB1_RELEASE_RESET();\r\n\r\n  __HAL_RCC_APB2_FORCE_RESET();\r\n  __HAL_RCC_APB2_RELEASE_RESET();\r\n\r\n  __HAL_RCC_AHB1_FORCE_RESET();\r\n  __HAL_RCC_AHB1_RELEASE_RESET();\r\n\r\n  __HAL_RCC_AHB2_FORCE_RESET();\r\n  __HAL_RCC_AHB2_RELEASE_RESET();\r\n\r\n  __HAL_RCC_AHB3_FORCE_RESET();\r\n  __HAL_RCC_AHB3_RELEASE_RESET();\r\n\r\n  /* De-Init the low level hardware */\r\n  HAL_MspDeInit();\r\n    \r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initialize the MSP.\r\n  * @retval None\r\n  */\r\n__weak void HAL_MspInit(void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the MSP.\r\n  * @retval None\r\n  */\r\n__weak void HAL_MspDeInit(void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_MspDeInit could be implemented in the user file\r\n   */ \r\n}\r\n\r\n/**\r\n  * @brief This function configures the source of the time base.\r\n  *        The time source is configured  to have 1ms time base with a dedicated \r\n  *        Tick interrupt priority.\r\n  * @note This function is called  automatically at the beginning of program after\r\n  *       reset by HAL_Init() or at any time when clock is reconfigured  by HAL_RCC_ClockConfig().\r\n  * @note In the default implementation, SysTick timer is the source of time base. \r\n  *       It is used to generate interrupts at regular time intervals. \r\n  *       Care must be taken if HAL_Delay() is called from a peripheral ISR process, \r\n  *       The SysTick interrupt must have higher priority (numerically lower)\r\n  *       than the peripheral interrupt. Otherwise the caller ISR process will be blocked.\r\n  *       The function is declared as __weak  to be overwritten  in case of other\r\n  *       implementation  in user file.\r\n  * @param TickPriority Tick interrupt priority.\r\n  * @retval HAL status\r\n  */\r\n__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)\r\n{\r\n  /* Configure the SysTick to have interrupt in 1ms time basis*/\r\n  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Configure the SysTick IRQ priority */\r\n  if (TickPriority < (1UL << __NVIC_PRIO_BITS))\r\n  {\r\n    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);\r\n    uwTickPrio = TickPriority;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup HAL_Exported_Functions_Group2 HAL Control functions \r\n *  @brief    HAL Control functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### HAL Control functions #####\r\n ===============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) Provide a tick value in millisecond\r\n      (+) Provide a blocking delay in millisecond\r\n      (+) Suspend the time base source interrupt\r\n      (+) Resume the time base source interrupt\r\n      (+) Get the HAL API driver version\r\n      (+) Get the device identifier\r\n      (+) Get the device revision identifier\r\n      (+) Enable/Disable Debug module during SLEEP mode\r\n      (+) Enable/Disable Debug module during STOP mode\r\n      (+) Enable/Disable Debug module during STANDBY mode\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief This function is called to increment  a global variable \"uwTick\"\r\n  *        used as application time base.\r\n  * @note In the default implementation, this variable is incremented each 1ms\r\n  *       in SysTick ISR.\r\n * @note This function is declared as __weak to be overwritten in case of other \r\n  *      implementations in user file.\r\n  * @retval None\r\n  */\r\n__weak void HAL_IncTick(void)\r\n{\r\n  uwTick += uwTickFreq;\r\n}\r\n\r\n/**\r\n  * @brief Provides a tick value in millisecond.\r\n  * @note This function is declared as __weak to be overwritten in case of other \r\n  *       implementations in user file.\r\n  * @retval tick value\r\n  */\r\n__weak uint32_t HAL_GetTick(void)\r\n{\r\n  return uwTick;\r\n}\r\n\r\n/**\r\n  * @brief This function returns a tick priority.\r\n  * @retval tick priority\r\n  */\r\nuint32_t HAL_GetTickPrio(void)\r\n{\r\n  return uwTickPrio;\r\n}\r\n\r\n/**\r\n  * @brief Set new tick Freq.\r\n  * @retval Status\r\n  */\r\nHAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)\r\n{\r\n  HAL_StatusTypeDef status  = HAL_OK;\r\n  HAL_TickFreqTypeDef prevTickFreq;\r\n\r\n  assert_param(IS_TICKFREQ(Freq));\r\n\r\n  if (uwTickFreq != Freq)\r\n  {\r\n    /* Back up uwTickFreq frequency */\r\n    prevTickFreq = uwTickFreq;\r\n\r\n    /* Update uwTickFreq global variable used by HAL_InitTick() */\r\n    uwTickFreq = Freq;\r\n\r\n    /* Apply the new tick Freq  */\r\n    status = HAL_InitTick(uwTickPrio);\r\n\r\n    if (status != HAL_OK)\r\n    {\r\n      /* Restore previous tick frequency */\r\n      uwTickFreq = prevTickFreq;\r\n    }\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief Return tick frequency.\r\n  * @retval tick period in Hz\r\n  */\r\nHAL_TickFreqTypeDef HAL_GetTickFreq(void)\r\n{\r\n  return uwTickFreq;\r\n}\r\n\r\n/**\r\n  * @brief This function provides minimum delay (in milliseconds) based \r\n  *        on variable incremented.\r\n  * @note In the default implementation , SysTick timer is the source of time base.\r\n  *       It is used to generate interrupts at regular time intervals where uwTick\r\n  *       is incremented.\r\n  * @note This function is declared as __weak to be overwritten in case of other\r\n  *       implementations in user file.\r\n  * @param Delay specifies the delay time length, in milliseconds.\r\n  * @retval None\r\n  */\r\n__weak void HAL_Delay(uint32_t Delay)\r\n{\r\n  uint32_t tickstart = HAL_GetTick();\r\n  uint32_t wait = Delay;\r\n\r\n  /* Add a freq to guarantee minimum wait */\r\n  if (wait < HAL_MAX_DELAY)\r\n  {\r\n    wait += (uint32_t)(uwTickFreq);\r\n  }\r\n\r\n  while((HAL_GetTick() - tickstart) < wait)\r\n  {\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Suspend Tick increment.\r\n  * @note In the default implementation , SysTick timer is the source of time base. It is\r\n  *       used to generate interrupts at regular time intervals. Once HAL_SuspendTick()\r\n  *       is called, the SysTick interrupt will be disabled and so Tick increment \r\n  *       is suspended.\r\n  * @note This function is declared as __weak to be overwritten in case of other\r\n  *       implementations in user file.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SuspendTick(void)\r\n{\r\n  /* Disable SysTick Interrupt */\r\n  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;\r\n}\r\n\r\n/**\r\n  * @brief Resume Tick increment.\r\n  * @note In the default implementation , SysTick timer is the source of time base. It is\r\n  *       used to generate interrupts at regular time intervals. Once HAL_ResumeTick()\r\n  *       is called, the SysTick interrupt will be enabled and so Tick increment \r\n  *       is resumed.\r\n  * @note This function is declared as __weak to be overwritten in case of other\r\n  *       implementations in user file.\r\n  * @retval None\r\n  */\r\n__weak void HAL_ResumeTick(void)\r\n{\r\n  /* Enable SysTick Interrupt */\r\n  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the HAL revision\r\n  * @retval version : 0xXYZR (8bits for each decimal, R for RC)\r\n  */\r\nuint32_t HAL_GetHalVersion(void)\r\n{\r\n  return __STM32F4xx_HAL_VERSION;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the device revision identifier.\r\n  * @retval Device revision identifier\r\n  */\r\nuint32_t HAL_GetREVID(void)\r\n{\r\n  return((DBGMCU->IDCODE) >> 16U);\r\n}\r\n\r\n/**\r\n  * @brief  Returns the device identifier.\r\n  * @retval Device identifier\r\n  */\r\nuint32_t HAL_GetDEVID(void)\r\n{\r\n  return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);\r\n}\r\n\r\n/**\r\n  * @brief  Enable the Debug Module during SLEEP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_EnableDBGSleepMode(void)\r\n{\r\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Debug Module during SLEEP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_DisableDBGSleepMode(void)\r\n{\r\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);\r\n}\r\n\r\n/**\r\n  * @brief  Enable the Debug Module during STOP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_EnableDBGStopMode(void)\r\n{\r\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Debug Module during STOP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_DisableDBGStopMode(void)\r\n{\r\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);\r\n}\r\n\r\n/**\r\n  * @brief  Enable the Debug Module during STANDBY mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_EnableDBGStandbyMode(void)\r\n{\r\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Debug Module during STANDBY mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_DisableDBGStandbyMode(void)\r\n{\r\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);\r\n}\r\n\r\n/**\r\n  * @brief  Enables the I/O Compensation Cell.\r\n  * @note   The I/O compensation cell can be used only when the device supply\r\n  *         voltage ranges from 2.4 to 3.6 V.  \r\n  * @retval None\r\n  */\r\nvoid HAL_EnableCompensationCell(void)\r\n{\r\n  *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)ENABLE;\r\n}\r\n\r\n/**\r\n  * @brief  Power-down the I/O Compensation Cell.\r\n  * @note   The I/O compensation cell can be used only when the device supply\r\n  *         voltage ranges from 2.4 to 3.6 V.  \r\n  * @retval None\r\n  */\r\nvoid HAL_DisableCompensationCell(void)\r\n{\r\n  *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)DISABLE;\r\n}\r\n\r\n/**\r\n  * @brief  Returns first word of the unique device identifier (UID based on 96 bits)\r\n  * @retval Device identifier\r\n  */\r\nuint32_t HAL_GetUIDw0(void)\r\n{\r\n  return (READ_REG(*((uint32_t *)UID_BASE)));\r\n}\r\n\r\n/**\r\n  * @brief  Returns second word of the unique device identifier (UID based on 96 bits)\r\n  * @retval Device identifier\r\n  */\r\nuint32_t HAL_GetUIDw1(void)\r\n{\r\n  return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));\r\n}\r\n\r\n/**\r\n  * @brief  Returns third word of the unique device identifier (UID based on 96 bits)\r\n  * @retval Device identifier\r\n  */\r\nuint32_t HAL_GetUIDw2(void)\r\n{\r\n  return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));\r\n}\r\n\r\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\\\r\n    defined(STM32F469xx) || defined(STM32F479xx)\r\n/**\r\n  * @brief  Enables the Internal FLASH Bank Swapping.\r\n  *   \r\n  * @note   This function can be used only for STM32F42xxx/43xxx/469xx/479xx devices. \r\n  *\r\n  * @note   Flash Bank2 mapped at 0x08000000 (and aliased @0x00000000) \r\n  *         and Flash Bank1 mapped at 0x08100000 (and aliased at 0x00100000)   \r\n  *\r\n  * @retval None\r\n  */\r\nvoid HAL_EnableMemorySwappingBank(void)\r\n{\r\n  *(__IO uint32_t *)UFB_MODE_BB = (uint32_t)ENABLE;\r\n}\r\n\r\n/**\r\n  * @brief  Disables the Internal FLASH Bank Swapping.\r\n  *   \r\n  * @note   This function can be used only for STM32F42xxx/43xxx/469xx/479xx devices. \r\n  *\r\n  * @note   The default state : Flash Bank1 mapped at 0x08000000 (and aliased @0x00000000) \r\n  *         and Flash Bank2 mapped at 0x08100000 (and aliased at 0x00100000) \r\n  *           \r\n  * @retval None\r\n  */\r\nvoid HAL_DisableMemorySwappingBank(void)\r\n{\r\n  *(__IO uint32_t *)UFB_MODE_BB = (uint32_t)DISABLE;\r\n}\r\n#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_can.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_can.c\r\n  * @author  MCD Application Team\r\n  * @brief   CAN HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Controller Area Network (CAN) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + Configuration functions\r\n  *           + Control functions\r\n  *           + Interrupts management\r\n  *           + Callbacks functions\r\n  *           + Peripheral State and Error functions\r\n  *\r\n  @verbatim\r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n      (#) Initialize the CAN low level resources by implementing the\r\n          HAL_CAN_MspInit():\r\n         (++) Enable the CAN interface clock using __HAL_RCC_CANx_CLK_ENABLE()\r\n         (++) Configure CAN pins\r\n             (+++) Enable the clock for the CAN GPIOs\r\n             (+++) Configure CAN pins as alternate function open-drain\r\n         (++) In case of using interrupts (e.g. HAL_CAN_ActivateNotification())\r\n             (+++) Configure the CAN interrupt priority using\r\n                   HAL_NVIC_SetPriority()\r\n             (+++) Enable the CAN IRQ handler using HAL_NVIC_EnableIRQ()\r\n             (+++) In CAN IRQ handler, call HAL_CAN_IRQHandler()\r\n\r\n      (#) Initialize the CAN peripheral using HAL_CAN_Init() function. This\r\n          function resorts to HAL_CAN_MspInit() for low-level initialization.\r\n\r\n      (#) Configure the reception filters using the following configuration\r\n          functions:\r\n            (++) HAL_CAN_ConfigFilter()\r\n\r\n      (#) Start the CAN module using HAL_CAN_Start() function. At this level\r\n          the node is active on the bus: it receive messages, and can send\r\n          messages.\r\n\r\n      (#) To manage messages transmission, the following Tx control functions\r\n          can be used:\r\n            (++) HAL_CAN_AddTxMessage() to request transmission of a new\r\n                 message.\r\n            (++) HAL_CAN_AbortTxRequest() to abort transmission of a pending\r\n                 message.\r\n            (++) HAL_CAN_GetTxMailboxesFreeLevel() to get the number of free Tx\r\n                 mailboxes.\r\n            (++) HAL_CAN_IsTxMessagePending() to check if a message is pending\r\n                 in a Tx mailbox.\r\n            (++) HAL_CAN_GetTxTimestamp() to get the timestamp of Tx message\r\n                 sent, if time triggered communication mode is enabled.\r\n\r\n      (#) When a message is received into the CAN Rx FIFOs, it can be retrieved\r\n          using the HAL_CAN_GetRxMessage() function. The function\r\n          HAL_CAN_GetRxFifoFillLevel() allows to know how many Rx message are\r\n          stored in the Rx Fifo.\r\n\r\n      (#) Calling the HAL_CAN_Stop() function stops the CAN module.\r\n\r\n      (#) The deinitialization is achieved with HAL_CAN_DeInit() function.\r\n\r\n\r\n      *** Polling mode operation ***\r\n      ==============================\r\n    [..]\r\n      (#) Reception:\r\n            (++) Monitor reception of message using HAL_CAN_GetRxFifoFillLevel()\r\n                 until at least one message is received.\r\n            (++) Then get the message using HAL_CAN_GetRxMessage().\r\n\r\n      (#) Transmission:\r\n            (++) Monitor the Tx mailboxes availability until at least one Tx\r\n                 mailbox is free, using HAL_CAN_GetTxMailboxesFreeLevel().\r\n            (++) Then request transmission of a message using\r\n                 HAL_CAN_AddTxMessage().\r\n\r\n\r\n      *** Interrupt mode operation ***\r\n      ================================\r\n    [..]\r\n      (#) Notifications are activated using HAL_CAN_ActivateNotification()\r\n          function. Then, the process can be controlled through the\r\n          available user callbacks: HAL_CAN_xxxCallback(), using same APIs\r\n          HAL_CAN_GetRxMessage() and HAL_CAN_AddTxMessage().\r\n\r\n      (#) Notifications can be deactivated using\r\n          HAL_CAN_DeactivateNotification() function.\r\n\r\n      (#) Special care should be taken for CAN_IT_RX_FIFO0_MSG_PENDING and\r\n          CAN_IT_RX_FIFO1_MSG_PENDING notifications. These notifications trig\r\n          the callbacks HAL_CAN_RxFIFO0MsgPendingCallback() and\r\n          HAL_CAN_RxFIFO1MsgPendingCallback(). User has two possible options\r\n          here.\r\n            (++) Directly get the Rx message in the callback, using\r\n                 HAL_CAN_GetRxMessage().\r\n            (++) Or deactivate the notification in the callback without\r\n                 getting the Rx message. The Rx message can then be got later\r\n                 using HAL_CAN_GetRxMessage(). Once the Rx message have been\r\n                 read, the notification can be activated again.\r\n\r\n\r\n      *** Sleep mode ***\r\n      ==================\r\n    [..]\r\n      (#) The CAN peripheral can be put in sleep mode (low power), using\r\n          HAL_CAN_RequestSleep(). The sleep mode will be entered as soon as the\r\n          current CAN activity (transmission or reception of a CAN frame) will\r\n          be completed.\r\n\r\n      (#) A notification can be activated to be informed when the sleep mode\r\n          will be entered.\r\n\r\n      (#) It can be checked if the sleep mode is entered using\r\n          HAL_CAN_IsSleepActive().\r\n          Note that the CAN state (accessible from the API HAL_CAN_GetState())\r\n          is HAL_CAN_STATE_SLEEP_PENDING as soon as the sleep mode request is\r\n          submitted (the sleep mode is not yet entered), and become\r\n          HAL_CAN_STATE_SLEEP_ACTIVE when the sleep mode is effective.\r\n\r\n      (#) The wake-up from sleep mode can be triggered by two ways:\r\n            (++) Using HAL_CAN_WakeUp(). When returning from this function,\r\n                 the sleep mode is exited (if return status is HAL_OK).\r\n            (++) When a start of Rx CAN frame is detected by the CAN peripheral,\r\n                 if automatic wake up mode is enabled.\r\n\r\n  *** Callback registration ***\r\n  =============================================\r\n\r\n  The compilation define  USE_HAL_CAN_REGISTER_CALLBACKS when set to 1\r\n  allows the user to configure dynamically the driver callbacks.\r\n  Use Function HAL_CAN_RegisterCallback() to register an interrupt callback.\r\n\r\n  Function HAL_CAN_RegisterCallback() allows to register following callbacks:\r\n    (+) TxMailbox0CompleteCallback   : Tx Mailbox 0 Complete Callback.\r\n    (+) TxMailbox1CompleteCallback   : Tx Mailbox 1 Complete Callback.\r\n    (+) TxMailbox2CompleteCallback   : Tx Mailbox 2 Complete Callback.\r\n    (+) TxMailbox0AbortCallback      : Tx Mailbox 0 Abort Callback.\r\n    (+) TxMailbox1AbortCallback      : Tx Mailbox 1 Abort Callback.\r\n    (+) TxMailbox2AbortCallback      : Tx Mailbox 2 Abort Callback.\r\n    (+) RxFifo0MsgPendingCallback    : Rx Fifo 0 Message Pending Callback.\r\n    (+) RxFifo0FullCallback          : Rx Fifo 0 Full Callback.\r\n    (+) RxFifo1MsgPendingCallback    : Rx Fifo 1 Message Pending Callback.\r\n    (+) RxFifo1FullCallback          : Rx Fifo 1 Full Callback.\r\n    (+) SleepCallback                : Sleep Callback.\r\n    (+) WakeUpFromRxMsgCallback      : Wake Up From Rx Message Callback.\r\n    (+) ErrorCallback                : Error Callback.\r\n    (+) MspInitCallback              : CAN MspInit.\r\n    (+) MspDeInitCallback            : CAN MspDeInit.\r\n  This function takes as parameters the HAL peripheral handle, the Callback ID\r\n  and a pointer to the user callback function.\r\n\r\n  Use function HAL_CAN_UnRegisterCallback() to reset a callback to the default\r\n  weak function.\r\n  HAL_CAN_UnRegisterCallback takes as parameters the HAL peripheral handle,\r\n  and the Callback ID.\r\n  This function allows to reset following callbacks:\r\n    (+) TxMailbox0CompleteCallback   : Tx Mailbox 0 Complete Callback.\r\n    (+) TxMailbox1CompleteCallback   : Tx Mailbox 1 Complete Callback.\r\n    (+) TxMailbox2CompleteCallback   : Tx Mailbox 2 Complete Callback.\r\n    (+) TxMailbox0AbortCallback      : Tx Mailbox 0 Abort Callback.\r\n    (+) TxMailbox1AbortCallback      : Tx Mailbox 1 Abort Callback.\r\n    (+) TxMailbox2AbortCallback      : Tx Mailbox 2 Abort Callback.\r\n    (+) RxFifo0MsgPendingCallback    : Rx Fifo 0 Message Pending Callback.\r\n    (+) RxFifo0FullCallback          : Rx Fifo 0 Full Callback.\r\n    (+) RxFifo1MsgPendingCallback    : Rx Fifo 1 Message Pending Callback.\r\n    (+) RxFifo1FullCallback          : Rx Fifo 1 Full Callback.\r\n    (+) SleepCallback                : Sleep Callback.\r\n    (+) WakeUpFromRxMsgCallback      : Wake Up From Rx Message Callback.\r\n    (+) ErrorCallback                : Error Callback.\r\n    (+) MspInitCallback              : CAN MspInit.\r\n    (+) MspDeInitCallback            : CAN MspDeInit.\r\n\r\n  By default, after the HAL_CAN_Init() and when the state is HAL_CAN_STATE_RESET,\r\n  all callbacks are set to the corresponding weak functions:\r\n  example HAL_CAN_ErrorCallback().\r\n  Exception done for MspInit and MspDeInit functions that are\r\n  reset to the legacy weak function in the HAL_CAN_Init()/ HAL_CAN_DeInit() only when\r\n  these callbacks are null (not registered beforehand).\r\n  if not, MspInit or MspDeInit are not null, the HAL_CAN_Init()/ HAL_CAN_DeInit()\r\n  keep and use the user MspInit/MspDeInit callbacks (registered beforehand)\r\n\r\n  Callbacks can be registered/unregistered in HAL_CAN_STATE_READY state only.\r\n  Exception done MspInit/MspDeInit that can be registered/unregistered\r\n  in HAL_CAN_STATE_READY or HAL_CAN_STATE_RESET state,\r\n  thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.\r\n  In that case first register the MspInit/MspDeInit user callbacks\r\n  using HAL_CAN_RegisterCallback() before calling HAL_CAN_DeInit()\r\n  or HAL_CAN_Init() function.\r\n\r\n  When The compilation define USE_HAL_CAN_REGISTER_CALLBACKS is set to 0 or\r\n  not defined, the callback registration feature is not available and all callbacks\r\n  are set to the corresponding weak functions.\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined(CAN1)\r\n\r\n/** @defgroup CAN CAN\r\n  * @brief CAN driver modules\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_CAN_MODULE_ENABLED\r\n\r\n#ifdef HAL_CAN_LEGACY_MODULE_ENABLED\r\n  #error \"The CAN driver cannot be used with its legacy, Please enable only one CAN module at once\"\r\n#endif\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @defgroup CAN_Private_Constants CAN Private Constants\r\n  * @{\r\n  */\r\n#define CAN_TIMEOUT_VALUE 10U\r\n/**\r\n  * @}\r\n  */\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup CAN_Exported_Functions CAN Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup CAN_Exported_Functions_Group1 Initialization and de-initialization functions\r\n *  @brief    Initialization and Configuration functions\r\n *\r\n@verbatim\r\n  ==============================================================================\r\n              ##### Initialization and de-initialization functions #####\r\n  ==============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) HAL_CAN_Init                       : Initialize and configure the CAN.\r\n      (+) HAL_CAN_DeInit                     : De-initialize the CAN.\r\n      (+) HAL_CAN_MspInit                    : Initialize the CAN MSP.\r\n      (+) HAL_CAN_MspDeInit                  : DeInitialize the CAN MSP.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initializes the CAN peripheral according to the specified\r\n  *         parameters in the CAN_InitStruct.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef *hcan)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Check CAN handle */\r\n  if (hcan == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_CAN_ALL_INSTANCE(hcan->Instance));\r\n  assert_param(IS_FUNCTIONAL_STATE(hcan->Init.TimeTriggeredMode));\r\n  assert_param(IS_FUNCTIONAL_STATE(hcan->Init.AutoBusOff));\r\n  assert_param(IS_FUNCTIONAL_STATE(hcan->Init.AutoWakeUp));\r\n  assert_param(IS_FUNCTIONAL_STATE(hcan->Init.AutoRetransmission));\r\n  assert_param(IS_FUNCTIONAL_STATE(hcan->Init.ReceiveFifoLocked));\r\n  assert_param(IS_FUNCTIONAL_STATE(hcan->Init.TransmitFifoPriority));\r\n  assert_param(IS_CAN_MODE(hcan->Init.Mode));\r\n  assert_param(IS_CAN_SJW(hcan->Init.SyncJumpWidth));\r\n  assert_param(IS_CAN_BS1(hcan->Init.TimeSeg1));\r\n  assert_param(IS_CAN_BS2(hcan->Init.TimeSeg2));\r\n  assert_param(IS_CAN_PRESCALER(hcan->Init.Prescaler));\r\n\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n  if (hcan->State == HAL_CAN_STATE_RESET)\r\n  {\r\n    /* Reset callbacks to legacy functions */\r\n    hcan->RxFifo0MsgPendingCallback  =  HAL_CAN_RxFifo0MsgPendingCallback;  /* Legacy weak RxFifo0MsgPendingCallback  */\r\n    hcan->RxFifo0FullCallback        =  HAL_CAN_RxFifo0FullCallback;        /* Legacy weak RxFifo0FullCallback        */\r\n    hcan->RxFifo1MsgPendingCallback  =  HAL_CAN_RxFifo1MsgPendingCallback;  /* Legacy weak RxFifo1MsgPendingCallback  */\r\n    hcan->RxFifo1FullCallback        =  HAL_CAN_RxFifo1FullCallback;        /* Legacy weak RxFifo1FullCallback        */\r\n    hcan->TxMailbox0CompleteCallback =  HAL_CAN_TxMailbox0CompleteCallback; /* Legacy weak TxMailbox0CompleteCallback */\r\n    hcan->TxMailbox1CompleteCallback =  HAL_CAN_TxMailbox1CompleteCallback; /* Legacy weak TxMailbox1CompleteCallback */\r\n    hcan->TxMailbox2CompleteCallback =  HAL_CAN_TxMailbox2CompleteCallback; /* Legacy weak TxMailbox2CompleteCallback */\r\n    hcan->TxMailbox0AbortCallback    =  HAL_CAN_TxMailbox0AbortCallback;    /* Legacy weak TxMailbox0AbortCallback    */\r\n    hcan->TxMailbox1AbortCallback    =  HAL_CAN_TxMailbox1AbortCallback;    /* Legacy weak TxMailbox1AbortCallback    */\r\n    hcan->TxMailbox2AbortCallback    =  HAL_CAN_TxMailbox2AbortCallback;    /* Legacy weak TxMailbox2AbortCallback    */\r\n    hcan->SleepCallback              =  HAL_CAN_SleepCallback;              /* Legacy weak SleepCallback              */\r\n    hcan->WakeUpFromRxMsgCallback    =  HAL_CAN_WakeUpFromRxMsgCallback;    /* Legacy weak WakeUpFromRxMsgCallback    */\r\n    hcan->ErrorCallback              =  HAL_CAN_ErrorCallback;              /* Legacy weak ErrorCallback              */\r\n\r\n    if (hcan->MspInitCallback == NULL)\r\n    {\r\n      hcan->MspInitCallback = HAL_CAN_MspInit; /* Legacy weak MspInit */\r\n    }\r\n\r\n    /* Init the low level hardware: CLOCK, NVIC */\r\n    hcan->MspInitCallback(hcan);\r\n  }\r\n\r\n#else\r\n  if (hcan->State == HAL_CAN_STATE_RESET)\r\n  {\r\n    /* Init the low level hardware: CLOCK, NVIC */\r\n    HAL_CAN_MspInit(hcan);\r\n  }\r\n#endif /* (USE_HAL_CAN_REGISTER_CALLBACKS) */\r\n\r\n  /* Request initialisation */\r\n  SET_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Wait initialisation acknowledge */\r\n  while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)\r\n    {\r\n      /* Update error code */\r\n      hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;\r\n\r\n      /* Change CAN state */\r\n      hcan->State = HAL_CAN_STATE_ERROR;\r\n\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  /* Exit from sleep mode */\r\n  CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Check Sleep mode leave acknowledge */\r\n  while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)\r\n    {\r\n      /* Update error code */\r\n      hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;\r\n\r\n      /* Change CAN state */\r\n      hcan->State = HAL_CAN_STATE_ERROR;\r\n\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  /* Set the time triggered communication mode */\r\n  if (hcan->Init.TimeTriggeredMode == ENABLE)\r\n  {\r\n    SET_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);\r\n  }\r\n  else\r\n  {\r\n    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);\r\n  }\r\n\r\n  /* Set the automatic bus-off management */\r\n  if (hcan->Init.AutoBusOff == ENABLE)\r\n  {\r\n    SET_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);\r\n  }\r\n  else\r\n  {\r\n    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);\r\n  }\r\n\r\n  /* Set the automatic wake-up mode */\r\n  if (hcan->Init.AutoWakeUp == ENABLE)\r\n  {\r\n    SET_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);\r\n  }\r\n  else\r\n  {\r\n    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);\r\n  }\r\n\r\n  /* Set the automatic retransmission */\r\n  if (hcan->Init.AutoRetransmission == ENABLE)\r\n  {\r\n    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_NART);\r\n  }\r\n  else\r\n  {\r\n    SET_BIT(hcan->Instance->MCR, CAN_MCR_NART);\r\n  }\r\n\r\n  /* Set the receive FIFO locked mode */\r\n  if (hcan->Init.ReceiveFifoLocked == ENABLE)\r\n  {\r\n    SET_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);\r\n  }\r\n  else\r\n  {\r\n    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);\r\n  }\r\n\r\n  /* Set the transmit FIFO priority */\r\n  if (hcan->Init.TransmitFifoPriority == ENABLE)\r\n  {\r\n    SET_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);\r\n  }\r\n  else\r\n  {\r\n    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);\r\n  }\r\n\r\n  /* Set the bit timing register */\r\n  WRITE_REG(hcan->Instance->BTR, (uint32_t)(hcan->Init.Mode           |\r\n                                            hcan->Init.SyncJumpWidth  |\r\n                                            hcan->Init.TimeSeg1       |\r\n                                            hcan->Init.TimeSeg2       |\r\n                                            (hcan->Init.Prescaler - 1U)));\r\n\r\n  /* Initialize the error code */\r\n  hcan->ErrorCode = HAL_CAN_ERROR_NONE;\r\n\r\n  /* Initialize the CAN state */\r\n  hcan->State = HAL_CAN_STATE_READY;\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Deinitializes the CAN peripheral registers to their default\r\n  *         reset values.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_DeInit(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Check CAN handle */\r\n  if (hcan == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_CAN_ALL_INSTANCE(hcan->Instance));\r\n\r\n  /* Stop the CAN module */\r\n  (void)HAL_CAN_Stop(hcan);\r\n\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n  if (hcan->MspDeInitCallback == NULL)\r\n  {\r\n    hcan->MspDeInitCallback = HAL_CAN_MspDeInit; /* Legacy weak MspDeInit */\r\n  }\r\n\r\n  /* DeInit the low level hardware: CLOCK, NVIC */\r\n  hcan->MspDeInitCallback(hcan);\r\n\r\n#else\r\n  /* DeInit the low level hardware: CLOCK, NVIC */\r\n  HAL_CAN_MspDeInit(hcan);\r\n#endif /* (USE_HAL_CAN_REGISTER_CALLBACKS) */\r\n\r\n  /* Reset the CAN peripheral */\r\n  SET_BIT(hcan->Instance->MCR, CAN_MCR_RESET);\r\n\r\n  /* Reset the CAN ErrorCode */\r\n  hcan->ErrorCode = HAL_CAN_ERROR_NONE;\r\n\r\n  /* Change CAN state */\r\n  hcan->State = HAL_CAN_STATE_RESET;\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the CAN MSP.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_MspInit(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the CAN MSP.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_MspDeInit(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n/**\r\n  * @brief  Register a CAN CallBack.\r\n  *         To be used instead of the weak predefined callback\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for CAN module\r\n  * @param  CallbackID ID of the callback to be registered\r\n  *         This parameter can be one of the following values:\r\n  *           @arg @ref HAL_CAN_TX_MAILBOX0_COMPLETE_CB_ID Tx Mailbox 0 Complete callback ID\r\n  *           @arg @ref HAL_CAN_TX_MAILBOX1_COMPLETE_CB_ID Tx Mailbox 1 Complete callback ID\r\n  *           @arg @ref HAL_CAN_TX_MAILBOX2_COMPLETE_CB_ID Tx Mailbox 2 Complete callback ID\r\n  *           @arg @ref HAL_CAN_TX_MAILBOX0_ABORT_CB_ID Tx Mailbox 0 Abort callback ID\r\n  *           @arg @ref HAL_CAN_TX_MAILBOX1_ABORT_CB_ID Tx Mailbox 1 Abort callback ID\r\n  *           @arg @ref HAL_CAN_TX_MAILBOX2_ABORT_CB_ID Tx Mailbox 2 Abort callback ID\r\n  *           @arg @ref HAL_CAN_RX_FIFO0_MSG_PENDING_CB_ID Rx Fifo 0 message pending callback ID\r\n  *           @arg @ref HAL_CAN_RX_FIFO0_FULL_CB_ID Rx Fifo 0 full callback ID\r\n  *           @arg @ref HAL_CAN_RX_FIFO1_MSG_PENDING_CB_ID Rx Fifo 1 message pending callback ID\r\n  *           @arg @ref HAL_CAN_RX_FIFO1_FULL_CB_ID Rx Fifo 1 full callback ID\r\n  *           @arg @ref HAL_CAN_SLEEP_CB_ID Sleep callback ID\r\n  *           @arg @ref HAL_CAN_WAKEUP_FROM_RX_MSG_CB_ID Wake Up from Rx message callback ID\r\n  *           @arg @ref HAL_CAN_ERROR_CB_ID Error callback ID\r\n  *           @arg @ref HAL_CAN_MSPINIT_CB_ID MspInit callback ID\r\n  *           @arg @ref HAL_CAN_MSPDEINIT_CB_ID MspDeInit callback ID\r\n  * @param  pCallback pointer to the Callback function\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_RegisterCallback(CAN_HandleTypeDef *hcan, HAL_CAN_CallbackIDTypeDef CallbackID, void (* pCallback)(CAN_HandleTypeDef *_hcan))\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    /* Update the error code */\r\n    hcan->ErrorCode |= HAL_CAN_ERROR_INVALID_CALLBACK;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if (hcan->State == HAL_CAN_STATE_READY)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_CAN_TX_MAILBOX0_COMPLETE_CB_ID :\r\n        hcan->TxMailbox0CompleteCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_TX_MAILBOX1_COMPLETE_CB_ID :\r\n        hcan->TxMailbox1CompleteCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_TX_MAILBOX2_COMPLETE_CB_ID :\r\n        hcan->TxMailbox2CompleteCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_TX_MAILBOX0_ABORT_CB_ID :\r\n        hcan->TxMailbox0AbortCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_TX_MAILBOX1_ABORT_CB_ID :\r\n        hcan->TxMailbox1AbortCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_TX_MAILBOX2_ABORT_CB_ID :\r\n        hcan->TxMailbox2AbortCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_RX_FIFO0_MSG_PENDING_CB_ID :\r\n        hcan->RxFifo0MsgPendingCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_RX_FIFO0_FULL_CB_ID :\r\n        hcan->RxFifo0FullCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_RX_FIFO1_MSG_PENDING_CB_ID :\r\n        hcan->RxFifo1MsgPendingCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_RX_FIFO1_FULL_CB_ID :\r\n        hcan->RxFifo1FullCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_SLEEP_CB_ID :\r\n        hcan->SleepCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_WAKEUP_FROM_RX_MSG_CB_ID :\r\n        hcan->WakeUpFromRxMsgCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_ERROR_CB_ID :\r\n        hcan->ErrorCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_MSPINIT_CB_ID :\r\n        hcan->MspInitCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_MSPDEINIT_CB_ID :\r\n        hcan->MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hcan->ErrorCode |= HAL_CAN_ERROR_INVALID_CALLBACK;\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (hcan->State == HAL_CAN_STATE_RESET)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_CAN_MSPINIT_CB_ID :\r\n        hcan->MspInitCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_CAN_MSPDEINIT_CB_ID :\r\n        hcan->MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hcan->ErrorCode |= HAL_CAN_ERROR_INVALID_CALLBACK;\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hcan->ErrorCode |= HAL_CAN_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Unregister a CAN CallBack.\r\n  *         CAN callabck is redirected to the weak predefined callback\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for CAN module\r\n  * @param  CallbackID ID of the callback to be unregistered\r\n  *         This parameter can be one of the following values:\r\n  *           @arg @ref HAL_CAN_TX_MAILBOX0_COMPLETE_CB_ID Tx Mailbox 0 Complete callback ID\r\n  *           @arg @ref HAL_CAN_TX_MAILBOX1_COMPLETE_CB_ID Tx Mailbox 1 Complete callback ID\r\n  *           @arg @ref HAL_CAN_TX_MAILBOX2_COMPLETE_CB_ID Tx Mailbox 2 Complete callback ID\r\n  *           @arg @ref HAL_CAN_TX_MAILBOX0_ABORT_CB_ID Tx Mailbox 0 Abort callback ID\r\n  *           @arg @ref HAL_CAN_TX_MAILBOX1_ABORT_CB_ID Tx Mailbox 1 Abort callback ID\r\n  *           @arg @ref HAL_CAN_TX_MAILBOX2_ABORT_CB_ID Tx Mailbox 2 Abort callback ID\r\n  *           @arg @ref HAL_CAN_RX_FIFO0_MSG_PENDING_CB_ID Rx Fifo 0 message pending callback ID\r\n  *           @arg @ref HAL_CAN_RX_FIFO0_FULL_CB_ID Rx Fifo 0 full callback ID\r\n  *           @arg @ref HAL_CAN_RX_FIFO1_MSG_PENDING_CB_ID Rx Fifo 1 message pending callback ID\r\n  *           @arg @ref HAL_CAN_RX_FIFO1_FULL_CB_ID Rx Fifo 1 full callback ID\r\n  *           @arg @ref HAL_CAN_SLEEP_CB_ID Sleep callback ID\r\n  *           @arg @ref HAL_CAN_WAKEUP_FROM_RX_MSG_CB_ID Wake Up from Rx message callback ID\r\n  *           @arg @ref HAL_CAN_ERROR_CB_ID Error callback ID\r\n  *           @arg @ref HAL_CAN_MSPINIT_CB_ID MspInit callback ID\r\n  *           @arg @ref HAL_CAN_MSPDEINIT_CB_ID MspDeInit callback ID\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_UnRegisterCallback(CAN_HandleTypeDef *hcan, HAL_CAN_CallbackIDTypeDef CallbackID)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (hcan->State == HAL_CAN_STATE_READY)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_CAN_TX_MAILBOX0_COMPLETE_CB_ID :\r\n        hcan->TxMailbox0CompleteCallback = HAL_CAN_TxMailbox0CompleteCallback;\r\n        break;\r\n\r\n      case HAL_CAN_TX_MAILBOX1_COMPLETE_CB_ID :\r\n        hcan->TxMailbox1CompleteCallback = HAL_CAN_TxMailbox1CompleteCallback;\r\n        break;\r\n\r\n      case HAL_CAN_TX_MAILBOX2_COMPLETE_CB_ID :\r\n        hcan->TxMailbox2CompleteCallback = HAL_CAN_TxMailbox2CompleteCallback;\r\n        break;\r\n\r\n      case HAL_CAN_TX_MAILBOX0_ABORT_CB_ID :\r\n        hcan->TxMailbox0AbortCallback = HAL_CAN_TxMailbox0AbortCallback;\r\n        break;\r\n\r\n      case HAL_CAN_TX_MAILBOX1_ABORT_CB_ID :\r\n        hcan->TxMailbox1AbortCallback = HAL_CAN_TxMailbox1AbortCallback;\r\n        break;\r\n\r\n      case HAL_CAN_TX_MAILBOX2_ABORT_CB_ID :\r\n        hcan->TxMailbox2AbortCallback = HAL_CAN_TxMailbox2AbortCallback;\r\n        break;\r\n\r\n      case HAL_CAN_RX_FIFO0_MSG_PENDING_CB_ID :\r\n        hcan->RxFifo0MsgPendingCallback = HAL_CAN_RxFifo0MsgPendingCallback;\r\n        break;\r\n\r\n      case HAL_CAN_RX_FIFO0_FULL_CB_ID :\r\n        hcan->RxFifo0FullCallback = HAL_CAN_RxFifo0FullCallback;\r\n        break;\r\n\r\n      case HAL_CAN_RX_FIFO1_MSG_PENDING_CB_ID :\r\n        hcan->RxFifo1MsgPendingCallback = HAL_CAN_RxFifo1MsgPendingCallback;\r\n        break;\r\n\r\n      case HAL_CAN_RX_FIFO1_FULL_CB_ID :\r\n        hcan->RxFifo1FullCallback = HAL_CAN_RxFifo1FullCallback;\r\n        break;\r\n\r\n      case HAL_CAN_SLEEP_CB_ID :\r\n        hcan->SleepCallback = HAL_CAN_SleepCallback;\r\n        break;\r\n\r\n      case HAL_CAN_WAKEUP_FROM_RX_MSG_CB_ID :\r\n        hcan->WakeUpFromRxMsgCallback = HAL_CAN_WakeUpFromRxMsgCallback;\r\n        break;\r\n\r\n      case HAL_CAN_ERROR_CB_ID :\r\n        hcan->ErrorCallback = HAL_CAN_ErrorCallback;\r\n        break;\r\n\r\n      case HAL_CAN_MSPINIT_CB_ID :\r\n        hcan->MspInitCallback = HAL_CAN_MspInit;\r\n        break;\r\n\r\n      case HAL_CAN_MSPDEINIT_CB_ID :\r\n        hcan->MspDeInitCallback = HAL_CAN_MspDeInit;\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hcan->ErrorCode |= HAL_CAN_ERROR_INVALID_CALLBACK;\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (hcan->State == HAL_CAN_STATE_RESET)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_CAN_MSPINIT_CB_ID :\r\n        hcan->MspInitCallback = HAL_CAN_MspInit;\r\n        break;\r\n\r\n      case HAL_CAN_MSPDEINIT_CB_ID :\r\n        hcan->MspDeInitCallback = HAL_CAN_MspDeInit;\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hcan->ErrorCode |= HAL_CAN_ERROR_INVALID_CALLBACK;\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hcan->ErrorCode |= HAL_CAN_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  return status;\r\n}\r\n#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup CAN_Exported_Functions_Group2 Configuration functions\r\n *  @brief    Configuration functions.\r\n *\r\n@verbatim\r\n  ==============================================================================\r\n              ##### Configuration functions #####\r\n  ==============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) HAL_CAN_ConfigFilter            : Configure the CAN reception filters\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Configures the CAN reception filter according to the specified\r\n  *         parameters in the CAN_FilterInitStruct.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @param  sFilterConfig pointer to a CAN_FilterTypeDef structure that\r\n  *         contains the filter configuration information.\r\n  * @retval None\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef *hcan, CAN_FilterTypeDef *sFilterConfig)\r\n{\r\n  uint32_t filternbrbitpos;\r\n  CAN_TypeDef *can_ip = hcan->Instance;\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterIdHigh));\r\n    assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterIdLow));\r\n    assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterMaskIdHigh));\r\n    assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterMaskIdLow));\r\n    assert_param(IS_CAN_FILTER_MODE(sFilterConfig->FilterMode));\r\n    assert_param(IS_CAN_FILTER_SCALE(sFilterConfig->FilterScale));\r\n    assert_param(IS_CAN_FILTER_FIFO(sFilterConfig->FilterFIFOAssignment));\r\n    assert_param(IS_CAN_FILTER_ACTIVATION(sFilterConfig->FilterActivation));\r\n\r\n#if defined(CAN3)\r\n    /* Check the CAN instance */\r\n    if (hcan->Instance == CAN3)\r\n    {\r\n      /* CAN3 is single instance with 14 dedicated filters banks */\r\n\r\n      /* Check the parameters */\r\n      assert_param(IS_CAN_FILTER_BANK_SINGLE(sFilterConfig->FilterBank));\r\n    }\r\n    else\r\n    {\r\n      /* CAN1 and CAN2 are dual instances with 28 common filters banks */\r\n      /* Select master instance to access the filter banks */\r\n      can_ip = CAN1;\r\n\r\n      /* Check the parameters */\r\n      assert_param(IS_CAN_FILTER_BANK_DUAL(sFilterConfig->FilterBank));\r\n      assert_param(IS_CAN_FILTER_BANK_DUAL(sFilterConfig->SlaveStartFilterBank));\r\n    }\r\n#elif defined(CAN2)\r\n    /* CAN1 and CAN2 are dual instances with 28 common filters banks */\r\n    /* Select master instance to access the filter banks */\r\n    can_ip = CAN1;\r\n\r\n    /* Check the parameters */\r\n    assert_param(IS_CAN_FILTER_BANK_DUAL(sFilterConfig->FilterBank));\r\n    assert_param(IS_CAN_FILTER_BANK_DUAL(sFilterConfig->SlaveStartFilterBank));\r\n#else\r\n    /* CAN1 is single instance with 14 dedicated filters banks */\r\n\r\n    /* Check the parameters */\r\n    assert_param(IS_CAN_FILTER_BANK_SINGLE(sFilterConfig->FilterBank));\r\n#endif\r\n\r\n    /* Initialisation mode for the filter */\r\n    SET_BIT(can_ip->FMR, CAN_FMR_FINIT);\r\n\r\n#if defined(CAN3)\r\n    /* Check the CAN instance */\r\n    if (can_ip == CAN1)\r\n    {\r\n      /* Select the start filter number of CAN2 slave instance */\r\n      CLEAR_BIT(can_ip->FMR, CAN_FMR_CAN2SB);\r\n      SET_BIT(can_ip->FMR, sFilterConfig->SlaveStartFilterBank << CAN_FMR_CAN2SB_Pos);\r\n    }\r\n\r\n#elif defined(CAN2)\r\n    /* Select the start filter number of CAN2 slave instance */\r\n    CLEAR_BIT(can_ip->FMR, CAN_FMR_CAN2SB);\r\n    SET_BIT(can_ip->FMR, sFilterConfig->SlaveStartFilterBank << CAN_FMR_CAN2SB_Pos);\r\n\r\n#endif\r\n    /* Convert filter number into bit position */\r\n    filternbrbitpos = (uint32_t)1 << (sFilterConfig->FilterBank & 0x1FU);\r\n\r\n    /* Filter Deactivation */\r\n    CLEAR_BIT(can_ip->FA1R, filternbrbitpos);\r\n\r\n    /* Filter Scale */\r\n    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)\r\n    {\r\n      /* 16-bit scale for the filter */\r\n      CLEAR_BIT(can_ip->FS1R, filternbrbitpos);\r\n\r\n      /* First 16-bit identifier and First 16-bit mask */\r\n      /* Or First 16-bit identifier and Second 16-bit identifier */\r\n      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =\r\n        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |\r\n        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);\r\n\r\n      /* Second 16-bit identifier and Second 16-bit mask */\r\n      /* Or Third 16-bit identifier and Fourth 16-bit identifier */\r\n      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =\r\n        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |\r\n        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh);\r\n    }\r\n\r\n    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)\r\n    {\r\n      /* 32-bit scale for the filter */\r\n      SET_BIT(can_ip->FS1R, filternbrbitpos);\r\n\r\n      /* 32-bit identifier or First 32-bit identifier */\r\n      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =\r\n        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |\r\n        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);\r\n\r\n      /* 32-bit mask or Second 32-bit identifier */\r\n      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =\r\n        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |\r\n        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow);\r\n    }\r\n\r\n    /* Filter Mode */\r\n    if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)\r\n    {\r\n      /* Id/Mask mode for the filter*/\r\n      CLEAR_BIT(can_ip->FM1R, filternbrbitpos);\r\n    }\r\n    else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */\r\n    {\r\n      /* Identifier list mode for the filter*/\r\n      SET_BIT(can_ip->FM1R, filternbrbitpos);\r\n    }\r\n\r\n    /* Filter FIFO assignment */\r\n    if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)\r\n    {\r\n      /* FIFO 0 assignation for the filter */\r\n      CLEAR_BIT(can_ip->FFA1R, filternbrbitpos);\r\n    }\r\n    else\r\n    {\r\n      /* FIFO 1 assignation for the filter */\r\n      SET_BIT(can_ip->FFA1R, filternbrbitpos);\r\n    }\r\n\r\n    /* Filter activation */\r\n    if (sFilterConfig->FilterActivation == CAN_FILTER_ENABLE)\r\n    {\r\n      SET_BIT(can_ip->FA1R, filternbrbitpos);\r\n    }\r\n\r\n    /* Leave the initialisation mode for the filter */\r\n    CLEAR_BIT(can_ip->FMR, CAN_FMR_FINIT);\r\n\r\n    /* Return function status */\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    /* Update error code */\r\n    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup CAN_Exported_Functions_Group3 Control functions\r\n *  @brief    Control functions\r\n *\r\n@verbatim\r\n  ==============================================================================\r\n                      ##### Control functions #####\r\n  ==============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) HAL_CAN_Start                    : Start the CAN module\r\n      (+) HAL_CAN_Stop                     : Stop the CAN module\r\n      (+) HAL_CAN_RequestSleep             : Request sleep mode entry.\r\n      (+) HAL_CAN_WakeUp                   : Wake up from sleep mode.\r\n      (+) HAL_CAN_IsSleepActive            : Check is sleep mode is active.\r\n      (+) HAL_CAN_AddTxMessage             : Add a message to the Tx mailboxes\r\n                                             and activate the corresponding\r\n                                             transmission request\r\n      (+) HAL_CAN_AbortTxRequest           : Abort transmission request\r\n      (+) HAL_CAN_GetTxMailboxesFreeLevel  : Return Tx mailboxes free level\r\n      (+) HAL_CAN_IsTxMessagePending       : Check if a transmission request is\r\n                                             pending on the selected Tx mailbox\r\n      (+) HAL_CAN_GetRxMessage             : Get a CAN frame from the Rx FIFO\r\n      (+) HAL_CAN_GetRxFifoFillLevel       : Return Rx FIFO fill level\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Start the CAN module.\r\n  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_Start(CAN_HandleTypeDef *hcan)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  if (hcan->State == HAL_CAN_STATE_READY)\r\n  {\r\n    /* Change CAN peripheral state */\r\n    hcan->State = HAL_CAN_STATE_LISTENING;\r\n\r\n    /* Request leave initialisation */\r\n    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);\r\n\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait the acknowledge */\r\n    while ((hcan->Instance->MSR & CAN_MSR_INAK) != 0U)\r\n    {\r\n      /* Check for the Timeout */\r\n      if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)\r\n      {\r\n        /* Update error code */\r\n        hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;\r\n\r\n        /* Change CAN state */\r\n        hcan->State = HAL_CAN_STATE_ERROR;\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    /* Reset the CAN ErrorCode */\r\n    hcan->ErrorCode = HAL_CAN_ERROR_NONE;\r\n\r\n    /* Return function status */\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    /* Update error code */\r\n    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_READY;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Stop the CAN module and enable access to configuration registers.\r\n  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_Stop(CAN_HandleTypeDef *hcan)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  if (hcan->State == HAL_CAN_STATE_LISTENING)\r\n  {\r\n    /* Request initialisation */\r\n    SET_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);\r\n\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait the acknowledge */\r\n    while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)\r\n    {\r\n      /* Check for the Timeout */\r\n      if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)\r\n      {\r\n        /* Update error code */\r\n        hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;\r\n\r\n        /* Change CAN state */\r\n        hcan->State = HAL_CAN_STATE_ERROR;\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    /* Exit from sleep mode */\r\n    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);\r\n\r\n    /* Change CAN peripheral state */\r\n    hcan->State = HAL_CAN_STATE_READY;\r\n\r\n    /* Return function status */\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    /* Update error code */\r\n    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_STARTED;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Request the sleep mode (low power) entry.\r\n  *         When returning from this function, Sleep mode will be entered\r\n  *         as soon as the current CAN activity (transmission or reception\r\n  *         of a CAN frame) has been completed.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval HAL status.\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_RequestSleep(CAN_HandleTypeDef *hcan)\r\n{\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    /* Request Sleep mode */\r\n    SET_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);\r\n\r\n    /* Return function status */\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    /* Update error code */\r\n    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;\r\n\r\n    /* Return function status */\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Wake up from sleep mode.\r\n  *         When returning with HAL_OK status from this function, Sleep mode\r\n  *         is exited.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval HAL status.\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_WakeUp(CAN_HandleTypeDef *hcan)\r\n{\r\n  __IO uint32_t count = 0;\r\n  uint32_t timeout = 1000000U;\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    /* Wake up request */\r\n    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);\r\n\r\n    /* Wait sleep mode is exited */\r\n    do\r\n    {\r\n      /* Increment counter */\r\n      count++;\r\n\r\n      /* Check if timeout is reached */\r\n      if (count > timeout)\r\n      {\r\n        /* Update error code */\r\n        hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U);\r\n\r\n    /* Return function status */\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    /* Update error code */\r\n    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Check is sleep mode is active.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval Status\r\n  *          - 0 : Sleep mode is not active.\r\n  *          - 1 : Sleep mode is active.\r\n  */\r\nuint32_t HAL_CAN_IsSleepActive(CAN_HandleTypeDef *hcan)\r\n{\r\n  uint32_t status = 0U;\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    /* Check Sleep mode */\r\n    if ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)\r\n    {\r\n      status = 1U;\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Add a message to the first free Tx mailbox and activate the\r\n  *         corresponding transmission request.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @param  pHeader pointer to a CAN_TxHeaderTypeDef structure.\r\n  * @param  aData array containing the payload of the Tx frame.\r\n  * @param  pTxMailbox pointer to a variable where the function will return\r\n  *         the TxMailbox used to store the Tx message.\r\n  *         This parameter can be a value of @arg CAN_Tx_Mailboxes.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_AddTxMessage(CAN_HandleTypeDef *hcan, CAN_TxHeaderTypeDef *pHeader, uint8_t aData[], uint32_t *pTxMailbox)\r\n{\r\n  uint32_t transmitmailbox;\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n  uint32_t tsr = READ_REG(hcan->Instance->TSR);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_CAN_IDTYPE(pHeader->IDE));\r\n  assert_param(IS_CAN_RTR(pHeader->RTR));\r\n  assert_param(IS_CAN_DLC(pHeader->DLC));\r\n  if (pHeader->IDE == CAN_ID_STD)\r\n  {\r\n    assert_param(IS_CAN_STDID(pHeader->StdId));\r\n  }\r\n  else\r\n  {\r\n    assert_param(IS_CAN_EXTID(pHeader->ExtId));\r\n  }\r\n  assert_param(IS_FUNCTIONAL_STATE(pHeader->TransmitGlobalTime));\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    /* Check that all the Tx mailboxes are not full */\r\n    if (((tsr & CAN_TSR_TME0) != 0U) ||\r\n        ((tsr & CAN_TSR_TME1) != 0U) ||\r\n        ((tsr & CAN_TSR_TME2) != 0U))\r\n    {\r\n      /* Select an empty transmit mailbox */\r\n      transmitmailbox = (tsr & CAN_TSR_CODE) >> CAN_TSR_CODE_Pos;\r\n\r\n      /* Check transmit mailbox value */\r\n      if (transmitmailbox > 2U)\r\n      {\r\n        /* Update error code */\r\n        hcan->ErrorCode |= HAL_CAN_ERROR_INTERNAL;\r\n\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Store the Tx mailbox */\r\n      *pTxMailbox = (uint32_t)1 << transmitmailbox;\r\n\r\n      /* Set up the Id */\r\n      if (pHeader->IDE == CAN_ID_STD)\r\n      {\r\n        hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->StdId << CAN_TI0R_STID_Pos) |\r\n                                                           pHeader->RTR);\r\n      }\r\n      else\r\n      {\r\n        hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->ExtId << CAN_TI0R_EXID_Pos) |\r\n                                                           pHeader->IDE |\r\n                                                           pHeader->RTR);\r\n      }\r\n\r\n      /* Set up the DLC */\r\n      hcan->Instance->sTxMailBox[transmitmailbox].TDTR = (pHeader->DLC);\r\n\r\n      /* Set up the Transmit Global Time mode */\r\n      if (pHeader->TransmitGlobalTime == ENABLE)\r\n      {\r\n        SET_BIT(hcan->Instance->sTxMailBox[transmitmailbox].TDTR, CAN_TDT0R_TGT);\r\n      }\r\n\r\n      /* Set up the data field */\r\n      WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDHR,\r\n                ((uint32_t)aData[7] << CAN_TDH0R_DATA7_Pos) |\r\n                ((uint32_t)aData[6] << CAN_TDH0R_DATA6_Pos) |\r\n                ((uint32_t)aData[5] << CAN_TDH0R_DATA5_Pos) |\r\n                ((uint32_t)aData[4] << CAN_TDH0R_DATA4_Pos));\r\n      WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDLR,\r\n                ((uint32_t)aData[3] << CAN_TDL0R_DATA3_Pos) |\r\n                ((uint32_t)aData[2] << CAN_TDL0R_DATA2_Pos) |\r\n                ((uint32_t)aData[1] << CAN_TDL0R_DATA1_Pos) |\r\n                ((uint32_t)aData[0] << CAN_TDL0R_DATA0_Pos));\r\n\r\n      /* Request transmission */\r\n      SET_BIT(hcan->Instance->sTxMailBox[transmitmailbox].TIR, CAN_TI0R_TXRQ);\r\n\r\n      /* Return function status */\r\n      return HAL_OK;\r\n    }\r\n    else\r\n    {\r\n      /* Update error code */\r\n      hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;\r\n\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Update error code */\r\n    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Abort transmission requests\r\n  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @param  TxMailboxes List of the Tx Mailboxes to abort.\r\n  *         This parameter can be any combination of @arg CAN_Tx_Mailboxes.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_AbortTxRequest(CAN_HandleTypeDef *hcan, uint32_t TxMailboxes)\r\n{\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n\r\n  /* Check function parameters */\r\n  assert_param(IS_CAN_TX_MAILBOX_LIST(TxMailboxes));\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    /* Check Tx Mailbox 0 */\r\n    if ((TxMailboxes & CAN_TX_MAILBOX0) != 0U)\r\n    {\r\n      /* Add cancellation request for Tx Mailbox 0 */\r\n      SET_BIT(hcan->Instance->TSR, CAN_TSR_ABRQ0);\r\n    }\r\n\r\n    /* Check Tx Mailbox 1 */\r\n    if ((TxMailboxes & CAN_TX_MAILBOX1) != 0U)\r\n    {\r\n      /* Add cancellation request for Tx Mailbox 1 */\r\n      SET_BIT(hcan->Instance->TSR, CAN_TSR_ABRQ1);\r\n    }\r\n\r\n    /* Check Tx Mailbox 2 */\r\n    if ((TxMailboxes & CAN_TX_MAILBOX2) != 0U)\r\n    {\r\n      /* Add cancellation request for Tx Mailbox 2 */\r\n      SET_BIT(hcan->Instance->TSR, CAN_TSR_ABRQ2);\r\n    }\r\n\r\n    /* Return function status */\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    /* Update error code */\r\n    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Return Tx Mailboxes free level: number of free Tx Mailboxes.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval Number of free Tx Mailboxes.\r\n  */\r\nuint32_t HAL_CAN_GetTxMailboxesFreeLevel(CAN_HandleTypeDef *hcan)\r\n{\r\n  uint32_t freelevel = 0U;\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    /* Check Tx Mailbox 0 status */\r\n    if ((hcan->Instance->TSR & CAN_TSR_TME0) != 0U)\r\n    {\r\n      freelevel++;\r\n    }\r\n\r\n    /* Check Tx Mailbox 1 status */\r\n    if ((hcan->Instance->TSR & CAN_TSR_TME1) != 0U)\r\n    {\r\n      freelevel++;\r\n    }\r\n\r\n    /* Check Tx Mailbox 2 status */\r\n    if ((hcan->Instance->TSR & CAN_TSR_TME2) != 0U)\r\n    {\r\n      freelevel++;\r\n    }\r\n  }\r\n\r\n  /* Return Tx Mailboxes free level */\r\n  return freelevel;\r\n}\r\n\r\n/**\r\n  * @brief  Check if a transmission request is pending on the selected Tx\r\n  *         Mailboxes.\r\n  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @param  TxMailboxes List of Tx Mailboxes to check.\r\n  *         This parameter can be any combination of @arg CAN_Tx_Mailboxes.\r\n  * @retval Status\r\n  *          - 0 : No pending transmission request on any selected Tx Mailboxes.\r\n  *          - 1 : Pending transmission request on at least one of the selected\r\n  *                Tx Mailbox.\r\n  */\r\nuint32_t HAL_CAN_IsTxMessagePending(CAN_HandleTypeDef *hcan, uint32_t TxMailboxes)\r\n{\r\n  uint32_t status = 0U;\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n\r\n  /* Check function parameters */\r\n  assert_param(IS_CAN_TX_MAILBOX_LIST(TxMailboxes));\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    /* Check pending transmission request on the selected Tx Mailboxes */\r\n    if ((hcan->Instance->TSR & (TxMailboxes << CAN_TSR_TME0_Pos)) != (TxMailboxes << CAN_TSR_TME0_Pos))\r\n    {\r\n      status = 1U;\r\n    }\r\n  }\r\n\r\n  /* Return status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Return timestamp of Tx message sent, if time triggered communication\r\n            mode is enabled.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @param  TxMailbox Tx Mailbox where the timestamp of message sent will be\r\n  *         read.\r\n  *         This parameter can be one value of @arg CAN_Tx_Mailboxes.\r\n  * @retval Timestamp of message sent from Tx Mailbox.\r\n  */\r\nuint32_t HAL_CAN_GetTxTimestamp(CAN_HandleTypeDef *hcan, uint32_t TxMailbox)\r\n{\r\n  uint32_t timestamp = 0U;\r\n  uint32_t transmitmailbox;\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n\r\n  /* Check function parameters */\r\n  assert_param(IS_CAN_TX_MAILBOX(TxMailbox));\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    /* Select the Tx mailbox */\r\n    transmitmailbox = POSITION_VAL(TxMailbox);\r\n\r\n    /* Get timestamp */\r\n    timestamp = (hcan->Instance->sTxMailBox[transmitmailbox].TDTR & CAN_TDT0R_TIME) >> CAN_TDT0R_TIME_Pos;\r\n  }\r\n\r\n  /* Return the timestamp */\r\n  return timestamp;\r\n}\r\n\r\n/**\r\n  * @brief  Get an CAN frame from the Rx FIFO zone into the message RAM.\r\n  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @param  RxFifo Fifo number of the received message to be read.\r\n  *         This parameter can be a value of @arg CAN_receive_FIFO_number.\r\n  * @param  pHeader pointer to a CAN_RxHeaderTypeDef structure where the header\r\n  *         of the Rx frame will be stored.\r\n  * @param  aData array where the payload of the Rx frame will be stored.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_GetRxMessage(CAN_HandleTypeDef *hcan, uint32_t RxFifo, CAN_RxHeaderTypeDef *pHeader, uint8_t aData[])\r\n{\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n\r\n  assert_param(IS_CAN_RX_FIFO(RxFifo));\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    /* Check the Rx FIFO */\r\n    if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */\r\n    {\r\n      /* Check that the Rx FIFO 0 is not empty */\r\n      if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) == 0U)\r\n      {\r\n        /* Update error code */\r\n        hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    else /* Rx element is assigned to Rx FIFO 1 */\r\n    {\r\n      /* Check that the Rx FIFO 1 is not empty */\r\n      if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) == 0U)\r\n      {\r\n        /* Update error code */\r\n        hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    /* Get the header */\r\n    pHeader->IDE = CAN_RI0R_IDE & hcan->Instance->sFIFOMailBox[RxFifo].RIR;\r\n    if (pHeader->IDE == CAN_ID_STD)\r\n    {\r\n      pHeader->StdId = (CAN_RI0R_STID & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_TI0R_STID_Pos;\r\n    }\r\n    else\r\n    {\r\n      pHeader->ExtId = ((CAN_RI0R_EXID | CAN_RI0R_STID) & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_RI0R_EXID_Pos;\r\n    }\r\n    pHeader->RTR = (CAN_RI0R_RTR & hcan->Instance->sFIFOMailBox[RxFifo].RIR);\r\n    pHeader->DLC = (CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos;\r\n    pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;\r\n    pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;\r\n\r\n    /* Get the data */\r\n    aData[0] = (uint8_t)((CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos);\r\n    aData[1] = (uint8_t)((CAN_RDL0R_DATA1 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA1_Pos);\r\n    aData[2] = (uint8_t)((CAN_RDL0R_DATA2 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA2_Pos);\r\n    aData[3] = (uint8_t)((CAN_RDL0R_DATA3 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA3_Pos);\r\n    aData[4] = (uint8_t)((CAN_RDH0R_DATA4 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA4_Pos);\r\n    aData[5] = (uint8_t)((CAN_RDH0R_DATA5 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA5_Pos);\r\n    aData[6] = (uint8_t)((CAN_RDH0R_DATA6 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA6_Pos);\r\n    aData[7] = (uint8_t)((CAN_RDH0R_DATA7 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA7_Pos);\r\n\r\n    /* Release the FIFO */\r\n    if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */\r\n    {\r\n      /* Release RX FIFO 0 */\r\n      SET_BIT(hcan->Instance->RF0R, CAN_RF0R_RFOM0);\r\n    }\r\n    else /* Rx element is assigned to Rx FIFO 1 */\r\n    {\r\n      /* Release RX FIFO 1 */\r\n      SET_BIT(hcan->Instance->RF1R, CAN_RF1R_RFOM1);\r\n    }\r\n\r\n    /* Return function status */\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    /* Update error code */\r\n    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Return Rx FIFO fill level.\r\n  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @param  RxFifo Rx FIFO.\r\n  *         This parameter can be a value of @arg CAN_receive_FIFO_number.\r\n  * @retval Number of messages available in Rx FIFO.\r\n  */\r\nuint32_t HAL_CAN_GetRxFifoFillLevel(CAN_HandleTypeDef *hcan, uint32_t RxFifo)\r\n{\r\n  uint32_t filllevel = 0U;\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n\r\n  /* Check function parameters */\r\n  assert_param(IS_CAN_RX_FIFO(RxFifo));\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    if (RxFifo == CAN_RX_FIFO0)\r\n    {\r\n      filllevel = hcan->Instance->RF0R & CAN_RF0R_FMP0;\r\n    }\r\n    else /* RxFifo == CAN_RX_FIFO1 */\r\n    {\r\n      filllevel = hcan->Instance->RF1R & CAN_RF1R_FMP1;\r\n    }\r\n  }\r\n\r\n  /* Return Rx FIFO fill level */\r\n  return filllevel;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup CAN_Exported_Functions_Group4 Interrupts management\r\n *  @brief    Interrupts management\r\n *\r\n@verbatim\r\n  ==============================================================================\r\n                       ##### Interrupts management #####\r\n  ==============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) HAL_CAN_ActivateNotification      : Enable interrupts\r\n      (+) HAL_CAN_DeactivateNotification    : Disable interrupts\r\n      (+) HAL_CAN_IRQHandler                : Handles CAN interrupt request\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Enable interrupts.\r\n  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @param  ActiveITs indicates which interrupts will be enabled.\r\n  *         This parameter can be any combination of @arg CAN_Interrupts.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_ActivateNotification(CAN_HandleTypeDef *hcan, uint32_t ActiveITs)\r\n{\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n\r\n  /* Check function parameters */\r\n  assert_param(IS_CAN_IT(ActiveITs));\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    /* Enable the selected interrupts */\r\n    __HAL_CAN_ENABLE_IT(hcan, ActiveITs);\r\n\r\n    /* Return function status */\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    /* Update error code */\r\n    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Disable interrupts.\r\n  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @param  InactiveITs indicates which interrupts will be disabled.\r\n  *         This parameter can be any combination of @arg CAN_Interrupts.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_DeactivateNotification(CAN_HandleTypeDef *hcan, uint32_t InactiveITs)\r\n{\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n\r\n  /* Check function parameters */\r\n  assert_param(IS_CAN_IT(InactiveITs));\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    /* Disable the selected interrupts */\r\n    __HAL_CAN_DISABLE_IT(hcan, InactiveITs);\r\n\r\n    /* Return function status */\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    /* Update error code */\r\n    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Handles CAN interrupt request\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\nvoid HAL_CAN_IRQHandler(CAN_HandleTypeDef *hcan)\r\n{\r\n  uint32_t errorcode = HAL_CAN_ERROR_NONE;\r\n  uint32_t interrupts = READ_REG(hcan->Instance->IER);\r\n  uint32_t msrflags = READ_REG(hcan->Instance->MSR);\r\n  uint32_t tsrflags = READ_REG(hcan->Instance->TSR);\r\n  uint32_t rf0rflags = READ_REG(hcan->Instance->RF0R);\r\n  uint32_t rf1rflags = READ_REG(hcan->Instance->RF1R);\r\n  uint32_t esrflags = READ_REG(hcan->Instance->ESR);\r\n\r\n  /* Transmit Mailbox empty interrupt management *****************************/\r\n  if ((interrupts & CAN_IT_TX_MAILBOX_EMPTY) != 0U)\r\n  {\r\n    /* Transmit Mailbox 0 management *****************************************/\r\n    if ((tsrflags & CAN_TSR_RQCP0) != 0U)\r\n    {\r\n      /* Clear the Transmission Complete flag (and TXOK0,ALST0,TERR0 bits) */\r\n      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP0);\r\n\r\n      if ((tsrflags & CAN_TSR_TXOK0) != 0U)\r\n      {\r\n        /* Transmission Mailbox 0 complete callback */\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n        /* Call registered callback*/\r\n        hcan->TxMailbox0CompleteCallback(hcan);\r\n#else\r\n        /* Call weak (surcharged) callback */\r\n        HAL_CAN_TxMailbox0CompleteCallback(hcan);\r\n#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */\r\n      }\r\n      else\r\n      {\r\n        if ((tsrflags & CAN_TSR_ALST0) != 0U)\r\n        {\r\n          /* Update error code */\r\n          errorcode |= HAL_CAN_ERROR_TX_ALST0;\r\n        }\r\n        else if ((tsrflags & CAN_TSR_TERR0) != 0U)\r\n        {\r\n          /* Update error code */\r\n          errorcode |= HAL_CAN_ERROR_TX_TERR0;\r\n        }\r\n        else\r\n        {\r\n          /* Transmission Mailbox 0 abort callback */\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n          /* Call registered callback*/\r\n          hcan->TxMailbox0AbortCallback(hcan);\r\n#else\r\n          /* Call weak (surcharged) callback */\r\n          HAL_CAN_TxMailbox0AbortCallback(hcan);\r\n#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Transmit Mailbox 1 management *****************************************/\r\n    if ((tsrflags & CAN_TSR_RQCP1) != 0U)\r\n    {\r\n      /* Clear the Transmission Complete flag (and TXOK1,ALST1,TERR1 bits) */\r\n      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP1);\r\n\r\n      if ((tsrflags & CAN_TSR_TXOK1) != 0U)\r\n      {\r\n        /* Transmission Mailbox 1 complete callback */\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n        /* Call registered callback*/\r\n        hcan->TxMailbox1CompleteCallback(hcan);\r\n#else\r\n        /* Call weak (surcharged) callback */\r\n        HAL_CAN_TxMailbox1CompleteCallback(hcan);\r\n#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */\r\n      }\r\n      else\r\n      {\r\n        if ((tsrflags & CAN_TSR_ALST1) != 0U)\r\n        {\r\n          /* Update error code */\r\n          errorcode |= HAL_CAN_ERROR_TX_ALST1;\r\n        }\r\n        else if ((tsrflags & CAN_TSR_TERR1) != 0U)\r\n        {\r\n          /* Update error code */\r\n          errorcode |= HAL_CAN_ERROR_TX_TERR1;\r\n        }\r\n        else\r\n        {\r\n          /* Transmission Mailbox 1 abort callback */\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n          /* Call registered callback*/\r\n          hcan->TxMailbox1AbortCallback(hcan);\r\n#else\r\n          /* Call weak (surcharged) callback */\r\n          HAL_CAN_TxMailbox1AbortCallback(hcan);\r\n#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Transmit Mailbox 2 management *****************************************/\r\n    if ((tsrflags & CAN_TSR_RQCP2) != 0U)\r\n    {\r\n      /* Clear the Transmission Complete flag (and TXOK2,ALST2,TERR2 bits) */\r\n      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP2);\r\n\r\n      if ((tsrflags & CAN_TSR_TXOK2) != 0U)\r\n      {\r\n        /* Transmission Mailbox 2 complete callback */\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n        /* Call registered callback*/\r\n        hcan->TxMailbox2CompleteCallback(hcan);\r\n#else\r\n        /* Call weak (surcharged) callback */\r\n        HAL_CAN_TxMailbox2CompleteCallback(hcan);\r\n#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */\r\n      }\r\n      else\r\n      {\r\n        if ((tsrflags & CAN_TSR_ALST2) != 0U)\r\n        {\r\n          /* Update error code */\r\n          errorcode |= HAL_CAN_ERROR_TX_ALST2;\r\n        }\r\n        else if ((tsrflags & CAN_TSR_TERR2) != 0U)\r\n        {\r\n          /* Update error code */\r\n          errorcode |= HAL_CAN_ERROR_TX_TERR2;\r\n        }\r\n        else\r\n        {\r\n          /* Transmission Mailbox 2 abort callback */\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n          /* Call registered callback*/\r\n          hcan->TxMailbox2AbortCallback(hcan);\r\n#else\r\n          /* Call weak (surcharged) callback */\r\n          HAL_CAN_TxMailbox2AbortCallback(hcan);\r\n#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Receive FIFO 0 overrun interrupt management *****************************/\r\n  if ((interrupts & CAN_IT_RX_FIFO0_OVERRUN) != 0U)\r\n  {\r\n    if ((rf0rflags & CAN_RF0R_FOVR0) != 0U)\r\n    {\r\n      /* Set CAN error code to Rx Fifo 0 overrun error */\r\n      errorcode |= HAL_CAN_ERROR_RX_FOV0;\r\n\r\n      /* Clear FIFO0 Overrun Flag */\r\n      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV0);\r\n    }\r\n  }\r\n\r\n  /* Receive FIFO 0 full interrupt management ********************************/\r\n  if ((interrupts & CAN_IT_RX_FIFO0_FULL) != 0U)\r\n  {\r\n    if ((rf0rflags & CAN_RF0R_FULL0) != 0U)\r\n    {\r\n      /* Clear FIFO 0 full Flag */\r\n      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF0);\r\n\r\n      /* Receive FIFO 0 full Callback */\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n      /* Call registered callback*/\r\n      hcan->RxFifo0FullCallback(hcan);\r\n#else\r\n      /* Call weak (surcharged) callback */\r\n      HAL_CAN_RxFifo0FullCallback(hcan);\r\n#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n\r\n  /* Receive FIFO 0 message pending interrupt management *********************/\r\n  if ((interrupts & CAN_IT_RX_FIFO0_MSG_PENDING) != 0U)\r\n  {\r\n    /* Check if message is still pending */\r\n    if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) != 0U)\r\n    {\r\n      /* Receive FIFO 0 message pending Callback */\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n      /* Call registered callback*/\r\n      hcan->RxFifo0MsgPendingCallback(hcan);\r\n#else\r\n      /* Call weak (surcharged) callback */\r\n      HAL_CAN_RxFifo0MsgPendingCallback(hcan);\r\n#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n\r\n  /* Receive FIFO 1 overrun interrupt management *****************************/\r\n  if ((interrupts & CAN_IT_RX_FIFO1_OVERRUN) != 0U)\r\n  {\r\n    if ((rf1rflags & CAN_RF1R_FOVR1) != 0U)\r\n    {\r\n      /* Set CAN error code to Rx Fifo 1 overrun error */\r\n      errorcode |= HAL_CAN_ERROR_RX_FOV1;\r\n\r\n      /* Clear FIFO1 Overrun Flag */\r\n      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV1);\r\n    }\r\n  }\r\n\r\n  /* Receive FIFO 1 full interrupt management ********************************/\r\n  if ((interrupts & CAN_IT_RX_FIFO1_FULL) != 0U)\r\n  {\r\n    if ((rf1rflags & CAN_RF1R_FULL1) != 0U)\r\n    {\r\n      /* Clear FIFO 1 full Flag */\r\n      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF1);\r\n\r\n      /* Receive FIFO 1 full Callback */\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n      /* Call registered callback*/\r\n      hcan->RxFifo1FullCallback(hcan);\r\n#else\r\n      /* Call weak (surcharged) callback */\r\n      HAL_CAN_RxFifo1FullCallback(hcan);\r\n#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n\r\n  /* Receive FIFO 1 message pending interrupt management *********************/\r\n  if ((interrupts & CAN_IT_RX_FIFO1_MSG_PENDING) != 0U)\r\n  {\r\n    /* Check if message is still pending */\r\n    if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) != 0U)\r\n    {\r\n      /* Receive FIFO 1 message pending Callback */\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n      /* Call registered callback*/\r\n      hcan->RxFifo1MsgPendingCallback(hcan);\r\n#else\r\n      /* Call weak (surcharged) callback */\r\n      HAL_CAN_RxFifo1MsgPendingCallback(hcan);\r\n#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n\r\n  /* Sleep interrupt management *********************************************/\r\n  if ((interrupts & CAN_IT_SLEEP_ACK) != 0U)\r\n  {\r\n    if ((msrflags & CAN_MSR_SLAKI) != 0U)\r\n    {\r\n      /* Clear Sleep interrupt Flag */\r\n      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_SLAKI);\r\n\r\n      /* Sleep Callback */\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n      /* Call registered callback*/\r\n      hcan->SleepCallback(hcan);\r\n#else\r\n      /* Call weak (surcharged) callback */\r\n      HAL_CAN_SleepCallback(hcan);\r\n#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n\r\n  /* WakeUp interrupt management *********************************************/\r\n  if ((interrupts & CAN_IT_WAKEUP) != 0U)\r\n  {\r\n    if ((msrflags & CAN_MSR_WKUI) != 0U)\r\n    {\r\n      /* Clear WakeUp Flag */\r\n      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_WKU);\r\n\r\n      /* WakeUp Callback */\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n      /* Call registered callback*/\r\n      hcan->WakeUpFromRxMsgCallback(hcan);\r\n#else\r\n      /* Call weak (surcharged) callback */\r\n      HAL_CAN_WakeUpFromRxMsgCallback(hcan);\r\n#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n\r\n  /* Error interrupts management *********************************************/\r\n  if ((interrupts & CAN_IT_ERROR) != 0U)\r\n  {\r\n    if ((msrflags & CAN_MSR_ERRI) != 0U)\r\n    {\r\n      /* Check Error Warning Flag */\r\n      if (((interrupts & CAN_IT_ERROR_WARNING) != 0U) &&\r\n          ((esrflags & CAN_ESR_EWGF) != 0U))\r\n      {\r\n        /* Set CAN error code to Error Warning */\r\n        errorcode |= HAL_CAN_ERROR_EWG;\r\n\r\n        /* No need for clear of Error Warning Flag as read-only */\r\n      }\r\n\r\n      /* Check Error Passive Flag */\r\n      if (((interrupts & CAN_IT_ERROR_PASSIVE) != 0U) &&\r\n          ((esrflags & CAN_ESR_EPVF) != 0U))\r\n      {\r\n        /* Set CAN error code to Error Passive */\r\n        errorcode |= HAL_CAN_ERROR_EPV;\r\n\r\n        /* No need for clear of Error Passive Flag as read-only */\r\n      }\r\n\r\n      /* Check Bus-off Flag */\r\n      if (((interrupts & CAN_IT_BUSOFF) != 0U) &&\r\n          ((esrflags & CAN_ESR_BOFF) != 0U))\r\n      {\r\n        /* Set CAN error code to Bus-Off */\r\n        errorcode |= HAL_CAN_ERROR_BOF;\r\n\r\n        /* No need for clear of Error Bus-Off as read-only */\r\n      }\r\n\r\n      /* Check Last Error Code Flag */\r\n      if (((interrupts & CAN_IT_LAST_ERROR_CODE) != 0U) &&\r\n          ((esrflags & CAN_ESR_LEC) != 0U))\r\n      {\r\n        switch (esrflags & CAN_ESR_LEC)\r\n        {\r\n          case (CAN_ESR_LEC_0):\r\n            /* Set CAN error code to Stuff error */\r\n            errorcode |= HAL_CAN_ERROR_STF;\r\n            break;\r\n          case (CAN_ESR_LEC_1):\r\n            /* Set CAN error code to Form error */\r\n            errorcode |= HAL_CAN_ERROR_FOR;\r\n            break;\r\n          case (CAN_ESR_LEC_1 | CAN_ESR_LEC_0):\r\n            /* Set CAN error code to Acknowledgement error */\r\n            errorcode |= HAL_CAN_ERROR_ACK;\r\n            break;\r\n          case (CAN_ESR_LEC_2):\r\n            /* Set CAN error code to Bit recessive error */\r\n            errorcode |= HAL_CAN_ERROR_BR;\r\n            break;\r\n          case (CAN_ESR_LEC_2 | CAN_ESR_LEC_0):\r\n            /* Set CAN error code to Bit Dominant error */\r\n            errorcode |= HAL_CAN_ERROR_BD;\r\n            break;\r\n          case (CAN_ESR_LEC_2 | CAN_ESR_LEC_1):\r\n            /* Set CAN error code to CRC error */\r\n            errorcode |= HAL_CAN_ERROR_CRC;\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n\r\n        /* Clear Last error code Flag */\r\n        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);\r\n      }\r\n    }\r\n\r\n    /* Clear ERRI Flag */\r\n    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);\r\n  }\r\n\r\n  /* Call the Error call Back in case of Errors */\r\n  if (errorcode != HAL_CAN_ERROR_NONE)\r\n  {\r\n    /* Update error code in handle */\r\n    hcan->ErrorCode |= errorcode;\r\n\r\n    /* Call Error callback function */\r\n#if USE_HAL_CAN_REGISTER_CALLBACKS == 1\r\n    /* Call registered callback*/\r\n    hcan->ErrorCallback(hcan);\r\n#else\r\n    /* Call weak (surcharged) callback */\r\n    HAL_CAN_ErrorCallback(hcan);\r\n#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup CAN_Exported_Functions_Group5 Callback functions\r\n *  @brief   CAN Callback functions\r\n *\r\n@verbatim\r\n  ==============================================================================\r\n                          ##### Callback functions #####\r\n  ==============================================================================\r\n    [..]\r\n    This subsection provides the following callback functions:\r\n      (+) HAL_CAN_TxMailbox0CompleteCallback\r\n      (+) HAL_CAN_TxMailbox1CompleteCallback\r\n      (+) HAL_CAN_TxMailbox2CompleteCallback\r\n      (+) HAL_CAN_TxMailbox0AbortCallback\r\n      (+) HAL_CAN_TxMailbox1AbortCallback\r\n      (+) HAL_CAN_TxMailbox2AbortCallback\r\n      (+) HAL_CAN_RxFifo0MsgPendingCallback\r\n      (+) HAL_CAN_RxFifo0FullCallback\r\n      (+) HAL_CAN_RxFifo1MsgPendingCallback\r\n      (+) HAL_CAN_RxFifo1FullCallback\r\n      (+) HAL_CAN_SleepCallback\r\n      (+) HAL_CAN_WakeUpFromRxMsgCallback\r\n      (+) HAL_CAN_ErrorCallback\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Transmission Mailbox 0 complete callback.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_TxMailbox0CompleteCallback could be implemented in the\r\n            user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Transmission Mailbox 1 complete callback.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_TxMailbox1CompleteCallback could be implemented in the\r\n            user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Transmission Mailbox 2 complete callback.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_TxMailbox2CompleteCallback could be implemented in the\r\n            user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Transmission Mailbox 0 Cancellation callback.\r\n  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_TxMailbox0AbortCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_TxMailbox0AbortCallback could be implemented in the\r\n            user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Transmission Mailbox 1 Cancellation callback.\r\n  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_TxMailbox1AbortCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_TxMailbox1AbortCallback could be implemented in the\r\n            user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Transmission Mailbox 2 Cancellation callback.\r\n  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_TxMailbox2AbortCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_TxMailbox2AbortCallback could be implemented in the\r\n            user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Rx FIFO 0 message pending callback.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_RxFifo0MsgPendingCallback could be implemented in the\r\n            user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Rx FIFO 0 full callback.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_RxFifo0FullCallback could be implemented in the user\r\n            file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Rx FIFO 1 message pending callback.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_RxFifo1MsgPendingCallback could be implemented in the\r\n            user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Rx FIFO 1 full callback.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_RxFifo1FullCallback could be implemented in the user\r\n            file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Sleep callback.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_SleepCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_SleepCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  WakeUp from Rx message callback.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_WakeUpFromRxMsgCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_WakeUpFromRxMsgCallback could be implemented in the\r\n            user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Error CAN callback.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval None\r\n  */\r\n__weak void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hcan);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_CAN_ErrorCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup CAN_Exported_Functions_Group6 Peripheral State and Error functions\r\n *  @brief   CAN Peripheral State functions\r\n *\r\n@verbatim\r\n  ==============================================================================\r\n            ##### Peripheral State and Error functions #####\r\n  ==============================================================================\r\n    [..]\r\n    This subsection provides functions allowing to :\r\n      (+) HAL_CAN_GetState()  : Return the CAN state.\r\n      (+) HAL_CAN_GetError()  : Return the CAN error codes if any.\r\n      (+) HAL_CAN_ResetError(): Reset the CAN error codes if any.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return the CAN state.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval HAL state\r\n  */\r\nHAL_CAN_StateTypeDef HAL_CAN_GetState(CAN_HandleTypeDef *hcan)\r\n{\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    /* Check sleep mode acknowledge flag */\r\n    if ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)\r\n    {\r\n      /* Sleep mode is active */\r\n      state = HAL_CAN_STATE_SLEEP_ACTIVE;\r\n    }\r\n    /* Check sleep mode request flag */\r\n    else if ((hcan->Instance->MCR & CAN_MCR_SLEEP) != 0U)\r\n    {\r\n      /* Sleep mode request is pending */\r\n      state = HAL_CAN_STATE_SLEEP_PENDING;\r\n    }\r\n    else\r\n    {\r\n      /* Neither sleep mode request nor sleep mode acknowledge */\r\n    }\r\n  }\r\n\r\n  /* Return CAN state */\r\n  return state;\r\n}\r\n\r\n/**\r\n  * @brief  Return the CAN error code.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval CAN Error Code\r\n  */\r\nuint32_t HAL_CAN_GetError(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Return CAN error code */\r\n  return hcan->ErrorCode;\r\n}\r\n\r\n/**\r\n  * @brief  Reset the CAN error code.\r\n  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n  *         the configuration information for the specified CAN.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_CAN_ResetError(CAN_HandleTypeDef *hcan)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  HAL_CAN_StateTypeDef state = hcan->State;\r\n\r\n  if ((state == HAL_CAN_STATE_READY) ||\r\n      (state == HAL_CAN_STATE_LISTENING))\r\n  {\r\n    /* Reset CAN error code */\r\n    hcan->ErrorCode = 0U;\r\n  }\r\n  else\r\n  {\r\n    /* Update error code */\r\n    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;\r\n\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Return the status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_CAN_MODULE_ENABLED */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* CAN1 */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_cortex.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_cortex.c\r\n  * @author  MCD Application Team\r\n  * @brief   CORTEX HAL module driver.\r\n  *          This file provides firmware functions to manage the following \r\n  *          functionalities of the CORTEX:\r\n  *           + Initialization and de-initialization functions\r\n  *           + Peripheral Control functions \r\n  *\r\n  @verbatim  \r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n\r\n    [..]  \r\n    *** How to configure Interrupts using CORTEX HAL driver ***\r\n    ===========================================================\r\n    [..]     \r\n    This section provides functions allowing to configure the NVIC interrupts (IRQ).\r\n    The Cortex-M4 exceptions are managed by CMSIS functions.\r\n   \r\n    (#) Configure the NVIC Priority Grouping using HAL_NVIC_SetPriorityGrouping()\r\n        function according to the following table.\r\n    (#) Configure the priority of the selected IRQ Channels using HAL_NVIC_SetPriority(). \r\n    (#) Enable the selected IRQ Channels using HAL_NVIC_EnableIRQ().\r\n    (#) please refer to programming manual for details in how to configure priority. \r\n      \r\n     -@- When the NVIC_PRIORITYGROUP_0 is selected, IRQ preemption is no more possible. \r\n         The pending IRQ priority will be managed only by the sub priority.\r\n   \r\n     -@- IRQ priority order (sorted by highest to lowest priority):\r\n        (+@) Lowest preemption priority\r\n        (+@) Lowest sub priority\r\n        (+@) Lowest hardware priority (IRQ number)\r\n \r\n    [..]  \r\n    *** How to configure Systick using CORTEX HAL driver ***\r\n    ========================================================\r\n    [..]\r\n    Setup SysTick Timer for time base.\r\n           \r\n   (+) The HAL_SYSTICK_Config() function calls the SysTick_Config() function which\r\n       is a CMSIS function that:\r\n        (++) Configures the SysTick Reload register with value passed as function parameter.\r\n        (++) Configures the SysTick IRQ priority to the lowest value 0x0F.\r\n        (++) Resets the SysTick Counter register.\r\n        (++) Configures the SysTick Counter clock source to be Core Clock Source (HCLK).\r\n        (++) Enables the SysTick Interrupt.\r\n        (++) Starts the SysTick Counter.\r\n    \r\n   (+) You can change the SysTick Clock source to be HCLK_Div8 by calling the macro\r\n       __HAL_CORTEX_SYSTICKCLK_CONFIG(SYSTICK_CLKSOURCE_HCLK_DIV8) just after the\r\n       HAL_SYSTICK_Config() function call. The __HAL_CORTEX_SYSTICKCLK_CONFIG() macro is defined\r\n       inside the stm32f4xx_hal_cortex.h file.\r\n\r\n   (+) You can change the SysTick IRQ priority by calling the\r\n       HAL_NVIC_SetPriority(SysTick_IRQn,...) function just after the HAL_SYSTICK_Config() function \r\n       call. The HAL_NVIC_SetPriority() call the NVIC_SetPriority() function which is a CMSIS function.\r\n\r\n   (+) To adjust the SysTick time base, use the following formula:\r\n                            \r\n       Reload Value = SysTick Counter Clock (Hz) x  Desired Time base (s)\r\n       (++) Reload Value is the parameter to be passed for HAL_SYSTICK_Config() function\r\n       (++) Reload Value should not exceed 0xFFFFFF\r\n   \r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup CORTEX CORTEX\r\n  * @brief CORTEX HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_CORTEX_MODULE_ENABLED\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup CORTEX_Exported_Functions CORTEX Exported Functions\r\n  * @{\r\n  */\r\n\r\n\r\n/** @defgroup CORTEX_Exported_Functions_Group1 Initialization and de-initialization functions\r\n *  @brief    Initialization and Configuration functions \r\n *\r\n@verbatim    \r\n  ==============================================================================\r\n              ##### Initialization and de-initialization functions #####\r\n  ==============================================================================\r\n    [..]\r\n      This section provides the CORTEX HAL driver functions allowing to configure Interrupts\r\n      Systick functionalities \r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n\r\n/**\r\n  * @brief  Sets the priority grouping field (preemption priority and subpriority)\r\n  *         using the required unlock sequence.\r\n  * @param  PriorityGroup The priority grouping bits length. \r\n  *         This parameter can be one of the following values:\r\n  *         @arg NVIC_PRIORITYGROUP_0: 0 bits for preemption priority\r\n  *                                    4 bits for subpriority\r\n  *         @arg NVIC_PRIORITYGROUP_1: 1 bits for preemption priority\r\n  *                                    3 bits for subpriority\r\n  *         @arg NVIC_PRIORITYGROUP_2: 2 bits for preemption priority\r\n  *                                    2 bits for subpriority\r\n  *         @arg NVIC_PRIORITYGROUP_3: 3 bits for preemption priority\r\n  *                                    1 bits for subpriority\r\n  *         @arg NVIC_PRIORITYGROUP_4: 4 bits for preemption priority\r\n  *                                    0 bits for subpriority\r\n  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. \r\n  *         The pending IRQ priority will be managed only by the subpriority. \r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));\r\n  \r\n  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */\r\n  NVIC_SetPriorityGrouping(PriorityGroup);\r\n}\r\n\r\n/**\r\n  * @brief  Sets the priority of an interrupt.\r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))\r\n  * @param  PreemptPriority The preemption priority for the IRQn channel.\r\n  *         This parameter can be a value between 0 and 15\r\n  *         A lower priority value indicates a higher priority \r\n  * @param  SubPriority the subpriority level for the IRQ channel.\r\n  *         This parameter can be a value between 0 and 15\r\n  *         A lower priority value indicates a higher priority.          \r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)\r\n{ \r\n  uint32_t prioritygroup = 0x00U;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));\r\n  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));\r\n  \r\n  prioritygroup = NVIC_GetPriorityGrouping();\r\n  \r\n  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));\r\n}\r\n\r\n/**\r\n  * @brief  Enables a device specific interrupt in the NVIC interrupt controller.\r\n  * @note   To configure interrupts priority correctly, the NVIC_PriorityGroupConfig()\r\n  *         function should be called before. \r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_EnableIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n  \r\n  /* Enable interrupt */\r\n  NVIC_EnableIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Disables a device specific interrupt in the NVIC interrupt controller.\r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_DisableIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n  \r\n  /* Disable interrupt */\r\n  NVIC_DisableIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Initiates a system reset request to reset the MCU.\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_SystemReset(void)\r\n{\r\n  /* System Reset */\r\n  NVIC_SystemReset();\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the System Timer and its interrupt, and starts the System Tick Timer.\r\n  *         Counter is in free running mode to generate periodic interrupts.\r\n  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.\r\n  * @retval status:  - 0  Function succeeded.\r\n  *                  - 1  Function failed.\r\n  */\r\nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)\r\n{\r\n   return SysTick_Config(TicksNumb);\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup CORTEX_Exported_Functions_Group2 Peripheral Control functions\r\n *  @brief   Cortex control functions \r\n *\r\n@verbatim   \r\n  ==============================================================================\r\n                      ##### Peripheral Control functions #####\r\n  ==============================================================================  \r\n    [..]\r\n      This subsection provides a set of functions allowing to control the CORTEX\r\n      (NVIC, SYSTICK, MPU) functionalities. \r\n \r\n      \r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n#if (__MPU_PRESENT == 1U)\r\n/**\r\n  * @brief  Disables the MPU\r\n  * @retval None\r\n  */\r\nvoid HAL_MPU_Disable(void)\r\n{\r\n  /* Make sure outstanding transfers are done */\r\n  __DMB();\r\n\r\n  /* Disable fault exceptions */\r\n  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;\r\n  \r\n  /* Disable the MPU and clear the control register*/\r\n  MPU->CTRL = 0U;\r\n}\r\n\r\n/**\r\n  * @brief  Enable the MPU.\r\n  * @param  MPU_Control Specifies the control mode of the MPU during hard fault, \r\n  *          NMI, FAULTMASK and privileged access to the default memory \r\n  *          This parameter can be one of the following values:\r\n  *            @arg MPU_HFNMI_PRIVDEF_NONE\r\n  *            @arg MPU_HARDFAULT_NMI\r\n  *            @arg MPU_PRIVILEGED_DEFAULT\r\n  *            @arg MPU_HFNMI_PRIVDEF\r\n  * @retval None\r\n  */\r\nvoid HAL_MPU_Enable(uint32_t MPU_Control)\r\n{\r\n  /* Enable the MPU */\r\n  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;\r\n  \r\n  /* Enable fault exceptions */\r\n  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;\r\n  \r\n  /* Ensure MPU setting take effects */\r\n  __DSB();\r\n  __ISB();\r\n}\r\n\r\n/**\r\n  * @brief  Initializes and configures the Region and the memory to be protected.\r\n  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains\r\n  *                the initialization and configuration information.\r\n  * @retval None\r\n  */\r\nvoid HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));\r\n  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));\r\n\r\n  /* Set the Region number */\r\n  MPU->RNR = MPU_Init->Number;\r\n\r\n  if ((MPU_Init->Enable) != RESET)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));\r\n    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));\r\n    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));\r\n    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));\r\n    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));\r\n    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));\r\n    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));\r\n    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));\r\n    \r\n    MPU->RBAR = MPU_Init->BaseAddress;\r\n    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |\r\n                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |\r\n                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |\r\n                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |\r\n                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |\r\n                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |\r\n                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |\r\n                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |\r\n                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);\r\n  }\r\n  else\r\n  {\r\n    MPU->RBAR = 0x00U;\r\n    MPU->RASR = 0x00U;\r\n  }\r\n}\r\n#endif /* __MPU_PRESENT */\r\n\r\n/**\r\n  * @brief  Gets the priority grouping field from the NVIC Interrupt Controller.\r\n  * @retval Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field)\r\n  */\r\nuint32_t HAL_NVIC_GetPriorityGrouping(void)\r\n{\r\n  /* Get the PRIGROUP[10:8] field value */\r\n  return NVIC_GetPriorityGrouping();\r\n}\r\n\r\n/**\r\n  * @brief  Gets the priority of an interrupt.\r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))\r\n  * @param   PriorityGroup the priority grouping bits length.\r\n  *         This parameter can be one of the following values:\r\n  *           @arg NVIC_PRIORITYGROUP_0: 0 bits for preemption priority\r\n  *                                      4 bits for subpriority\r\n  *           @arg NVIC_PRIORITYGROUP_1: 1 bits for preemption priority\r\n  *                                      3 bits for subpriority\r\n  *           @arg NVIC_PRIORITYGROUP_2: 2 bits for preemption priority\r\n  *                                      2 bits for subpriority\r\n  *           @arg NVIC_PRIORITYGROUP_3: 3 bits for preemption priority\r\n  *                                      1 bits for subpriority\r\n  *           @arg NVIC_PRIORITYGROUP_4: 4 bits for preemption priority\r\n  *                                      0 bits for subpriority\r\n  * @param  pPreemptPriority Pointer on the Preemptive priority value (starting from 0).\r\n  * @param  pSubPriority Pointer on the Subpriority value (starting from 0).\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));\r\n /* Get priority for Cortex-M system or device specific interrupts */\r\n  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);\r\n}\r\n\r\n/**\r\n  * @brief  Sets Pending bit of an external interrupt.\r\n  * @param  IRQn External interrupt number\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n  \r\n  /* Set interrupt pending */\r\n  NVIC_SetPendingIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Gets Pending Interrupt (reads the pending register in the NVIC \r\n  *         and returns the pending bit for the specified interrupt).\r\n  * @param  IRQn External interrupt number.\r\n  *          This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))\r\n  * @retval status: - 0  Interrupt status is not pending.\r\n  *                 - 1  Interrupt status is pending.\r\n  */\r\nuint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n  \r\n  /* Return 1 if pending else 0 */\r\n  return NVIC_GetPendingIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Clears the pending bit of an external interrupt.\r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n  \r\n  /* Clear pending interrupt */\r\n  NVIC_ClearPendingIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief Gets active interrupt ( reads the active register in NVIC and returns the active bit).\r\n  * @param IRQn External interrupt number\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))\r\n  * @retval status: - 0  Interrupt status is not pending.\r\n  *                 - 1  Interrupt status is pending.\r\n  */\r\nuint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n  \r\n  /* Return 1 if active else 0 */\r\n  return NVIC_GetActive(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Configures the SysTick clock source.\r\n  * @param  CLKSource specifies the SysTick clock source.\r\n  *          This parameter can be one of the following values:\r\n  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.\r\n  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));\r\n  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)\r\n  {\r\n    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;\r\n  }\r\n  else\r\n  {\r\n    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  This function handles SYSTICK interrupt request.\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSTICK_IRQHandler(void)\r\n{\r\n  HAL_SYSTICK_Callback();\r\n}\r\n\r\n/**\r\n  * @brief  SYSTICK callback.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SYSTICK_Callback(void)\r\n{\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_SYSTICK_Callback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_CORTEX_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_dma.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_dma.c\r\n  * @author  MCD Application Team\r\n  * @brief   DMA HAL module driver.\r\n  *    \r\n  *          This file provides firmware functions to manage the following \r\n  *          functionalities of the Direct Memory Access (DMA) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + IO operation functions\r\n  *           + Peripheral State and errors functions\r\n  @verbatim     \r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..]\r\n   (#) Enable and configure the peripheral to be connected to the DMA Stream\r\n       (except for internal SRAM/FLASH memories: no initialization is \r\n       necessary) please refer to Reference manual for connection between peripherals\r\n       and DMA requests.\r\n\r\n   (#) For a given Stream, program the required configuration through the following parameters:\r\n       Transfer Direction, Source and Destination data formats, \r\n       Circular, Normal or peripheral flow control mode, Stream Priority level, \r\n       Source and Destination Increment mode, FIFO mode and its Threshold (if needed), \r\n       Burst mode for Source and/or Destination (if needed) using HAL_DMA_Init() function.\r\n\r\n   -@-   Prior to HAL_DMA_Init() the clock must be enabled for DMA through the following macros:\r\n         __HAL_RCC_DMA1_CLK_ENABLE() or __HAL_RCC_DMA2_CLK_ENABLE().\r\n\r\n     *** Polling mode IO operation ***\r\n     =================================\r\n    [..]\r\n          (+) Use HAL_DMA_Start() to start DMA transfer after the configuration of Source \r\n              address and destination address and the Length of data to be transferred.\r\n          (+) Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this  \r\n              case a fixed Timeout can be configured by User depending from his application.\r\n          (+) Use HAL_DMA_Abort() function to abort the current transfer.\r\n\r\n     *** Interrupt mode IO operation ***\r\n     ===================================\r\n    [..]\r\n          (+) Configure the DMA interrupt priority using HAL_NVIC_SetPriority()\r\n          (+) Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ() \r\n          (+) Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of  \r\n              Source address and destination address and the Length of data to be transferred. In this \r\n              case the DMA interrupt is configured \r\n          (+) Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine\r\n          (+) At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can \r\n              add his own function by customization of function pointer XferCpltCallback and \r\n              XferErrorCallback (i.e a member of DMA handle structure).\r\n    [..]\r\n     (#) Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error \r\n         detection.\r\n\r\n     (#) Use HAL_DMA_Abort_IT() function to abort the current transfer\r\n\r\n     -@-   In Memory-to-Memory transfer mode, Circular mode is not allowed.\r\n\r\n     -@-   The FIFO is used mainly to reduce bus usage and to allow data packing/unpacking: it is\r\n           possible to set different Data Sizes for the Peripheral and the Memory (ie. you can set\r\n           Half-Word data size for the peripheral to access its data register and set Word data size\r\n           for the Memory to gain in access time. Each two half words will be packed and written in\r\n           a single access to a Word in the Memory).\r\n\r\n     -@-   When FIFO is disabled, it is not allowed to configure different Data Sizes for Source\r\n           and Destination. In this case the Peripheral Data Size will be applied to both Source\r\n           and Destination.\r\n\r\n     *** DMA HAL driver macros list ***\r\n     =============================================\r\n     [..]\r\n       Below the list of most used macros in DMA HAL driver.\r\n       \r\n      (+) __HAL_DMA_ENABLE: Enable the specified DMA Stream.\r\n      (+) __HAL_DMA_DISABLE: Disable the specified DMA Stream.\r\n      (+) __HAL_DMA_GET_IT_SOURCE: Check whether the specified DMA Stream interrupt has occurred or not. \r\n\r\n     [..]\r\n      (@) You can refer to the DMA HAL driver header file for more useful macros\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */ \r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup DMA DMA\r\n  * @brief DMA HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_DMA_MODULE_ENABLED\r\n\r\n/* Private types -------------------------------------------------------------*/\r\ntypedef struct\r\n{\r\n  __IO uint32_t ISR;   /*!< DMA interrupt status register */\r\n  __IO uint32_t Reserved0;\r\n  __IO uint32_t IFCR;  /*!< DMA interrupt flag clear register */\r\n} DMA_Base_Registers;\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/** @addtogroup DMA_Private_Constants\r\n * @{\r\n */\r\n #define HAL_TIMEOUT_DMA_ABORT    5U  /* 5 ms */\r\n/**\r\n  * @}\r\n  */\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/** @addtogroup DMA_Private_Functions\r\n  * @{\r\n  */\r\nstatic void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);\r\nstatic uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma);\r\nstatic HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma);\r\n\r\n/**\r\n  * @}\r\n  */  \r\n\r\n/* Exported functions ---------------------------------------------------------*/\r\n/** @addtogroup DMA_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup DMA_Exported_Functions_Group1\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n             ##### Initialization and de-initialization functions  #####\r\n ===============================================================================\r\n    [..]\r\n    This section provides functions allowing to initialize the DMA Stream source\r\n    and destination addresses, incrementation and data sizes, transfer direction, \r\n    circular/normal mode selection, memory-to-memory mode selection and Stream priority value.\r\n    [..]\r\n    The HAL_DMA_Init() function follows the DMA configuration procedures as described in\r\n    reference manual.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n  \r\n/**\r\n  * @brief  Initialize the DMA according to the specified\r\n  *         parameters in the DMA_InitTypeDef and create the associated handle.\r\n  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA Stream.  \r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)\r\n{\r\n  uint32_t tmp = 0U;\r\n  uint32_t tickstart = HAL_GetTick();\r\n  DMA_Base_Registers *regs;\r\n\r\n  /* Check the DMA peripheral state */\r\n  if(hdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));\r\n  assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));\r\n  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));\r\n  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));\r\n  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));\r\n  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));\r\n  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));\r\n  assert_param(IS_DMA_MODE(hdma->Init.Mode));\r\n  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));\r\n  assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));\r\n  /* Check the memory burst, peripheral burst and FIFO threshold parameters only\r\n     when FIFO mode is enabled */\r\n  if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)\r\n  {\r\n    assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));\r\n    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));\r\n    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));\r\n  }\r\n\r\n  /* Change DMA peripheral state */\r\n  hdma->State = HAL_DMA_STATE_BUSY;\r\n\r\n  /* Allocate lock resource */\r\n  __HAL_UNLOCK(hdma);\r\n  \r\n  /* Disable the peripheral */\r\n  __HAL_DMA_DISABLE(hdma);\r\n  \r\n  /* Check if the DMA Stream is effectively disabled */\r\n  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)\r\n  {\r\n    /* Check for the Timeout */\r\n    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)\r\n    {\r\n      /* Update error code */\r\n      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;\r\n      \r\n      /* Change the DMA state */\r\n      hdma->State = HAL_DMA_STATE_TIMEOUT;\r\n      \r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n  \r\n  /* Get the CR register value */\r\n  tmp = hdma->Instance->CR;\r\n\r\n  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */\r\n  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \\\r\n                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \\\r\n                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \\\r\n                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));\r\n\r\n  /* Prepare the DMA Stream configuration */\r\n  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |\r\n          hdma->Init.PeriphInc           | hdma->Init.MemInc           |\r\n          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |\r\n          hdma->Init.Mode                | hdma->Init.Priority;\r\n\r\n  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */\r\n  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)\r\n  {\r\n    /* Get memory burst and peripheral burst */\r\n    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;\r\n  }\r\n  \r\n  /* Write to DMA Stream CR register */\r\n  hdma->Instance->CR = tmp;  \r\n\r\n  /* Get the FCR register value */\r\n  tmp = hdma->Instance->FCR;\r\n\r\n  /* Clear Direct mode and FIFO threshold bits */\r\n  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);\r\n\r\n  /* Prepare the DMA Stream FIFO configuration */\r\n  tmp |= hdma->Init.FIFOMode;\r\n\r\n  /* The FIFO threshold is not used when the FIFO mode is disabled */\r\n  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)\r\n  {\r\n    /* Get the FIFO threshold */\r\n    tmp |= hdma->Init.FIFOThreshold;\r\n    \r\n    /* Check compatibility between FIFO threshold level and size of the memory burst */\r\n    /* for INCR4, INCR8, INCR16 bursts */\r\n    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)\r\n    {\r\n      if (DMA_CheckFifoParam(hdma) != HAL_OK)\r\n      {\r\n        /* Update error code */\r\n        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;\r\n        \r\n        /* Change the DMA state */\r\n        hdma->State = HAL_DMA_STATE_READY;\r\n        \r\n        return HAL_ERROR; \r\n      }\r\n    }\r\n  }\r\n  \r\n  /* Write to DMA Stream FCR */\r\n  hdma->Instance->FCR = tmp;\r\n\r\n  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate\r\n     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */\r\n  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);\r\n  \r\n  /* Clear all interrupt flags */\r\n  regs->IFCR = 0x3FU << hdma->StreamIndex;\r\n\r\n  /* Initialize the error code */\r\n  hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n                                                                                     \r\n  /* Initialize the DMA state */\r\n  hdma->State = HAL_DMA_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the DMA peripheral \r\n  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA Stream.  \r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)\r\n{\r\n  DMA_Base_Registers *regs;\r\n\r\n  /* Check the DMA peripheral state */\r\n  if(hdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  \r\n  /* Check the DMA peripheral state */\r\n  if(hdma->State == HAL_DMA_STATE_BUSY)\r\n  {\r\n    /* Return error status */\r\n    return HAL_BUSY;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));\r\n\r\n  /* Disable the selected DMA Streamx */\r\n  __HAL_DMA_DISABLE(hdma);\r\n\r\n  /* Reset DMA Streamx control register */\r\n  hdma->Instance->CR   = 0U;\r\n\r\n  /* Reset DMA Streamx number of data to transfer register */\r\n  hdma->Instance->NDTR = 0U;\r\n\r\n  /* Reset DMA Streamx peripheral address register */\r\n  hdma->Instance->PAR  = 0U;\r\n\r\n  /* Reset DMA Streamx memory 0 address register */\r\n  hdma->Instance->M0AR = 0U;\r\n  \r\n  /* Reset DMA Streamx memory 1 address register */\r\n  hdma->Instance->M1AR = 0U;\r\n  \r\n  /* Reset DMA Streamx FIFO control register */\r\n  hdma->Instance->FCR  = 0x00000021U;\r\n  \r\n  /* Get DMA steam Base Address */  \r\n  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);\r\n  \r\n  /* Clean all callbacks */\r\n  hdma->XferCpltCallback = NULL;\r\n  hdma->XferHalfCpltCallback = NULL;\r\n  hdma->XferM1CpltCallback = NULL;\r\n  hdma->XferM1HalfCpltCallback = NULL;\r\n  hdma->XferErrorCallback = NULL;\r\n  hdma->XferAbortCallback = NULL;\r\n\r\n  /* Clear all interrupt flags at correct offset within the register */\r\n  regs->IFCR = 0x3FU << hdma->StreamIndex;\r\n\r\n  /* Reset the error code */\r\n  hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n\r\n  /* Reset the DMA state */\r\n  hdma->State = HAL_DMA_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hdma);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup DMA_Exported_Functions_Group2\r\n  *\r\n@verbatim   \r\n ===============================================================================\r\n                      #####  IO operation functions  #####\r\n ===============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) Configure the source, destination address and data length and Start DMA transfer\r\n      (+) Configure the source, destination address and data length and \r\n          Start DMA transfer with interrupt\r\n      (+) Abort DMA transfer\r\n      (+) Poll for transfer complete\r\n      (+) Handle DMA interrupt request  \r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Starts the DMA Transfer.\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @param  SrcAddress The source memory Buffer address\r\n  * @param  DstAddress The destination memory Buffer address\r\n  * @param  DataLength The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n\r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    /* Change DMA peripheral state */\r\n    hdma->State = HAL_DMA_STATE_BUSY;\r\n    \r\n    /* Initialize the error code */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n    \r\n    /* Configure the source, destination address and the data length */\r\n    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);\r\n\r\n    /* Enable the Peripheral */\r\n    __HAL_DMA_ENABLE(hdma);\r\n  }\r\n  else\r\n  {\r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hdma);\r\n    \r\n    /* Return error status */\r\n    status = HAL_BUSY;\r\n  } \r\n  return status; \r\n}\r\n\r\n/**\r\n  * @brief  Start the DMA Transfer with interrupt enabled.\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.  \r\n  * @param  SrcAddress The source memory Buffer address\r\n  * @param  DstAddress The destination memory Buffer address\r\n  * @param  DataLength The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* calculate DMA base and stream number */\r\n  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\r\n \r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n  \r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    /* Change DMA peripheral state */\r\n    hdma->State = HAL_DMA_STATE_BUSY;\r\n    \r\n    /* Initialize the error code */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n    \r\n    /* Configure the source, destination address and the data length */\r\n    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);\r\n    \r\n    /* Clear all interrupt flags at correct offset within the register */\r\n    regs->IFCR = 0x3FU << hdma->StreamIndex;\r\n    \r\n    /* Enable Common interrupts*/\r\n    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;\r\n    \r\n    if(hdma->XferHalfCpltCallback != NULL)\r\n    {\r\n      hdma->Instance->CR  |= DMA_IT_HT;\r\n    }\r\n    \r\n    /* Enable the Peripheral */\r\n    __HAL_DMA_ENABLE(hdma);\r\n  }\r\n  else\r\n  {\r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hdma);\t  \r\n    \r\n    /* Return error status */\r\n    status = HAL_BUSY;\r\n  }\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Aborts the DMA Transfer.\r\n  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains\r\n  *                 the configuration information for the specified DMA Stream.\r\n  *                   \r\n  * @note  After disabling a DMA Stream, a check for wait until the DMA Stream is \r\n  *        effectively disabled is added. If a Stream is disabled \r\n  *        while a data transfer is ongoing, the current data will be transferred\r\n  *        and the Stream will be effectively disabled only after the transfer of\r\n  *        this single data is finished.  \r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)\r\n{\r\n  /* calculate DMA base and stream number */\r\n  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;\r\n  \r\n  uint32_t tickstart = HAL_GetTick();\r\n  \r\n  if(hdma->State != HAL_DMA_STATE_BUSY)\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\r\n    \r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hdma);\r\n    \r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Disable all the transfer interrupts */\r\n    hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);\r\n    hdma->Instance->FCR &= ~(DMA_IT_FE);\r\n    \r\n    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))\r\n    {\r\n      hdma->Instance->CR  &= ~(DMA_IT_HT);\r\n    }\r\n    \r\n    /* Disable the stream */\r\n    __HAL_DMA_DISABLE(hdma);\r\n    \r\n    /* Check if the DMA Stream is effectively disabled */\r\n    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)\r\n    {\r\n      /* Check for the Timeout */\r\n      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)\r\n      {\r\n        /* Update error code */\r\n        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;\r\n        \r\n        /* Change the DMA state */\r\n        hdma->State = HAL_DMA_STATE_TIMEOUT;\r\n        \r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hdma);\r\n        \r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n    \r\n    /* Clear all interrupt flags at correct offset within the register */\r\n    regs->IFCR = 0x3FU << hdma->StreamIndex;\r\n    \r\n    /* Change the DMA state*/\r\n    hdma->State = HAL_DMA_STATE_READY;\r\n    \r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hdma);\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Aborts the DMA Transfer in Interrupt mode.\r\n  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains\r\n  *                 the configuration information for the specified DMA Stream.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)\r\n{\r\n  if(hdma->State != HAL_DMA_STATE_BUSY)\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Set Abort State  */\r\n    hdma->State = HAL_DMA_STATE_ABORT;\r\n    \r\n    /* Disable the stream */\r\n    __HAL_DMA_DISABLE(hdma);\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Polling for transfer complete.\r\n  * @param  hdma          pointer to a DMA_HandleTypeDef structure that contains\r\n  *                        the configuration information for the specified DMA Stream.\r\n  * @param  CompleteLevel Specifies the DMA level complete.\r\n  * @note   The polling mode is kept in this version for legacy. it is recommanded to use the IT model instead.\r\n  *         This model could be used for debug purpose.\r\n  * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode). \r\n  * @param  Timeout       Timeout duration.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK; \r\n  uint32_t mask_cpltlevel;\r\n  uint32_t tickstart = HAL_GetTick(); \r\n  uint32_t tmpisr;\r\n  \r\n  /* calculate DMA base and stream number */\r\n  DMA_Base_Registers *regs;\r\n\r\n  if(HAL_DMA_STATE_BUSY != hdma->State)\r\n  {\r\n    /* No transfer ongoing */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\r\n    __HAL_UNLOCK(hdma);\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Polling mode not supported in circular mode and double buffering mode */\r\n  if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\r\n    return HAL_ERROR;\r\n  }\r\n  \r\n  /* Get the level transfer complete flag */\r\n  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)\r\n  {\r\n    /* Transfer Complete flag */\r\n    mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;\r\n  }\r\n  else\r\n  {\r\n    /* Half Transfer Complete flag */\r\n    mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;\r\n  }\r\n  \r\n  regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;\r\n  tmpisr = regs->ISR;\r\n  \r\n  while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))\r\n  {\r\n    /* Check for the Timeout (Not applicable in circular mode)*/\r\n    if(Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))\r\n      {\r\n        /* Update error code */\r\n        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;\r\n        \r\n        /* Change the DMA state */\r\n        hdma->State = HAL_DMA_STATE_READY;\r\n        \r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hdma);\r\n        \r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /* Get the ISR register value */\r\n    tmpisr = regs->ISR;\r\n\r\n    if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)\r\n    {\r\n      /* Update error code */\r\n      hdma->ErrorCode |= HAL_DMA_ERROR_TE;\r\n      \r\n      /* Clear the transfer error flag */\r\n      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;\r\n    }\r\n    \r\n    if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)\r\n    {\r\n      /* Update error code */\r\n      hdma->ErrorCode |= HAL_DMA_ERROR_FE;\r\n      \r\n      /* Clear the FIFO error flag */\r\n      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;\r\n    }\r\n    \r\n    if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)\r\n    {\r\n      /* Update error code */\r\n      hdma->ErrorCode |= HAL_DMA_ERROR_DME;\r\n      \r\n      /* Clear the Direct Mode error flag */\r\n      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;\r\n    }\r\n  }\r\n  \r\n  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)\r\n  {\r\n    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)\r\n    {\r\n      HAL_DMA_Abort(hdma);\r\n    \r\n      /* Clear the half transfer and transfer complete flags */\r\n      regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;\r\n    \r\n      /* Change the DMA state */\r\n      hdma->State= HAL_DMA_STATE_READY;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hdma);\r\n\r\n      return HAL_ERROR;\r\n   }\r\n  }\r\n  \r\n  /* Get the level transfer complete flag */\r\n  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)\r\n  {\r\n    /* Clear the half transfer and transfer complete flags */\r\n    regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;\r\n    \r\n    hdma->State = HAL_DMA_STATE_READY;\r\n    \r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hdma);\r\n  }\r\n  else\r\n  {\r\n    /* Clear the half transfer and transfer complete flags */\r\n    regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;\r\n  }\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Handles DMA interrupt request.\r\n  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA Stream.  \r\n  * @retval None\r\n  */\r\nvoid HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)\r\n{\r\n  uint32_t tmpisr;\r\n  __IO uint32_t count = 0U;\r\n  uint32_t timeout = SystemCoreClock / 9600U;\r\n\r\n  /* calculate DMA base and stream number */\r\n  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;\r\n\r\n  tmpisr = regs->ISR;\r\n\r\n  /* Transfer Error Interrupt management ***************************************/\r\n  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)\r\n  {\r\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)\r\n    {\r\n      /* Disable the transfer error interrupt */\r\n      hdma->Instance->CR  &= ~(DMA_IT_TE);\r\n      \r\n      /* Clear the transfer error flag */\r\n      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;\r\n      \r\n      /* Update error code */\r\n      hdma->ErrorCode |= HAL_DMA_ERROR_TE;\r\n    }\r\n  }\r\n  /* FIFO Error Interrupt management ******************************************/\r\n  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)\r\n  {\r\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)\r\n    {\r\n      /* Clear the FIFO error flag */\r\n      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;\r\n\r\n      /* Update error code */\r\n      hdma->ErrorCode |= HAL_DMA_ERROR_FE;\r\n    }\r\n  }\r\n  /* Direct Mode Error Interrupt management ***********************************/\r\n  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)\r\n  {\r\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)\r\n    {\r\n      /* Clear the direct mode error flag */\r\n      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;\r\n\r\n      /* Update error code */\r\n      hdma->ErrorCode |= HAL_DMA_ERROR_DME;\r\n    }\r\n  }\r\n  /* Half Transfer Complete Interrupt management ******************************/\r\n  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)\r\n  {\r\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)\r\n    {\r\n      /* Clear the half transfer complete flag */\r\n      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;\r\n      \r\n      /* Multi_Buffering mode enabled */\r\n      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)\r\n      {\r\n        /* Current memory buffer used is Memory 0 */\r\n        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)\r\n        {\r\n          if(hdma->XferHalfCpltCallback != NULL)\r\n          {\r\n            /* Half transfer callback */\r\n            hdma->XferHalfCpltCallback(hdma);\r\n          }\r\n        }\r\n        /* Current memory buffer used is Memory 1 */\r\n        else\r\n        {\r\n          if(hdma->XferM1HalfCpltCallback != NULL)\r\n          {\r\n            /* Half transfer callback */\r\n            hdma->XferM1HalfCpltCallback(hdma);\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */\r\n        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)\r\n        {\r\n          /* Disable the half transfer interrupt */\r\n          hdma->Instance->CR  &= ~(DMA_IT_HT);\r\n        }\r\n        \r\n        if(hdma->XferHalfCpltCallback != NULL)\r\n        {\r\n          /* Half transfer callback */\r\n          hdma->XferHalfCpltCallback(hdma);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /* Transfer Complete Interrupt management ***********************************/\r\n  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)\r\n  {\r\n    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)\r\n    {\r\n      /* Clear the transfer complete flag */\r\n      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;\r\n      \r\n      if(HAL_DMA_STATE_ABORT == hdma->State)\r\n      {\r\n        /* Disable all the transfer interrupts */\r\n        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);\r\n        hdma->Instance->FCR &= ~(DMA_IT_FE);\r\n        \r\n        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))\r\n        {\r\n          hdma->Instance->CR  &= ~(DMA_IT_HT);\r\n        }\r\n\r\n        /* Clear all interrupt flags at correct offset within the register */\r\n        regs->IFCR = 0x3FU << hdma->StreamIndex;\r\n\r\n        /* Change the DMA state */\r\n        hdma->State = HAL_DMA_STATE_READY;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hdma);\r\n\r\n        if(hdma->XferAbortCallback != NULL)\r\n        {\r\n          hdma->XferAbortCallback(hdma);\r\n        }\r\n        return;\r\n      }\r\n\r\n      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)\r\n      {\r\n        /* Current memory buffer used is Memory 0 */\r\n        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)\r\n        {\r\n          if(hdma->XferM1CpltCallback != NULL)\r\n          {\r\n            /* Transfer complete Callback for memory1 */\r\n            hdma->XferM1CpltCallback(hdma);\r\n          }\r\n        }\r\n        /* Current memory buffer used is Memory 1 */\r\n        else\r\n        {\r\n          if(hdma->XferCpltCallback != NULL)\r\n          {\r\n            /* Transfer complete Callback for memory0 */\r\n            hdma->XferCpltCallback(hdma);\r\n          }\r\n        }\r\n      }\r\n      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */\r\n      else\r\n      {\r\n        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)\r\n        {\r\n          /* Disable the transfer complete interrupt */\r\n          hdma->Instance->CR  &= ~(DMA_IT_TC);\r\n\r\n          /* Change the DMA state */\r\n          hdma->State = HAL_DMA_STATE_READY;\r\n\r\n          /* Process Unlocked */\r\n          __HAL_UNLOCK(hdma);\r\n        }\r\n\r\n        if(hdma->XferCpltCallback != NULL)\r\n        {\r\n          /* Transfer complete callback */\r\n          hdma->XferCpltCallback(hdma);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  /* manage error case */\r\n  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)\r\n  {\r\n    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)\r\n    {\r\n      hdma->State = HAL_DMA_STATE_ABORT;\r\n\r\n      /* Disable the stream */\r\n      __HAL_DMA_DISABLE(hdma);\r\n\r\n      do\r\n      {\r\n        if (++count > timeout)\r\n        {\r\n          break;\r\n        }\r\n      }\r\n      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);\r\n\r\n      /* Change the DMA state */\r\n      hdma->State = HAL_DMA_STATE_READY;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hdma);\r\n    }\r\n\r\n    if(hdma->XferErrorCallback != NULL)\r\n    {\r\n      /* Transfer error callback */\r\n      hdma->XferErrorCallback(hdma);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Register callbacks\r\n  * @param  hdma                 pointer to a DMA_HandleTypeDef structure that contains\r\n  *                               the configuration information for the specified DMA Stream.\r\n  * @param  CallbackID           User Callback identifer\r\n  *                               a DMA_HandleTypeDef structure as parameter.\r\n  * @param  pCallback            pointer to private callbacsk function which has pointer to \r\n  *                               a DMA_HandleTypeDef structure as parameter.\r\n  * @retval HAL status\r\n  */                      \r\nHAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))\r\n{\r\n\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n\r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n    case  HAL_DMA_XFER_CPLT_CB_ID:\r\n      hdma->XferCpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_HALFCPLT_CB_ID:\r\n      hdma->XferHalfCpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_M1CPLT_CB_ID:\r\n      hdma->XferM1CpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:\r\n      hdma->XferM1HalfCpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_ERROR_CB_ID:\r\n      hdma->XferErrorCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_ABORT_CB_ID:\r\n      hdma->XferAbortCallback = pCallback;\r\n      break;\r\n\r\n    default:\r\n      break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hdma);\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  UnRegister callbacks\r\n  * @param  hdma                 pointer to a DMA_HandleTypeDef structure that contains\r\n  *                               the configuration information for the specified DMA Stream.\r\n  * @param  CallbackID           User Callback identifer\r\n  *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.\r\n  * @retval HAL status\r\n  */              \r\nHAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n  \r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n    case  HAL_DMA_XFER_CPLT_CB_ID:\r\n      hdma->XferCpltCallback = NULL;\r\n      break;\r\n      \r\n    case  HAL_DMA_XFER_HALFCPLT_CB_ID:\r\n      hdma->XferHalfCpltCallback = NULL;\r\n      break;\r\n      \r\n    case  HAL_DMA_XFER_M1CPLT_CB_ID:\r\n      hdma->XferM1CpltCallback = NULL;\r\n      break;\r\n      \r\n    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:\r\n      hdma->XferM1HalfCpltCallback = NULL;\r\n      break;\r\n      \r\n    case  HAL_DMA_XFER_ERROR_CB_ID:\r\n      hdma->XferErrorCallback = NULL;\r\n      break;\r\n      \r\n    case  HAL_DMA_XFER_ABORT_CB_ID:\r\n      hdma->XferAbortCallback = NULL;\r\n      break; \r\n      \r\n    case   HAL_DMA_XFER_ALL_CB_ID:\r\n      hdma->XferCpltCallback = NULL;\r\n      hdma->XferHalfCpltCallback = NULL;\r\n      hdma->XferM1CpltCallback = NULL;\r\n      hdma->XferM1HalfCpltCallback = NULL;\r\n      hdma->XferErrorCallback = NULL;\r\n      hdma->XferAbortCallback = NULL;\r\n      break; \r\n      \r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    status = HAL_ERROR;\r\n  }\r\n  \r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hdma);\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup DMA_Exported_Functions_Group3\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                    ##### State and Errors functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides functions allowing to\r\n      (+) Check the DMA state\r\n      (+) Get error code\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Returns the DMA state.\r\n  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA Stream.\r\n  * @retval HAL state\r\n  */\r\nHAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)\r\n{\r\n  return hdma->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the DMA error code\r\n  * @param  hdma  pointer to a DMA_HandleTypeDef structure that contains\r\n  *              the configuration information for the specified DMA Stream.\r\n  * @retval DMA Error Code\r\n  */\r\nuint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)\r\n{\r\n  return hdma->ErrorCode;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup DMA_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Sets the DMA Transfer parameter.\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @param  SrcAddress The source memory Buffer address\r\n  * @param  DstAddress The destination memory Buffer address\r\n  * @param  DataLength The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nstatic void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\r\n{\r\n  /* Clear DBM bit */\r\n  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);\r\n\r\n  /* Configure DMA Stream data length */\r\n  hdma->Instance->NDTR = DataLength;\r\n\r\n  /* Memory to Peripheral */\r\n  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)\r\n  {\r\n    /* Configure DMA Stream destination address */\r\n    hdma->Instance->PAR = DstAddress;\r\n\r\n    /* Configure DMA Stream source address */\r\n    hdma->Instance->M0AR = SrcAddress;\r\n  }\r\n  /* Peripheral to Memory */\r\n  else\r\n  {\r\n    /* Configure DMA Stream source address */\r\n    hdma->Instance->PAR = SrcAddress;\r\n\r\n    /* Configure DMA Stream destination address */\r\n    hdma->Instance->M0AR = DstAddress;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Returns the DMA Stream base address depending on stream number\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream. \r\n  * @retval Stream base address\r\n  */\r\nstatic uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)\r\n{\r\n  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;\r\n  \r\n  /* lookup table for necessary bitshift of flags within status registers */\r\n  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};\r\n  hdma->StreamIndex = flagBitshiftOffset[stream_number];\r\n  \r\n  if (stream_number > 3U)\r\n  {\r\n    /* return pointer to HISR and HIFCR */\r\n    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);\r\n  }\r\n  else\r\n  {\r\n    /* return pointer to LISR and LIFCR */\r\n    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));\r\n  }\r\n  \r\n  return hdma->StreamBaseAddress;\r\n}\r\n\r\n/**\r\n  * @brief  Check compatibility between FIFO threshold level and size of the memory burst\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream. \r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmp = hdma->Init.FIFOThreshold;\r\n  \r\n  /* Memory Data size equal to Byte */\r\n  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)\r\n  {\r\n    switch (tmp)\r\n    {\r\n    case DMA_FIFO_THRESHOLD_1QUARTERFULL:\r\n    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\r\n      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\r\n      {\r\n        status = HAL_ERROR;\r\n      }\r\n      break;\r\n    case DMA_FIFO_THRESHOLD_HALFFULL:\r\n      if (hdma->Init.MemBurst == DMA_MBURST_INC16)\r\n      {\r\n        status = HAL_ERROR;\r\n      }\r\n      break;\r\n    case DMA_FIFO_THRESHOLD_FULL:\r\n      break;\r\n    default:\r\n      break;\r\n    }\r\n  }\r\n  \r\n  /* Memory Data size equal to Half-Word */\r\n  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)\r\n  {\r\n    switch (tmp)\r\n    {\r\n    case DMA_FIFO_THRESHOLD_1QUARTERFULL:\r\n    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\r\n      status = HAL_ERROR;\r\n      break;\r\n    case DMA_FIFO_THRESHOLD_HALFFULL:\r\n      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\r\n      {\r\n        status = HAL_ERROR;\r\n      }\r\n      break;\r\n    case DMA_FIFO_THRESHOLD_FULL:\r\n      if (hdma->Init.MemBurst == DMA_MBURST_INC16)\r\n      {\r\n        status = HAL_ERROR;\r\n      }\r\n      break;   \r\n    default:\r\n      break;\r\n    }\r\n  }\r\n  \r\n  /* Memory Data size equal to Word */\r\n  else\r\n  {\r\n    switch (tmp)\r\n    {\r\n    case DMA_FIFO_THRESHOLD_1QUARTERFULL:\r\n    case DMA_FIFO_THRESHOLD_HALFFULL:\r\n    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\r\n      status = HAL_ERROR;\r\n      break;\r\n    case DMA_FIFO_THRESHOLD_FULL:\r\n      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\r\n      {\r\n        status = HAL_ERROR;\r\n      }\r\n      break;\r\n    default:\r\n      break;\r\n    }\r\n  } \r\n  \r\n  return status; \r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_DMA_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_dma_ex.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_dma_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   DMA Extension HAL module driver\r\n  *         This file provides firmware functions to manage the following \r\n  *         functionalities of the DMA Extension peripheral:\r\n  *           + Extended features functions\r\n  *\r\n  @verbatim\r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..]\r\n  The DMA Extension HAL driver can be used as follows:\r\n   (#) Start a multi buffer transfer using the HAL_DMA_MultiBufferStart() function\r\n       for polling mode or HAL_DMA_MultiBufferStart_IT() for interrupt mode.\r\n                   \r\n     -@-  In Memory-to-Memory transfer mode, Multi (Double) Buffer mode is not allowed.\r\n     -@-  When Multi (Double) Buffer mode is enabled the, transfer is circular by default.\r\n     -@-  In Multi (Double) buffer mode, it is possible to update the base address for \r\n          the AHB memory port on the fly (DMA_SxM0AR or DMA_SxM1AR) when the stream is enabled. \r\n  \r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup DMAEx DMAEx\r\n  * @brief DMA Extended HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_DMA_MODULE_ENABLED\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private Constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/** @addtogroup DMAEx_Private_Functions\r\n  * @{\r\n  */\r\nstatic void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions ---------------------------------------------------------*/\r\n\r\n/** @addtogroup DMAEx_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n\r\n/** @addtogroup DMAEx_Exported_Functions_Group1\r\n  *\r\n@verbatim   \r\n ===============================================================================\r\n                #####  Extended features functions  #####\r\n ===============================================================================  \r\n    [..]  This section provides functions allowing to:\r\n      (+) Configure the source, destination address and data length and \r\n          Start MultiBuffer DMA transfer\r\n      (+) Configure the source, destination address and data length and \r\n          Start MultiBuffer DMA transfer with interrupt\r\n      (+) Change on the fly the memory0 or memory1 address.\r\n      \r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n\r\n/**\r\n  * @brief  Starts the multi_buffer DMA Transfer.\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.  \r\n  * @param  SrcAddress The source memory Buffer address\r\n  * @param  DstAddress The destination memory Buffer address\r\n  * @param  SecondMemAddress The second memory Buffer address in case of multi buffer Transfer  \r\n  * @param  DataLength The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\r\n  \r\n  /* Memory-to-memory transfer not supported in double buffering mode */\r\n  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\r\n    status = HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hdma);\r\n    \r\n    if(HAL_DMA_STATE_READY == hdma->State)\r\n    {\r\n      /* Change DMA peripheral state */\r\n      hdma->State = HAL_DMA_STATE_BUSY; \r\n      \r\n      /* Enable the double buffer mode */\r\n      hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;\r\n      \r\n      /* Configure DMA Stream destination address */\r\n      hdma->Instance->M1AR = SecondMemAddress;\r\n      \r\n      /* Configure the source, destination address and the data length */\r\n      DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);\r\n      \r\n      /* Enable the peripheral */\r\n      __HAL_DMA_ENABLE(hdma);\r\n    }\r\n    else\r\n    {\r\n      /* Return error status */\r\n      status = HAL_BUSY;\r\n    }\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the multi_buffer DMA Transfer with interrupt enabled.\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.  \r\n  * @param  SrcAddress The source memory Buffer address\r\n  * @param  DstAddress The destination memory Buffer address\r\n  * @param  SecondMemAddress The second memory Buffer address in case of multi buffer Transfer  \r\n  * @param  DataLength The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\r\n  \r\n  /* Memory-to-memory transfer not supported in double buffering mode */\r\n  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\r\n    return HAL_ERROR;\r\n  }\r\n  \r\n  /* Check callback functions */\r\n  if ((NULL == hdma->XferCpltCallback) || (NULL == hdma->XferM1CpltCallback) || (NULL == hdma->XferErrorCallback))\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;\r\n    return HAL_ERROR;\r\n  }\r\n  \r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n  \r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    /* Change DMA peripheral state */\r\n    hdma->State = HAL_DMA_STATE_BUSY;\r\n    \r\n    /* Initialize the error code */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n    \r\n    /* Enable the Double buffer mode */\r\n    hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;\r\n    \r\n    /* Configure DMA Stream destination address */\r\n    hdma->Instance->M1AR = SecondMemAddress;\r\n    \r\n    /* Configure the source, destination address and the data length */\r\n    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength); \r\n    \r\n    /* Clear all flags */\r\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));\r\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));\r\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));\r\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));\r\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));\r\n\r\n    /* Enable Common interrupts*/\r\n    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;\r\n    hdma->Instance->FCR |= DMA_IT_FE;\r\n    \r\n    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))\r\n    {\r\n      hdma->Instance->CR  |= DMA_IT_HT;\r\n    }\r\n    \r\n    /* Enable the peripheral */\r\n    __HAL_DMA_ENABLE(hdma); \r\n  }\r\n  else\r\n  {     \r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hdma);\t  \r\n    \r\n    /* Return error status */\r\n    status = HAL_BUSY;\r\n  }  \r\n  return status; \r\n}\r\n\r\n/**\r\n  * @brief  Change the memory0 or memory1 address on the fly.\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.  \r\n  * @param  Address    The new address\r\n  * @param  memory     the memory to be changed, This parameter can be one of \r\n  *                     the following values:\r\n  *                      MEMORY0 /\r\n  *                      MEMORY1\r\n  * @note   The MEMORY0 address can be changed only when the current transfer use\r\n  *         MEMORY1 and the MEMORY1 address can be changed only when the current \r\n  *         transfer use MEMORY0.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)\r\n{\r\n  if(memory == MEMORY0)\r\n  {\r\n    /* change the memory0 address */\r\n    hdma->Instance->M0AR = Address;\r\n  }\r\n  else\r\n  {\r\n    /* change the memory1 address */\r\n    hdma->Instance->M1AR = Address;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup DMAEx_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Set the DMA Transfer parameter.\r\n  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.  \r\n  * @param  SrcAddress The source memory Buffer address\r\n  * @param  DstAddress The destination memory Buffer address\r\n  * @param  DataLength The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nstatic void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\r\n{  \r\n  /* Configure DMA Stream data length */\r\n  hdma->Instance->NDTR = DataLength;\r\n  \r\n  /* Peripheral to Memory */\r\n  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)\r\n  {   \r\n    /* Configure DMA Stream destination address */\r\n    hdma->Instance->PAR = DstAddress;\r\n    \r\n    /* Configure DMA Stream source address */\r\n    hdma->Instance->M0AR = SrcAddress;\r\n  }\r\n  /* Memory to Peripheral */\r\n  else\r\n  {\r\n    /* Configure DMA Stream source address */\r\n    hdma->Instance->PAR = SrcAddress;\r\n    \r\n    /* Configure DMA Stream destination address */\r\n    hdma->Instance->M0AR = DstAddress;\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_DMA_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_exti.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_exti.c\r\n  * @author  MCD Application Team\r\n  * @brief   EXTI HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Extended Interrupts and events controller (EXTI) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + IO operation functions\r\n  *\r\n  @verbatim\r\n  ==============================================================================\r\n                    ##### EXTI Peripheral features #####\r\n  ==============================================================================\r\n  [..]\r\n    (+) Each Exti line can be configured within this driver.\r\n\r\n    (+) Exti line can be configured in 3 different modes\r\n        (++) Interrupt\r\n        (++) Event\r\n        (++) Both of them\r\n\r\n    (+) Configurable Exti lines can be configured with 3 different triggers\r\n        (++) Rising\r\n        (++) Falling\r\n        (++) Both of them\r\n\r\n    (+) When set in interrupt mode, configurable Exti lines have two different\r\n        interrupts pending registers which allow to distinguish which transition\r\n        occurs:\r\n        (++) Rising edge pending interrupt\r\n        (++) Falling\r\n\r\n    (+) Exti lines 0 to 15 are linked to gpio pin number 0 to 15. Gpio port can\r\n        be selected through multiplexer.\r\n\r\n                     ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..]\r\n\r\n    (#) Configure the EXTI line using HAL_EXTI_SetConfigLine().\r\n        (++) Choose the interrupt line number by setting \"Line\" member from\r\n             EXTI_ConfigTypeDef structure.\r\n        (++) Configure the interrupt and/or event mode using \"Mode\" member from\r\n             EXTI_ConfigTypeDef structure.\r\n        (++) For configurable lines, configure rising and/or falling trigger\r\n             \"Trigger\" member from EXTI_ConfigTypeDef structure.\r\n        (++) For Exti lines linked to gpio, choose gpio port using \"GPIOSel\"\r\n             member from GPIO_InitTypeDef structure.\r\n\r\n    (#) Get current Exti configuration of a dedicated line using\r\n        HAL_EXTI_GetConfigLine().\r\n        (++) Provide exiting handle as parameter.\r\n        (++) Provide pointer on EXTI_ConfigTypeDef structure as second parameter.\r\n\r\n    (#) Clear Exti configuration of a dedicated line using HAL_EXTI_GetConfigLine().\r\n        (++) Provide exiting handle as parameter.\r\n\r\n    (#) Register callback to treat Exti interrupts using HAL_EXTI_RegisterCallback().\r\n        (++) Provide exiting handle as first parameter.\r\n        (++) Provide which callback will be registered using one value from\r\n             EXTI_CallbackIDTypeDef.\r\n        (++) Provide callback function pointer.\r\n\r\n    (#) Get interrupt pending bit using HAL_EXTI_GetPending().\r\n\r\n    (#) Clear interrupt pending bit using HAL_EXTI_GetPending().\r\n\r\n    (#) Generate software interrupt using HAL_EXTI_GenerateSWI().\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2018 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup EXTI\r\n  * @{\r\n  */\r\n/** MISRA C:2012 deviation rule has been granted for following rule:\r\n  * Rule-18.1_b - Medium: Array `EXTICR' 1st subscript interval [0,7] may be out\r\n  * of bounds [0,3] in following API :\r\n  * HAL_EXTI_SetConfigLine\r\n  * HAL_EXTI_GetConfigLine\r\n  * HAL_EXTI_ClearConfigLine\r\n  */\r\n\r\n#ifdef HAL_EXTI_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private defines -----------------------------------------------------------*/\r\n/** @defgroup EXTI_Private_Constants EXTI Private Constants\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @addtogroup EXTI_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup EXTI_Exported_Functions_Group1\r\n  *  @brief    Configuration functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n              ##### Configuration functions #####\r\n ===============================================================================\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Set configuration of a dedicated Exti line.\r\n  * @param  hexti Exti handle.\r\n  * @param  pExtiConfig Pointer on EXTI configuration to be set.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)\r\n{\r\n  uint32_t regval;\r\n  uint32_t linepos;\r\n  uint32_t maskline;\r\n\r\n  /* Check null pointer */\r\n  if ((hexti == NULL) || (pExtiConfig == NULL))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_EXTI_LINE(pExtiConfig->Line));\r\n  assert_param(IS_EXTI_MODE(pExtiConfig->Mode));\r\n\r\n  /* Assign line number to handle */\r\n  hexti->Line = pExtiConfig->Line;\r\n\r\n  /* Compute line mask */\r\n  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);\r\n  maskline = (1uL << linepos);\r\n\r\n  /* Configure triggers for configurable lines */\r\n  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00u)\r\n  {\r\n    assert_param(IS_EXTI_TRIGGER(pExtiConfig->Trigger));\r\n\r\n    /* Configure rising trigger */\r\n    /* Mask or set line */\r\n    if ((pExtiConfig->Trigger & EXTI_TRIGGER_RISING) != 0x00u)\r\n    {\r\n      EXTI->RTSR |= maskline;\r\n    }\r\n    else\r\n    {\r\n      EXTI->RTSR &= ~maskline;\r\n    }\r\n\r\n    /* Configure falling trigger */\r\n    /* Mask or set line */\r\n    if ((pExtiConfig->Trigger & EXTI_TRIGGER_FALLING) != 0x00u)\r\n    {\r\n      EXTI->FTSR |= maskline;\r\n    }\r\n    else\r\n    {\r\n      EXTI->FTSR &= ~maskline;\r\n    }\r\n\r\n\r\n    /* Configure gpio port selection in case of gpio exti line */\r\n    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)\r\n    {\r\n      assert_param(IS_EXTI_GPIO_PORT(pExtiConfig->GPIOSel));\r\n      assert_param(IS_EXTI_GPIO_PIN(linepos));\r\n\r\n      regval = SYSCFG->EXTICR[linepos >> 2u];\r\n      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03u)));\r\n      regval |= (pExtiConfig->GPIOSel << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03u)));\r\n      SYSCFG->EXTICR[linepos >> 2u] = regval;\r\n    }\r\n  }\r\n\r\n  /* Configure interrupt mode : read current mode */\r\n  /* Mask or set line */\r\n  if ((pExtiConfig->Mode & EXTI_MODE_INTERRUPT) != 0x00u)\r\n  {\r\n    EXTI->IMR |= maskline;\r\n  }\r\n  else\r\n  {\r\n    EXTI->IMR &= ~maskline;\r\n  }\r\n\r\n  /* Configure event mode : read current mode */\r\n  /* Mask or set line */\r\n  if ((pExtiConfig->Mode & EXTI_MODE_EVENT) != 0x00u)\r\n  {\r\n    EXTI->EMR |= maskline;\r\n  }\r\n  else\r\n  {\r\n    EXTI->EMR &= ~maskline;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Get configuration of a dedicated Exti line.\r\n  * @param  hexti Exti handle.\r\n  * @param  pExtiConfig Pointer on structure to store Exti configuration.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)\r\n{\r\n  uint32_t regval;\r\n  uint32_t linepos;\r\n  uint32_t maskline;\r\n\r\n  /* Check null pointer */\r\n  if ((hexti == NULL) || (pExtiConfig == NULL))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameter */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n\r\n  /* Store handle line number to configuration structure */\r\n  pExtiConfig->Line = hexti->Line;\r\n\r\n  /* Compute line mask */\r\n  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);\r\n  maskline = (1uL << linepos);\r\n\r\n  /* 1] Get core mode : interrupt */\r\n\r\n  /* Check if selected line is enable */\r\n  if ((EXTI->IMR & maskline) != 0x00u)\r\n  {\r\n    pExtiConfig->Mode = EXTI_MODE_INTERRUPT;\r\n  }\r\n  else\r\n  {\r\n    pExtiConfig->Mode = EXTI_MODE_NONE;\r\n  }\r\n\r\n  /* Get event mode */\r\n  /* Check if selected line is enable */\r\n  if ((EXTI->EMR & maskline) != 0x00u)\r\n  {\r\n    pExtiConfig->Mode |= EXTI_MODE_EVENT;\r\n  }\r\n\r\n  /* Get default Trigger and GPIOSel configuration */\r\n  pExtiConfig->Trigger = EXTI_TRIGGER_NONE;\r\n  pExtiConfig->GPIOSel = 0x00u;\r\n\r\n  /* 2] Get trigger for configurable lines : rising */\r\n  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00u)\r\n  {\r\n    /* Check if configuration of selected line is enable */\r\n    if ((EXTI->RTSR & maskline) != 0x00u)\r\n    {\r\n      pExtiConfig->Trigger = EXTI_TRIGGER_RISING;\r\n    }\r\n\r\n    /* Get falling configuration */\r\n    /* Check if configuration of selected line is enable */\r\n    if ((EXTI->FTSR & maskline) != 0x00u)\r\n    {\r\n      pExtiConfig->Trigger |= EXTI_TRIGGER_FALLING;\r\n    }\r\n\r\n    /* Get Gpio port selection for gpio lines */\r\n    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)\r\n    {\r\n      assert_param(IS_EXTI_GPIO_PIN(linepos));\r\n\r\n      regval = SYSCFG->EXTICR[linepos >> 2u];\r\n      pExtiConfig->GPIOSel = ((regval << (SYSCFG_EXTICR1_EXTI1_Pos * (3uL - (linepos & 0x03u)))) >> 24);\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Clear whole configuration of a dedicated Exti line.\r\n  * @param  hexti Exti handle.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti)\r\n{\r\n  uint32_t regval;\r\n  uint32_t linepos;\r\n  uint32_t maskline;\r\n\r\n  /* Check null pointer */\r\n  if (hexti == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameter */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n\r\n  /* compute line mask */\r\n  linepos = (hexti->Line & EXTI_PIN_MASK);\r\n  maskline = (1uL << linepos);\r\n\r\n  /* 1] Clear interrupt mode */\r\n  EXTI->IMR = (EXTI->IMR & ~maskline);\r\n\r\n  /* 2] Clear event mode */\r\n  EXTI->EMR = (EXTI->EMR & ~maskline);\r\n\r\n  /* 3] Clear triggers in case of configurable lines */\r\n  if ((hexti->Line & EXTI_CONFIG) != 0x00u)\r\n  {\r\n    EXTI->RTSR = (EXTI->RTSR & ~maskline);\r\n    EXTI->FTSR = (EXTI->FTSR & ~maskline);\r\n\r\n    /* Get Gpio port selection for gpio lines */\r\n    if ((hexti->Line & EXTI_GPIO) == EXTI_GPIO)\r\n    {\r\n      assert_param(IS_EXTI_GPIO_PIN(linepos));\r\n\r\n      regval = SYSCFG->EXTICR[linepos >> 2u];\r\n      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03u)));\r\n      SYSCFG->EXTICR[linepos >> 2u] = regval;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Register callback for a dedicated Exti line.\r\n  * @param  hexti Exti handle.\r\n  * @param  CallbackID User callback identifier.\r\n  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.\r\n  * @param  pPendingCbfn function pointer to be stored as callback.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  switch (CallbackID)\r\n  {\r\n    case  HAL_EXTI_COMMON_CB_ID:\r\n      hexti->PendingCallback = pPendingCbfn;\r\n      break;\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Store line number as handle private field.\r\n  * @param  hexti Exti handle.\r\n  * @param  ExtiLine Exti line number.\r\n  *         This parameter can be from 0 to @ref EXTI_LINE_NB.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_EXTI_LINE(ExtiLine));\r\n\r\n  /* Check null pointer */\r\n  if (hexti == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Store line number as handle private field */\r\n    hexti->Line = ExtiLine;\r\n\r\n    return HAL_OK;\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup EXTI_Exported_Functions_Group2\r\n  *  @brief EXTI IO functions.\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                       ##### IO operation functions #####\r\n ===============================================================================\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Handle EXTI interrupt request.\r\n  * @param  hexti Exti handle.\r\n  * @retval none.\r\n  */\r\nvoid HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti)\r\n{\r\n  uint32_t regval;\r\n  uint32_t maskline;\r\n\r\n  /* Compute line mask */\r\n  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));\r\n\r\n  /* Get pending bit  */\r\n  regval = (EXTI->PR & maskline);\r\n  if (regval != 0x00u)\r\n  {\r\n    /* Clear pending bit */\r\n    EXTI->PR = maskline;\r\n\r\n    /* Call callback */\r\n    if (hexti->PendingCallback != NULL)\r\n    {\r\n      hexti->PendingCallback();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Get interrupt pending bit of a dedicated line.\r\n  * @param  hexti Exti handle.\r\n  * @param  Edge Specify which pending edge as to be checked.\r\n  *         This parameter can be one of the following values:\r\n  *           @arg @ref EXTI_TRIGGER_RISING_FALLING\r\n  *         This parameter is kept for compatibility with other series.\r\n  * @retval 1 if interrupt is pending else 0.\r\n  */\r\nuint32_t HAL_EXTI_GetPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)\r\n{\r\n  uint32_t regval;\r\n  uint32_t linepos;\r\n  uint32_t maskline;\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_PENDING_EDGE(Edge));\r\n\r\n  /* Compute line mask */\r\n  linepos = (hexti->Line & EXTI_PIN_MASK);\r\n  maskline = (1uL << linepos);\r\n\r\n  /* return 1 if bit is set else 0 */\r\n  regval = ((EXTI->PR & maskline) >> linepos);\r\n  return regval;\r\n}\r\n\r\n/**\r\n  * @brief  Clear interrupt pending bit of a dedicated line.\r\n  * @param  hexti Exti handle.\r\n  * @param  Edge Specify which pending edge as to be clear.\r\n  *         This parameter can be one of the following values:\r\n  *           @arg @ref EXTI_TRIGGER_RISING_FALLING\r\n  *         This parameter is kept for compatibility with other series.\r\n  * @retval None.\r\n  */\r\nvoid HAL_EXTI_ClearPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)\r\n{\r\n  uint32_t maskline;\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_PENDING_EDGE(Edge));\r\n\r\n  /* Compute line mask */\r\n  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));\r\n\r\n  /* Clear Pending bit */\r\n  EXTI->PR =  maskline;\r\n}\r\n\r\n/**\r\n  * @brief  Generate a software interrupt for a dedicated line.\r\n  * @param  hexti Exti handle.\r\n  * @retval None.\r\n  */\r\nvoid HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti)\r\n{\r\n  uint32_t maskline;\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));\r\n\r\n  /* Compute line mask */\r\n  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));\r\n\r\n  /* Generate Software interrupt */\r\n  EXTI->SWIER = maskline;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_EXTI_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_flash.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_flash.c\r\n  * @author  MCD Application Team\r\n  * @brief   FLASH HAL module driver.\r\n  *          This file provides firmware functions to manage the following \r\n  *          functionalities of the internal FLASH memory:\r\n  *           + Program operations functions\r\n  *           + Memory Control functions \r\n  *           + Peripheral Errors functions\r\n  *         \r\n  @verbatim\r\n  ==============================================================================\r\n                        ##### FLASH peripheral features #####\r\n  ==============================================================================\r\n           \r\n  [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses \r\n       to the Flash memory. It implements the erase and program Flash memory operations \r\n       and the read and write protection mechanisms.\r\n      \r\n  [..] The Flash memory interface accelerates code execution with a system of instruction\r\n       prefetch and cache lines. \r\n\r\n  [..] The FLASH main features are:\r\n      (+) Flash memory read operations\r\n      (+) Flash memory program/erase operations\r\n      (+) Read / write protections\r\n      (+) Prefetch on I-Code\r\n      (+) 64 cache lines of 128 bits on I-Code\r\n      (+) 8 cache lines of 128 bits on D-Code\r\n      \r\n      \r\n                     ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]                             \r\n      This driver provides functions and macros to configure and program the FLASH \r\n      memory of all STM32F4xx devices.\r\n    \r\n      (#) FLASH Memory IO Programming functions: \r\n           (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and \r\n                HAL_FLASH_Lock() functions\r\n           (++) Program functions: byte, half word, word and double word\r\n           (++) There Two modes of programming :\r\n            (+++) Polling mode using HAL_FLASH_Program() function\r\n            (+++) Interrupt mode using HAL_FLASH_Program_IT() function\r\n    \r\n      (#) Interrupts and flags management functions : \r\n           (++) Handle FLASH interrupts by calling HAL_FLASH_IRQHandler()\r\n           (++) Wait for last FLASH operation according to its status\r\n           (++) Get error flag status by calling HAL_SetErrorCode()          \r\n\r\n    [..] \r\n      In addition to these functions, this driver includes a set of macros allowing\r\n      to handle the following operations:\r\n       (+) Set the latency\r\n       (+) Enable/Disable the prefetch buffer\r\n       (+) Enable/Disable the Instruction cache and the Data cache\r\n       (+) Reset the Instruction cache and the Data cache\r\n       (+) Enable/Disable the FLASH interrupts\r\n       (+) Monitor the FLASH flags status\r\n          \r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */ \r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup FLASH FLASH\r\n  * @brief FLASH HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_FLASH_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup FLASH_Private_Constants\r\n  * @{\r\n  */\r\n#define FLASH_TIMEOUT_VALUE       50000U /* 50 s */\r\n/**\r\n  * @}\r\n  */         \r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/** @addtogroup FLASH_Private_Variables\r\n  * @{\r\n  */\r\n/* Variable used for Erase sectors under interruption */\r\nFLASH_ProcessTypeDef pFlash;\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @addtogroup FLASH_Private_Functions\r\n  * @{\r\n  */\r\n/* Program operations */\r\nstatic void   FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data);\r\nstatic void   FLASH_Program_Word(uint32_t Address, uint32_t Data);\r\nstatic void   FLASH_Program_HalfWord(uint32_t Address, uint16_t Data);\r\nstatic void   FLASH_Program_Byte(uint32_t Address, uint8_t Data);\r\nstatic void   FLASH_SetErrorCode(void);\r\n\r\nHAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout);\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup FLASH_Exported_Functions FLASH Exported Functions\r\n  * @{\r\n  */\r\n  \r\n/** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions \r\n *  @brief   Programming operation functions \r\n *\r\n@verbatim   \r\n ===============================================================================\r\n                  ##### Programming operation functions #####\r\n ===============================================================================  \r\n    [..]\r\n    This subsection provides a set of functions allowing to manage the FLASH \r\n    program operations.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Program byte, halfword, word or double word at a specified address\r\n  * @param  TypeProgram  Indicate the way to program at a specified address.\r\n  *                           This parameter can be a value of @ref FLASH_Type_Program\r\n  * @param  Address  specifies the address to be programmed.\r\n  * @param  Data specifies the data to be programmed\r\n  * \r\n  * @retval HAL_StatusTypeDef HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)\r\n{\r\n  HAL_StatusTypeDef status = HAL_ERROR;\r\n  \r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));\r\n  \r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n  \r\n  if(status == HAL_OK)\r\n  {\r\n    if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)\r\n    {\r\n      /*Program byte (8-bit) at a specified address.*/\r\n      FLASH_Program_Byte(Address, (uint8_t) Data);\r\n    }\r\n    else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)\r\n    {\r\n      /*Program halfword (16-bit) at a specified address.*/\r\n      FLASH_Program_HalfWord(Address, (uint16_t) Data);\r\n    }\r\n    else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)\r\n    {\r\n      /*Program word (32-bit) at a specified address.*/\r\n      FLASH_Program_Word(Address, (uint32_t) Data);\r\n    }\r\n    else\r\n    {\r\n      /*Program double word (64-bit) at a specified address.*/\r\n      FLASH_Program_DoubleWord(Address, Data);\r\n    }\r\n    \r\n    /* Wait for last operation to be completed */\r\n    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n    \r\n    /* If the program operation is completed, disable the PG Bit */\r\n    FLASH->CR &= (~FLASH_CR_PG);  \r\n  }\r\n  \r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(&pFlash);\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief   Program byte, halfword, word or double word at a specified address  with interrupt enabled.\r\n  * @param  TypeProgram  Indicate the way to program at a specified address.\r\n  *                           This parameter can be a value of @ref FLASH_Type_Program\r\n  * @param  Address  specifies the address to be programmed.\r\n  * @param  Data specifies the data to be programmed\r\n  * \r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  \r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));\r\n\r\n  /* Enable End of FLASH Operation interrupt */\r\n  __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);\r\n  \r\n  /* Enable Error source interrupt */\r\n  __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);\r\n\r\n  pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM;\r\n  pFlash.Address = Address;\r\n\r\n  if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)\r\n  {\r\n    /*Program byte (8-bit) at a specified address.*/\r\n      FLASH_Program_Byte(Address, (uint8_t) Data);\r\n  }\r\n  else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)\r\n  {\r\n    /*Program halfword (16-bit) at a specified address.*/\r\n    FLASH_Program_HalfWord(Address, (uint16_t) Data);\r\n  }\r\n  else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)\r\n  {\r\n    /*Program word (32-bit) at a specified address.*/\r\n    FLASH_Program_Word(Address, (uint32_t) Data);\r\n  }\r\n  else\r\n  {\r\n    /*Program double word (64-bit) at a specified address.*/\r\n    FLASH_Program_DoubleWord(Address, Data);\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief This function handles FLASH interrupt request.\r\n  * @retval None\r\n  */\r\nvoid HAL_FLASH_IRQHandler(void)\r\n{\r\n  uint32_t addresstmp = 0U;\r\n  \r\n  /* Check FLASH operation error flags */\r\n#if defined(FLASH_SR_RDERR) \r\n  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \\\r\n    FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR | FLASH_FLAG_RDERR)) != RESET)\r\n#else\r\n  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \\\r\n    FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR)) != RESET)\r\n#endif /* FLASH_SR_RDERR */\r\n  {\r\n    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE)\r\n    {\r\n      /*return the faulty sector*/\r\n      addresstmp = pFlash.Sector;\r\n      pFlash.Sector = 0xFFFFFFFFU;\r\n    }\r\n    else if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE)\r\n    {\r\n      /*return the faulty bank*/\r\n      addresstmp = pFlash.Bank;\r\n    }\r\n    else\r\n    {\r\n      /*return the faulty address*/\r\n      addresstmp = pFlash.Address;\r\n    }\r\n    \r\n    /*Save the Error code*/\r\n    FLASH_SetErrorCode();\r\n    \r\n    /* FLASH error interrupt user callback */\r\n    HAL_FLASH_OperationErrorCallback(addresstmp);\r\n    \r\n    /*Stop the procedure ongoing*/\r\n    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;\r\n  }\r\n  \r\n  /* Check FLASH End of Operation flag  */\r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)\r\n  {\r\n    /* Clear FLASH End of Operation pending bit */\r\n    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);\r\n    \r\n    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE)\r\n    {\r\n      /*Nb of sector to erased can be decreased*/\r\n      pFlash.NbSectorsToErase--;\r\n      \r\n      /* Check if there are still sectors to erase*/\r\n      if(pFlash.NbSectorsToErase != 0U)\r\n      {\r\n        addresstmp = pFlash.Sector;\r\n        /*Indicate user which sector has been erased*/\r\n        HAL_FLASH_EndOfOperationCallback(addresstmp);\r\n        \r\n        /*Increment sector number*/\r\n        pFlash.Sector++;\r\n        addresstmp = pFlash.Sector;\r\n        FLASH_Erase_Sector(addresstmp, pFlash.VoltageForErase);\r\n      }\r\n      else\r\n      {\r\n        /*No more sectors to Erase, user callback can be called.*/\r\n        /*Reset Sector and stop Erase sectors procedure*/\r\n        pFlash.Sector = addresstmp = 0xFFFFFFFFU;\r\n        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;\r\n        \r\n        /* Flush the caches to be sure of the data consistency */\r\n        FLASH_FlushCaches() ;\r\n                \r\n        /* FLASH EOP interrupt user callback */\r\n        HAL_FLASH_EndOfOperationCallback(addresstmp);\r\n      }\r\n    }\r\n    else \r\n    {\r\n      if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE) \r\n      {\r\n        /* MassErase ended. Return the selected bank */\r\n        /* Flush the caches to be sure of the data consistency */\r\n        FLASH_FlushCaches() ;\r\n\r\n        /* FLASH EOP interrupt user callback */\r\n        HAL_FLASH_EndOfOperationCallback(pFlash.Bank);\r\n      }\r\n      else\r\n      {\r\n        /*Program ended. Return the selected address*/\r\n        /* FLASH EOP interrupt user callback */\r\n        HAL_FLASH_EndOfOperationCallback(pFlash.Address);\r\n      }\r\n      pFlash.ProcedureOnGoing = FLASH_PROC_NONE;\r\n    }\r\n  }\r\n  \r\n  if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)\r\n  {\r\n    /* Operation is completed, disable the PG, SER, SNB and MER Bits */\r\n    CLEAR_BIT(FLASH->CR, (FLASH_CR_PG | FLASH_CR_SER | FLASH_CR_SNB | FLASH_MER_BIT));\r\n\r\n    /* Disable End of FLASH Operation interrupt */\r\n    __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP);\r\n    \r\n    /* Disable Error source interrupt */\r\n    __HAL_FLASH_DISABLE_IT(FLASH_IT_ERR);\r\n    \r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(&pFlash);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  FLASH end of operation interrupt callback\r\n  * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure\r\n  *                  Mass Erase: Bank number which has been requested to erase\r\n  *                  Sectors Erase: Sector which has been erased \r\n  *                    (if 0xFFFFFFFFU, it means that all the selected sectors have been erased)\r\n  *                  Program: Address which was selected for data program\r\n  * @retval None\r\n  */\r\n__weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(ReturnValue);\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file\r\n   */ \r\n}\r\n\r\n/**\r\n  * @brief  FLASH operation error interrupt callback\r\n  * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure\r\n  *                 Mass Erase: Bank number which has been requested to erase\r\n  *                 Sectors Erase: Sector number which returned an error\r\n  *                 Program: Address which was selected for data program\r\n  * @retval None\r\n  */\r\n__weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(ReturnValue);\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_FLASH_OperationErrorCallback could be implemented in the user file\r\n   */ \r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions \r\n *  @brief   management functions \r\n *\r\n@verbatim   \r\n ===============================================================================\r\n                      ##### Peripheral Control functions #####\r\n ===============================================================================  \r\n    [..]\r\n    This subsection provides a set of functions allowing to control the FLASH \r\n    memory operations.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Unlock the FLASH control register access\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_Unlock(void)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)\r\n  {\r\n    /* Authorize the FLASH Registers access */\r\n    WRITE_REG(FLASH->KEYR, FLASH_KEY1);\r\n    WRITE_REG(FLASH->KEYR, FLASH_KEY2);\r\n\r\n    /* Verify Flash is unlocked */\r\n    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)\r\n    {\r\n      status = HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Locks the FLASH control register access\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_Lock(void)\r\n{\r\n  /* Set the LOCK Bit to lock the FLASH Registers access */\r\n  FLASH->CR |= FLASH_CR_LOCK;\r\n  \r\n  return HAL_OK;  \r\n}\r\n\r\n/**\r\n  * @brief  Unlock the FLASH Option Control Registers access.\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)\r\n{\r\n  if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)\r\n  {\r\n    /* Authorizes the Option Byte register programming */\r\n    FLASH->OPTKEYR = FLASH_OPT_KEY1;\r\n    FLASH->OPTKEYR = FLASH_OPT_KEY2;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }  \r\n  \r\n  return HAL_OK;  \r\n}\r\n\r\n/**\r\n  * @brief  Lock the FLASH Option Control Registers access.\r\n  * @retval HAL Status \r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_OB_Lock(void)\r\n{\r\n  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */\r\n  FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;\r\n  \r\n  return HAL_OK;  \r\n}\r\n\r\n/**\r\n  * @brief  Launch the option byte loading.\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_OB_Launch(void)\r\n{\r\n  /* Set the OPTSTRT bit in OPTCR register */\r\n  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;\r\n\r\n  /* Wait for last operation to be completed */\r\n  return(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE)); \r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup FLASH_Exported_Functions_Group3 Peripheral State and Errors functions \r\n *  @brief   Peripheral Errors functions \r\n *\r\n@verbatim   \r\n ===============================================================================\r\n                ##### Peripheral Errors functions #####\r\n ===============================================================================  \r\n    [..]\r\n    This subsection permits to get in run-time Errors of the FLASH peripheral.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Get the specific FLASH error flag.\r\n  * @retval FLASH_ErrorCode: The returned value can be a combination of:\r\n  *            @arg HAL_FLASH_ERROR_RD: FLASH Read Protection error flag (PCROP)\r\n  *            @arg HAL_FLASH_ERROR_PGS: FLASH Programming Sequence error flag \r\n  *            @arg HAL_FLASH_ERROR_PGP: FLASH Programming Parallelism error flag  \r\n  *            @arg HAL_FLASH_ERROR_PGA: FLASH Programming Alignment error flag\r\n  *            @arg HAL_FLASH_ERROR_WRP: FLASH Write protected error flag\r\n  *            @arg HAL_FLASH_ERROR_OPERATION: FLASH operation Error flag \r\n  */\r\nuint32_t HAL_FLASH_GetError(void)\r\n{ \r\n   return pFlash.ErrorCode;\r\n}  \r\n  \r\n/**\r\n  * @}\r\n  */    \r\n\r\n/**\r\n  * @brief  Wait for a FLASH operation to complete.\r\n  * @param  Timeout maximum flash operationtimeout\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)\r\n{ \r\n  uint32_t tickstart = 0U;\r\n  \r\n  /* Clear Error Code */\r\n  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;\r\n  \r\n  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.\r\n     Even if the FLASH operation fails, the BUSY flag will be reset and an error\r\n     flag will be set */\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) \r\n  { \r\n    if(Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    } \r\n  }\r\n\r\n  /* Check FLASH End of Operation flag  */\r\n  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)\r\n  {\r\n    /* Clear FLASH End of Operation pending bit */\r\n    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);\r\n  }\r\n#if defined(FLASH_SR_RDERR)  \r\n  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \\\r\n                           FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR | FLASH_FLAG_RDERR)) != RESET)\r\n#else\r\n  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \\\r\n                           FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR)) != RESET)\r\n#endif /* FLASH_SR_RDERR */\r\n  {\r\n    /*Save the error code*/\r\n    FLASH_SetErrorCode();\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* If there is no error flag set */\r\n  return HAL_OK;\r\n  \r\n}  \r\n\r\n/**\r\n  * @brief  Program a double word (64-bit) at a specified address.\r\n  * @note   This function must be used when the device voltage range is from\r\n  *         2.7V to 3.6V and Vpp in the range 7V to 9V.\r\n  *\r\n  * @note   If an erase and a program operations are requested simultaneously,    \r\n  *         the erase operation is performed before the program one.\r\n  *  \r\n  * @param  Address specifies the address to be programmed.\r\n  * @param  Data specifies the data to be programmed.\r\n  * @retval None\r\n  */\r\nstatic void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_ADDRESS(Address));\r\n  \r\n  /* If the previous operation is completed, proceed to program the new data */\r\n  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);\r\n  FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;\r\n  FLASH->CR |= FLASH_CR_PG;\r\n\r\n  /* Program first word */\r\n  *(__IO uint32_t*)Address = (uint32_t)Data;\r\n\r\n  /* Barrier to ensure programming is performed in 2 steps, in right order\r\n    (independently of compiler optimization behavior) */\r\n  __ISB();\r\n\r\n  /* Program second word */\r\n  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Program word (32-bit) at a specified address.\r\n  * @note   This function must be used when the device voltage range is from\r\n  *         2.7V to 3.6V.\r\n  *\r\n  * @note   If an erase and a program operations are requested simultaneously,    \r\n  *         the erase operation is performed before the program one.\r\n  *  \r\n  * @param  Address specifies the address to be programmed.\r\n  * @param  Data specifies the data to be programmed.\r\n  * @retval None\r\n  */\r\nstatic void FLASH_Program_Word(uint32_t Address, uint32_t Data)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_ADDRESS(Address));\r\n  \r\n  /* If the previous operation is completed, proceed to program the new data */\r\n  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);\r\n  FLASH->CR |= FLASH_PSIZE_WORD;\r\n  FLASH->CR |= FLASH_CR_PG;\r\n\r\n  *(__IO uint32_t*)Address = Data;\r\n}\r\n\r\n/**\r\n  * @brief  Program a half-word (16-bit) at a specified address.\r\n  * @note   This function must be used when the device voltage range is from\r\n  *         2.1V to 3.6V.\r\n  *\r\n  * @note   If an erase and a program operations are requested simultaneously,    \r\n  *         the erase operation is performed before the program one.\r\n  *  \r\n  * @param  Address specifies the address to be programmed.\r\n  * @param  Data specifies the data to be programmed.\r\n  * @retval None\r\n  */\r\nstatic void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_ADDRESS(Address));\r\n  \r\n  /* If the previous operation is completed, proceed to program the new data */\r\n  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);\r\n  FLASH->CR |= FLASH_PSIZE_HALF_WORD;\r\n  FLASH->CR |= FLASH_CR_PG;\r\n\r\n  *(__IO uint16_t*)Address = Data;\r\n}\r\n\r\n/**\r\n  * @brief  Program byte (8-bit) at a specified address.\r\n  * @note   This function must be used when the device voltage range is from\r\n  *         1.8V to 3.6V.\r\n  *\r\n  * @note   If an erase and a program operations are requested simultaneously,    \r\n  *         the erase operation is performed before the program one.\r\n  *  \r\n  * @param  Address specifies the address to be programmed.\r\n  * @param  Data specifies the data to be programmed.\r\n  * @retval None\r\n  */\r\nstatic void FLASH_Program_Byte(uint32_t Address, uint8_t Data)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_ADDRESS(Address));\r\n  \r\n  /* If the previous operation is completed, proceed to program the new data */\r\n  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);\r\n  FLASH->CR |= FLASH_PSIZE_BYTE;\r\n  FLASH->CR |= FLASH_CR_PG;\r\n\r\n  *(__IO uint8_t*)Address = Data;\r\n}\r\n\r\n/**\r\n  * @brief  Set the specific FLASH error flag.\r\n  * @retval None\r\n  */\r\nstatic void FLASH_SetErrorCode(void)\r\n{ \r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)\r\n  {\r\n   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;\r\n   \r\n   /* Clear FLASH write protection error pending bit */\r\n   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR);\r\n  }\r\n  \r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)\r\n  {\r\n   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;\r\n   \r\n   /* Clear FLASH Programming alignment error pending bit */\r\n   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGAERR);\r\n  }\r\n  \r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)\r\n  {\r\n    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;\r\n    \r\n    /* Clear FLASH Programming parallelism error pending bit */\r\n    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGPERR);\r\n  }\r\n  \r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR) != RESET)\r\n  {\r\n    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;\r\n    \r\n    /* Clear FLASH Programming sequence error pending bit */\r\n    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGSERR);\r\n  }\r\n#if defined(FLASH_SR_RDERR) \r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) != RESET)\r\n  {\r\n    pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;\r\n    \r\n    /* Clear FLASH Proprietary readout protection error pending bit */\r\n    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);\r\n  }\r\n#endif /* FLASH_SR_RDERR */  \r\n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)\r\n  {\r\n    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;\r\n    \r\n    /* Clear FLASH Operation error pending bit */\r\n    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR);\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_FLASH_MODULE_ENABLED */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_flash_ex.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_flash_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   Extended FLASH HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the FLASH extension peripheral:\r\n  *           + Extended programming operations functions\r\n  *\r\n  @verbatim\r\n  ==============================================================================\r\n                   ##### Flash Extension features #####\r\n  ==============================================================================\r\n\r\n  [..] Comparing to other previous devices, the FLASH interface for STM32F427xx/437xx and\r\n       STM32F429xx/439xx devices contains the following additional features\r\n\r\n       (+) Capacity up to 2 Mbyte with dual bank architecture supporting read-while-write\r\n           capability (RWW)\r\n       (+) Dual bank memory organization\r\n       (+) PCROP protection for all banks\r\n\r\n                      ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..] This driver provides functions to configure and program the FLASH memory\r\n       of all STM32F427xx/437xx, STM32F429xx/439xx, STM32F469xx/479xx and STM32F446xx\r\n       devices. It includes\r\n      (#) FLASH Memory Erase functions:\r\n           (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and\r\n                HAL_FLASH_Lock() functions\r\n           (++) Erase function: Erase sector, erase all sectors\r\n           (++) There are two modes of erase :\r\n             (+++) Polling Mode using HAL_FLASHEx_Erase()\r\n             (+++) Interrupt Mode using HAL_FLASHEx_Erase_IT()\r\n\r\n      (#) Option Bytes Programming functions: Use HAL_FLASHEx_OBProgram() to :\r\n           (++) Set/Reset the write protection\r\n           (++) Set the Read protection Level\r\n           (++) Set the BOR level\r\n           (++) Program the user Option Bytes\r\n      (#) Advanced Option Bytes Programming functions: Use HAL_FLASHEx_AdvOBProgram() to :\r\n       (++) Extended space (bank 2) erase function\r\n       (++) Full FLASH space (2 Mo) erase (bank 1 and bank 2)\r\n       (++) Dual Boot activation\r\n       (++) Write protection configuration for bank 2\r\n       (++) PCROP protection configuration and control for both banks\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup FLASHEx FLASHEx\r\n  * @brief FLASH HAL Extension module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_FLASH_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup FLASHEx_Private_Constants\r\n  * @{\r\n  */\r\n#define FLASH_TIMEOUT_VALUE       50000U /* 50 s */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/** @addtogroup FLASHEx_Private_Variables\r\n  * @{\r\n  */\r\nextern FLASH_ProcessTypeDef pFlash;\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @addtogroup FLASHEx_Private_Functions\r\n  * @{\r\n  */\r\n/* Option bytes control */\r\nstatic void               FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks);\r\nstatic HAL_StatusTypeDef  FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks);\r\nstatic HAL_StatusTypeDef  FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks);\r\nstatic HAL_StatusTypeDef  FLASH_OB_RDP_LevelConfig(uint8_t Level);\r\nstatic HAL_StatusTypeDef  FLASH_OB_UserConfig(uint8_t Iwdg, uint8_t Stop, uint8_t Stdby);\r\nstatic HAL_StatusTypeDef  FLASH_OB_BOR_LevelConfig(uint8_t Level);\r\nstatic uint8_t            FLASH_OB_GetUser(void);\r\nstatic uint16_t           FLASH_OB_GetWRP(void);\r\nstatic uint8_t            FLASH_OB_GetRDP(void);\r\nstatic uint8_t            FLASH_OB_GetBOR(void);\r\n\r\n#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) ||\\\r\n    defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\\\r\n    defined(STM32F423xx)\r\nstatic HAL_StatusTypeDef  FLASH_OB_EnablePCROP(uint32_t Sector);\r\nstatic HAL_StatusTypeDef  FLASH_OB_DisablePCROP(uint32_t Sector);\r\n#endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx\r\n          STM32F413xx || STM32F423xx */\r\n\r\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)\r\nstatic HAL_StatusTypeDef FLASH_OB_EnablePCROP(uint32_t SectorBank1, uint32_t SectorBank2, uint32_t Banks);\r\nstatic HAL_StatusTypeDef FLASH_OB_DisablePCROP(uint32_t SectorBank1, uint32_t SectorBank2, uint32_t Banks);\r\nstatic HAL_StatusTypeDef FLASH_OB_BootConfig(uint8_t BootConfig);\r\n#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */\r\n\r\nextern HAL_StatusTypeDef         FLASH_WaitForLastOperation(uint32_t Timeout);\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup FLASHEx_Exported_Functions FLASHEx Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup FLASHEx_Exported_Functions_Group1 Extended IO operation functions\r\n *  @brief   Extended IO operation functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                ##### Extended programming operation functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to manage the Extension FLASH\r\n    programming operations.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Perform a mass erase or erase the specified FLASH memory sectors\r\n  * @param[in]  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that\r\n  *         contains the configuration information for the erasing.\r\n  *\r\n  * @param[out]  SectorError pointer to variable  that\r\n  *         contains the configuration information on faulty sector in case of error\r\n  *         (0xFFFFFFFFU means that all the sectors have been correctly erased)\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)\r\n{\r\n  HAL_StatusTypeDef status = HAL_ERROR;\r\n  uint32_t index = 0U;\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /*Initialization of SectorError variable*/\r\n    *SectorError = 0xFFFFFFFFU;\r\n\r\n    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)\r\n    {\r\n      /*Mass erase to be done*/\r\n      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);\r\n\r\n      /* Wait for last operation to be completed */\r\n      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n      /* if the erase operation is completed, disable the MER Bit */\r\n      FLASH->CR &= (~FLASH_MER_BIT);\r\n    }\r\n    else\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));\r\n\r\n      /* Erase by sector by sector to be done*/\r\n      for (index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)\r\n      {\r\n        FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);\r\n\r\n        /* Wait for last operation to be completed */\r\n        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n        /* If the erase operation is completed, disable the SER and SNB Bits */\r\n        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB));\r\n\r\n        if (status != HAL_OK)\r\n        {\r\n          /* In case of error, stop erase procedure and return the faulty sector*/\r\n          *SectorError = index;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    /* Flush the caches to be sure of the data consistency */\r\n    FLASH_FlushCaches();\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(&pFlash);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Perform a mass erase or erase the specified FLASH memory sectors  with interrupt enabled\r\n  * @param  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that\r\n  *         contains the configuration information for the erasing.\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));\r\n\r\n  /* Enable End of FLASH Operation interrupt */\r\n  __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);\r\n\r\n  /* Enable Error source interrupt */\r\n  __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);\r\n\r\n  /* Clear pending flags (if any) */\r\n  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP    | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | \\\r\n                         FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);\r\n\r\n  if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)\r\n  {\r\n    /*Mass erase to be done*/\r\n    pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE;\r\n    pFlash.Bank = pEraseInit->Banks;\r\n    FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);\r\n  }\r\n  else\r\n  {\r\n    /* Erase by sector to be done*/\r\n\r\n    /* Check the parameters */\r\n    assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));\r\n\r\n    pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE;\r\n    pFlash.NbSectorsToErase = pEraseInit->NbSectors;\r\n    pFlash.Sector = pEraseInit->Sector;\r\n    pFlash.VoltageForErase = (uint8_t)pEraseInit->VoltageRange;\r\n\r\n    /*Erase 1st sector and wait for IT*/\r\n    FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->VoltageRange);\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief   Program option bytes\r\n  * @param  pOBInit pointer to an FLASH_OBInitStruct structure that\r\n  *         contains the configuration information for the programming.\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)\r\n{\r\n  HAL_StatusTypeDef status = HAL_ERROR;\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OPTIONBYTE(pOBInit->OptionType));\r\n\r\n  /*Write protection configuration*/\r\n  if ((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)\r\n  {\r\n    assert_param(IS_WRPSTATE(pOBInit->WRPState));\r\n    if (pOBInit->WRPState == OB_WRPSTATE_ENABLE)\r\n    {\r\n      /*Enable of Write protection on the selected Sector*/\r\n      status = FLASH_OB_EnableWRP(pOBInit->WRPSector, pOBInit->Banks);\r\n    }\r\n    else\r\n    {\r\n      /*Disable of Write protection on the selected Sector*/\r\n      status = FLASH_OB_DisableWRP(pOBInit->WRPSector, pOBInit->Banks);\r\n    }\r\n  }\r\n\r\n  /*Read protection configuration*/\r\n  if ((pOBInit->OptionType & OPTIONBYTE_RDP) == OPTIONBYTE_RDP)\r\n  {\r\n    status = FLASH_OB_RDP_LevelConfig(pOBInit->RDPLevel);\r\n  }\r\n\r\n  /*USER  configuration*/\r\n  if ((pOBInit->OptionType & OPTIONBYTE_USER) == OPTIONBYTE_USER)\r\n  {\r\n    status = FLASH_OB_UserConfig(pOBInit->USERConfig & OB_IWDG_SW,\r\n                                 pOBInit->USERConfig & OB_STOP_NO_RST,\r\n                                 pOBInit->USERConfig & OB_STDBY_NO_RST);\r\n  }\r\n\r\n  /*BOR Level  configuration*/\r\n  if ((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)\r\n  {\r\n    status = FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(&pFlash);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief   Get the Option byte configuration\r\n  * @param  pOBInit pointer to an FLASH_OBInitStruct structure that\r\n  *         contains the configuration information for the programming.\r\n  *\r\n  * @retval None\r\n  */\r\nvoid HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)\r\n{\r\n  pOBInit->OptionType = OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER | OPTIONBYTE_BOR;\r\n\r\n  /*Get WRP*/\r\n  pOBInit->WRPSector = (uint32_t)FLASH_OB_GetWRP();\r\n\r\n  /*Get RDP Level*/\r\n  pOBInit->RDPLevel = (uint32_t)FLASH_OB_GetRDP();\r\n\r\n  /*Get USER*/\r\n  pOBInit->USERConfig = (uint8_t)FLASH_OB_GetUser();\r\n\r\n  /*Get BOR Level*/\r\n  pOBInit->BORLevel = (uint32_t)FLASH_OB_GetBOR();\r\n}\r\n\r\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\\\r\n    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\\\r\n    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\\\r\n    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\\\r\n    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)\r\n/**\r\n  * @brief   Program option bytes\r\n  * @param  pAdvOBInit pointer to an FLASH_AdvOBProgramInitTypeDef structure that\r\n  *         contains the configuration information for the programming.\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_AdvOBProgram(FLASH_AdvOBProgramInitTypeDef *pAdvOBInit)\r\n{\r\n  HAL_StatusTypeDef status = HAL_ERROR;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OBEX(pAdvOBInit->OptionType));\r\n\r\n  /*Program PCROP option byte*/\r\n  if (((pAdvOBInit->OptionType) & OPTIONBYTE_PCROP) == OPTIONBYTE_PCROP)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_PCROPSTATE(pAdvOBInit->PCROPState));\r\n    if ((pAdvOBInit->PCROPState) == OB_PCROP_STATE_ENABLE)\r\n    {\r\n      /*Enable of Write protection on the selected Sector*/\r\n#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\\\r\n    defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\\\r\n    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)\r\n      status = FLASH_OB_EnablePCROP(pAdvOBInit->Sectors);\r\n#else  /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */\r\n      status = FLASH_OB_EnablePCROP(pAdvOBInit->SectorsBank1, pAdvOBInit->SectorsBank2, pAdvOBInit->Banks);\r\n#endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||\r\n          STM32F413xx || STM32F423xx */\r\n    }\r\n    else\r\n    {\r\n      /*Disable of Write protection on the selected Sector*/\r\n#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\\\r\n    defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\\\r\n    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)\r\n      status = FLASH_OB_DisablePCROP(pAdvOBInit->Sectors);\r\n#else /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */\r\n      status = FLASH_OB_DisablePCROP(pAdvOBInit->SectorsBank1, pAdvOBInit->SectorsBank2, pAdvOBInit->Banks);\r\n#endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||\r\n          STM32F413xx || STM32F423xx */\r\n    }\r\n  }\r\n\r\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)\r\n  /*Program BOOT config option byte*/\r\n  if (((pAdvOBInit->OptionType) & OPTIONBYTE_BOOTCONFIG) == OPTIONBYTE_BOOTCONFIG)\r\n  {\r\n    status = FLASH_OB_BootConfig(pAdvOBInit->BootConfig);\r\n  }\r\n#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief   Get the OBEX byte configuration\r\n  * @param  pAdvOBInit pointer to an FLASH_AdvOBProgramInitTypeDef structure that\r\n  *         contains the configuration information for the programming.\r\n  *\r\n  * @retval None\r\n  */\r\nvoid HAL_FLASHEx_AdvOBGetConfig(FLASH_AdvOBProgramInitTypeDef *pAdvOBInit)\r\n{\r\n#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\\\r\n    defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\\\r\n    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)\r\n  /*Get Sector*/\r\n  pAdvOBInit->Sectors = (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));\r\n#else  /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */\r\n  /*Get Sector for Bank1*/\r\n  pAdvOBInit->SectorsBank1 = (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));\r\n\r\n  /*Get Sector for Bank2*/\r\n  pAdvOBInit->SectorsBank2 = (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));\r\n\r\n  /*Get Boot config OB*/\r\n  pAdvOBInit->BootConfig = *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS;\r\n#endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||\r\n          STM32F413xx || STM32F423xx */\r\n}\r\n\r\n/**\r\n  * @brief  Select the Protection Mode\r\n  *\r\n  * @note   After PCROP activated Option Byte modification NOT POSSIBLE! excepted\r\n  *         Global Read Out Protection modification (from level1 to level0)\r\n  * @note   Once SPRMOD bit is active unprotection of a protected sector is not possible\r\n  * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag\r\n  * @note   This function can be used only for STM32F42xxx/STM32F43xxx/STM32F401xx/STM32F411xx/STM32F446xx/\r\n  *         STM32F469xx/STM32F479xx/STM32F412xx/STM32F413xx devices.\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_OB_SelectPCROP(void)\r\n{\r\n  uint8_t optiontmp = 0xFF;\r\n\r\n  /* Mask SPRMOD bit */\r\n  optiontmp = (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F);\r\n\r\n  /* Update Option Byte */\r\n  *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PCROP_SELECTED | optiontmp);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Deselect the Protection Mode\r\n  *\r\n  * @note   After PCROP activated Option Byte modification NOT POSSIBLE! excepted\r\n  *         Global Read Out Protection modification (from level1 to level0)\r\n  * @note   Once SPRMOD bit is active unprotection of a protected sector is not possible\r\n  * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag\r\n  * @note   This function can be used only for STM32F42xxx/STM32F43xxx/STM32F401xx/STM32F411xx/STM32F446xx/\r\n  *         STM32F469xx/STM32F479xx/STM32F412xx/STM32F413xx devices.\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_OB_DeSelectPCROP(void)\r\n{\r\n  uint8_t optiontmp = 0xFF;\r\n\r\n  /* Mask SPRMOD bit */\r\n  optiontmp = (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F);\r\n\r\n  /* Update Option Byte */\r\n  *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PCROP_DESELECTED | optiontmp);\r\n\r\n  return HAL_OK;\r\n}\r\n#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE || STM32F410xx ||\\\r\n          STM32F411xE || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||\r\n          STM32F413xx || STM32F423xx */\r\n\r\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)\r\n/**\r\n  * @brief  Returns the FLASH Write Protection Option Bytes value for Bank 2\r\n  * @note   This function can be used only for STM32F42xxx/STM32F43xxx/STM32F469xx/STM32F479xx devices.\r\n  * @retval The FLASH Write Protection  Option Bytes value\r\n  */\r\nuint16_t HAL_FLASHEx_OB_GetBank2WRP(void)\r\n{\r\n  /* Return the FLASH write protection Register value */\r\n  return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));\r\n}\r\n#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)\r\n/**\r\n  * @brief  Full erase of FLASH memory sectors\r\n  * @param  VoltageRange The device voltage range which defines the erase parallelism.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V,\r\n  *                                  the operation will be done by byte (8-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,\r\n  *                                  the operation will be done by half word (16-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,\r\n  *                                  the operation will be done by word (32-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp,\r\n  *                                  the operation will be done by double word (64-bit)\r\n  *\r\n  * @param  Banks Banks to be erased\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: Bank1 to be erased\r\n  *            @arg FLASH_BANK_2: Bank2 to be erased\r\n  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nstatic void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_VOLTAGERANGE(VoltageRange));\r\n  assert_param(IS_FLASH_BANK(Banks));\r\n\r\n  /* if the previous operation is completed, proceed to erase all sectors */\r\n  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);\r\n\r\n  if (Banks == FLASH_BANK_BOTH)\r\n  {\r\n    /* bank1 & bank2 will be erased*/\r\n    FLASH->CR |= FLASH_MER_BIT;\r\n  }\r\n  else if (Banks == FLASH_BANK_1)\r\n  {\r\n    /*Only bank1 will be erased*/\r\n    FLASH->CR |= FLASH_CR_MER1;\r\n  }\r\n  else\r\n  {\r\n    /*Only bank2 will be erased*/\r\n    FLASH->CR |= FLASH_CR_MER2;\r\n  }\r\n  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange << 8U);\r\n}\r\n\r\n/**\r\n  * @brief  Erase the specified FLASH memory sector\r\n  * @param  Sector FLASH sector to erase\r\n  *         The value of this parameter depend on device used within the same series\r\n  * @param  VoltageRange The device voltage range which defines the erase parallelism.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V,\r\n  *                                  the operation will be done by byte (8-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,\r\n  *                                  the operation will be done by half word (16-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,\r\n  *                                  the operation will be done by word (32-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp,\r\n  *                                  the operation will be done by double word (64-bit)\r\n  *\r\n  * @retval None\r\n  */\r\nvoid FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)\r\n{\r\n  uint32_t tmp_psize = 0U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_SECTOR(Sector));\r\n  assert_param(IS_VOLTAGERANGE(VoltageRange));\r\n\r\n  if (VoltageRange == FLASH_VOLTAGE_RANGE_1)\r\n  {\r\n    tmp_psize = FLASH_PSIZE_BYTE;\r\n  }\r\n  else if (VoltageRange == FLASH_VOLTAGE_RANGE_2)\r\n  {\r\n    tmp_psize = FLASH_PSIZE_HALF_WORD;\r\n  }\r\n  else if (VoltageRange == FLASH_VOLTAGE_RANGE_3)\r\n  {\r\n    tmp_psize = FLASH_PSIZE_WORD;\r\n  }\r\n  else\r\n  {\r\n    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;\r\n  }\r\n\r\n  /* Need to add offset of 4 when sector higher than FLASH_SECTOR_11 */\r\n  if (Sector > FLASH_SECTOR_11)\r\n  {\r\n    Sector += 4U;\r\n  }\r\n  /* If the previous operation is completed, proceed to erase the sector */\r\n  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);\r\n  FLASH->CR |= tmp_psize;\r\n  CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);\r\n  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);\r\n  FLASH->CR |= FLASH_CR_STRT;\r\n}\r\n\r\n/**\r\n  * @brief  Enable the write protection of the desired bank1 or bank 2 sectors\r\n  *\r\n  * @note   When the memory read protection level is selected (RDP level = 1),\r\n  *         it is not possible to program or erase the flash sector i if CortexM4\r\n  *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1\r\n  * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).\r\n  *\r\n  * @param  WRPSector specifies the sector(s) to be write protected.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg WRPSector: A value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_23\r\n  *            @arg OB_WRP_SECTOR_All\r\n  * @note   BANK2 starts from OB_WRP_SECTOR_12\r\n  *\r\n  * @param  Banks Enable write protection on all the sectors for the specific bank\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: WRP on all sectors of bank1\r\n  *            @arg FLASH_BANK_2: WRP on all sectors of bank2\r\n  *            @arg FLASH_BANK_BOTH: WRP on all sectors of bank1 & bank2\r\n  *\r\n  * @retval HAL FLASH State\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_WRP_SECTOR(WRPSector));\r\n  assert_param(IS_FLASH_BANK(Banks));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    if (((WRPSector == OB_WRP_SECTOR_All) && ((Banks == FLASH_BANK_1) || (Banks == FLASH_BANK_BOTH))) ||\r\n        (WRPSector < OB_WRP_SECTOR_12))\r\n    {\r\n      if (WRPSector == OB_WRP_SECTOR_All)\r\n      {\r\n        /*Write protection on all sector of BANK1*/\r\n        *(__IO uint16_t *)OPTCR_BYTE2_ADDRESS &= (~(WRPSector >> 12));\r\n      }\r\n      else\r\n      {\r\n        /*Write protection done on sectors of BANK1*/\r\n        *(__IO uint16_t *)OPTCR_BYTE2_ADDRESS &= (~WRPSector);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /*Write protection done on sectors of BANK2*/\r\n      *(__IO uint16_t *)OPTCR1_BYTE2_ADDRESS &= (~(WRPSector >> 12));\r\n    }\r\n\r\n    /*Write protection on all sector of BANK2*/\r\n    if ((WRPSector == OB_WRP_SECTOR_All) && (Banks == FLASH_BANK_BOTH))\r\n    {\r\n      /* Wait for last operation to be completed */\r\n      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n      if (status == HAL_OK)\r\n      {\r\n        *(__IO uint16_t *)OPTCR1_BYTE2_ADDRESS &= (~(WRPSector >> 12));\r\n      }\r\n    }\r\n\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Disable the write protection of the desired bank1 or bank 2 sectors\r\n  *\r\n  * @note   When the memory read protection level is selected (RDP level = 1),\r\n  *         it is not possible to program or erase the flash sector i if CortexM4\r\n  *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1\r\n  * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).\r\n  *\r\n  * @param  WRPSector specifies the sector(s) to be write protected.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg WRPSector: A value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_23\r\n  *            @arg OB_WRP_Sector_All\r\n  * @note   BANK2 starts from OB_WRP_SECTOR_12\r\n  *\r\n  * @param  Banks Disable write protection on all the sectors for the specific bank\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: Bank1 to be erased\r\n  *            @arg FLASH_BANK_2: Bank2 to be erased\r\n  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_WRP_SECTOR(WRPSector));\r\n  assert_param(IS_FLASH_BANK(Banks));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    if (((WRPSector == OB_WRP_SECTOR_All) && ((Banks == FLASH_BANK_1) || (Banks == FLASH_BANK_BOTH))) ||\r\n        (WRPSector < OB_WRP_SECTOR_12))\r\n    {\r\n      if (WRPSector == OB_WRP_SECTOR_All)\r\n      {\r\n        /*Write protection on all sector of BANK1*/\r\n        *(__IO uint16_t *)OPTCR_BYTE2_ADDRESS |= (uint16_t)(WRPSector >> 12);\r\n      }\r\n      else\r\n      {\r\n        /*Write protection done on sectors of BANK1*/\r\n        *(__IO uint16_t *)OPTCR_BYTE2_ADDRESS |= (uint16_t)WRPSector;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /*Write protection done on sectors of BANK2*/\r\n      *(__IO uint16_t *)OPTCR1_BYTE2_ADDRESS |= (uint16_t)(WRPSector >> 12);\r\n    }\r\n\r\n    /*Write protection on all sector  of BANK2*/\r\n    if ((WRPSector == OB_WRP_SECTOR_All) && (Banks == FLASH_BANK_BOTH))\r\n    {\r\n      /* Wait for last operation to be completed */\r\n      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n      if (status == HAL_OK)\r\n      {\r\n        *(__IO uint16_t *)OPTCR1_BYTE2_ADDRESS |= (uint16_t)(WRPSector >> 12);\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the Dual Bank Boot.\r\n  *\r\n  * @note   This function can be used only for STM32F42xxx/43xxx devices.\r\n  *\r\n  * @param  BootConfig specifies the Dual Bank Boot Option byte.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_Dual_BootEnabled: Dual Bank Boot Enable\r\n  *            @arg OB_Dual_BootDisabled: Dual Bank Boot Disabled\r\n  * @retval None\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_BootConfig(uint8_t BootConfig)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_BOOT(BootConfig));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Set Dual Bank Boot */\r\n    *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BFB2);\r\n    *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= BootConfig;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Enable the read/write protection (PCROP) of the desired\r\n  *         sectors of Bank 1 and/or Bank 2.\r\n  * @note   This function can be used only for STM32F42xxx/43xxx devices.\r\n  * @param  SectorBank1 Specifies the sector(s) to be read/write protected or unprotected for bank1.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_PCROP: A value between OB_PCROP_SECTOR_0 and OB_PCROP_SECTOR_11\r\n  *            @arg OB_PCROP_SECTOR__All\r\n  * @param  SectorBank2 Specifies the sector(s) to be read/write protected or unprotected for bank2.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_PCROP: A value between OB_PCROP_SECTOR_12 and OB_PCROP_SECTOR_23\r\n  *            @arg OB_PCROP_SECTOR__All\r\n  * @param  Banks Enable PCROP protection on all the sectors for the specific bank\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: WRP on all sectors of bank1\r\n  *            @arg FLASH_BANK_2: WRP on all sectors of bank2\r\n  *            @arg FLASH_BANK_BOTH: WRP on all sectors of bank1 & bank2\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_EnablePCROP(uint32_t SectorBank1, uint32_t SectorBank2, uint32_t Banks)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  assert_param(IS_FLASH_BANK(Banks));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    if ((Banks == FLASH_BANK_1) || (Banks == FLASH_BANK_BOTH))\r\n    {\r\n      assert_param(IS_OB_PCROP(SectorBank1));\r\n      /*Write protection done on sectors of BANK1*/\r\n      *(__IO uint16_t *)OPTCR_BYTE2_ADDRESS |= (uint16_t)SectorBank1;\r\n    }\r\n    else\r\n    {\r\n      assert_param(IS_OB_PCROP(SectorBank2));\r\n      /*Write protection done on sectors of BANK2*/\r\n      *(__IO uint16_t *)OPTCR1_BYTE2_ADDRESS |= (uint16_t)SectorBank2;\r\n    }\r\n\r\n    /*Write protection on all sector  of BANK2*/\r\n    if (Banks == FLASH_BANK_BOTH)\r\n    {\r\n      assert_param(IS_OB_PCROP(SectorBank2));\r\n      /* Wait for last operation to be completed */\r\n      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n      if (status == HAL_OK)\r\n      {\r\n        /*Write protection done on sectors of BANK2*/\r\n        *(__IO uint16_t *)OPTCR1_BYTE2_ADDRESS |= (uint16_t)SectorBank2;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Disable the read/write protection (PCROP) of the desired\r\n  *         sectors  of Bank 1 and/or Bank 2.\r\n  * @note   This function can be used only for STM32F42xxx/43xxx devices.\r\n  * @param  SectorBank1 specifies the sector(s) to be read/write protected or unprotected for bank1.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_PCROP: A value between OB_PCROP_SECTOR_0 and OB_PCROP_SECTOR_11\r\n  *            @arg OB_PCROP_SECTOR__All\r\n  * @param  SectorBank2 Specifies the sector(s) to be read/write protected or unprotected for bank2.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_PCROP: A value between OB_PCROP_SECTOR_12 and OB_PCROP_SECTOR_23\r\n  *            @arg OB_PCROP_SECTOR__All\r\n  * @param  Banks Disable PCROP protection on all the sectors for the specific bank\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: WRP on all sectors of bank1\r\n  *            @arg FLASH_BANK_2: WRP on all sectors of bank2\r\n  *            @arg FLASH_BANK_BOTH: WRP on all sectors of bank1 & bank2\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_DisablePCROP(uint32_t SectorBank1, uint32_t SectorBank2, uint32_t Banks)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_BANK(Banks));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    if ((Banks == FLASH_BANK_1) || (Banks == FLASH_BANK_BOTH))\r\n    {\r\n      assert_param(IS_OB_PCROP(SectorBank1));\r\n      /*Write protection done on sectors of BANK1*/\r\n      *(__IO uint16_t *)OPTCR_BYTE2_ADDRESS &= (~SectorBank1);\r\n    }\r\n    else\r\n    {\r\n      /*Write protection done on sectors of BANK2*/\r\n      assert_param(IS_OB_PCROP(SectorBank2));\r\n      *(__IO uint16_t *)OPTCR1_BYTE2_ADDRESS &= (~SectorBank2);\r\n    }\r\n\r\n    /*Write protection on all sector  of BANK2*/\r\n    if (Banks == FLASH_BANK_BOTH)\r\n    {\r\n      assert_param(IS_OB_PCROP(SectorBank2));\r\n      /* Wait for last operation to be completed */\r\n      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n      if (status == HAL_OK)\r\n      {\r\n        /*Write protection done on sectors of BANK2*/\r\n        *(__IO uint16_t *)OPTCR1_BYTE2_ADDRESS &= (~SectorBank2);\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  return status;\r\n\r\n}\r\n\r\n#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */\r\n\r\n#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\\\r\n    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\\\r\n    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\\\r\n    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\\\r\n    defined(STM32F423xx)\r\n/**\r\n  * @brief  Mass erase of FLASH memory\r\n  * @param  VoltageRange The device voltage range which defines the erase parallelism.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V,\r\n  *                                  the operation will be done by byte (8-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,\r\n  *                                  the operation will be done by half word (16-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,\r\n  *                                  the operation will be done by word (32-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp,\r\n  *                                  the operation will be done by double word (64-bit)\r\n  *\r\n  * @param  Banks Banks to be erased\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: Bank1 to be erased\r\n  *\r\n  * @retval None\r\n  */\r\nstatic void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_VOLTAGERANGE(VoltageRange));\r\n  assert_param(IS_FLASH_BANK(Banks));\r\n\r\n  /* If the previous operation is completed, proceed to erase all sectors */\r\n  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);\r\n  FLASH->CR |= FLASH_CR_MER;\r\n  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange << 8U);\r\n}\r\n\r\n/**\r\n  * @brief  Erase the specified FLASH memory sector\r\n  * @param  Sector FLASH sector to erase\r\n  *         The value of this parameter depend on device used within the same series\r\n  * @param  VoltageRange The device voltage range which defines the erase parallelism.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V,\r\n  *                                  the operation will be done by byte (8-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,\r\n  *                                  the operation will be done by half word (16-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,\r\n  *                                  the operation will be done by word (32-bit)\r\n  *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp,\r\n  *                                  the operation will be done by double word (64-bit)\r\n  *\r\n  * @retval None\r\n  */\r\nvoid FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)\r\n{\r\n  uint32_t tmp_psize = 0U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_SECTOR(Sector));\r\n  assert_param(IS_VOLTAGERANGE(VoltageRange));\r\n\r\n  if (VoltageRange == FLASH_VOLTAGE_RANGE_1)\r\n  {\r\n    tmp_psize = FLASH_PSIZE_BYTE;\r\n  }\r\n  else if (VoltageRange == FLASH_VOLTAGE_RANGE_2)\r\n  {\r\n    tmp_psize = FLASH_PSIZE_HALF_WORD;\r\n  }\r\n  else if (VoltageRange == FLASH_VOLTAGE_RANGE_3)\r\n  {\r\n    tmp_psize = FLASH_PSIZE_WORD;\r\n  }\r\n  else\r\n  {\r\n    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;\r\n  }\r\n\r\n  /* If the previous operation is completed, proceed to erase the sector */\r\n  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);\r\n  FLASH->CR |= tmp_psize;\r\n  CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);\r\n  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);\r\n  FLASH->CR |= FLASH_CR_STRT;\r\n}\r\n\r\n/**\r\n  * @brief  Enable the write protection of the desired bank 1 sectors\r\n  *\r\n  * @note   When the memory read protection level is selected (RDP level = 1),\r\n  *         it is not possible to program or erase the flash sector i if CortexM4\r\n  *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1\r\n  * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).\r\n  *\r\n  * @param  WRPSector specifies the sector(s) to be write protected.\r\n  *         The value of this parameter depend on device used within the same series\r\n  *\r\n  * @param  Banks Enable write protection on all the sectors for the specific bank\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: WRP on all sectors of bank1\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_WRP_SECTOR(WRPSector));\r\n  assert_param(IS_FLASH_BANK(Banks));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    *(__IO uint16_t *)OPTCR_BYTE2_ADDRESS &= (~WRPSector);\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Disable the write protection of the desired bank 1 sectors\r\n  *\r\n  * @note   When the memory read protection level is selected (RDP level = 1),\r\n  *         it is not possible to program or erase the flash sector i if CortexM4\r\n  *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1\r\n  * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).\r\n  *\r\n  * @param  WRPSector specifies the sector(s) to be write protected.\r\n  *         The value of this parameter depend on device used within the same series\r\n  *\r\n  * @param  Banks Enable write protection on all the sectors for the specific bank\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: WRP on all sectors of bank1\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_WRP_SECTOR(WRPSector));\r\n  assert_param(IS_FLASH_BANK(Banks));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    *(__IO uint16_t *)OPTCR_BYTE2_ADDRESS |= (uint16_t)WRPSector;\r\n  }\r\n\r\n  return status;\r\n}\r\n#endif /* STM32F40xxx || STM32F41xxx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx\r\n          STM32F413xx || STM32F423xx */\r\n\r\n#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\\\r\n    defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\\\r\n    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)\r\n/**\r\n  * @brief  Enable the read/write protection (PCROP) of the desired sectors.\r\n  * @note   This function can be used only for STM32F401xx devices.\r\n  * @param  Sector specifies the sector(s) to be read/write protected or unprotected.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_PCROP: A value between OB_PCROP_Sector0 and OB_PCROP_Sector5\r\n  *            @arg OB_PCROP_Sector_All\r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_EnablePCROP(uint32_t Sector)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_PCROP(Sector));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    *(__IO uint16_t *)OPTCR_BYTE2_ADDRESS |= (uint16_t)Sector;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Disable the read/write protection (PCROP) of the desired sectors.\r\n  * @note   This function can be used only for STM32F401xx devices.\r\n  * @param  Sector specifies the sector(s) to be read/write protected or unprotected.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_PCROP: A value between OB_PCROP_Sector0 and OB_PCROP_Sector5\r\n  *            @arg OB_PCROP_Sector_All\r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_DisablePCROP(uint32_t Sector)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_PCROP(Sector));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    *(__IO uint16_t *)OPTCR_BYTE2_ADDRESS &= (~Sector);\r\n  }\r\n\r\n  return status;\r\n\r\n}\r\n#endif /* STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx\r\n          STM32F413xx || STM32F423xx */\r\n\r\n/**\r\n  * @brief  Set the read protection level.\r\n  * @param  Level specifies the read protection level.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_RDP_LEVEL_0: No protection\r\n  *            @arg OB_RDP_LEVEL_1: Read protection of the memory\r\n  *            @arg OB_RDP_LEVEL_2: Full chip protection\r\n  *\r\n  * @note WARNING: When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_RDP_LevelConfig(uint8_t Level)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_RDP_LEVEL(Level));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    *(__IO uint8_t *)OPTCR_BYTE1_ADDRESS = Level;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Program the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.\r\n  * @param  Iwdg Selects the IWDG mode\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_IWDG_SW: Software IWDG selected\r\n  *            @arg OB_IWDG_HW: Hardware IWDG selected\r\n  * @param  Stop Reset event when entering STOP mode.\r\n  *          This parameter  can be one of the following values:\r\n  *            @arg OB_STOP_NO_RST: No reset generated when entering in STOP\r\n  *            @arg OB_STOP_RST: Reset generated when entering in STOP\r\n  * @param  Stdby Reset event when entering Standby mode.\r\n  *          This parameter  can be one of the following values:\r\n  *            @arg OB_STDBY_NO_RST: No reset generated when entering in STANDBY\r\n  *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY\r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_UserConfig(uint8_t Iwdg, uint8_t Stop, uint8_t Stdby)\r\n{\r\n  uint8_t optiontmp = 0xFF;\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_IWDG_SOURCE(Iwdg));\r\n  assert_param(IS_OB_STOP_SOURCE(Stop));\r\n  assert_param(IS_OB_STDBY_SOURCE(Stdby));\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Mask OPTLOCK, OPTSTRT, BOR_LEV and BFB2 bits */\r\n    optiontmp = (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x1F);\r\n\r\n    /* Update User Option Byte */\r\n    *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = Iwdg | (uint8_t)(Stdby | (uint8_t)(Stop | ((uint8_t)optiontmp)));\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Set the BOR Level.\r\n  * @param  Level specifies the Option Bytes BOR Reset Level.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V\r\n  *            @arg OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V\r\n  *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V\r\n  *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V\r\n  * @retval HAL Status\r\n  */\r\nstatic HAL_StatusTypeDef FLASH_OB_BOR_LevelConfig(uint8_t Level)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_BOR_LEVEL(Level));\r\n\r\n  /* Set the BOR Level */\r\n  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);\r\n  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= Level;\r\n\r\n  return HAL_OK;\r\n\r\n}\r\n\r\n/**\r\n  * @brief  Return the FLASH User Option Byte value.\r\n  * @retval uint8_t FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1)\r\n  *         and RST_STDBY(Bit2).\r\n  */\r\nstatic uint8_t FLASH_OB_GetUser(void)\r\n{\r\n  /* Return the User Option Byte */\r\n  return ((uint8_t)(FLASH->OPTCR & 0xE0));\r\n}\r\n\r\n/**\r\n  * @brief  Return the FLASH Write Protection Option Bytes value.\r\n  * @retval uint16_t FLASH Write Protection Option Bytes value\r\n  */\r\nstatic uint16_t FLASH_OB_GetWRP(void)\r\n{\r\n  /* Return the FLASH write protection Register value */\r\n  return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));\r\n}\r\n\r\n/**\r\n  * @brief  Returns the FLASH Read Protection level.\r\n  * @retval FLASH ReadOut Protection Status:\r\n  *         This parameter can be one of the following values:\r\n  *            @arg OB_RDP_LEVEL_0: No protection\r\n  *            @arg OB_RDP_LEVEL_1: Read protection of the memory\r\n  *            @arg OB_RDP_LEVEL_2: Full chip protection\r\n  */\r\nstatic uint8_t FLASH_OB_GetRDP(void)\r\n{\r\n  uint8_t readstatus = OB_RDP_LEVEL_0;\r\n\r\n  if (*(__IO uint8_t *)(OPTCR_BYTE1_ADDRESS) == (uint8_t)OB_RDP_LEVEL_2)\r\n  {\r\n    readstatus = OB_RDP_LEVEL_2;\r\n  }\r\n  else if (*(__IO uint8_t *)(OPTCR_BYTE1_ADDRESS) == (uint8_t)OB_RDP_LEVEL_0)\r\n  {\r\n    readstatus = OB_RDP_LEVEL_0;\r\n  }\r\n  else\r\n  {\r\n    readstatus = OB_RDP_LEVEL_1;\r\n  }\r\n\r\n  return readstatus;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the FLASH BOR level.\r\n  * @retval uint8_t The FLASH BOR level:\r\n  *           - OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V\r\n  *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V\r\n  *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V\r\n  *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V\r\n  */\r\nstatic uint8_t FLASH_OB_GetBOR(void)\r\n{\r\n  /* Return the FLASH BOR level */\r\n  return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);\r\n}\r\n\r\n/**\r\n  * @brief  Flush the instruction and data caches\r\n  * @retval None\r\n  */\r\nvoid FLASH_FlushCaches(void)\r\n{\r\n  /* Flush instruction cache  */\r\n  if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != RESET)\r\n  {\r\n    /* Disable instruction cache  */\r\n    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();\r\n    /* Reset instruction cache */\r\n    __HAL_FLASH_INSTRUCTION_CACHE_RESET();\r\n    /* Enable instruction cache */\r\n    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();\r\n  }\r\n\r\n  /* Flush data cache */\r\n  if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)\r\n  {\r\n    /* Disable data cache  */\r\n    __HAL_FLASH_DATA_CACHE_DISABLE();\r\n    /* Reset data cache */\r\n    __HAL_FLASH_DATA_CACHE_RESET();\r\n    /* Enable data cache */\r\n    __HAL_FLASH_DATA_CACHE_ENABLE();\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_FLASH_MODULE_ENABLED */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_flash_ramfunc.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_flash_ramfunc.c\r\n  * @author  MCD Application Team\r\n  * @brief   FLASH RAMFUNC module driver.\r\n  *          This file provides a FLASH firmware functions which should be \r\n  *          executed from internal SRAM\r\n  *            + Stop/Start the flash interface while System Run\r\n  *            + Enable/Disable the flash sleep while System Run\r\n  @verbatim\r\n  ==============================================================================\r\n                    ##### APIs executed from Internal RAM #####\r\n  ==============================================================================\r\n  [..]\r\n    *** ARM Compiler ***\r\n    --------------------\r\n    [..] RAM functions are defined using the toolchain options. \r\n         Functions that are be executed in RAM should reside in a separate\r\n         source module. Using the 'Options for File' dialog you can simply change\r\n         the 'Code / Const' area of a module to a memory space in physical RAM.\r\n         Available memory areas are declared in the 'Target' tab of the \r\n         Options for Target' dialog.\r\n\r\n    *** ICCARM Compiler ***\r\n    -----------------------\r\n    [..] RAM functions are defined using a specific toolchain keyword \"__ramfunc\".\r\n\r\n    *** GNU Compiler ***\r\n    --------------------\r\n    [..] RAM functions are defined using a specific toolchain attribute\r\n         \"__attribute__((section(\".RamFunc\")))\".\r\n  \r\n  @endverbatim         \r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */ \r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup FLASH_RAMFUNC FLASH RAMFUNC\r\n  * @brief FLASH functions executed from RAM\r\n  * @{\r\n  */\r\n#ifdef HAL_FLASH_MODULE_ENABLED\r\n#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \\\r\n    defined(STM32F412Rx) || defined(STM32F412Cx)\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup FLASH_RAMFUNC_Exported_Functions FLASH RAMFUNC Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup FLASH_RAMFUNC_Exported_Functions_Group1 Peripheral features functions executed from internal RAM \r\n  *  @brief Peripheral Extended features functions \r\n  *\r\n@verbatim   \r\n\r\n ===============================================================================\r\n                      ##### ramfunc functions #####\r\n ===============================================================================  \r\n    [..]\r\n    This subsection provides a set of functions that should be executed from RAM \r\n    transfers.\r\n    \r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Stop the flash interface while System Run\r\n  * @note  This mode is only available for STM32F41xxx/STM32F446xx devices. \r\n  * @note  This mode couldn't be set while executing with the flash itself. \r\n  *        It should be done with specific routine executed from RAM.     \r\n  * @retval HAL status\r\n  */\r\n__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_StopFlashInterfaceClk(void)\r\n{\r\n  /* Enable Power ctrl clock */\r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n  /* Stop the flash interface while System Run */  \r\n  SET_BIT(PWR->CR, PWR_CR_FISSR);\r\n   \r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Start the flash interface while System Run\r\n  * @note  This mode is only available for STM32F411xx/STM32F446xx devices. \r\n  * @note  This mode couldn't be set while executing with the flash itself. \r\n  *        It should be done with specific routine executed from RAM.     \r\n  * @retval HAL status\r\n  */\r\n__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_StartFlashInterfaceClk(void)\r\n{\r\n  /* Enable Power ctrl clock */\r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n  /* Start the flash interface while System Run */\r\n  CLEAR_BIT(PWR->CR, PWR_CR_FISSR);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Enable the flash sleep while System Run\r\n  * @note  This mode is only available for STM32F41xxx/STM32F446xx devices. \r\n  * @note  This mode could n't be set while executing with the flash itself. \r\n  *        It should be done with specific routine executed from RAM.     \r\n  * @retval HAL status\r\n  */\r\n__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_EnableFlashSleepMode(void)\r\n{\r\n  /* Enable Power ctrl clock */\r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n  /* Enable the flash sleep while System Run */\r\n  SET_BIT(PWR->CR, PWR_CR_FMSSR);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Disable the flash sleep while System Run\r\n  * @note  This mode is only available for STM32F41xxx/STM32F446xx devices. \r\n  * @note  This mode couldn't be set while executing with the flash itself. \r\n  *        It should be done with specific routine executed from RAM.     \r\n  * @retval HAL status\r\n  */\r\n__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_DisableFlashSleepMode(void)\r\n{\r\n  /* Enable Power ctrl clock */\r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n  /* Disable the flash sleep while System Run */\r\n  CLEAR_BIT(PWR->CR, PWR_CR_FMSSR);\r\n  \r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */\r\n#endif /* HAL_FLASH_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_gpio.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_gpio.c\r\n  * @author  MCD Application Team\r\n  * @brief   GPIO HAL module driver.\r\n  *          This file provides firmware functions to manage the following \r\n  *          functionalities of the General Purpose Input/Output (GPIO) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + IO operation functions\r\n  *\r\n  @verbatim\r\n  ==============================================================================\r\n                    ##### GPIO Peripheral features #####\r\n  ==============================================================================\r\n  [..] \r\n  Subject to the specific hardware characteristics of each I/O port listed in the datasheet, each\r\n  port bit of the General Purpose IO (GPIO) Ports, can be individually configured by software\r\n  in several modes:\r\n  (+) Input mode \r\n  (+) Analog mode\r\n  (+) Output mode\r\n  (+) Alternate function mode\r\n  (+) External interrupt/event lines\r\n\r\n  [..]  \r\n  During and just after reset, the alternate functions and external interrupt  \r\n  lines are not active and the I/O ports are configured in input floating mode.\r\n  \r\n  [..]   \r\n  All GPIO pins have weak internal pull-up and pull-down resistors, which can be \r\n  activated or not.\r\n\r\n  [..]\r\n  In Output or Alternate mode, each IO can be configured on open-drain or push-pull\r\n  type and the IO speed can be selected depending on the VDD value.\r\n\r\n  [..]  \r\n  All ports have external interrupt/event capability. To use external interrupt \r\n  lines, the port must be configured in input mode. All available GPIO pins are \r\n  connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.\r\n  \r\n  [..]\r\n  The external interrupt/event controller consists of up to 23 edge detectors \r\n  (16 lines are connected to GPIO) for generating event/interrupt requests (each \r\n  input line can be independently configured to select the type (interrupt or event) \r\n  and the corresponding trigger event (rising or falling or both). Each line can \r\n  also be masked independently. \r\n\r\n                     ##### How to use this driver #####\r\n  ==============================================================================  \r\n  [..]\r\n    (#) Enable the GPIO AHB clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE(). \r\n\r\n    (#) Configure the GPIO pin(s) using HAL_GPIO_Init().\r\n        (++) Configure the IO mode using \"Mode\" member from GPIO_InitTypeDef structure\r\n        (++) Activate Pull-up, Pull-down resistor using \"Pull\" member from GPIO_InitTypeDef \r\n             structure.\r\n        (++) In case of Output or alternate function mode selection: the speed is \r\n             configured through \"Speed\" member from GPIO_InitTypeDef structure.\r\n        (++) In alternate mode is selection, the alternate function connected to the IO\r\n             is configured through \"Alternate\" member from GPIO_InitTypeDef structure.\r\n        (++) Analog mode is required when a pin is to be used as ADC channel \r\n             or DAC output.\r\n        (++) In case of external interrupt/event selection the \"Mode\" member from \r\n             GPIO_InitTypeDef structure select the type (interrupt or event) and \r\n             the corresponding trigger event (rising or falling or both).\r\n\r\n    (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority \r\n        mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using\r\n        HAL_NVIC_EnableIRQ().\r\n         \r\n    (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().\r\n            \r\n    (#) To set/reset the level of a pin configured in output mode use \r\n        HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().\r\n    \r\n    (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().\r\n\r\n                 \r\n    (#) During and just after reset, the alternate functions are not \r\n        active and the GPIO pins are configured in input floating mode (except JTAG\r\n        pins).\r\n  \r\n    (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose \r\n        (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has \r\n        priority over the GPIO function.\r\n  \r\n    (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as \r\n        general purpose PH0 and PH1, respectively, when the HSE oscillator is off. \r\n        The HSE has priority over the GPIO function.\r\n  \r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */ \r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup GPIO GPIO\r\n  * @brief GPIO HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_GPIO_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup GPIO_Private_Constants GPIO Private Constants\r\n  * @{\r\n  */\r\n\r\n#define GPIO_NUMBER           16U\r\n/**\r\n  * @}\r\n  */\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup GPIO_Exported_Functions GPIO Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup GPIO_Exported_Functions_Group1 Initialization and de-initialization functions\r\n  *  @brief    Initialization and Configuration functions\r\n  *\r\n@verbatim    \r\n ===============================================================================\r\n              ##### Initialization and de-initialization functions #####\r\n ===============================================================================\r\n  [..]\r\n    This section provides functions allowing to initialize and de-initialize the GPIOs\r\n    to be ready for use.\r\n \r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n\r\n/**\r\n  * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.\r\n  * @param  GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or\r\n  *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.\r\n  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains\r\n  *         the configuration information for the specified GPIO peripheral.\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)\r\n{\r\n  uint32_t position;\r\n  uint32_t ioposition = 0x00U;\r\n  uint32_t iocurrent = 0x00U;\r\n  uint32_t temp = 0x00U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\r\n  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));\r\n  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));\r\n\r\n  /* Configure the port pins */\r\n  for(position = 0U; position < GPIO_NUMBER; position++)\r\n  {\r\n    /* Get the IO position */\r\n    ioposition = 0x01U << position;\r\n    /* Get the current IO position */\r\n    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;\r\n\r\n    if(iocurrent == ioposition)\r\n    {\r\n      /*--------------------- GPIO Mode Configuration ------------------------*/\r\n      /* In case of Output or Alternate function mode selection */\r\n      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \\\r\n          (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)\r\n      {\r\n        /* Check the Speed parameter */\r\n        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));\r\n        /* Configure the IO Speed */\r\n        temp = GPIOx->OSPEEDR; \r\n        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));\r\n        temp |= (GPIO_Init->Speed << (position * 2U));\r\n        GPIOx->OSPEEDR = temp;\r\n\r\n        /* Configure the IO Output Type */\r\n        temp = GPIOx->OTYPER;\r\n        temp &= ~(GPIO_OTYPER_OT_0 << position) ;\r\n        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);\r\n        GPIOx->OTYPER = temp;\r\n       }\r\n\r\n      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)\r\n      {\r\n        /* Check the parameters */\r\n        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));\r\n        \r\n        /* Activate the Pull-up or Pull down resistor for the current IO */\r\n        temp = GPIOx->PUPDR;\r\n        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));\r\n        temp |= ((GPIO_Init->Pull) << (position * 2U));\r\n        GPIOx->PUPDR = temp;\r\n      }\r\n\r\n      /* In case of Alternate function mode selection */\r\n      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)\r\n      {\r\n        /* Check the Alternate function parameter */\r\n        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));\r\n        /* Configure Alternate function mapped with the current IO */\r\n        temp = GPIOx->AFR[position >> 3U];\r\n        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;\r\n        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));\r\n        GPIOx->AFR[position >> 3U] = temp;\r\n      }\r\n\r\n      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */\r\n      temp = GPIOx->MODER;\r\n      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));\r\n      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));\r\n      GPIOx->MODER = temp;\r\n\r\n      /*--------------------- EXTI Mode Configuration ------------------------*/\r\n      /* Configure the External Interrupt or event for the current IO */\r\n      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)\r\n      {\r\n        /* Enable SYSCFG Clock */\r\n        __HAL_RCC_SYSCFG_CLK_ENABLE();\r\n\r\n        temp = SYSCFG->EXTICR[position >> 2U];\r\n        temp &= ~(0x0FU << (4U * (position & 0x03U)));\r\n        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));\r\n        SYSCFG->EXTICR[position >> 2U] = temp;\r\n\r\n        /* Clear EXTI line configuration */\r\n        temp = EXTI->IMR;\r\n        temp &= ~((uint32_t)iocurrent);\r\n        if((GPIO_Init->Mode & EXTI_IT) != 0x00U)\r\n        {\r\n          temp |= iocurrent;\r\n        }\r\n        EXTI->IMR = temp;\r\n\r\n        temp = EXTI->EMR;\r\n        temp &= ~((uint32_t)iocurrent);\r\n        if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)\r\n        {\r\n          temp |= iocurrent;\r\n        }\r\n        EXTI->EMR = temp;\r\n\r\n        /* Clear Rising Falling edge configuration */\r\n        temp = EXTI->RTSR;\r\n        temp &= ~((uint32_t)iocurrent);\r\n        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)\r\n        {\r\n          temp |= iocurrent;\r\n        }\r\n        EXTI->RTSR = temp;\r\n\r\n        temp = EXTI->FTSR;\r\n        temp &= ~((uint32_t)iocurrent);\r\n        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)\r\n        {\r\n          temp |= iocurrent;\r\n        }\r\n        EXTI->FTSR = temp;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  De-initializes the GPIOx peripheral registers to their default reset values.\r\n  * @param  GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or\r\n  *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.\r\n  * @param  GPIO_Pin specifies the port bit to be written.\r\n  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)\r\n{\r\n  uint32_t position;\r\n  uint32_t ioposition = 0x00U;\r\n  uint32_t iocurrent = 0x00U;\r\n  uint32_t tmp = 0x00U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\r\n  \r\n  /* Configure the port pins */\r\n  for(position = 0U; position < GPIO_NUMBER; position++)\r\n  {\r\n    /* Get the IO position */\r\n    ioposition = 0x01U << position;\r\n    /* Get the current IO position */\r\n    iocurrent = (GPIO_Pin) & ioposition;\r\n\r\n    if(iocurrent == ioposition)\r\n    {\r\n      /*------------------------- EXTI Mode Configuration --------------------*/\r\n      tmp = SYSCFG->EXTICR[position >> 2U];\r\n      tmp &= (0x0FU << (4U * (position & 0x03U)));\r\n      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))\r\n      {\r\n        /* Clear EXTI line configuration */\r\n        EXTI->IMR &= ~((uint32_t)iocurrent);\r\n        EXTI->EMR &= ~((uint32_t)iocurrent);\r\n        \r\n        /* Clear Rising Falling edge configuration */\r\n        EXTI->RTSR &= ~((uint32_t)iocurrent);\r\n        EXTI->FTSR &= ~((uint32_t)iocurrent);\r\n\r\n        /* Configure the External Interrupt or event for the current IO */\r\n        tmp = 0x0FU << (4U * (position & 0x03U));\r\n        SYSCFG->EXTICR[position >> 2U] &= ~tmp;\r\n      }\r\n\r\n      /*------------------------- GPIO Mode Configuration --------------------*/\r\n      /* Configure IO Direction in Input Floating Mode */\r\n      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));\r\n\r\n      /* Configure the default Alternate Function in current IO */\r\n      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;\r\n\r\n      /* Deactivate the Pull-up and Pull-down resistor for the current IO */\r\n      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));\r\n\r\n      /* Configure the default value IO Output Type */\r\n      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;\r\n\r\n      /* Configure the default value for IO Speed */\r\n      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup GPIO_Exported_Functions_Group2 IO operation functions \r\n  *  @brief   GPIO Read and Write\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                       ##### IO operation functions #####\r\n ===============================================================================\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Reads the specified input port pin.\r\n  * @param  GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or\r\n  *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.\r\n  * @param  GPIO_Pin specifies the port bit to read.\r\n  *         This parameter can be GPIO_PIN_x where x can be (0..15).\r\n  * @retval The input port pin value.\r\n  */\r\nGPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)\r\n{\r\n  GPIO_PinState bitstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\r\n\r\n  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)\r\n  {\r\n    bitstatus = GPIO_PIN_SET;\r\n  }\r\n  else\r\n  {\r\n    bitstatus = GPIO_PIN_RESET;\r\n  }\r\n  return bitstatus;\r\n}\r\n\r\n/**\r\n  * @brief  Sets or clears the selected data port bit.\r\n  *\r\n  * @note   This function uses GPIOx_BSRR register to allow atomic read/modify\r\n  *         accesses. In this way, there is no risk of an IRQ occurring between\r\n  *         the read and the modify access.\r\n  *\r\n  * @param  GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or\r\n  *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.\r\n  * @param  GPIO_Pin specifies the port bit to be written.\r\n  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).\r\n  * @param  PinState specifies the value to be written to the selected bit.\r\n  *          This parameter can be one of the GPIO_PinState enum values:\r\n  *            @arg GPIO_PIN_RESET: to clear the port pin\r\n  *            @arg GPIO_PIN_SET: to set the port pin\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\r\n  assert_param(IS_GPIO_PIN_ACTION(PinState));\r\n\r\n  if(PinState != GPIO_PIN_RESET)\r\n  {\r\n    GPIOx->BSRR = GPIO_Pin;\r\n  }\r\n  else\r\n  {\r\n    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Toggles the specified GPIO pins.\r\n  * @param  GPIOx Where x can be (A..K) to select the GPIO peripheral for STM32F429X device or\r\n  *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.\r\n  * @param  GPIO_Pin Specifies the pins to be toggled.\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)\r\n{\r\n  uint32_t odr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\r\n\r\n  /* get current Ouput Data Register value */\r\n  odr = GPIOx->ODR;\r\n\r\n  /* Set selected pins that were at low level, and reset ones that were high */\r\n  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);\r\n}\r\n\r\n/**\r\n  * @brief  Locks GPIO Pins configuration registers.\r\n  * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,\r\n  *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.\r\n  * @note   The configuration of the locked GPIO pins can no longer be modified\r\n  *         until the next reset.\r\n  * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32F4 family\r\n  * @param  GPIO_Pin specifies the port bit to be locked.\r\n  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).\r\n  * @retval None\r\n  */\r\nHAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)\r\n{\r\n  __IO uint32_t tmp = GPIO_LCKR_LCKK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\r\n\r\n  /* Apply lock key write sequence */\r\n  tmp |= GPIO_Pin;\r\n  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */\r\n  GPIOx->LCKR = tmp;\r\n  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */\r\n  GPIOx->LCKR = GPIO_Pin;\r\n  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */\r\n  GPIOx->LCKR = tmp;\r\n  /* Read LCKR register. This read is mandatory to complete key lock sequence */\r\n  tmp = GPIOx->LCKR;\r\n\r\n  /* Read again in order to confirm lock is active */\r\n if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)\r\n  {\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  This function handles EXTI interrupt request.\r\n  * @param  GPIO_Pin Specifies the pins connected EXTI line\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)\r\n{\r\n  /* EXTI line interrupt detected */\r\n  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)\r\n  {\r\n    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);\r\n    HAL_GPIO_EXTI_Callback(GPIO_Pin);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  EXTI line detection callbacks.\r\n  * @param  GPIO_Pin Specifies the pins connected EXTI line\r\n  * @retval None\r\n  */\r\n__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(GPIO_Pin);\r\n  /* NOTE: This function Should not be modified, when the callback is needed,\r\n           the HAL_GPIO_EXTI_Callback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_GPIO_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_msp.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Core\\Src","tag":"","groupDisplay":"Other files","code":"/* USER CODE BEGIN Header */\r\n/**\r\n  ******************************************************************************\r\n  * @file         stm32f4xx_hal_msp.c\r\n  * @brief        This file provides code for the MSP Initialization\r\n  *               and de-Initialization codes.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2024 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* USER CODE END Header */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"main.h\"\r\n/* USER CODE BEGIN Includes */\r\n\r\n/* USER CODE END Includes */\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* USER CODE BEGIN TD */\r\n\r\n/* USER CODE END TD */\r\n\r\n/* Private define ------------------------------------------------------------*/\r\n/* USER CODE BEGIN Define */\r\n\r\n/* USER CODE END Define */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* USER CODE BEGIN Macro */\r\n\r\n/* USER CODE END Macro */\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/* USER CODE BEGIN PV */\r\n\r\n/* USER CODE END PV */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* USER CODE BEGIN PFP */\r\n\r\n/* USER CODE END PFP */\r\n\r\n/* External functions --------------------------------------------------------*/\r\n/* USER CODE BEGIN ExternalFunctions */\r\n\r\n/* USER CODE END ExternalFunctions */\r\n\r\n/* USER CODE BEGIN 0 */\r\n\r\n/* USER CODE END 0 */\r\n/**\r\n  * Initializes the Global MSP.\r\n  */\r\nvoid HAL_MspInit(void)\r\n{\r\n  /* USER CODE BEGIN MspInit 0 */\r\n\r\n  /* USER CODE END MspInit 0 */\r\n\r\n  __HAL_RCC_SYSCFG_CLK_ENABLE();\r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n\r\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);\r\n\r\n  /* System interrupt init*/\r\n\r\n  /* USER CODE BEGIN MspInit 1 */\r\n\r\n  /* USER CODE END MspInit 1 */\r\n}\r\n\r\n/**\r\n* @brief CAN MSP Initialization\r\n* This function configures the hardware resources used in this example\r\n* @param hcan: CAN handle pointer\r\n* @retval None\r\n*/\r\nvoid HAL_CAN_MspInit(CAN_HandleTypeDef* hcan)\r\n{\r\n  GPIO_InitTypeDef GPIO_InitStruct = {0};\r\n  if(hcan->Instance==CAN1)\r\n  {\r\n  /* USER CODE BEGIN CAN1_MspInit 0 */\r\n\r\n  /* USER CODE END CAN1_MspInit 0 */\r\n    /* Peripheral clock enable */\r\n    __HAL_RCC_CAN1_CLK_ENABLE();\r\n\r\n    __HAL_RCC_GPIOB_CLK_ENABLE();\r\n    /**CAN1 GPIO Configuration\r\n    PB8     ------> CAN1_RX\r\n    PB9     ------> CAN1_TX\r\n    */\r\n    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;\r\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\r\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\r\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\r\n    GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;\r\n    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);\r\n\r\n  /* USER CODE BEGIN CAN1_MspInit 1 */\r\n\r\n  /* USER CODE END CAN1_MspInit 1 */\r\n  }\r\n\r\n}\r\n\r\n/**\r\n* @brief CAN MSP De-Initialization\r\n* This function freeze the hardware resources used in this example\r\n* @param hcan: CAN handle pointer\r\n* @retval None\r\n*/\r\nvoid HAL_CAN_MspDeInit(CAN_HandleTypeDef* hcan)\r\n{\r\n  if(hcan->Instance==CAN1)\r\n  {\r\n  /* USER CODE BEGIN CAN1_MspDeInit 0 */\r\n\r\n  /* USER CODE END CAN1_MspDeInit 0 */\r\n    /* Peripheral clock disable */\r\n    __HAL_RCC_CAN1_CLK_DISABLE();\r\n\r\n    /**CAN1 GPIO Configuration\r\n    PB8     ------> CAN1_RX\r\n    PB9     ------> CAN1_TX\r\n    */\r\n    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_8|GPIO_PIN_9);\r\n\r\n  /* USER CODE BEGIN CAN1_MspDeInit 1 */\r\n\r\n  /* USER CODE END CAN1_MspDeInit 1 */\r\n  }\r\n\r\n}\r\n\r\n/* USER CODE BEGIN 1 */\r\n\r\n/* USER CODE END 1 */\r\n\r\n"},{"name":"stm32f4xx_hal_pwr.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_pwr.c\r\n  * @author  MCD Application Team\r\n  * @brief   PWR HAL module driver.\r\n  *          This file provides firmware functions to manage the following \r\n  *          functionalities of the Power Controller (PWR) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + Peripheral Control functions \r\n  *         \r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */ \r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PWR PWR\r\n  * @brief PWR HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_PWR_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup PWR_Private_Constants\r\n  * @{\r\n  */\r\n  \r\n/** @defgroup PWR_PVD_Mode_Mask PWR PVD Mode Mask\r\n  * @{\r\n  */     \r\n#define PVD_MODE_IT               0x00010000U\r\n#define PVD_MODE_EVT              0x00020000U\r\n#define PVD_RISING_EDGE           0x00000001U\r\n#define PVD_FALLING_EDGE          0x00000002U\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */    \r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/** @defgroup PWR_Exported_Functions PWR Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions \r\n  *  @brief    Initialization and de-initialization functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n              ##### Initialization and de-initialization functions #####\r\n ===============================================================================\r\n    [..]\r\n      After reset, the backup domain (RTC registers, RTC backup data \r\n      registers and backup SRAM) is protected against possible unwanted \r\n      write accesses. \r\n      To enable access to the RTC Domain and RTC registers, proceed as follows:\r\n        (+) Enable the Power Controller (PWR) APB1 interface clock using the\r\n            __HAL_RCC_PWR_CLK_ENABLE() macro.\r\n        (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.\r\n \r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Deinitializes the HAL PWR peripheral registers to their default reset values.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_DeInit(void)\r\n{\r\n  __HAL_RCC_PWR_FORCE_RESET();\r\n  __HAL_RCC_PWR_RELEASE_RESET();\r\n}\r\n\r\n/**\r\n  * @brief Enables access to the backup domain (RTC registers, RTC \r\n  *         backup data registers and backup SRAM).\r\n  * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the \r\n  *         Backup Domain Access should be kept enabled.\r\n  * @note The following sequence is required to bypass the delay between\r\n  *         DBP bit programming and the effective enabling  of the backup domain.\r\n  *         Please check the Errata Sheet for more details under \"Possible delay\r\n  *         in backup domain protection disabling/enabling after programming the\r\n  *         DBP bit\" section.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnableBkUpAccess(void)\r\n{\r\n  __IO uint32_t dummyread;\r\n  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)ENABLE;\r\n  dummyread = PWR->CR;\r\n  UNUSED(dummyread);\r\n}\r\n\r\n/**\r\n  * @brief Disables access to the backup domain (RTC registers, RTC \r\n  *         backup data registers and backup SRAM).\r\n  * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the \r\n  *         Backup Domain Access should be kept enabled.\r\n  * @note The following sequence is required to bypass the delay between\r\n  *         DBP bit programming and the effective disabling  of the backup domain.\r\n  *         Please check the Errata Sheet for more details under \"Possible delay\r\n  *         in backup domain protection disabling/enabling after programming the\r\n  *         DBP bit\" section.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_DisableBkUpAccess(void)\r\n{\r\n  __IO uint32_t dummyread;\r\n  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)DISABLE;\r\n  dummyread = PWR->CR;\r\n  UNUSED(dummyread);\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup PWR_Exported_Functions_Group2 Peripheral Control functions \r\n  *  @brief Low Power modes configuration functions \r\n  *\r\n@verbatim\r\n\r\n ===============================================================================\r\n                 ##### Peripheral Control functions #####\r\n ===============================================================================\r\n     \r\n    *** PVD configuration ***\r\n    =========================\r\n    [..]\r\n      (+) The PVD is used to monitor the VDD power supply by comparing it to a \r\n          threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).\r\n      (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower \r\n          than the PVD threshold. This event is internally connected to the EXTI \r\n          line16 and can generate an interrupt if enabled. This is done through\r\n          __HAL_PWR_PVD_EXTI_ENABLE_IT() macro.\r\n      (+) The PVD is stopped in Standby mode.\r\n\r\n    *** Wake-up pin configuration ***\r\n    ================================\r\n    [..]\r\n      (+) Wake-up pin is used to wake up the system from Standby mode. This pin is \r\n          forced in input pull-down configuration and is active on rising edges.\r\n      (+) There is one Wake-up pin: Wake-up Pin 1 on PA.00.\r\n\t   (++) For STM32F446xx there are two Wake-Up pins: Pin1 on PA.00 and Pin2 on PC.13\r\n           (++) For STM32F410xx/STM32F412xx/STM32F413xx/STM32F423xx  there are three Wake-Up pins: Pin1 on PA.00, Pin2 on PC.00 and Pin3 on PC.01 \r\n\r\n    *** Low Power modes configuration ***\r\n    =====================================\r\n    [..]\r\n      The devices feature 3 low-power modes:\r\n      (+) Sleep mode: Cortex-M4 core stopped, peripherals kept running.\r\n      (+) Stop mode: all clocks are stopped, regulator running, regulator \r\n          in low power mode\r\n      (+) Standby mode: 1.2V domain powered off.\r\n   \r\n   *** Sleep mode ***\r\n   ==================\r\n    [..]\r\n      (+) Entry:\r\n        The Sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI)\r\n              functions with\r\n          (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction\r\n          (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction\r\n      \r\n      -@@- The Regulator parameter is not used for the STM32F4 family \r\n              and is kept as parameter just to maintain compatibility with the \r\n              lower power families (STM32L).\r\n      (+) Exit:\r\n        Any peripheral interrupt acknowledged by the nested vectored interrupt \r\n              controller (NVIC) can wake up the device from Sleep mode.\r\n\r\n   *** Stop mode ***\r\n   =================\r\n    [..]\r\n      In Stop mode, all clocks in the 1.2V domain are stopped, the PLL, the HSI,\r\n      and the HSE RC oscillators are disabled. Internal SRAM and register contents \r\n      are preserved.\r\n      The voltage regulator can be configured either in normal or low-power mode.\r\n      To minimize the consumption In Stop mode, FLASH can be powered off before \r\n      entering the Stop mode using the HAL_PWREx_EnableFlashPowerDown() function.\r\n      It can be switched on again by software after exiting the Stop mode using\r\n      the HAL_PWREx_DisableFlashPowerDown() function. \r\n\r\n      (+) Entry:\r\n         The Stop mode is entered using the HAL_PWR_EnterSTOPMode(PWR_MAINREGULATOR_ON) \r\n             function with:\r\n          (++) Main regulator ON.\r\n          (++) Low Power regulator ON.\r\n      (+) Exit:\r\n        Any EXTI Line (Internal or External) configured in Interrupt/Event mode.\r\n\r\n   *** Standby mode ***\r\n   ====================\r\n    [..]\r\n    (+)\r\n      The Standby mode allows to achieve the lowest power consumption. It is based \r\n      on the Cortex-M4 deep sleep mode, with the voltage regulator disabled. \r\n      The 1.2V domain is consequently powered off. The PLL, the HSI oscillator and \r\n      the HSE oscillator are also switched off. SRAM and register contents are lost \r\n      except for the RTC registers, RTC backup registers, backup SRAM and Standby \r\n      circuitry.\r\n   \r\n      The voltage regulator is OFF.\r\n      \r\n      (++) Entry:\r\n        (+++) The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.\r\n      (++) Exit:\r\n        (+++) WKUP pin rising edge, RTC alarm (Alarm A and Alarm B), RTC wake-up,\r\n             tamper event, time-stamp event, external reset in NRST pin, IWDG reset.\r\n\r\n   *** Auto-wake-up (AWU) from low-power mode ***\r\n   =============================================\r\n    [..]\r\n    \r\n     (+) The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC \r\n      Wake-up event, a tamper event or a time-stamp event, without depending on \r\n      an external interrupt (Auto-wake-up mode).\r\n\r\n      (+) RTC auto-wake-up (AWU) from the Stop and Standby modes\r\n       \r\n        (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to \r\n              configure the RTC to generate the RTC alarm using the HAL_RTC_SetAlarm_IT() function.\r\n\r\n        (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it \r\n             is necessary to configure the RTC to detect the tamper or time stamp event using the\r\n                HAL_RTCEx_SetTimeStamp_IT() or HAL_RTCEx_SetTamper_IT() functions.\r\n                  \r\n        (++) To wake up from the Stop mode with an RTC Wake-up event, it is necessary to\r\n              configure the RTC to generate the RTC Wake-up event using the HAL_RTCEx_SetWakeUpTimer_IT() function.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Configures the voltage threshold detected by the Power Voltage Detector(PVD).\r\n  * @param sConfigPVD pointer to an PWR_PVDTypeDef structure that contains the configuration\r\n  *        information for the PVD.\r\n  * @note Refer to the electrical characteristics of your device datasheet for\r\n  *         more details about the voltage threshold corresponding to each \r\n  *         detection level.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));\r\n  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));\r\n  \r\n  /* Set PLS[7:5] bits according to PVDLevel value */\r\n  MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);\r\n  \r\n  /* Clear any previous config. Keep it clear if no event or IT mode is selected */\r\n  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();\r\n  __HAL_PWR_PVD_EXTI_DISABLE_IT();\r\n  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();\r\n  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); \r\n\r\n  /* Configure interrupt mode */\r\n  if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)\r\n  {\r\n    __HAL_PWR_PVD_EXTI_ENABLE_IT();\r\n  }\r\n  \r\n  /* Configure event mode */\r\n  if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)\r\n  {\r\n    __HAL_PWR_PVD_EXTI_ENABLE_EVENT();\r\n  }\r\n  \r\n  /* Configure the edge */\r\n  if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)\r\n  {\r\n    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();\r\n  }\r\n  \r\n  if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)\r\n  {\r\n    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Enables the Power Voltage Detector(PVD).\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnablePVD(void)\r\n{\r\n  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)ENABLE;\r\n}\r\n\r\n/**\r\n  * @brief Disables the Power Voltage Detector(PVD).\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_DisablePVD(void)\r\n{\r\n  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)DISABLE;\r\n}\r\n\r\n/**\r\n  * @brief Enables the Wake-up PINx functionality.\r\n  * @param WakeUpPinx Specifies the Power Wake-Up pin to enable.\r\n  *         This parameter can be one of the following values:\r\n  *           @arg PWR_WAKEUP_PIN1\r\n  *           @arg PWR_WAKEUP_PIN2 available only on STM32F410xx/STM32F446xx/STM32F412xx/STM32F413xx/STM32F423xx devices\r\n  *           @arg PWR_WAKEUP_PIN3 available only on STM32F410xx/STM32F412xx/STM32F413xx/STM32F423xx devices\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));\r\n\r\n  /* Enable the wake up pin */\r\n  SET_BIT(PWR->CSR, WakeUpPinx);\r\n}\r\n\r\n/**\r\n  * @brief Disables the Wake-up PINx functionality.\r\n  * @param WakeUpPinx Specifies the Power Wake-Up pin to disable.\r\n  *         This parameter can be one of the following values:\r\n  *           @arg PWR_WAKEUP_PIN1\r\n  *           @arg PWR_WAKEUP_PIN2 available only on STM32F410xx/STM32F446xx/STM32F412xx/STM32F413xx/STM32F423xx devices\r\n  *           @arg PWR_WAKEUP_PIN3 available only on STM32F410xx/STM32F412xx/STM32F413xx/STM32F423xx devices\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));  \r\n\r\n  /* Disable the wake up pin */\r\n  CLEAR_BIT(PWR->CSR, WakeUpPinx);\r\n}\r\n  \r\n/**\r\n  * @brief Enters Sleep mode.\r\n  *   \r\n  * @note In Sleep mode, all I/O pins keep the same state as in Run mode.\r\n  * \r\n  * @note In Sleep mode, the systick is stopped to avoid exit from this mode with\r\n  *       systick interrupt when used as time base for Timeout \r\n  *                \r\n  * @param Regulator Specifies the regulator state in SLEEP mode.\r\n  *            This parameter can be one of the following values:\r\n  *            @arg PWR_MAINREGULATOR_ON: SLEEP mode with regulator ON\r\n  *            @arg PWR_LOWPOWERREGULATOR_ON: SLEEP mode with low power regulator ON\r\n  * @note This parameter is not used for the STM32F4 family and is kept as parameter\r\n  *       just to maintain compatibility with the lower power families.\r\n  * @param SLEEPEntry Specifies if SLEEP mode in entered with WFI or WFE instruction.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction\r\n  *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_PWR_REGULATOR(Regulator));\r\n  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));\r\n\r\n  /* Clear SLEEPDEEP bit of Cortex System Control Register */\r\n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\r\n\r\n  /* Select SLEEP mode entry -------------------------------------------------*/\r\n  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)\r\n  {   \r\n    /* Request Wait For Interrupt */\r\n    __WFI();\r\n  }\r\n  else\r\n  {\r\n    /* Request Wait For Event */\r\n    __SEV();\r\n    __WFE();\r\n    __WFE();\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Enters Stop mode. \r\n  * @note In Stop mode, all I/O pins keep the same state as in Run mode.\r\n  * @note When exiting Stop mode by issuing an interrupt or a wake-up event, \r\n  *         the HSI RC oscillator is selected as system clock.\r\n  * @note When the voltage regulator operates in low power mode, an additional \r\n  *         startup delay is incurred when waking up from Stop mode. \r\n  *         By keeping the internal regulator ON during Stop mode, the consumption \r\n  *         is higher although the startup time is reduced.    \r\n  * @param Regulator Specifies the regulator state in Stop mode.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_MAINREGULATOR_ON: Stop mode with regulator ON\r\n  *            @arg PWR_LOWPOWERREGULATOR_ON: Stop mode with low power regulator ON\r\n  * @param STOPEntry Specifies if Stop mode in entered with WFI or WFE instruction.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_STOPENTRY_WFI: Enter Stop mode with WFI instruction\r\n  *            @arg PWR_STOPENTRY_WFE: Enter Stop mode with WFE instruction\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_PWR_REGULATOR(Regulator));\r\n  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));\r\n  \r\n  /* Select the regulator state in Stop mode: Set PDDS and LPDS bits according to PWR_Regulator value */\r\n  MODIFY_REG(PWR->CR, (PWR_CR_PDDS | PWR_CR_LPDS), Regulator);\r\n  \r\n  /* Set SLEEPDEEP bit of Cortex System Control Register */\r\n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\r\n  \r\n  /* Select Stop mode entry --------------------------------------------------*/\r\n  if(STOPEntry == PWR_STOPENTRY_WFI)\r\n  {   \r\n    /* Request Wait For Interrupt */\r\n    __WFI();\r\n  }\r\n  else\r\n  {\r\n    /* Request Wait For Event */\r\n    __SEV();\r\n    __WFE();\r\n    __WFE();\r\n  }\r\n  /* Reset SLEEPDEEP bit of Cortex System Control Register */\r\n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  \r\n}\r\n\r\n/**\r\n  * @brief Enters Standby mode.\r\n  * @note In Standby mode, all I/O pins are high impedance except for:\r\n  *          - Reset pad (still available) \r\n  *          - RTC_AF1 pin (PC13) if configured for tamper, time-stamp, RTC \r\n  *            Alarm out, or RTC clock calibration out.\r\n  *          - RTC_AF2 pin (PI8) if configured for tamper or time-stamp.  \r\n  *          - WKUP pin 1 (PA0) if enabled.       \r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnterSTANDBYMode(void)\r\n{\r\n  /* Select Standby mode */\r\n  SET_BIT(PWR->CR, PWR_CR_PDDS);\r\n\r\n  /* Set SLEEPDEEP bit of Cortex System Control Register */\r\n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\r\n  \r\n  /* This option is used to ensure that store operations are completed */\r\n#if defined ( __CC_ARM)\r\n  __force_stores();\r\n#endif\r\n  /* Request Wait For Interrupt */\r\n  __WFI();\r\n}\r\n\r\n/**\r\n  * @brief This function handles the PWR PVD interrupt request.\r\n  * @note This API should be called under the PVD_IRQHandler().\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_PVD_IRQHandler(void)\r\n{\r\n  /* Check PWR Exti flag */\r\n  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)\r\n  {\r\n    /* PWR PVD interrupt user callback */\r\n    HAL_PWR_PVDCallback();\r\n    \r\n    /* Clear PWR Exti pending bit */\r\n    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  PWR PVD interrupt callback\r\n  * @retval None\r\n  */\r\n__weak void HAL_PWR_PVDCallback(void)\r\n{\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_PWR_PVDCallback could be implemented in the user file\r\n   */ \r\n}\r\n\r\n/**\r\n  * @brief Indicates Sleep-On-Exit when returning from Handler mode to Thread mode. \r\n  * @note Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor \r\n  *       re-enters SLEEP mode when an interruption handling is over.\r\n  *       Setting this bit is useful when the processor is expected to run only on\r\n  *       interruptions handling.         \r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnableSleepOnExit(void)\r\n{\r\n  /* Set SLEEPONEXIT bit of Cortex System Control Register */\r\n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));\r\n}\r\n\r\n/**\r\n  * @brief Disables Sleep-On-Exit feature when returning from Handler mode to Thread mode. \r\n  * @note Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor \r\n  *       re-enters SLEEP mode when an interruption handling is over.          \r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_DisableSleepOnExit(void)\r\n{\r\n  /* Clear SLEEPONEXIT bit of Cortex System Control Register */\r\n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));\r\n}\r\n\r\n/**\r\n  * @brief Enables CORTEX M4 SEVONPEND bit. \r\n  * @note Sets SEVONPEND bit of SCR register. When this bit is set, this causes \r\n  *       WFE to wake up when an interrupt moves from inactive to pended.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_EnableSEVOnPend(void)\r\n{\r\n  /* Set SEVONPEND bit of Cortex System Control Register */\r\n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));\r\n}\r\n\r\n/**\r\n  * @brief Disables CORTEX M4 SEVONPEND bit. \r\n  * @note Clears SEVONPEND bit of SCR register. When this bit is set, this causes \r\n  *       WFE to wake up when an interrupt moves from inactive to pended.         \r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_DisableSEVOnPend(void)\r\n{\r\n  /* Clear SEVONPEND bit of Cortex System Control Register */\r\n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n  \r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_PWR_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_pwr_ex.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_pwr_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   Extended PWR HAL module driver.\r\n  *          This file provides firmware functions to manage the following \r\n  *          functionalities of PWR extension peripheral:           \r\n  *           + Peripheral Extended features functions\r\n  *         \r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */ \r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PWREx PWREx\r\n  * @brief PWR HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_PWR_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup PWREx_Private_Constants\r\n  * @{\r\n  */    \r\n#define PWR_OVERDRIVE_TIMEOUT_VALUE  1000U\r\n#define PWR_UDERDRIVE_TIMEOUT_VALUE  1000U\r\n#define PWR_BKPREG_TIMEOUT_VALUE     1000U\r\n#define PWR_VOSRDY_TIMEOUT_VALUE     1000U\r\n/**\r\n  * @}\r\n  */\r\n\r\n   \r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/** @defgroup PWREx_Exported_Functions PWREx Exported Functions\r\n  *  @{\r\n  */\r\n\r\n/** @defgroup PWREx_Exported_Functions_Group1 Peripheral Extended features functions \r\n  *  @brief Peripheral Extended features functions \r\n  *\r\n@verbatim   \r\n\r\n ===============================================================================\r\n                 ##### Peripheral extended features functions #####\r\n ===============================================================================\r\n\r\n    *** Main and Backup Regulators configuration ***\r\n    ================================================\r\n    [..] \r\n      (+) The backup domain includes 4 Kbytes of backup SRAM accessible only from \r\n          the CPU, and address in 32-bit, 16-bit or 8-bit mode. Its content is \r\n          retained even in Standby or VBAT mode when the low power backup regulator\r\n          is enabled. It can be considered as an internal EEPROM when VBAT is \r\n          always present. You can use the HAL_PWREx_EnableBkUpReg() function to \r\n          enable the low power backup regulator. \r\n\r\n      (+) When the backup domain is supplied by VDD (analog switch connected to VDD) \r\n          the backup SRAM is powered from VDD which replaces the VBAT power supply to \r\n          save battery life.\r\n\r\n      (+) The backup SRAM is not mass erased by a tamper event. It is read \r\n          protected to prevent confidential data, such as cryptographic private \r\n          key, from being accessed. The backup SRAM can be erased only through \r\n          the Flash interface when a protection level change from level 1 to \r\n          level 0 is requested. \r\n      -@- Refer to the description of Read protection (RDP) in the Flash \r\n          programming manual.\r\n\r\n      (+) The main internal regulator can be configured to have a tradeoff between \r\n          performance and power consumption when the device does not operate at \r\n          the maximum frequency. This is done through __HAL_PWR_MAINREGULATORMODE_CONFIG() \r\n          macro which configure VOS bit in PWR_CR register\r\n          \r\n        Refer to the product datasheets for more details.\r\n\r\n    *** FLASH Power Down configuration ****\r\n    =======================================\r\n    [..] \r\n      (+) By setting the FPDS bit in the PWR_CR register by using the \r\n          HAL_PWREx_EnableFlashPowerDown() function, the Flash memory also enters power \r\n          down mode when the device enters Stop mode. When the Flash memory \r\n          is in power down mode, an additional startup delay is incurred when \r\n          waking up from Stop mode.\r\n          \r\n           (+) For STM32F42xxx/43xxx/446xx/469xx/479xx Devices, the scale can be modified only when the PLL \r\n           is OFF and the HSI or HSE clock source is selected as system clock. \r\n           The new value programmed is active only when the PLL is ON.\r\n           When the PLL is OFF, the voltage scale 3 is automatically selected. \r\n        Refer to the datasheets for more details.\r\n\r\n    *** Over-Drive and Under-Drive configuration ****\r\n    =================================================\r\n    [..]         \r\n       (+) For STM32F42xxx/43xxx/446xx/469xx/479xx Devices, in Run mode: the main regulator has\r\n           2 operating modes available:\r\n        (++) Normal mode: The CPU and core logic operate at maximum frequency at a given \r\n             voltage scaling (scale 1, scale 2 or scale 3)\r\n        (++) Over-drive mode: This mode allows the CPU and the core logic to operate at a \r\n            higher frequency than the normal mode for a given voltage scaling (scale 1,  \r\n            scale 2 or scale 3). This mode is enabled through HAL_PWREx_EnableOverDrive() function and\r\n            disabled by HAL_PWREx_DisableOverDrive() function, to enter or exit from Over-drive mode please follow \r\n            the sequence described in Reference manual.\r\n             \r\n       (+) For STM32F42xxx/43xxx/446xx/469xx/479xx Devices, in Stop mode: the main regulator or low power regulator \r\n           supplies a low power voltage to the 1.2V domain, thus preserving the content of registers \r\n           and internal SRAM. 2 operating modes are available:\r\n         (++) Normal mode: the 1.2V domain is preserved in nominal leakage mode. This mode is only \r\n              available when the main regulator or the low power regulator is used in Scale 3 or \r\n              low voltage mode.\r\n         (++) Under-drive mode: the 1.2V domain is preserved in reduced leakage mode. This mode is only\r\n              available when the main regulator or the low power regulator is in low voltage mode.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Enables the Backup Regulator.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)\r\n{\r\n  uint32_t tickstart = 0U;\r\n\r\n  *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)ENABLE;\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Wait till Backup regulator ready flag is set */  \r\n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    } \r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Disables the Backup Regulator.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)\r\n{\r\n  uint32_t tickstart = 0U;\r\n\r\n  *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)DISABLE;\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Wait till Backup regulator ready flag is set */  \r\n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    } \r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Enables the Flash Power Down in Stop mode.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_EnableFlashPowerDown(void)\r\n{\r\n  *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)ENABLE;\r\n}\r\n\r\n/**\r\n  * @brief Disables the Flash Power Down in Stop mode.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_DisableFlashPowerDown(void)\r\n{\r\n  *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)DISABLE;\r\n}\r\n\r\n/**\r\n  * @brief Return Voltage Scaling Range.\r\n  * @retval The configured scale for the regulator voltage(VOS bit field).\r\n  *         The returned value can be one of the following:\r\n  *            - @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output Scale 1 mode\r\n  *            - @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output Scale 2 mode\r\n  *            - @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output Scale 3 mode\r\n  */  \r\nuint32_t HAL_PWREx_GetVoltageRange(void)\r\n{\r\n  return (PWR->CR & PWR_CR_VOS);\r\n}\r\n\r\n#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)\r\n/**\r\n  * @brief Configures the main internal regulator output voltage.\r\n  * @param  VoltageScaling specifies the regulator output voltage to achieve\r\n  *         a tradeoff between performance and power consumption.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output range 1 mode,\r\n  *                                               the maximum value of fHCLK = 168 MHz.\r\n  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output range 2 mode,\r\n  *                                               the maximum value of fHCLK = 144 MHz.\r\n  * @note  When moving from Range 1 to Range 2, the system frequency must be decreased to\r\n  *        a value below 144 MHz before calling HAL_PWREx_ConfigVoltageScaling() API.\r\n  *        When moving from Range 2 to Range 1, the system frequency can be increased to\r\n  *        a value up to 168 MHz after calling HAL_PWREx_ConfigVoltageScaling() API.\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)\r\n{\r\n  uint32_t tickstart = 0U;\r\n  \r\n  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));\r\n  \r\n  /* Enable PWR RCC Clock Peripheral */\r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n  \r\n  /* Set Range */\r\n  __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);\r\n  \r\n  /* Get Start Tick*/\r\n  tickstart = HAL_GetTick();\r\n  while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    } \r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n#elif defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \\\r\n      defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || \\\r\n      defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) || \\\r\n      defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || \\\r\n      defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)\r\n/**\r\n  * @brief Configures the main internal regulator output voltage.\r\n  * @param  VoltageScaling specifies the regulator output voltage to achieve\r\n  *         a tradeoff between performance and power consumption.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output range 1 mode,\r\n  *                                               the maximum value of fHCLK is 168 MHz. It can be extended to\r\n  *                                               180 MHz by activating the over-drive mode.\r\n  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output range 2 mode,\r\n  *                                               the maximum value of fHCLK is 144 MHz. It can be extended to,                \r\n  *                                               168 MHz by activating the over-drive mode.\r\n  *            @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output range 3 mode,\r\n  *                                               the maximum value of fHCLK is 120 MHz.\r\n  * @note To update the system clock frequency(SYSCLK):\r\n  *        - Set the HSI or HSE as system clock frequency using the HAL_RCC_ClockConfig().\r\n  *        - Call the HAL_RCC_OscConfig() to configure the PLL.\r\n  *        - Call HAL_PWREx_ConfigVoltageScaling() API to adjust the voltage scale.\r\n  *        - Set the new system clock frequency using the HAL_RCC_ClockConfig().\r\n  * @note The scale can be modified only when the HSI or HSE clock source is selected \r\n  *        as system clock source, otherwise the API returns HAL_ERROR.  \r\n  * @note When the PLL is OFF, the voltage scale 3 is automatically selected and the VOS bits\r\n  *       value in the PWR_CR1 register are not taken in account.\r\n  * @note This API forces the PLL state ON to allow the possibility to configure the voltage scale 1 or 2.\r\n  * @note The new voltage scale is active only when the PLL is ON.  \r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)\r\n{\r\n  uint32_t tickstart = 0U;\r\n  \r\n  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));\r\n  \r\n  /* Enable PWR RCC Clock Peripheral */\r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n  \r\n  /* Check if the PLL is used as system clock or not */\r\n  if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)\r\n  {\r\n    /* Disable the main PLL */\r\n    __HAL_RCC_PLL_DISABLE();\r\n    \r\n    /* Get Start Tick */\r\n    tickstart = HAL_GetTick();    \r\n    /* Wait till PLL is disabled */  \r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n    \r\n    /* Set Range */\r\n    __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);\r\n    \r\n    /* Enable the main PLL */\r\n    __HAL_RCC_PLL_ENABLE();\r\n    \r\n    /* Get Start Tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLL is ready */  \r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      } \r\n    }\r\n    \r\n    /* Get Start Tick */\r\n    tickstart = HAL_GetTick();\r\n    while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      } \r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */\r\n\r\n#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\\\r\n    defined(STM32F411xE) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\\\r\n    defined(STM32F413xx) || defined(STM32F423xx)\r\n/**\r\n  * @brief Enables Main Regulator low voltage mode.\r\n  * @note  This mode is only available for STM32F401xx/STM32F410xx/STM32F411xx/STM32F412Zx/STM32F412Rx/STM32F412Vx/STM32F412Cx/\r\n  *        STM32F413xx/STM32F423xx devices.   \r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_EnableMainRegulatorLowVoltage(void)\r\n{\r\n  *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)ENABLE;\r\n}\r\n\r\n/**\r\n  * @brief Disables Main Regulator low voltage mode.\r\n  * @note  This mode is only available for STM32F401xx/STM32F410xx/STM32F411xx/STM32F412Zx/STM32F412Rx/STM32F412Vx/STM32F412Cx/\r\n  *        STM32F413xx/STM32F423xxdevices. \r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_DisableMainRegulatorLowVoltage(void)\r\n{\r\n  *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)DISABLE;\r\n}\r\n\r\n/**\r\n  * @brief Enables Low Power Regulator low voltage mode.\r\n  * @note  This mode is only available for STM32F401xx/STM32F410xx/STM32F411xx/STM32F412Zx/STM32F412Rx/STM32F412Vx/STM32F412Cx/\r\n  *        STM32F413xx/STM32F423xx devices.   \r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_EnableLowRegulatorLowVoltage(void)\r\n{\r\n  *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)ENABLE;\r\n}\r\n\r\n/**\r\n  * @brief Disables Low Power Regulator low voltage mode.\r\n  * @note  This mode is only available for STM32F401xx/STM32F410xx/STM32F411xx/STM32F412Zx/STM32F412Rx/STM32F412Vx/STM32F412Cx/\r\n  *        STM32F413xx/STM32F423xx  devices.   \r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_DisableLowRegulatorLowVoltage(void)\r\n{\r\n  *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)DISABLE;\r\n}\r\n\r\n#endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx ||\r\n          STM32F413xx || STM32F423xx */\r\n\r\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\\\r\n    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)\r\n/**\r\n  * @brief  Activates the Over-Drive mode.\r\n  * @note   This function can be used only for STM32F42xx/STM32F43xx/STM32F446xx/STM32F469xx/STM32F479xx devices.\r\n  *         This mode allows the CPU and the core logic to operate at a higher frequency\r\n  *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).   \r\n  * @note   It is recommended to enter or exit Over-drive mode when the application is not running \r\n  *         critical tasks and when the system clock source is either HSI or HSE. \r\n  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   \r\n  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   \r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)\r\n{\r\n  uint32_t tickstart = 0U;\r\n\r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n  \r\n  /* Enable the Over-drive to extend the clock frequency to 180 Mhz */\r\n  __HAL_PWR_OVERDRIVE_ENABLE();\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))\r\n  {\r\n    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n  \r\n  /* Enable the Over-drive switch */\r\n  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  } \r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Deactivates the Over-Drive mode.\r\n  * @note   This function can be used only for STM32F42xx/STM32F43xx/STM32F446xx/STM32F469xx/STM32F479xx devices.\r\n  *         This mode allows the CPU and the core logic to operate at a higher frequency\r\n  *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).    \r\n  * @note   It is recommended to enter or exit Over-drive mode when the application is not running \r\n  *         critical tasks and when the system clock source is either HSI or HSE. \r\n  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   \r\n  *         The peripheral clocks must be enabled once the Over-drive mode is activated.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)\r\n{\r\n  uint32_t tickstart = 0U;\r\n  \r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n    \r\n  /* Disable the Over-drive switch */\r\n  __HAL_PWR_OVERDRIVESWITCHING_DISABLE();\r\n  \r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n \r\n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))\r\n  {\r\n    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  } \r\n  \r\n  /* Disable the Over-drive */\r\n  __HAL_PWR_OVERDRIVE_DISABLE();\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))\r\n  {\r\n    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n  \r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Enters in Under-Drive STOP mode.\r\n  *  \r\n  * @note   This mode is only available for STM32F42xxx/STM32F43xxx/STM32F446xx/STM32F469xx/STM32F479xx devices.\r\n  * \r\n  * @note    This mode can be selected only when the Under-Drive is already active \r\n  *   \r\n  * @note    This mode is enabled only with STOP low power mode.\r\n  *          In this mode, the 1.2V domain is preserved in reduced leakage mode. This \r\n  *          mode is only available when the main regulator or the low power regulator \r\n  *          is in low voltage mode\r\n  *        \r\n  * @note   If the Under-drive mode was enabled, it is automatically disabled after \r\n  *         exiting Stop mode. \r\n  *         When the voltage regulator operates in Under-drive mode, an additional  \r\n  *         startup delay is induced when waking up from Stop mode.\r\n  *                    \r\n  * @note   In Stop mode, all I/O pins keep the same state as in Run mode.\r\n  *   \r\n  * @note   When exiting Stop mode by issuing an interrupt or a wake-up event, \r\n  *         the HSI RC oscillator is selected as system clock.\r\n  *           \r\n  * @note   When the voltage regulator operates in low power mode, an additional \r\n  *         startup delay is incurred when waking up from Stop mode. \r\n  *         By keeping the internal regulator ON during Stop mode, the consumption \r\n  *         is higher although the startup time is reduced.\r\n  *     \r\n  * @param  Regulator specifies the regulator state in STOP mode.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_MAINREGULATOR_UNDERDRIVE_ON:  Main Regulator in under-drive mode \r\n  *                 and Flash memory in power-down when the device is in Stop under-drive mode\r\n  *            @arg PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON:  Low Power Regulator in under-drive mode \r\n  *                and Flash memory in power-down when the device is in Stop under-drive mode\r\n  * @param  STOPEntry specifies if STOP mode in entered with WFI or WFE instruction.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_SLEEPENTRY_WFI: enter STOP mode with WFI instruction\r\n  *            @arg PWR_SLEEPENTRY_WFE: enter STOP mode with WFE instruction\r\n  * @retval None\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)\r\n{\r\n  uint32_t tmpreg1 = 0U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));\r\n  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));\r\n  \r\n  /* Enable Power ctrl clock */\r\n  __HAL_RCC_PWR_CLK_ENABLE();\r\n  /* Enable the Under-drive Mode ---------------------------------------------*/\r\n  /* Clear Under-drive flag */\r\n  __HAL_PWR_CLEAR_ODRUDR_FLAG();\r\n  \r\n  /* Enable the Under-drive */ \r\n  __HAL_PWR_UNDERDRIVE_ENABLE();\r\n\r\n  /* Select the regulator state in STOP mode ---------------------------------*/\r\n  tmpreg1 = PWR->CR;\r\n  /* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */\r\n  tmpreg1 &= (uint32_t)~(PWR_CR_PDDS | PWR_CR_LPDS | PWR_CR_LPUDS | PWR_CR_MRUDS);\r\n  \r\n  /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */\r\n  tmpreg1 |= Regulator;\r\n  \r\n  /* Store the new value */\r\n  PWR->CR = tmpreg1;\r\n  \r\n  /* Set SLEEPDEEP bit of Cortex System Control Register */\r\n  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;\r\n  \r\n  /* Select STOP mode entry --------------------------------------------------*/\r\n  if(STOPEntry == PWR_SLEEPENTRY_WFI)\r\n  {   \r\n    /* Request Wait For Interrupt */\r\n    __WFI();\r\n  }\r\n  else\r\n  {\r\n    /* Request Wait For Event */\r\n    __WFE();\r\n  }\r\n  /* Reset SLEEPDEEP bit of Cortex System Control Register */\r\n  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);\r\n\r\n  return HAL_OK;  \r\n}\r\n\r\n#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_PWR_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_rcc.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_rcc.c\r\n  * @author  MCD Application Team\r\n  * @brief   RCC HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Reset and Clock Control (RCC) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + Peripheral Control functions\r\n  *\r\n  @verbatim\r\n  ==============================================================================\r\n                      ##### RCC specific features #####\r\n  ==============================================================================\r\n    [..]\r\n      After reset the device is running from Internal High Speed oscillator\r\n      (HSI 16MHz) with Flash 0 wait state, Flash prefetch buffer, D-Cache\r\n      and I-Cache are disabled, and all peripherals are off except internal\r\n      SRAM, Flash and JTAG.\r\n      (+) There is no prescaler on High speed (AHB) and Low speed (APB) busses;\r\n          all peripherals mapped on these busses are running at HSI speed.\r\n      (+) The clock for all peripherals is switched off, except the SRAM and FLASH.\r\n      (+) All GPIOs are in input floating state, except the JTAG pins which\r\n          are assigned to be used for debug purpose.\r\n\r\n    [..]\r\n      Once the device started from reset, the user application has to:\r\n      (+) Configure the clock source to be used to drive the System clock\r\n          (if the application needs higher frequency/performance)\r\n      (+) Configure the System clock frequency and Flash settings\r\n      (+) Configure the AHB and APB busses prescalers\r\n      (+) Enable the clock for the peripheral(s) to be used\r\n      (+) Configure the clock source(s) for peripherals which clocks are not\r\n          derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG)\r\n\r\n                      ##### RCC Limitations #####\r\n  ==============================================================================\r\n    [..]\r\n      A delay between an RCC peripheral clock enable and the effective peripheral\r\n      enabling should be taken into account in order to manage the peripheral read/write\r\n      from/to registers.\r\n      (+) This delay depends on the peripheral mapping.\r\n      (+) If peripheral is mapped on AHB: the delay is 2 AHB clock cycle\r\n          after the clock enable bit is set on the hardware register\r\n      (+) If peripheral is mapped on APB: the delay is 2 APB clock cycle\r\n          after the clock enable bit is set on the hardware register\r\n\r\n    [..]\r\n      Implemented Workaround:\r\n      (+) For AHB & APB peripherals, a dummy read to the peripheral register has been\r\n          inserted in each __HAL_RCC_PPP_CLK_ENABLE() macro.\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup RCC RCC\r\n  * @brief RCC HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_RCC_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup RCC_Private_Constants\r\n  * @{\r\n  */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n#define __MCO1_CLK_ENABLE()   __HAL_RCC_GPIOA_CLK_ENABLE()\r\n#define MCO1_GPIO_PORT        GPIOA\r\n#define MCO1_PIN              GPIO_PIN_8\r\n\r\n#define __MCO2_CLK_ENABLE()   __HAL_RCC_GPIOC_CLK_ENABLE()\r\n#define MCO2_GPIO_PORT         GPIOC\r\n#define MCO2_PIN               GPIO_PIN_9\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/** @defgroup RCC_Private_Variables RCC Private Variables\r\n  * @{\r\n  */\r\n/**\r\n  * @}\r\n  */\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/** @defgroup RCC_Exported_Functions RCC Exported Functions\r\n  *  @{\r\n  */\r\n\r\n/** @defgroup RCC_Exported_Functions_Group1 Initialization and de-initialization functions\r\n *  @brief    Initialization and Configuration functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n           ##### Initialization and de-initialization functions #####\r\n ===============================================================================\r\n    [..]\r\n      This section provides functions allowing to configure the internal/external oscillators\r\n      (HSE, HSI, LSE, LSI, PLL, CSS and MCO) and the System busses clocks (SYSCLK, AHB, APB1\r\n       and APB2).\r\n\r\n    [..] Internal/external clock and PLL configuration\r\n         (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through\r\n             the PLL as System clock source.\r\n\r\n         (#) LSI (low-speed internal), 32 KHz low consumption RC used as IWDG and/or RTC\r\n             clock source.\r\n\r\n         (#) HSE (high-speed external), 4 to 26 MHz crystal oscillator used directly or\r\n             through the PLL as System clock source. Can be used also as RTC clock source.\r\n\r\n         (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.\r\n\r\n         (#) PLL (clocked by HSI or HSE), featuring two different output clocks:\r\n           (++) The first output is used to generate the high speed system clock (up to 168 MHz)\r\n           (++) The second output is used to generate the clock for the USB OTG FS (48 MHz),\r\n                the random analog generator (<=48 MHz) and the SDIO (<= 48 MHz).\r\n\r\n         (#) CSS (Clock security system), once enable using the macro __HAL_RCC_CSS_ENABLE()\r\n             and if a HSE clock failure occurs(HSE used directly or through PLL as System\r\n             clock source), the System clocks automatically switched to HSI and an interrupt\r\n             is generated if enabled. The interrupt is linked to the Cortex-M4 NMI\r\n             (Non-Maskable Interrupt) exception vector.\r\n\r\n         (#) MCO1 (microcontroller clock output), used to output HSI, LSE, HSE or PLL\r\n             clock (through a configurable prescaler) on PA8 pin.\r\n\r\n         (#) MCO2 (microcontroller clock output), used to output HSE, PLL, SYSCLK or PLLI2S\r\n             clock (through a configurable prescaler) on PC9 pin.\r\n\r\n    [..] System, AHB and APB busses clocks configuration\r\n         (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,\r\n             HSE and PLL.\r\n             The AHB clock (HCLK) is derived from System clock through configurable\r\n             prescaler and used to clock the CPU, memory and peripherals mapped\r\n             on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived\r\n             from AHB clock through configurable prescalers and used to clock\r\n             the peripherals mapped on these busses. You can use\r\n             \"HAL_RCC_GetSysClockFreq()\" function to retrieve the frequencies of these clocks.\r\n\r\n         (#) For the STM32F405xx/07xx and STM32F415xx/17xx devices, the maximum\r\n             frequency of the SYSCLK and HCLK is 168 MHz, PCLK2 84 MHz and PCLK1 42 MHz.\r\n             Depending on the device voltage range, the maximum frequency should\r\n             be adapted accordingly (refer to the product datasheets for more details).\r\n\r\n         (#) For the STM32F42xxx, STM32F43xxx, STM32F446xx, STM32F469xx and STM32F479xx devices,\r\n             the maximum frequency of the SYSCLK and HCLK is 180 MHz, PCLK2 90 MHz and PCLK1 45 MHz.\r\n             Depending on the device voltage range, the maximum frequency should\r\n             be adapted accordingly (refer to the product datasheets for more details).\r\n\r\n         (#) For the STM32F401xx, the maximum frequency of the SYSCLK and HCLK is 84 MHz,\r\n             PCLK2 84 MHz and PCLK1 42 MHz.\r\n             Depending on the device voltage range, the maximum frequency should\r\n             be adapted accordingly (refer to the product datasheets for more details).\r\n\r\n         (#) For the STM32F41xxx, the maximum frequency of the SYSCLK and HCLK is 100 MHz,\r\n             PCLK2 100 MHz and PCLK1 50 MHz.\r\n             Depending on the device voltage range, the maximum frequency should\r\n             be adapted accordingly (refer to the product datasheets for more details).\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Resets the RCC clock configuration to the default reset state.\r\n  * @note   The default reset state of the clock configuration is given below:\r\n  *            - HSI ON and used as system clock source\r\n  *            - HSE and PLL OFF\r\n  *            - AHB, APB1 and APB2 prescaler set to 1.\r\n  *            - CSS, MCO1 and MCO2 OFF\r\n  *            - All interrupts disabled\r\n  * @note   This function doesn't modify the configuration of the\r\n  *            - Peripheral clocks\r\n  *            - LSI, LSE and RTC clocks\r\n  * @retval HAL status\r\n  */\r\n__weak HAL_StatusTypeDef HAL_RCC_DeInit(void)\r\n{\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the RCC Oscillators according to the specified parameters in the\r\n  *         RCC_OscInitTypeDef.\r\n  * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that\r\n  *         contains the configuration information for the RCC Oscillators.\r\n  * @note   The PLL is not disabled when used as system clock.\r\n  * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not\r\n  *         supported by this API. User should request a transition to LSE Off\r\n  *         first and then LSE On or LSE Bypass.\r\n  * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not\r\n  *         supported by this API. User should request a transition to HSE Off\r\n  *         first and then HSE On or HSE Bypass.\r\n  * @retval HAL status\r\n  */\r\n__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)\r\n{\r\n  uint32_t tickstart, pll_config;\r\n\r\n  /* Check Null pointer */\r\n  if(RCC_OscInitStruct == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));\r\n  /*------------------------------- HSE Configuration ------------------------*/\r\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));\r\n    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */\r\n    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\\\r\n      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))\r\n    {\r\n      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Set the new HSE configuration ---------------------------------------*/\r\n      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);\r\n\r\n      /* Check the HSE State */\r\n      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)\r\n      {\r\n        /* Get Start Tick */\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSE is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Get Start Tick */\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSE is bypassed or disabled */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /*----------------------------- HSI Configuration --------------------------*/\r\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));\r\n    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));\r\n\r\n    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */\r\n    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\\\r\n      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))\r\n    {\r\n      /* When HSI is used as system clock it will not disabled */\r\n      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      /* Otherwise, just the calibration is allowed */\r\n      else\r\n      {\r\n        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/\r\n        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Check the HSI State */\r\n      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)\r\n      {\r\n        /* Enable the Internal High Speed oscillator (HSI). */\r\n        __HAL_RCC_HSI_ENABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSI is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n\r\n        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */\r\n        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);\r\n      }\r\n      else\r\n      {\r\n        /* Disable the Internal High Speed oscillator (HSI). */\r\n        __HAL_RCC_HSI_DISABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSI is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /*------------------------------ LSI Configuration -------------------------*/\r\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));\r\n\r\n    /* Check the LSI State */\r\n    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)\r\n    {\r\n      /* Enable the Internal Low Speed oscillator (LSI). */\r\n      __HAL_RCC_LSI_ENABLE();\r\n\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSI is ready */\r\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)\r\n      {\r\n        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Disable the Internal Low Speed oscillator (LSI). */\r\n      __HAL_RCC_LSI_DISABLE();\r\n\r\n      /* Get Start Tick */\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSI is ready */\r\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)\r\n      {\r\n        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /*------------------------------ LSE Configuration -------------------------*/\r\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)\r\n  {\r\n    FlagStatus       pwrclkchanged = RESET;\r\n\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));\r\n\r\n    /* Update LSE configuration in Backup Domain control register    */\r\n    /* Requires to enable write access to Backup Domain of necessary */\r\n    if(__HAL_RCC_PWR_IS_CLK_DISABLED())\r\n    {\r\n      __HAL_RCC_PWR_CLK_ENABLE();\r\n      pwrclkchanged = SET;\r\n    }\r\n\r\n    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))\r\n    {\r\n      /* Enable write access to Backup domain */\r\n      SET_BIT(PWR->CR, PWR_CR_DBP);\r\n\r\n      /* Wait for Backup domain Write protection disable */\r\n      tickstart = HAL_GetTick();\r\n\r\n      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))\r\n      {\r\n        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Set the new LSE configuration -----------------------------------------*/\r\n    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);\r\n    /* Check the LSE State */\r\n    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)\r\n    {\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSE is ready */\r\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)\r\n      {\r\n        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Get Start Tick */\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSE is ready */\r\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)\r\n      {\r\n        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Restore clock configuration if changed */\r\n    if(pwrclkchanged == SET)\r\n    {\r\n      __HAL_RCC_PWR_CLK_DISABLE();\r\n    }\r\n  }\r\n  /*-------------------------------- PLL Configuration -----------------------*/\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));\r\n  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)\r\n  {\r\n    /* Check if the PLL is used as system clock or not */\r\n    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)\r\n    {\r\n      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)\r\n      {\r\n        /* Check the parameters */\r\n        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));\r\n        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));\r\n        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));\r\n        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));\r\n        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));\r\n\r\n        /* Disable the main PLL. */\r\n        __HAL_RCC_PLL_DISABLE();\r\n\r\n        /* Get Start Tick */\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till PLL is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n\r\n        /* Configure the main PLL clock source, multiplication and division factors. */\r\n        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \\\r\n                                 RCC_OscInitStruct->PLL.PLLM                                                 | \\\r\n                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \\\r\n                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \\\r\n                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));\r\n        /* Enable the main PLL. */\r\n        __HAL_RCC_PLL_ENABLE();\r\n\r\n        /* Get Start Tick */\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till PLL is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Disable the main PLL. */\r\n        __HAL_RCC_PLL_DISABLE();\r\n\r\n        /* Get Start Tick */\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till PLL is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Check if there is a request to disable the PLL used as System clock source */\r\n      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      else\r\n      {\r\n        /* Do not return HAL_ERROR if request repeats the current configuration */\r\n        pll_config = RCC->PLLCFGR;\r\n#if defined (RCC_PLLCFGR_PLLR)\r\n        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))\r\n#else\r\n        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))\r\n#endif\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the CPU, AHB and APB busses clocks according to the specified\r\n  *         parameters in the RCC_ClkInitStruct.\r\n  * @param  RCC_ClkInitStruct pointer to an RCC_OscInitTypeDef structure that\r\n  *         contains the configuration information for the RCC peripheral.\r\n  * @param  FLatency FLASH Latency, this parameter depend on device selected\r\n  *\r\n  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency\r\n  *         and updated by HAL_RCC_GetHCLKFreq() function called within this function\r\n  *\r\n  * @note   The HSI is used (enabled by hardware) as system clock source after\r\n  *         startup from Reset, wake-up from STOP and STANDBY mode, or in case\r\n  *         of failure of the HSE used directly or indirectly as system clock\r\n  *         (if the Clock Security System CSS is enabled).\r\n  *\r\n  * @note   A switch from one clock source to another occurs only if the target\r\n  *         clock source is ready (clock stable after startup delay or PLL locked).\r\n  *         If a clock source which is not yet ready is selected, the switch will\r\n  *         occur when the clock source will be ready.\r\n  *\r\n  * @note   Depending on the device voltage range, the software has to set correctly\r\n  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency\r\n  *         (for more details refer to section above \"Initialization/de-initialization functions\")\r\n  * @retval None\r\n  */\r\nHAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Check Null pointer */\r\n  if(RCC_ClkInitStruct == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));\r\n  assert_param(IS_FLASH_LATENCY(FLatency));\r\n\r\n  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)\r\n    must be correctly programmed according to the frequency of the CPU clock\r\n    (HCLK) and the supply voltage of the device. */\r\n\r\n  /* Increasing the number of wait states because of higher CPU frequency */\r\n  if(FLatency > __HAL_FLASH_GET_LATENCY())\r\n  {\r\n    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */\r\n    __HAL_FLASH_SET_LATENCY(FLatency);\r\n\r\n    /* Check that the new number of wait states is taken into account to access the Flash\r\n    memory by reading the FLASH_ACR register */\r\n    if(__HAL_FLASH_GET_LATENCY() != FLatency)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  /*-------------------------- HCLK Configuration --------------------------*/\r\n  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)\r\n  {\r\n    /* Set the highest APBx dividers in order to ensure that we do not go through\r\n       a non-spec phase whatever we decrease or increase HCLK. */\r\n    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)\r\n    {\r\n      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);\r\n    }\r\n\r\n    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)\r\n    {\r\n      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));\r\n    }\r\n\r\n    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));\r\n    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);\r\n  }\r\n\r\n  /*------------------------- SYSCLK Configuration ---------------------------*/\r\n  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)\r\n  {\r\n    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));\r\n\r\n    /* HSE is selected as System Clock Source */\r\n    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)\r\n    {\r\n      /* Check the HSE ready flag */\r\n      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    /* PLL is selected as System Clock Source */\r\n    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||\r\n            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))\r\n    {\r\n      /* Check the PLL ready flag */\r\n      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    /* HSI is selected as System Clock Source */\r\n    else\r\n    {\r\n      /* Check the HSI ready flag */\r\n      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);\r\n\r\n    /* Get Start Tick */\r\n    tickstart = HAL_GetTick();\r\n\r\n    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))\r\n    {\r\n      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Decreasing the number of wait states because of lower CPU frequency */\r\n  if(FLatency < __HAL_FLASH_GET_LATENCY())\r\n  {\r\n     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */\r\n    __HAL_FLASH_SET_LATENCY(FLatency);\r\n\r\n    /* Check that the new number of wait states is taken into account to access the Flash\r\n    memory by reading the FLASH_ACR register */\r\n    if(__HAL_FLASH_GET_LATENCY() != FLatency)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  /*-------------------------- PCLK1 Configuration ---------------------------*/\r\n  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)\r\n  {\r\n    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));\r\n    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);\r\n  }\r\n\r\n  /*-------------------------- PCLK2 Configuration ---------------------------*/\r\n  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)\r\n  {\r\n    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));\r\n    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));\r\n  }\r\n\r\n  /* Update the SystemCoreClock global variable */\r\n  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];\r\n\r\n  /* Configure the source of time base considering new system clocks settings */\r\n  HAL_InitTick (uwTickPrio);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup RCC_Exported_Functions_Group2 Peripheral Control functions\r\n *  @brief   RCC clocks control functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### Peripheral Control functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to control the RCC Clocks\r\n    frequencies.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Selects the clock source to output on MCO1 pin(PA8) or on MCO2 pin(PC9).\r\n  * @note   PA8/PC9 should be configured in alternate function mode.\r\n  * @param  RCC_MCOx specifies the output direction for the clock source.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg RCC_MCO1: Clock source to output on MCO1 pin(PA8).\r\n  *            @arg RCC_MCO2: Clock source to output on MCO2 pin(PC9).\r\n  * @param  RCC_MCOSource specifies the clock source to output.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg RCC_MCO1SOURCE_HSI: HSI clock selected as MCO1 source\r\n  *            @arg RCC_MCO1SOURCE_LSE: LSE clock selected as MCO1 source\r\n  *            @arg RCC_MCO1SOURCE_HSE: HSE clock selected as MCO1 source\r\n  *            @arg RCC_MCO1SOURCE_PLLCLK: main PLL clock selected as MCO1 source\r\n  *            @arg RCC_MCO2SOURCE_SYSCLK: System clock (SYSCLK) selected as MCO2 source\r\n  *            @arg RCC_MCO2SOURCE_PLLI2SCLK: PLLI2S clock selected as MCO2 source, available for all STM32F4 devices except STM32F410xx\r\n  *            @arg RCC_MCO2SOURCE_I2SCLK: I2SCLK clock selected as MCO2 source, available only for STM32F410Rx devices\r\n  *            @arg RCC_MCO2SOURCE_HSE: HSE clock selected as MCO2 source\r\n  *            @arg RCC_MCO2SOURCE_PLLCLK: main PLL clock selected as MCO2 source\r\n  * @param  RCC_MCODiv specifies the MCOx prescaler.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg RCC_MCODIV_1: no division applied to MCOx clock\r\n  *            @arg RCC_MCODIV_2: division by 2 applied to MCOx clock\r\n  *            @arg RCC_MCODIV_3: division by 3 applied to MCOx clock\r\n  *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock\r\n  *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock\r\n  * @note  For STM32F410Rx devices to output I2SCLK clock on MCO2 you should have\r\n  *        at last one of the SPI clocks enabled (SPI1, SPI2 or SPI5).\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)\r\n{\r\n  GPIO_InitTypeDef GPIO_InitStruct;\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_MCO(RCC_MCOx));\r\n  assert_param(IS_RCC_MCODIV(RCC_MCODiv));\r\n  /* RCC_MCO1 */\r\n  if(RCC_MCOx == RCC_MCO1)\r\n  {\r\n    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));\r\n\r\n    /* MCO1 Clock Enable */\r\n    __MCO1_CLK_ENABLE();\r\n\r\n    /* Configure the MCO1 pin in alternate function mode */\r\n    GPIO_InitStruct.Pin = MCO1_PIN;\r\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\r\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\r\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\r\n    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;\r\n    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);\r\n\r\n    /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */\r\n    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));\r\n\r\n   /* This RCC MCO1 enable feature is available only on STM32F410xx devices */\r\n#if defined(RCC_CFGR_MCO1EN)\r\n    __HAL_RCC_MCO1_ENABLE();\r\n#endif /* RCC_CFGR_MCO1EN */\r\n  }\r\n#if defined(RCC_CFGR_MCO2)\r\n  else\r\n  {\r\n    assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));\r\n\r\n    /* MCO2 Clock Enable */\r\n    __MCO2_CLK_ENABLE();\r\n\r\n    /* Configure the MCO2 pin in alternate function mode */\r\n    GPIO_InitStruct.Pin = MCO2_PIN;\r\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\r\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\r\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\r\n    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;\r\n    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);\r\n\r\n    /* Mask MCO2 and MCO2PRE[2:0] bits then Select MCO2 clock source and prescaler */\r\n    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3U)));\r\n\r\n   /* This RCC MCO2 enable feature is available only on STM32F410Rx devices */\r\n#if defined(RCC_CFGR_MCO2EN)\r\n    __HAL_RCC_MCO2_ENABLE();\r\n#endif /* RCC_CFGR_MCO2EN */\r\n  }\r\n#endif /* RCC_CFGR_MCO2 */\r\n}\r\n\r\n/**\r\n  * @brief  Enables the Clock Security System.\r\n  * @note   If a failure is detected on the HSE oscillator clock, this oscillator\r\n  *         is automatically disabled and an interrupt is generated to inform the\r\n  *         software about the failure (Clock Security System Interrupt, CSSI),\r\n  *         allowing the MCU to perform rescue operations. The CSSI is linked to\r\n  *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_EnableCSS(void)\r\n{\r\n  *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;\r\n}\r\n\r\n/**\r\n  * @brief  Disables the Clock Security System.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_DisableCSS(void)\r\n{\r\n  *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)DISABLE;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the SYSCLK frequency\r\n  *\r\n  * @note   The system frequency computed by this function is not the real\r\n  *         frequency in the chip. It is calculated based on the predefined\r\n  *         constant and the selected clock source:\r\n  * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)\r\n  * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)\r\n  * @note     If SYSCLK source is PLL, function returns values based on HSE_VALUE(**)\r\n  *           or HSI_VALUE(*) multiplied/divided by the PLL factors.\r\n  * @note     (*) HSI_VALUE is a constant defined in stm32f4xx_hal_conf.h file (default value\r\n  *               16 MHz) but the real value may vary depending on the variations\r\n  *               in voltage and temperature.\r\n  * @note     (**) HSE_VALUE is a constant defined in stm32f4xx_hal_conf.h file (default value\r\n  *                25 MHz), user has to ensure that HSE_VALUE is same as the real\r\n  *                frequency of the crystal used. Otherwise, this function may\r\n  *                have wrong result.\r\n  *\r\n  * @note   The result of this function could be not correct when using fractional\r\n  *         value for HSE crystal.\r\n  *\r\n  * @note   This function can be used by the user application to compute the\r\n  *         baudrate for the communication peripherals or configure other parameters.\r\n  *\r\n  * @note   Each time SYSCLK changes, this function must be called to update the\r\n  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.\r\n  *\r\n  *\r\n  * @retval SYSCLK frequency\r\n  */\r\n__weak uint32_t HAL_RCC_GetSysClockFreq(void)\r\n{\r\n  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;\r\n  uint32_t sysclockfreq = 0U;\r\n\r\n  /* Get SYSCLK source -------------------------------------------------------*/\r\n  switch (RCC->CFGR & RCC_CFGR_SWS)\r\n  {\r\n    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */\r\n    {\r\n      sysclockfreq = HSI_VALUE;\r\n       break;\r\n    }\r\n    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */\r\n    {\r\n      sysclockfreq = HSE_VALUE;\r\n      break;\r\n    }\r\n    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */\r\n    {\r\n      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN\r\n      SYSCLK = PLL_VCO / PLLP */\r\n      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;\r\n      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)\r\n      {\r\n        /* HSE used as PLL clock source */\r\n        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);\r\n      }\r\n      else\r\n      {\r\n        /* HSI used as PLL clock source */\r\n        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);\r\n      }\r\n      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);\r\n\r\n      sysclockfreq = pllvco/pllp;\r\n      break;\r\n    }\r\n    default:\r\n    {\r\n      sysclockfreq = HSI_VALUE;\r\n      break;\r\n    }\r\n  }\r\n  return sysclockfreq;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the HCLK frequency\r\n  * @note   Each time HCLK changes, this function must be called to update the\r\n  *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.\r\n  *\r\n  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency\r\n  *         and updated within this function\r\n  * @retval HCLK frequency\r\n  */\r\nuint32_t HAL_RCC_GetHCLKFreq(void)\r\n{\r\n  return SystemCoreClock;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the PCLK1 frequency\r\n  * @note   Each time PCLK1 changes, this function must be called to update the\r\n  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.\r\n  * @retval PCLK1 frequency\r\n  */\r\nuint32_t HAL_RCC_GetPCLK1Freq(void)\r\n{\r\n  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/\r\n  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);\r\n}\r\n\r\n/**\r\n  * @brief  Returns the PCLK2 frequency\r\n  * @note   Each time PCLK2 changes, this function must be called to update the\r\n  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.\r\n  * @retval PCLK2 frequency\r\n  */\r\nuint32_t HAL_RCC_GetPCLK2Freq(void)\r\n{\r\n  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/\r\n  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);\r\n}\r\n\r\n/**\r\n  * @brief  Configures the RCC_OscInitStruct according to the internal\r\n  * RCC configuration registers.\r\n  * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that\r\n  * will be configured.\r\n  * @retval None\r\n  */\r\n__weak void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)\r\n{\r\n  /* Set all possible values for the Oscillator type parameter ---------------*/\r\n  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;\r\n\r\n  /* Get the HSE configuration -----------------------------------------------*/\r\n  if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;\r\n  }\r\n  else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;\r\n  }\r\n\r\n  /* Get the HSI configuration -----------------------------------------------*/\r\n  if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)\r\n  {\r\n    RCC_OscInitStruct->HSIState = RCC_HSI_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;\r\n  }\r\n\r\n  RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR &RCC_CR_HSITRIM) >> RCC_CR_HSITRIM_Pos);\r\n\r\n  /* Get the LSE configuration -----------------------------------------------*/\r\n  if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;\r\n  }\r\n  else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;\r\n  }\r\n\r\n  /* Get the LSI configuration -----------------------------------------------*/\r\n  if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)\r\n  {\r\n    RCC_OscInitStruct->LSIState = RCC_LSI_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;\r\n  }\r\n\r\n  /* Get the PLL configuration -----------------------------------------------*/\r\n  if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)\r\n  {\r\n    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;\r\n  }\r\n  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);\r\n  RCC_OscInitStruct->PLL.PLLM = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);\r\n  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);\r\n  RCC_OscInitStruct->PLL.PLLP = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) + RCC_PLLCFGR_PLLP_0) << 1U) >> RCC_PLLCFGR_PLLP_Pos);\r\n  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos);\r\n}\r\n\r\n/**\r\n  * @brief  Configures the RCC_ClkInitStruct according to the internal\r\n  * RCC configuration registers.\r\n  * @param  RCC_ClkInitStruct pointer to an RCC_ClkInitTypeDef structure that\r\n  * will be configured.\r\n  * @param  pFLatency Pointer on the Flash Latency.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)\r\n{\r\n  /* Set all possible values for the Clock type parameter --------------------*/\r\n  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;\r\n\r\n  /* Get the SYSCLK configuration --------------------------------------------*/\r\n  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);\r\n\r\n  /* Get the HCLK configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);\r\n\r\n  /* Get the APB1 configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);\r\n\r\n  /* Get the APB2 configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3U);\r\n\r\n  /* Get the Flash Wait State (Latency) configuration ------------------------*/\r\n  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);\r\n}\r\n\r\n/**\r\n  * @brief This function handles the RCC CSS interrupt request.\r\n  * @note This API should be called under the NMI_Handler().\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_NMI_IRQHandler(void)\r\n{\r\n  /* Check RCC CSSF flag  */\r\n  if(__HAL_RCC_GET_IT(RCC_IT_CSS))\r\n  {\r\n    /* RCC Clock Security System interrupt user callback */\r\n    HAL_RCC_CSSCallback();\r\n\r\n    /* Clear RCC CSS pending bit */\r\n    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  RCC Clock Security System interrupt callback\r\n  * @retval None\r\n  */\r\n__weak void HAL_RCC_CSSCallback(void)\r\n{\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_RCC_CSSCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_RCC_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_rcc_ex.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_rcc_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   Extension RCC HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities RCC extension peripheral:\r\n  *           + Extended Peripheral Control functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup RCCEx RCCEx\r\n  * @brief RCCEx HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_RCC_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup RCCEx_Private_Constants\r\n  * @{\r\n  */\r\n/**\r\n  * @}\r\n  */\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/** @defgroup RCCEx_Exported_Functions RCCEx Exported Functions\r\n  *  @{\r\n  */\r\n\r\n/** @defgroup RCCEx_Exported_Functions_Group1 Extended Peripheral Control functions\r\n *  @brief  Extended Peripheral Control functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                ##### Extended Peripheral Control functions  #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to control the RCC Clocks\r\n    frequencies.\r\n    [..]\r\n    (@) Important note: Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to\r\n        select the RTC clock source; in this case the Backup domain will be reset in\r\n        order to modify the RTC Clock source, as consequence RTC registers (including\r\n        the backup registers) and RCC_BDCR register are set to their reset values.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n#if defined(STM32F446xx)\r\n/**\r\n  * @brief  Initializes the RCC extended peripherals clocks according to the specified\r\n  *         parameters in the RCC_PeriphCLKInitTypeDef.\r\n  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  *         contains the configuration information for the Extended Peripherals\r\n  *         clocks(I2S, SAI, LTDC RTC and TIM).\r\n  *\r\n  * @note   Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to select\r\n  *         the RTC clock source; in this case the Backup domain will be reset in\r\n  *         order to modify the RTC Clock source, as consequence RTC registers (including\r\n  *         the backup registers) and RCC_BDCR register are set to their reset values.\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tickstart = 0U;\r\n  uint32_t tmpreg1 = 0U;\r\n  uint32_t plli2sp = 0U;\r\n  uint32_t plli2sq = 0U;\r\n  uint32_t plli2sr = 0U;\r\n  uint32_t pllsaip = 0U;\r\n  uint32_t pllsaiq = 0U;\r\n  uint32_t plli2sused = 0U;\r\n  uint32_t pllsaiused = 0U;\r\n\r\n  /* Check the peripheral clock selection parameters */\r\n  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));\r\n\r\n  /*------------------------ I2S APB1 configuration --------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S_APB1) == (RCC_PERIPHCLK_I2S_APB1))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2SAPB1CLKSOURCE(PeriphClkInit->I2sApb1ClockSelection));\r\n\r\n    /* Configure I2S Clock source */\r\n    __HAL_RCC_I2S_APB1_CONFIG(PeriphClkInit->I2sApb1ClockSelection);\r\n    /* Enable the PLLI2S when it's used as clock source for I2S */\r\n    if(PeriphClkInit->I2sApb1ClockSelection == RCC_I2SAPB1CLKSOURCE_PLLI2S)\r\n    {\r\n      plli2sused = 1U;\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*---------------------------- I2S APB2 configuration ----------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S_APB2) == (RCC_PERIPHCLK_I2S_APB2))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2SAPB2CLKSOURCE(PeriphClkInit->I2sApb2ClockSelection));\r\n\r\n    /* Configure I2S Clock source */\r\n    __HAL_RCC_I2S_APB2_CONFIG(PeriphClkInit->I2sApb2ClockSelection);\r\n    /* Enable the PLLI2S when it's used as clock source for I2S */\r\n    if(PeriphClkInit->I2sApb2ClockSelection == RCC_I2SAPB2CLKSOURCE_PLLI2S)\r\n    {\r\n      plli2sused = 1U;\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*--------------------------- SAI1 configuration ---------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));\r\n\r\n    /* Configure SAI1 Clock source */\r\n    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);\r\n    /* Enable the PLLI2S when it's used as clock source for SAI */\r\n    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)\r\n    {\r\n      plli2sused = 1U;\r\n    }\r\n    /* Enable the PLLSAI when it's used as clock source for SAI */\r\n    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)\r\n    {\r\n      pllsaiused = 1U;\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*-------------------------- SAI2 configuration ----------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));\r\n\r\n    /* Configure SAI2 Clock source */\r\n    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);\r\n\r\n    /* Enable the PLLI2S when it's used as clock source for SAI */\r\n    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)\r\n    {\r\n      plli2sused = 1U;\r\n    }\r\n    /* Enable the PLLSAI when it's used as clock source for SAI */\r\n    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)\r\n    {\r\n      pllsaiused = 1U;\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*----------------------------- RTC configuration --------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))\r\n  {\r\n    /* Check for RTC Parameters used to output RTCCLK */\r\n    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));\r\n\r\n    /* Enable Power Clock*/\r\n    __HAL_RCC_PWR_CLK_ENABLE();\r\n\r\n    /* Enable write access to Backup domain */\r\n    PWR->CR |= PWR_CR_DBP;\r\n\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n\r\n    while((PWR->CR & PWR_CR_DBP) == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */\r\n    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);\r\n    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))\r\n    {\r\n      /* Store the content of BDCR register before the reset of Backup Domain */\r\n      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));\r\n      /* RTC Clock selection can be changed only if the Backup Domain is reset */\r\n      __HAL_RCC_BACKUPRESET_FORCE();\r\n      __HAL_RCC_BACKUPRESET_RELEASE();\r\n      /* Restore the Content of BDCR register */\r\n      RCC->BDCR = tmpreg1;\r\n\r\n      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */\r\n      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))\r\n      {\r\n        /* Get tick */\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till LSE is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*---------------------------- TIM configuration ---------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))\r\n  {\r\n    /* Configure Timer Prescaler */\r\n    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*---------------------------- FMPI2C1 Configuration -----------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMPI2C1) == RCC_PERIPHCLK_FMPI2C1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_FMPI2C1CLKSOURCE(PeriphClkInit->Fmpi2c1ClockSelection));\r\n\r\n    /* Configure the FMPI2C1 clock source */\r\n    __HAL_RCC_FMPI2C1_CONFIG(PeriphClkInit->Fmpi2c1ClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*------------------------------ CEC Configuration -------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));\r\n\r\n    /* Configure the CEC clock source */\r\n    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*----------------------------- CLK48 Configuration ------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_CLK48CLKSOURCE(PeriphClkInit->Clk48ClockSelection));\r\n\r\n    /* Configure the CLK48 clock source */\r\n    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);\r\n\r\n    /* Enable the PLLSAI when it's used as clock source for CLK48 */\r\n    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48CLKSOURCE_PLLSAIP)\r\n    {\r\n      pllsaiused = 1U;\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*----------------------------- SDIO Configuration -------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDIO) == RCC_PERIPHCLK_SDIO)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SDIOCLKSOURCE(PeriphClkInit->SdioClockSelection));\r\n\r\n    /* Configure the SDIO clock source */\r\n    __HAL_RCC_SDIO_CONFIG(PeriphClkInit->SdioClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*------------------------------ SPDIFRX Configuration ---------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SPDIFRXCLKSOURCE(PeriphClkInit->SpdifClockSelection));\r\n\r\n    /* Configure the SPDIFRX clock source */\r\n    __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifClockSelection);\r\n    /* Enable the PLLI2S when it's used as clock source for SPDIFRX */\r\n    if(PeriphClkInit->SpdifClockSelection == RCC_SPDIFRXCLKSOURCE_PLLI2SP)\r\n    {\r\n      plli2sused = 1U;\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*---------------------------- PLLI2S Configuration ------------------------*/\r\n  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S on APB1,\r\n     I2S on APB2 or SPDIFRX */\r\n  if((plli2sused == 1U) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))\r\n  {\r\n    /* Disable the PLLI2S */\r\n    __HAL_RCC_PLLI2S_DISABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLI2S is disabled */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /* check for common PLLI2S Parameters */\r\n    assert_param(IS_RCC_PLLI2SM_VALUE(PeriphClkInit->PLLI2S.PLLI2SM));\r\n    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));\r\n\r\n    /*------ In Case of PLLI2S is selected as source clock for I2S -----------*/\r\n    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S_APB1) == RCC_PERIPHCLK_I2S_APB1) && (PeriphClkInit->I2sApb1ClockSelection == RCC_I2SAPB1CLKSOURCE_PLLI2S)) ||\r\n       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S_APB2) == RCC_PERIPHCLK_I2S_APB2) && (PeriphClkInit->I2sApb2ClockSelection == RCC_I2SAPB2CLKSOURCE_PLLI2S)))\r\n    {\r\n      /* check for Parameters */\r\n      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));\r\n\r\n      /* Read PLLI2SP/PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */\r\n      plli2sp = ((((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos) + 1U) << 1U);\r\n      plli2sq = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */\r\n      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN , plli2sp, plli2sq, PeriphClkInit->PLLI2S.PLLI2SR);\r\n    }\r\n\r\n    /*------- In Case of PLLI2S is selected as source clock for SAI ----------*/\r\n    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||\r\n       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))\r\n    {\r\n      /* Check for PLLI2S Parameters */\r\n      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));\r\n      /* Check for PLLI2S/DIVQ parameters */\r\n      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));\r\n\r\n      /* Read PLLI2SP/PLLI2SR value from PLLI2SCFGR register (this value is not needed for SAI configuration) */\r\n      plli2sp = ((((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos) + 1U) << 1U);\r\n      plli2sr = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */\r\n      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN , plli2sp, PeriphClkInit->PLLI2S.PLLI2SQ, plli2sr);\r\n\r\n      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */\r\n      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);\r\n    }\r\n\r\n    /*------ In Case of PLLI2S is selected as source clock for SPDIFRX -------*/\r\n    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX) && (PeriphClkInit->SpdifClockSelection == RCC_SPDIFRXCLKSOURCE_PLLI2SP))\r\n    {\r\n      /* check for Parameters */\r\n      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));\r\n      /* Read PLLI2SR value from PLLI2SCFGR register (this value is not need for SAI configuration) */\r\n      plli2sq = ((((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos) + 1U) << 1U);\r\n      plli2sr = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */\r\n      /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, plli2sq, plli2sr);\r\n    }\r\n\r\n     /*----------------- In Case of PLLI2S is just selected  -----------------*/\r\n    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)\r\n    {\r\n      /* Check for Parameters */\r\n      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));\r\n      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));\r\n      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));\r\n\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);\r\n    }\r\n\r\n    /* Enable the PLLI2S */\r\n    __HAL_RCC_PLLI2S_ENABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLI2S is ready */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*----------------------------- PLLSAI Configuration -----------------------*/\r\n  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, CLK48 or SDIO */\r\n  if(pllsaiused == 1U)\r\n  {\r\n    /* Disable PLLSAI Clock */\r\n    __HAL_RCC_PLLSAI_DISABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLSAI is disabled */\r\n    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /* Check the PLLSAI division factors */\r\n    assert_param(IS_RCC_PLLSAIM_VALUE(PeriphClkInit->PLLSAI.PLLSAIM));\r\n    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));\r\n\r\n    /*------ In Case of PLLSAI is selected as source clock for SAI -----------*/\r\n    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\r\n       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))\r\n    {\r\n      /* check for PLLSAIQ Parameter */\r\n      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));\r\n      /* check for PLLSAI/DIVQ Parameter */\r\n      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));\r\n\r\n      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */\r\n      pllsaip = ((((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos) + 1U) << 1U);\r\n      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */\r\n      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */\r\n      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */\r\n      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIM, PeriphClkInit->PLLSAI.PLLSAIN , pllsaip, PeriphClkInit->PLLSAI.PLLSAIQ, 0U);\r\n\r\n      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */\r\n      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);\r\n    }\r\n\r\n    /*------ In Case of PLLSAI is selected as source clock for CLK48 ---------*/\r\n    /* In Case of PLLI2S is selected as source clock for CLK48 */\r\n    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48CLKSOURCE_PLLSAIP))\r\n    {\r\n      /* check for Parameters */\r\n      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));\r\n      /* Read PLLSAIQ value from PLLI2SCFGR register (this value is not need for SAI configuration) */\r\n      pllsaiq = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);\r\n      /* Configure the PLLSAI division factors */\r\n      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) * (PLLI2SN/PLLSAIM) */\r\n      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */\r\n      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIM, PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, pllsaiq, 0U);\r\n    }\r\n\r\n    /* Enable PLLSAI Clock */\r\n    __HAL_RCC_PLLSAI_ENABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLSAI is ready */\r\n    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Get the RCC_PeriphCLKInitTypeDef according to the internal\r\n  *         RCC configuration registers.\r\n  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  *         will be configured.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tempreg;\r\n\r\n  /* Set all possible values for the extended clock type parameter------------*/\r\n  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S_APB1 | RCC_PERIPHCLK_I2S_APB2 |\\\r\n                                        RCC_PERIPHCLK_SAI1     | RCC_PERIPHCLK_SAI2     |\\\r\n                                        RCC_PERIPHCLK_TIM      | RCC_PERIPHCLK_RTC      |\\\r\n                                        RCC_PERIPHCLK_CEC      | RCC_PERIPHCLK_FMPI2C1  |\\\r\n                                        RCC_PERIPHCLK_CLK48     | RCC_PERIPHCLK_SDIO     |\\\r\n                                        RCC_PERIPHCLK_SPDIFRX;\r\n\r\n  /* Get the PLLI2S Clock configuration --------------------------------------*/\r\n  PeriphClkInit->PLLI2S.PLLI2SM = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM) >> RCC_PLLI2SCFGR_PLLI2SM_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SP = (uint32_t)((((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos) + 1U) << 1U);\r\n  PeriphClkInit->PLLI2S.PLLI2SQ = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);\r\n  /* Get the PLLSAI Clock configuration --------------------------------------*/\r\n  PeriphClkInit->PLLSAI.PLLSAIM = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIM) >> RCC_PLLSAICFGR_PLLSAIM_Pos);\r\n  PeriphClkInit->PLLSAI.PLLSAIN = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> RCC_PLLSAICFGR_PLLSAIN_Pos);\r\n  PeriphClkInit->PLLSAI.PLLSAIP = (uint32_t)((((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos) + 1U) << 1U);\r\n  PeriphClkInit->PLLSAI.PLLSAIQ = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);\r\n  /* Get the PLLSAI/PLLI2S division factors ----------------------------------*/\r\n  PeriphClkInit->PLLI2SDivQ = (uint32_t)((RCC->DCKCFGR & RCC_DCKCFGR_PLLI2SDIVQ) >> RCC_DCKCFGR_PLLI2SDIVQ_Pos);\r\n  PeriphClkInit->PLLSAIDivQ = (uint32_t)((RCC->DCKCFGR & RCC_DCKCFGR_PLLSAIDIVQ) >> RCC_DCKCFGR_PLLSAIDIVQ_Pos);\r\n\r\n  /* Get the SAI1 clock configuration ----------------------------------------*/\r\n  PeriphClkInit->Sai1ClockSelection = __HAL_RCC_GET_SAI1_SOURCE();\r\n\r\n  /* Get the SAI2 clock configuration ----------------------------------------*/\r\n  PeriphClkInit->Sai2ClockSelection = __HAL_RCC_GET_SAI2_SOURCE();\r\n\r\n  /* Get the I2S APB1 clock configuration ------------------------------------*/\r\n  PeriphClkInit->I2sApb1ClockSelection = __HAL_RCC_GET_I2S_APB1_SOURCE();\r\n\r\n  /* Get the I2S APB2 clock configuration ------------------------------------*/\r\n  PeriphClkInit->I2sApb2ClockSelection = __HAL_RCC_GET_I2S_APB2_SOURCE();\r\n\r\n  /* Get the RTC Clock configuration -----------------------------------------*/\r\n  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);\r\n  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));\r\n\r\n  /* Get the CEC clock configuration -----------------------------------------*/\r\n  PeriphClkInit->CecClockSelection = __HAL_RCC_GET_CEC_SOURCE();\r\n\r\n  /* Get the FMPI2C1 clock configuration -------------------------------------*/\r\n  PeriphClkInit->Fmpi2c1ClockSelection = __HAL_RCC_GET_FMPI2C1_SOURCE();\r\n\r\n  /* Get the CLK48 clock configuration ----------------------------------------*/\r\n  PeriphClkInit->Clk48ClockSelection = __HAL_RCC_GET_CLK48_SOURCE();\r\n\r\n  /* Get the SDIO clock configuration ----------------------------------------*/\r\n  PeriphClkInit->SdioClockSelection = __HAL_RCC_GET_SDIO_SOURCE();\r\n\r\n  /* Get the SPDIFRX clock configuration -------------------------------------*/\r\n  PeriphClkInit->SpdifClockSelection = __HAL_RCC_GET_SPDIFRX_SOURCE();\r\n\r\n  /* Get the TIM Prescaler configuration -------------------------------------*/\r\n  if ((RCC->DCKCFGR & RCC_DCKCFGR_TIMPRE) == RESET)\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;\r\n  }\r\n  else\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Return the peripheral clock frequency for a given peripheral(SAI..)\r\n  * @note   Return 0 if peripheral clock identifier not managed by this API\r\n  * @param  PeriphClk Peripheral clock identifier\r\n  *         This parameter can be one of the following values:\r\n  *            @arg RCC_PERIPHCLK_SAI1: SAI1 peripheral clock\r\n  *            @arg RCC_PERIPHCLK_SAI2: SAI2 peripheral clock\r\n  *            @arg RCC_PERIPHCLK_I2S_APB1: I2S APB1 peripheral clock\r\n  *            @arg RCC_PERIPHCLK_I2S_APB2: I2S APB2 peripheral clock\r\n  * @retval Frequency in KHz\r\n  */\r\nuint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)\r\n{\r\n  uint32_t tmpreg1 = 0U;\r\n  /* This variable used to store the SAI clock frequency (value in Hz) */\r\n  uint32_t frequency = 0U;\r\n  /* This variable used to store the VCO Input (value in Hz) */\r\n  uint32_t vcoinput = 0U;\r\n  /* This variable used to store the SAI clock source */\r\n  uint32_t saiclocksource = 0U;\r\n  uint32_t srcclk = 0U;\r\n  /* This variable used to store the VCO Output (value in Hz) */\r\n  uint32_t vcooutput = 0U;\r\n  switch (PeriphClk)\r\n  {\r\n  case RCC_PERIPHCLK_SAI1:\r\n  case RCC_PERIPHCLK_SAI2:\r\n    {\r\n      saiclocksource = RCC->DCKCFGR;\r\n      saiclocksource &= (RCC_DCKCFGR_SAI1SRC | RCC_DCKCFGR_SAI2SRC);\r\n      switch (saiclocksource)\r\n      {\r\n      case 0U: /* PLLSAI is the clock source for SAI*/\r\n        {\r\n          /* Configure the PLLSAI division factor */\r\n          /* PLLSAI_VCO Input  = PLL_SOURCE/PLLSAIM */\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)\r\n          {\r\n            /* In Case the PLL Source is HSI (Internal Clock) */\r\n            vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIM));\r\n          }\r\n          else\r\n          {\r\n            /* In Case the PLL Source is HSE (External Clock) */\r\n            vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIM)));\r\n          }\r\n          /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */\r\n          /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */\r\n          tmpreg1 = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24U;\r\n          frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6U))/(tmpreg1);\r\n\r\n          /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */\r\n          tmpreg1 = (((RCC->DCKCFGR & RCC_DCKCFGR_PLLSAIDIVQ) >> 8U) + 1U);\r\n          frequency = frequency/(tmpreg1);\r\n          break;\r\n        }\r\n      case RCC_DCKCFGR_SAI1SRC_0: /* PLLI2S is the clock source for SAI*/\r\n      case RCC_DCKCFGR_SAI2SRC_0: /* PLLI2S is the clock source for SAI*/\r\n        {\r\n          /* Configure the PLLI2S division factor */\r\n          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)\r\n          {\r\n            /* In Case the PLL Source is HSI (Internal Clock) */\r\n            vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));\r\n          }\r\n          else\r\n          {\r\n            /* In Case the PLL Source is HSE (External Clock) */\r\n            vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM)));\r\n          }\r\n\r\n          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n          /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */\r\n          tmpreg1 = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24U;\r\n          frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U))/(tmpreg1);\r\n\r\n          /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */\r\n          tmpreg1 = ((RCC->DCKCFGR & RCC_DCKCFGR_PLLI2SDIVQ) + 1U);\r\n          frequency = frequency/(tmpreg1);\r\n          break;\r\n        }\r\n      case RCC_DCKCFGR_SAI1SRC_1: /* PLLR is the clock source for SAI*/\r\n      case RCC_DCKCFGR_SAI2SRC_1: /* PLLR is the clock source for SAI*/\r\n        {\r\n          /* Configure the PLLI2S division factor */\r\n          /* PLL_VCO Input  = PLL_SOURCE/PLLM */\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)\r\n          {\r\n            /* In Case the PLL Source is HSI (Internal Clock) */\r\n            vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n          else\r\n          {\r\n            /* In Case the PLL Source is HSE (External Clock) */\r\n            vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));\r\n          }\r\n\r\n          /* PLL_VCO Output = PLL_VCO Input * PLLN */\r\n          /* SAI_CLK_x = PLL_VCO Output/PLLR */\r\n          tmpreg1 = (RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 28U;\r\n          frequency = (vcoinput * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6U))/(tmpreg1);\r\n          break;\r\n        }\r\n      case RCC_DCKCFGR_SAI1SRC: /* External clock is the clock source for SAI*/\r\n        {\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n      case RCC_DCKCFGR_SAI2SRC: /* PLLSRC(HSE or HSI) is the clock source for SAI*/\r\n        {\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)\r\n          {\r\n            /* In Case the PLL Source is HSI (Internal Clock) */\r\n            frequency = (uint32_t)(HSI_VALUE);\r\n          }\r\n          else\r\n          {\r\n            /* In Case the PLL Source is HSE (External Clock) */\r\n            frequency = (uint32_t)(HSE_VALUE);\r\n          }\r\n          break;\r\n        }\r\n      default :\r\n        {\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  case RCC_PERIPHCLK_I2S_APB1:\r\n    {\r\n      /* Get the current I2S source */\r\n      srcclk = __HAL_RCC_GET_I2S_APB1_SOURCE();\r\n      switch (srcclk)\r\n      {\r\n      /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */\r\n      case RCC_I2SAPB1CLKSOURCE_EXT:\r\n        {\r\n          /* Set the I2S clock to the external clock  value */\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n      /* Check if I2S clock selection is PLLI2S VCO output clock divided by PLLI2SR used as I2S clock */\r\n      case RCC_I2SAPB1CLKSOURCE_PLLI2S:\r\n        {\r\n          /* Configure the PLLI2S division factor */\r\n          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));\r\n          }\r\n          else\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));\r\n          }\r\n\r\n          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));\r\n          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */\r\n          frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));\r\n          break;\r\n        }\r\n      /* Check if I2S clock selection is PLL VCO Output divided by PLLR used as I2S clock */\r\n      case RCC_I2SAPB1CLKSOURCE_PLLR:\r\n        {\r\n          /* Configure the PLL division factor R */\r\n          /* PLL_VCO Input  = PLL_SOURCE/PLLM */\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n          else\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n\r\n          /* PLL_VCO Output = PLL_VCO Input * PLLN */\r\n          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6U) & (RCC_PLLCFGR_PLLN >> 6U)));\r\n          /* I2S_CLK = PLL_VCO Output/PLLR */\r\n          frequency = (uint32_t)(vcooutput /(((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 28U) & (RCC_PLLCFGR_PLLR >> 28U)));\r\n          break;\r\n        }\r\n      /* Check if I2S clock selection is HSI or HSE depending from PLL source Clock */\r\n      case RCC_I2SAPB1CLKSOURCE_PLLSRC:\r\n        {\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            frequency = HSE_VALUE;\r\n          }\r\n          else\r\n          {\r\n            frequency = HSI_VALUE;\r\n          }\r\n          break;\r\n        }\r\n        /* Clock not enabled for I2S*/\r\n      default:\r\n        {\r\n          frequency = 0U;\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  case RCC_PERIPHCLK_I2S_APB2:\r\n    {\r\n      /* Get the current I2S source */\r\n      srcclk = __HAL_RCC_GET_I2S_APB2_SOURCE();\r\n      switch (srcclk)\r\n      {\r\n        /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */\r\n      case RCC_I2SAPB2CLKSOURCE_EXT:\r\n        {\r\n          /* Set the I2S clock to the external clock  value */\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n        /* Check if I2S clock selection is PLLI2S VCO output clock divided by PLLI2SR used as I2S clock */\r\n      case RCC_I2SAPB2CLKSOURCE_PLLI2S:\r\n        {\r\n          /* Configure the PLLI2S division factor */\r\n          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));\r\n          }\r\n          else\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));\r\n          }\r\n\r\n          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));\r\n          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */\r\n          frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));\r\n          break;\r\n        }\r\n        /* Check if I2S clock selection is PLL VCO Output divided by PLLR used as I2S clock */\r\n      case RCC_I2SAPB2CLKSOURCE_PLLR:\r\n        {\r\n          /* Configure the PLL division factor R */\r\n          /* PLL_VCO Input  = PLL_SOURCE/PLLM */\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n          else\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n\r\n          /* PLL_VCO Output = PLL_VCO Input * PLLN */\r\n          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6U) & (RCC_PLLCFGR_PLLN >> 6U)));\r\n          /* I2S_CLK = PLL_VCO Output/PLLR */\r\n          frequency = (uint32_t)(vcooutput /(((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 28U) & (RCC_PLLCFGR_PLLR >> 28U)));\r\n          break;\r\n        }\r\n        /* Check if I2S clock selection is HSI or HSE depending from PLL source Clock */\r\n      case RCC_I2SAPB2CLKSOURCE_PLLSRC:\r\n        {\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            frequency = HSE_VALUE;\r\n          }\r\n          else\r\n          {\r\n            frequency = HSI_VALUE;\r\n          }\r\n          break;\r\n        }\r\n        /* Clock not enabled for I2S*/\r\n      default:\r\n        {\r\n          frequency = 0U;\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  }\r\n  return frequency;\r\n}\r\n#endif /* STM32F446xx */\r\n\r\n#if defined(STM32F469xx) || defined(STM32F479xx)\r\n/**\r\n  * @brief  Initializes the RCC extended peripherals clocks according to the specified\r\n  *         parameters in the RCC_PeriphCLKInitTypeDef.\r\n  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  *         contains the configuration information for the Extended Peripherals\r\n  *         clocks(I2S, SAI, LTDC, RTC and TIM).\r\n  *\r\n  * @note   Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to select\r\n  *         the RTC clock source; in this case the Backup domain will be reset in\r\n  *         order to modify the RTC Clock source, as consequence RTC registers (including\r\n  *         the backup registers) and RCC_BDCR register are set to their reset values.\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tickstart = 0U;\r\n  uint32_t tmpreg1 = 0U;\r\n  uint32_t pllsaip = 0U;\r\n  uint32_t pllsaiq = 0U;\r\n  uint32_t pllsair = 0U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));\r\n\r\n  /*--------------------------- CLK48 Configuration --------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_CLK48CLKSOURCE(PeriphClkInit->Clk48ClockSelection));\r\n\r\n    /* Configure the CLK48 clock source */\r\n    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*------------------------------ SDIO Configuration ------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDIO) == RCC_PERIPHCLK_SDIO)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SDIOCLKSOURCE(PeriphClkInit->SdioClockSelection));\r\n\r\n    /* Configure the SDIO clock source */\r\n    __HAL_RCC_SDIO_CONFIG(PeriphClkInit->SdioClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*----------------------- SAI/I2S Configuration (PLLI2S) -------------------*/\r\n  /*------------------- Common configuration SAI/I2S -------------------------*/\r\n  /* In Case of SAI or I2S Clock Configuration through PLLI2S, PLLI2SN division\r\n     factor is common parameters for both peripherals */\r\n  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||\r\n     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLI2S) == RCC_PERIPHCLK_SAI_PLLI2S) ||\r\n     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))\r\n  {\r\n    /* check for Parameters */\r\n    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));\r\n\r\n    /* Disable the PLLI2S */\r\n    __HAL_RCC_PLLI2S_DISABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLI2S is disabled */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /*---------------------- I2S configuration -------------------------------*/\r\n    /* In Case of I2S Clock Configuration through PLLI2S, PLLI2SR must be added\r\n      only for I2S configuration */\r\n    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))\r\n    {\r\n      /* check for Parameters */\r\n      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */\r\n      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);\r\n    }\r\n\r\n    /*---------------------------- SAI configuration -------------------------*/\r\n    /* In Case of SAI Clock Configuration through PLLI2S, PLLI2SQ and PLLI2S_DIVQ must\r\n       be added only for SAI configuration */\r\n    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLI2S) == (RCC_PERIPHCLK_SAI_PLLI2S))\r\n    {\r\n      /* Check the PLLI2S division factors */\r\n      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));\r\n      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));\r\n\r\n      /* Read PLLI2SR value from PLLI2SCFGR register (this value is not need for SAI configuration) */\r\n      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */\r\n      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */\r\n      __HAL_RCC_PLLI2S_SAICLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SQ , tmpreg1);\r\n      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */\r\n      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);\r\n    }\r\n\r\n    /*----------------- In Case of PLLI2S is just selected  -----------------*/\r\n    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)\r\n    {\r\n      /* Check for Parameters */\r\n      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));\r\n      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));\r\n\r\n      /* Configure the PLLI2S multiplication and division factors */\r\n      __HAL_RCC_PLLI2S_SAICLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);\r\n    }\r\n\r\n    /* Enable the PLLI2S */\r\n    __HAL_RCC_PLLI2S_ENABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLI2S is ready */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*----------------------- SAI/LTDC Configuration (PLLSAI) ------------------*/\r\n  /*----------------------- Common configuration SAI/LTDC --------------------*/\r\n  /* In Case of SAI, LTDC or CLK48 Clock Configuration through PLLSAI, PLLSAIN division\r\n     factor is common parameters for these peripherals */\r\n  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == RCC_PERIPHCLK_SAI_PLLSAI) ||\r\n     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)             ||\r\n     ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)          &&\r\n      (PeriphClkInit->Clk48ClockSelection == RCC_CLK48CLKSOURCE_PLLSAIP)))\r\n  {\r\n    /* Check the PLLSAI division factors */\r\n    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));\r\n\r\n    /* Disable PLLSAI Clock */\r\n    __HAL_RCC_PLLSAI_DISABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLSAI is disabled */\r\n    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /*---------------------------- SAI configuration -------------------------*/\r\n    /* In Case of SAI Clock Configuration through PLLSAI, PLLSAIQ and PLLSAI_DIVQ must\r\n       be added only for SAI configuration */\r\n    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == (RCC_PERIPHCLK_SAI_PLLSAI))\r\n    {\r\n      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));\r\n      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));\r\n\r\n      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */\r\n      pllsaip = ((((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos) + 1U) << 1U);\r\n      /* Read PLLSAIR value from PLLSAICFGR register (this value is not need for SAI configuration) */\r\n      pllsair = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);\r\n      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */\r\n      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */\r\n      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */\r\n      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN, pllsaip, PeriphClkInit->PLLSAI.PLLSAIQ, pllsair);\r\n      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */\r\n      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);\r\n    }\r\n\r\n    /*---------------------------- LTDC configuration ------------------------*/\r\n    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))\r\n    {\r\n      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));\r\n      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));\r\n\r\n      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */\r\n      pllsaip = ((((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos) + 1U) << 1U);\r\n      /* Read PLLSAIQ value from PLLSAICFGR register (this value is not need for SAI configuration) */\r\n      pllsaiq = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);\r\n      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */\r\n      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */\r\n      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */\r\n      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN, pllsaip, pllsaiq, PeriphClkInit->PLLSAI.PLLSAIR);\r\n      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */\r\n      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);\r\n    }\r\n\r\n    /*---------------------------- CLK48 configuration ------------------------*/\r\n    /* Configure the PLLSAI when it is used as clock source for CLK48 */\r\n    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == (RCC_PERIPHCLK_CLK48)) &&\r\n       (PeriphClkInit->Clk48ClockSelection == RCC_CLK48CLKSOURCE_PLLSAIP))\r\n    {\r\n      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));\r\n\r\n      /* Read PLLSAIQ value from PLLSAICFGR register (this value is not need for SAI configuration) */\r\n      pllsaiq = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);\r\n      /* Read PLLSAIR value from PLLSAICFGR register (this value is not need for SAI configuration) */\r\n      pllsair = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);\r\n      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */\r\n      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */\r\n      /* CLK48_CLK(first level) = PLLSAI_VCO Output/PLLSAIP */\r\n      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN, PeriphClkInit->PLLSAI.PLLSAIP, pllsaiq, pllsair);\r\n    }\r\n\r\n    /* Enable PLLSAI Clock */\r\n    __HAL_RCC_PLLSAI_ENABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLSAI is ready */\r\n    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*---------------------------- RTC configuration ---------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))\r\n  {\r\n    /* Check for RTC Parameters used to output RTCCLK */\r\n    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));\r\n\r\n    /* Enable Power Clock*/\r\n    __HAL_RCC_PWR_CLK_ENABLE();\r\n\r\n    /* Enable write access to Backup domain */\r\n    PWR->CR |= PWR_CR_DBP;\r\n\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n\r\n    while((PWR->CR & PWR_CR_DBP) == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */\r\n    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);\r\n    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))\r\n    {\r\n      /* Store the content of BDCR register before the reset of Backup Domain */\r\n      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));\r\n      /* RTC Clock selection can be changed only if the Backup Domain is reset */\r\n      __HAL_RCC_BACKUPRESET_FORCE();\r\n      __HAL_RCC_BACKUPRESET_RELEASE();\r\n      /* Restore the Content of BDCR register */\r\n      RCC->BDCR = tmpreg1;\r\n\r\n      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */\r\n      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))\r\n      {\r\n        /* Get tick */\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till LSE is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*---------------------------- TIM configuration ---------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))\r\n  {\r\n    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the RCC_PeriphCLKInitTypeDef according to the internal\r\n  * RCC configuration registers.\r\n  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  *         will be configured.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tempreg;\r\n\r\n  /* Set all possible values for the extended clock type parameter------------*/\r\n  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S        | RCC_PERIPHCLK_SAI_PLLSAI |\\\r\n                                        RCC_PERIPHCLK_SAI_PLLI2S | RCC_PERIPHCLK_LTDC       |\\\r\n                                        RCC_PERIPHCLK_TIM        | RCC_PERIPHCLK_RTC        |\\\r\n                                        RCC_PERIPHCLK_CLK48       | RCC_PERIPHCLK_SDIO;\r\n\r\n  /* Get the PLLI2S Clock configuration --------------------------------------*/\r\n  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SQ = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);\r\n  /* Get the PLLSAI Clock configuration --------------------------------------*/\r\n  PeriphClkInit->PLLSAI.PLLSAIN = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> RCC_PLLSAICFGR_PLLSAIN_Pos);\r\n  PeriphClkInit->PLLSAI.PLLSAIR = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);\r\n  PeriphClkInit->PLLSAI.PLLSAIQ = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);\r\n  /* Get the PLLSAI/PLLI2S division factors ----------------------------------*/\r\n  PeriphClkInit->PLLI2SDivQ = (uint32_t)((RCC->DCKCFGR & RCC_DCKCFGR_PLLI2SDIVQ) >> RCC_DCKCFGR_PLLI2SDIVQ_Pos);\r\n  PeriphClkInit->PLLSAIDivQ = (uint32_t)((RCC->DCKCFGR & RCC_DCKCFGR_PLLSAIDIVQ) >> RCC_DCKCFGR_PLLSAIDIVQ_Pos);\r\n  PeriphClkInit->PLLSAIDivR = (uint32_t)(RCC->DCKCFGR & RCC_DCKCFGR_PLLSAIDIVR);\r\n  /* Get the RTC Clock configuration -----------------------------------------*/\r\n  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);\r\n  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));\r\n\r\n    /* Get the CLK48 clock configuration -------------------------------------*/\r\n  PeriphClkInit->Clk48ClockSelection = __HAL_RCC_GET_CLK48_SOURCE();\r\n\r\n  /* Get the SDIO clock configuration ----------------------------------------*/\r\n  PeriphClkInit->SdioClockSelection = __HAL_RCC_GET_SDIO_SOURCE();\r\n\r\n  if ((RCC->DCKCFGR & RCC_DCKCFGR_TIMPRE) == RESET)\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;\r\n  }\r\n  else\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Return the peripheral clock frequency for a given peripheral(SAI..)\r\n  * @note   Return 0 if peripheral clock identifier not managed by this API\r\n  * @param  PeriphClk Peripheral clock identifier\r\n  *         This parameter can be one of the following values:\r\n  *            @arg RCC_PERIPHCLK_I2S: I2S peripheral clock\r\n  * @retval Frequency in KHz\r\n  */\r\nuint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)\r\n{\r\n  /* This variable used to store the I2S clock frequency (value in Hz) */\r\n  uint32_t frequency = 0U;\r\n  /* This variable used to store the VCO Input (value in Hz) */\r\n  uint32_t vcoinput = 0U;\r\n  uint32_t srcclk = 0U;\r\n  /* This variable used to store the VCO Output (value in Hz) */\r\n  uint32_t vcooutput = 0U;\r\n  switch (PeriphClk)\r\n  {\r\n  case RCC_PERIPHCLK_I2S:\r\n    {\r\n      /* Get the current I2S source */\r\n      srcclk = __HAL_RCC_GET_I2S_SOURCE();\r\n      switch (srcclk)\r\n      {\r\n      /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */\r\n      case RCC_I2SCLKSOURCE_EXT:\r\n        {\r\n          /* Set the I2S clock to the external clock  value */\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n      /* Check if I2S clock selection is PLLI2S VCO output clock divided by PLLI2SR used as I2S clock */\r\n      case RCC_I2SCLKSOURCE_PLLI2S:\r\n        {\r\n          /* Configure the PLLI2S division factor */\r\n          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n          else\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n\r\n          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));\r\n          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */\r\n          frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));\r\n          break;\r\n        }\r\n        /* Clock not enabled for I2S*/\r\n      default:\r\n        {\r\n          frequency = 0U;\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  }\r\n  return frequency;\r\n}\r\n#endif /* STM32F469xx || STM32F479xx */\r\n\r\n#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)\r\n/**\r\n  * @brief  Initializes the RCC extended peripherals clocks according to the specified\r\n  *         parameters in the RCC_PeriphCLKInitTypeDef.\r\n  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  *         contains the configuration information for the Extended Peripherals\r\n  *         clocks(I2S, LTDC RTC and TIM).\r\n  *\r\n  * @note   Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to select\r\n  *         the RTC clock source; in this case the Backup domain will be reset in\r\n  *         order to modify the RTC Clock source, as consequence RTC registers (including\r\n  *         the backup registers) and RCC_BDCR register are set to their reset values.\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tickstart = 0U;\r\n  uint32_t tmpreg1 = 0U;\r\n#if defined(STM32F413xx) || defined(STM32F423xx)\r\n  uint32_t plli2sq = 0U;\r\n#endif /* STM32F413xx || STM32F423xx */\r\n  uint32_t plli2sused = 0U;\r\n\r\n  /* Check the peripheral clock selection parameters */\r\n  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));\r\n\r\n  /*----------------------------------- I2S APB1 configuration ---------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S_APB1) == (RCC_PERIPHCLK_I2S_APB1))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2SAPB1CLKSOURCE(PeriphClkInit->I2sApb1ClockSelection));\r\n\r\n    /* Configure I2S Clock source */\r\n    __HAL_RCC_I2S_APB1_CONFIG(PeriphClkInit->I2sApb1ClockSelection);\r\n    /* Enable the PLLI2S when it's used as clock source for I2S */\r\n    if(PeriphClkInit->I2sApb1ClockSelection == RCC_I2SAPB1CLKSOURCE_PLLI2S)\r\n    {\r\n      plli2sused = 1U;\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*----------------------------------- I2S APB2 configuration ---------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S_APB2) == (RCC_PERIPHCLK_I2S_APB2))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2SAPB2CLKSOURCE(PeriphClkInit->I2sApb2ClockSelection));\r\n\r\n    /* Configure I2S Clock source */\r\n    __HAL_RCC_I2S_APB2_CONFIG(PeriphClkInit->I2sApb2ClockSelection);\r\n    /* Enable the PLLI2S when it's used as clock source for I2S */\r\n    if(PeriphClkInit->I2sApb2ClockSelection == RCC_I2SAPB2CLKSOURCE_PLLI2S)\r\n    {\r\n      plli2sused = 1U;\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n#if defined(STM32F413xx) || defined(STM32F423xx)\r\n  /*----------------------- SAI1 Block A configuration -----------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAIA) == (RCC_PERIPHCLK_SAIA))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SAIACLKSOURCE(PeriphClkInit->SaiAClockSelection));\r\n\r\n    /* Configure SAI1 Clock source */\r\n    __HAL_RCC_SAI_BLOCKACLKSOURCE_CONFIG(PeriphClkInit->SaiAClockSelection);\r\n    /* Enable the PLLI2S when it's used as clock source for SAI */\r\n    if(PeriphClkInit->SaiAClockSelection == RCC_SAIACLKSOURCE_PLLI2SR)\r\n    {\r\n      plli2sused = 1U;\r\n    }\r\n    /* Enable the PLLSAI when it's used as clock source for SAI */\r\n    if(PeriphClkInit->SaiAClockSelection == RCC_SAIACLKSOURCE_PLLR)\r\n    {\r\n      /* Check for PLL/DIVR parameters */\r\n      assert_param(IS_RCC_PLL_DIVR_VALUE(PeriphClkInit->PLLDivR));\r\n\r\n      /* SAI_CLK_x = SAI_CLK(first level)/PLLDIVR */\r\n      __HAL_RCC_PLL_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLDivR);\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*---------------------- SAI1 Block B configuration ------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAIB) == (RCC_PERIPHCLK_SAIB))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SAIBCLKSOURCE(PeriphClkInit->SaiBClockSelection));\r\n\r\n    /* Configure SAI1 Clock source */\r\n    __HAL_RCC_SAI_BLOCKBCLKSOURCE_CONFIG(PeriphClkInit->SaiBClockSelection);\r\n    /* Enable the PLLI2S when it's used as clock source for SAI */\r\n    if(PeriphClkInit->SaiBClockSelection == RCC_SAIBCLKSOURCE_PLLI2SR)\r\n    {\r\n      plli2sused = 1U;\r\n    }\r\n    /* Enable the PLLSAI when it's used as clock source for SAI */\r\n    if(PeriphClkInit->SaiBClockSelection == RCC_SAIBCLKSOURCE_PLLR)\r\n    {\r\n      /* Check for PLL/DIVR parameters */\r\n      assert_param(IS_RCC_PLL_DIVR_VALUE(PeriphClkInit->PLLDivR));\r\n\r\n      /* SAI_CLK_x = SAI_CLK(first level)/PLLDIVR */\r\n      __HAL_RCC_PLL_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLDivR);\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n#endif /* STM32F413xx || STM32F423xx */\r\n\r\n  /*------------------------------------ RTC configuration -------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))\r\n  {\r\n    /* Check for RTC Parameters used to output RTCCLK */\r\n    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));\r\n\r\n    /* Enable Power Clock*/\r\n    __HAL_RCC_PWR_CLK_ENABLE();\r\n\r\n    /* Enable write access to Backup domain */\r\n    PWR->CR |= PWR_CR_DBP;\r\n\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n\r\n    while((PWR->CR & PWR_CR_DBP) == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */\r\n    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);\r\n    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))\r\n    {\r\n      /* Store the content of BDCR register before the reset of Backup Domain */\r\n      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));\r\n      /* RTC Clock selection can be changed only if the Backup Domain is reset */\r\n      __HAL_RCC_BACKUPRESET_FORCE();\r\n      __HAL_RCC_BACKUPRESET_RELEASE();\r\n      /* Restore the Content of BDCR register */\r\n      RCC->BDCR = tmpreg1;\r\n\r\n      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */\r\n      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))\r\n      {\r\n        /* Get tick */\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till LSE is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*------------------------------------ TIM configuration -------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))\r\n  {\r\n    /* Configure Timer Prescaler */\r\n    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*------------------------------------- FMPI2C1 Configuration --------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMPI2C1) == RCC_PERIPHCLK_FMPI2C1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_FMPI2C1CLKSOURCE(PeriphClkInit->Fmpi2c1ClockSelection));\r\n\r\n    /* Configure the FMPI2C1 clock source */\r\n    __HAL_RCC_FMPI2C1_CONFIG(PeriphClkInit->Fmpi2c1ClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*------------------------------------- CLK48 Configuration ----------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_CLK48CLKSOURCE(PeriphClkInit->Clk48ClockSelection));\r\n\r\n    /* Configure the SDIO clock source */\r\n    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);\r\n\r\n    /* Enable the PLLI2S when it's used as clock source for CLK48 */\r\n    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48CLKSOURCE_PLLI2SQ)\r\n    {\r\n      plli2sused = 1U;\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*------------------------------------- SDIO Configuration -----------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDIO) == RCC_PERIPHCLK_SDIO)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SDIOCLKSOURCE(PeriphClkInit->SdioClockSelection));\r\n\r\n    /* Configure the SDIO clock source */\r\n    __HAL_RCC_SDIO_CONFIG(PeriphClkInit->SdioClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*-------------------------------------- PLLI2S Configuration --------------*/\r\n  /* PLLI2S is configured when a peripheral will use it as source clock : I2S on APB1 or\r\n     I2S on APB2*/\r\n  if((plli2sused == 1U) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))\r\n  {\r\n    /* Disable the PLLI2S */\r\n    __HAL_RCC_PLLI2S_DISABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLI2S is disabled */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /* check for common PLLI2S Parameters */\r\n    assert_param(IS_RCC_PLLI2SCLKSOURCE(PeriphClkInit->PLLI2SSelection));\r\n    assert_param(IS_RCC_PLLI2SM_VALUE(PeriphClkInit->PLLI2S.PLLI2SM));\r\n    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));\r\n    /*-------------------- Set the PLL I2S clock -----------------------------*/\r\n    __HAL_RCC_PLL_I2S_CONFIG(PeriphClkInit->PLLI2SSelection);\r\n\r\n    /*------- In Case of PLLI2S is selected as source clock for I2S ----------*/\r\n    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S_APB1) == RCC_PERIPHCLK_I2S_APB1) && (PeriphClkInit->I2sApb1ClockSelection == RCC_I2SAPB1CLKSOURCE_PLLI2S)) ||\r\n       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S_APB2) == RCC_PERIPHCLK_I2S_APB2) && (PeriphClkInit->I2sApb2ClockSelection == RCC_I2SAPB2CLKSOURCE_PLLI2S)) ||\r\n       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48CLKSOURCE_PLLI2SQ)) ||\r\n       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDIO) == RCC_PERIPHCLK_SDIO) && (PeriphClkInit->SdioClockSelection == RCC_SDIOCLKSOURCE_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48CLKSOURCE_PLLI2SQ)))\r\n    {\r\n      /* check for Parameters */\r\n      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));\r\n      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));\r\n\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM)*/\r\n      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);\r\n    }\r\n\r\n#if defined(STM32F413xx) || defined(STM32F423xx)\r\n    /*------- In Case of PLLI2S is selected as source clock for SAI ----------*/\r\n    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAIA) == RCC_PERIPHCLK_SAIA) && (PeriphClkInit->SaiAClockSelection == RCC_SAIACLKSOURCE_PLLI2SR)) ||\r\n       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAIB) == RCC_PERIPHCLK_SAIB) && (PeriphClkInit->SaiBClockSelection == RCC_SAIBCLKSOURCE_PLLI2SR)))\r\n    {\r\n      /* Check for PLLI2S Parameters */\r\n      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));\r\n      /* Check for PLLI2S/DIVR parameters */\r\n      assert_param(IS_RCC_PLLI2S_DIVR_VALUE(PeriphClkInit->PLLI2SDivR));\r\n\r\n      /* Read PLLI2SQ value from PLLI2SCFGR register (this value is not needed for SAI configuration) */\r\n      plli2sq = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */\r\n      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN, plli2sq, PeriphClkInit->PLLI2S.PLLI2SR);\r\n\r\n      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVR */\r\n      __HAL_RCC_PLLI2S_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLI2SDivR);\r\n    }\r\n#endif /* STM32F413xx || STM32F423xx */\r\n\r\n    /*----------------- In Case of PLLI2S is just selected  ------------------*/\r\n    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)\r\n    {\r\n      /* Check for Parameters */\r\n      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));\r\n      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));\r\n\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM)*/\r\n      /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);\r\n    }\r\n\r\n    /* Enable the PLLI2S */\r\n    __HAL_RCC_PLLI2S_ENABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLI2S is ready */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*-------------------- DFSDM1 clock source configuration -------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));\r\n\r\n    /* Configure the DFSDM1 interface clock source */\r\n    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*-------------------- DFSDM1 Audio clock source configuration -------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));\r\n\r\n    /* Configure the DFSDM1 Audio interface clock source */\r\n    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n#if defined(STM32F413xx) || defined(STM32F423xx)\r\n  /*-------------------- DFSDM2 clock source configuration -------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM2) == RCC_PERIPHCLK_DFSDM2)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_DFSDM2CLKSOURCE(PeriphClkInit->Dfsdm2ClockSelection));\r\n\r\n    /* Configure the DFSDM1 interface clock source */\r\n    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*-------------------- DFSDM2 Audio clock source configuration -------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM2_AUDIO) == RCC_PERIPHCLK_DFSDM2_AUDIO)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_DFSDM2AUDIOCLKSOURCE(PeriphClkInit->Dfsdm2AudioClockSelection));\r\n\r\n    /* Configure the DFSDM1 Audio interface clock source */\r\n    __HAL_RCC_DFSDM2AUDIO_CONFIG(PeriphClkInit->Dfsdm2AudioClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*---------------------------- LPTIM1 Configuration ------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));\r\n\r\n    /* Configure the LPTIM1 clock source */\r\n    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n#endif /* STM32F413xx || STM32F423xx */\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Get the RCC_PeriphCLKInitTypeDef according to the internal\r\n  *         RCC configuration registers.\r\n  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  *         will be configured.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tempreg;\r\n\r\n  /* Set all possible values for the extended clock type parameter------------*/\r\n#if defined(STM32F413xx) || defined(STM32F423xx)\r\n  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S_APB1     | RCC_PERIPHCLK_I2S_APB2 |\\\r\n                                        RCC_PERIPHCLK_TIM          | RCC_PERIPHCLK_RTC      |\\\r\n                                        RCC_PERIPHCLK_FMPI2C1      | RCC_PERIPHCLK_CLK48    |\\\r\n                                        RCC_PERIPHCLK_SDIO         | RCC_PERIPHCLK_DFSDM1   |\\\r\n                                        RCC_PERIPHCLK_DFSDM1_AUDIO | RCC_PERIPHCLK_DFSDM2   |\\\r\n                                        RCC_PERIPHCLK_DFSDM2_AUDIO | RCC_PERIPHCLK_LPTIM1   |\\\r\n                                        RCC_PERIPHCLK_SAIA         | RCC_PERIPHCLK_SAIB;\r\n#else /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */\r\n  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S_APB1 | RCC_PERIPHCLK_I2S_APB2 |\\\r\n                                        RCC_PERIPHCLK_TIM      | RCC_PERIPHCLK_RTC      |\\\r\n                                        RCC_PERIPHCLK_FMPI2C1  | RCC_PERIPHCLK_CLK48    |\\\r\n                                        RCC_PERIPHCLK_SDIO     | RCC_PERIPHCLK_DFSDM1   |\\\r\n                                        RCC_PERIPHCLK_DFSDM1_AUDIO;\r\n#endif /* STM32F413xx || STM32F423xx */\r\n\r\n\r\n\r\n  /* Get the PLLI2S Clock configuration --------------------------------------*/\r\n  PeriphClkInit->PLLI2S.PLLI2SM = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM) >> RCC_PLLI2SCFGR_PLLI2SM_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SQ = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);\r\n#if defined(STM32F413xx) || defined(STM32F423xx)\r\n  /* Get the PLL/PLLI2S division factors -------------------------------------*/\r\n  PeriphClkInit->PLLI2SDivR = (uint32_t)((RCC->DCKCFGR & RCC_DCKCFGR_PLLI2SDIVR) >> RCC_DCKCFGR_PLLI2SDIVR_Pos);\r\n  PeriphClkInit->PLLDivR = (uint32_t)((RCC->DCKCFGR & RCC_DCKCFGR_PLLDIVR) >> RCC_DCKCFGR_PLLDIVR_Pos);\r\n#endif /* STM32F413xx || STM32F423xx */\r\n\r\n  /* Get the I2S APB1 clock configuration ------------------------------------*/\r\n  PeriphClkInit->I2sApb1ClockSelection = __HAL_RCC_GET_I2S_APB1_SOURCE();\r\n\r\n  /* Get the I2S APB2 clock configuration ------------------------------------*/\r\n  PeriphClkInit->I2sApb2ClockSelection = __HAL_RCC_GET_I2S_APB2_SOURCE();\r\n\r\n  /* Get the RTC Clock configuration -----------------------------------------*/\r\n  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);\r\n  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));\r\n\r\n  /* Get the FMPI2C1 clock configuration -------------------------------------*/\r\n  PeriphClkInit->Fmpi2c1ClockSelection = __HAL_RCC_GET_FMPI2C1_SOURCE();\r\n\r\n  /* Get the CLK48 clock configuration ---------------------------------------*/\r\n  PeriphClkInit->Clk48ClockSelection = __HAL_RCC_GET_CLK48_SOURCE();\r\n\r\n  /* Get the SDIO clock configuration ----------------------------------------*/\r\n  PeriphClkInit->SdioClockSelection = __HAL_RCC_GET_SDIO_SOURCE();\r\n\r\n  /* Get the DFSDM1 clock configuration --------------------------------------*/\r\n  PeriphClkInit->Dfsdm1ClockSelection = __HAL_RCC_GET_DFSDM1_SOURCE();\r\n\r\n  /* Get the DFSDM1 Audio clock configuration --------------------------------*/\r\n  PeriphClkInit->Dfsdm1AudioClockSelection = __HAL_RCC_GET_DFSDM1AUDIO_SOURCE();\r\n\r\n#if defined(STM32F413xx) || defined(STM32F423xx)\r\n  /* Get the DFSDM2 clock configuration --------------------------------------*/\r\n  PeriphClkInit->Dfsdm2ClockSelection = __HAL_RCC_GET_DFSDM2_SOURCE();\r\n\r\n  /* Get the DFSDM2 Audio clock configuration --------------------------------*/\r\n  PeriphClkInit->Dfsdm2AudioClockSelection = __HAL_RCC_GET_DFSDM2AUDIO_SOURCE();\r\n\r\n  /* Get the LPTIM1 clock configuration --------------------------------------*/\r\n  PeriphClkInit->Lptim1ClockSelection = __HAL_RCC_GET_LPTIM1_SOURCE();\r\n\r\n  /* Get the SAI1 Block Aclock configuration ---------------------------------*/\r\n  PeriphClkInit->SaiAClockSelection = __HAL_RCC_GET_SAI_BLOCKA_SOURCE();\r\n\r\n  /* Get the SAI1 Block B clock configuration --------------------------------*/\r\n  PeriphClkInit->SaiBClockSelection = __HAL_RCC_GET_SAI_BLOCKB_SOURCE();\r\n#endif /* STM32F413xx || STM32F423xx */\r\n\r\n  /* Get the TIM Prescaler configuration -------------------------------------*/\r\n  if ((RCC->DCKCFGR & RCC_DCKCFGR_TIMPRE) == RESET)\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;\r\n  }\r\n  else\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Return the peripheral clock frequency for a given peripheral(I2S..)\r\n  * @note   Return 0 if peripheral clock identifier not managed by this API\r\n  * @param  PeriphClk Peripheral clock identifier\r\n  *         This parameter can be one of the following values:\r\n  *            @arg RCC_PERIPHCLK_I2S_APB1: I2S APB1 peripheral clock\r\n  *            @arg RCC_PERIPHCLK_I2S_APB2: I2S APB2 peripheral clock\r\n  * @retval Frequency in KHz\r\n  */\r\nuint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)\r\n{\r\n  /* This variable used to store the I2S clock frequency (value in Hz) */\r\n  uint32_t frequency = 0U;\r\n  /* This variable used to store the VCO Input (value in Hz) */\r\n  uint32_t vcoinput = 0U;\r\n  uint32_t srcclk = 0U;\r\n  /* This variable used to store the VCO Output (value in Hz) */\r\n  uint32_t vcooutput = 0U;\r\n  switch (PeriphClk)\r\n  {\r\n  case RCC_PERIPHCLK_I2S_APB1:\r\n    {\r\n      /* Get the current I2S source */\r\n      srcclk = __HAL_RCC_GET_I2S_APB1_SOURCE();\r\n      switch (srcclk)\r\n      {\r\n      /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */\r\n      case RCC_I2SAPB1CLKSOURCE_EXT:\r\n        {\r\n          /* Set the I2S clock to the external clock  value */\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n      /* Check if I2S clock selection is PLLI2S VCO output clock divided by PLLI2SR used as I2S clock */\r\n      case RCC_I2SAPB1CLKSOURCE_PLLI2S:\r\n        {\r\n          if((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SSRC) == RCC_PLLI2SCFGR_PLLI2SSRC)\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(EXTERNAL_CLOCK_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));\r\n          }\r\n          else\r\n          {\r\n            /* Configure the PLLI2S division factor */\r\n            /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */\r\n            if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n            {\r\n              /* Get the I2S source clock value */\r\n              vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));\r\n            }\r\n            else\r\n            {\r\n              /* Get the I2S source clock value */\r\n              vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));\r\n            }\r\n          }\r\n          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));\r\n          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */\r\n          frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));\r\n          break;\r\n        }\r\n      /* Check if I2S clock selection is PLL VCO Output divided by PLLR used as I2S clock */\r\n      case RCC_I2SAPB1CLKSOURCE_PLLR:\r\n        {\r\n          /* Configure the PLL division factor R */\r\n          /* PLL_VCO Input  = PLL_SOURCE/PLLM */\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n          else\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n\r\n          /* PLL_VCO Output = PLL_VCO Input * PLLN */\r\n          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6U) & (RCC_PLLCFGR_PLLN >> 6U)));\r\n          /* I2S_CLK = PLL_VCO Output/PLLR */\r\n          frequency = (uint32_t)(vcooutput /(((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 28U) & (RCC_PLLCFGR_PLLR >> 28U)));\r\n          break;\r\n        }\r\n      /* Check if I2S clock selection is HSI or HSE depending from PLL source Clock */\r\n      case RCC_I2SAPB1CLKSOURCE_PLLSRC:\r\n        {\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            frequency = HSE_VALUE;\r\n          }\r\n          else\r\n          {\r\n            frequency = HSI_VALUE;\r\n          }\r\n          break;\r\n        }\r\n        /* Clock not enabled for I2S*/\r\n      default:\r\n        {\r\n          frequency = 0U;\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  case RCC_PERIPHCLK_I2S_APB2:\r\n    {\r\n      /* Get the current I2S source */\r\n      srcclk = __HAL_RCC_GET_I2S_APB2_SOURCE();\r\n      switch (srcclk)\r\n      {\r\n        /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */\r\n      case RCC_I2SAPB2CLKSOURCE_EXT:\r\n        {\r\n          /* Set the I2S clock to the external clock  value */\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n        /* Check if I2S clock selection is PLLI2S VCO output clock divided by PLLI2SR used as I2S clock */\r\n      case RCC_I2SAPB2CLKSOURCE_PLLI2S:\r\n        {\r\n          if((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SSRC) == RCC_PLLI2SCFGR_PLLI2SSRC)\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(EXTERNAL_CLOCK_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));\r\n          }\r\n          else\r\n          {\r\n            /* Configure the PLLI2S division factor */\r\n            /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */\r\n            if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n            {\r\n              /* Get the I2S source clock value */\r\n              vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));\r\n            }\r\n            else\r\n            {\r\n              /* Get the I2S source clock value */\r\n              vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));\r\n            }\r\n          }\r\n          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));\r\n          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */\r\n          frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));\r\n          break;\r\n        }\r\n        /* Check if I2S clock selection is PLL VCO Output divided by PLLR used as I2S clock */\r\n      case RCC_I2SAPB2CLKSOURCE_PLLR:\r\n        {\r\n          /* Configure the PLL division factor R */\r\n          /* PLL_VCO Input  = PLL_SOURCE/PLLM */\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n          else\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n\r\n          /* PLL_VCO Output = PLL_VCO Input * PLLN */\r\n          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6U) & (RCC_PLLCFGR_PLLN >> 6U)));\r\n          /* I2S_CLK = PLL_VCO Output/PLLR */\r\n          frequency = (uint32_t)(vcooutput /(((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 28U) & (RCC_PLLCFGR_PLLR >> 28U)));\r\n          break;\r\n        }\r\n        /* Check if I2S clock selection is HSI or HSE depending from PLL source Clock */\r\n      case RCC_I2SAPB2CLKSOURCE_PLLSRC:\r\n        {\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            frequency = HSE_VALUE;\r\n          }\r\n          else\r\n          {\r\n            frequency = HSI_VALUE;\r\n          }\r\n          break;\r\n        }\r\n      /* Clock not enabled for I2S*/\r\n      default:\r\n        {\r\n          frequency = 0U;\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  }\r\n  return frequency;\r\n}\r\n#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */\r\n\r\n#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)\r\n/**\r\n  * @brief  Initializes the RCC extended peripherals clocks according to the specified parameters in the\r\n  *         RCC_PeriphCLKInitTypeDef.\r\n  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  *         contains the configuration information for the Extended Peripherals clocks(I2S and RTC clocks).\r\n  *\r\n  * @note   A caution to be taken when HAL_RCCEx_PeriphCLKConfig() is used to select RTC clock selection, in this case\r\n  *         the Reset of Backup domain will be applied in order to modify the RTC Clock source as consequence all backup\r\n  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tickstart = 0U;\r\n  uint32_t tmpreg1 = 0U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));\r\n\r\n  /*---------------------------- RTC configuration ---------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))\r\n  {\r\n    /* Check for RTC Parameters used to output RTCCLK */\r\n    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));\r\n\r\n    /* Enable Power Clock*/\r\n    __HAL_RCC_PWR_CLK_ENABLE();\r\n\r\n    /* Enable write access to Backup domain */\r\n    PWR->CR |= PWR_CR_DBP;\r\n\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n\r\n    while((PWR->CR & PWR_CR_DBP) == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */\r\n    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);\r\n    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))\r\n    {\r\n      /* Store the content of BDCR register before the reset of Backup Domain */\r\n      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));\r\n      /* RTC Clock selection can be changed only if the Backup Domain is reset */\r\n      __HAL_RCC_BACKUPRESET_FORCE();\r\n      __HAL_RCC_BACKUPRESET_RELEASE();\r\n      /* Restore the Content of BDCR register */\r\n      RCC->BDCR = tmpreg1;\r\n\r\n      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */\r\n      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))\r\n      {\r\n        /* Get tick */\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till LSE is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*---------------------------- TIM configuration ---------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))\r\n  {\r\n    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*---------------------------- FMPI2C1 Configuration -----------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMPI2C1) == RCC_PERIPHCLK_FMPI2C1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_FMPI2C1CLKSOURCE(PeriphClkInit->Fmpi2c1ClockSelection));\r\n\r\n    /* Configure the FMPI2C1 clock source */\r\n    __HAL_RCC_FMPI2C1_CONFIG(PeriphClkInit->Fmpi2c1ClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*---------------------------- LPTIM1 Configuration ------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));\r\n\r\n    /* Configure the LPTIM1 clock source */\r\n    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);\r\n  }\r\n\r\n  /*---------------------------- I2S Configuration ---------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2SAPBCLKSOURCE(PeriphClkInit->I2SClockSelection));\r\n\r\n    /* Configure the I2S clock source */\r\n    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2SClockSelection);\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the RCC_OscInitStruct according to the internal\r\n  * RCC configuration registers.\r\n  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  * will be configured.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tempreg;\r\n\r\n  /* Set all possible values for the extended clock type parameter------------*/\r\n  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_FMPI2C1 | RCC_PERIPHCLK_LPTIM1 | RCC_PERIPHCLK_TIM | RCC_PERIPHCLK_RTC;\r\n\r\n  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);\r\n  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));\r\n\r\n  if ((RCC->DCKCFGR & RCC_DCKCFGR_TIMPRE) == RESET)\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;\r\n  }\r\n  else\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;\r\n  }\r\n  /* Get the FMPI2C1 clock configuration -------------------------------------*/\r\n  PeriphClkInit->Fmpi2c1ClockSelection = __HAL_RCC_GET_FMPI2C1_SOURCE();\r\n\r\n  /* Get the I2S clock configuration -----------------------------------------*/\r\n  PeriphClkInit->I2SClockSelection = __HAL_RCC_GET_I2S_SOURCE();\r\n\r\n\r\n}\r\n/**\r\n  * @brief  Return the peripheral clock frequency for a given peripheral(SAI..)\r\n  * @note   Return 0 if peripheral clock identifier not managed by this API\r\n  * @param  PeriphClk Peripheral clock identifier\r\n  *         This parameter can be one of the following values:\r\n  *            @arg RCC_PERIPHCLK_I2S: I2S peripheral clock\r\n  * @retval Frequency in KHz\r\n  */\r\nuint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)\r\n{\r\n  /* This variable used to store the I2S clock frequency (value in Hz) */\r\n  uint32_t frequency = 0U;\r\n  /* This variable used to store the VCO Input (value in Hz) */\r\n  uint32_t vcoinput = 0U;\r\n  uint32_t srcclk = 0U;\r\n  /* This variable used to store the VCO Output (value in Hz) */\r\n  uint32_t vcooutput = 0U;\r\n  switch (PeriphClk)\r\n  {\r\n  case RCC_PERIPHCLK_I2S:\r\n    {\r\n      /* Get the current I2S source */\r\n      srcclk = __HAL_RCC_GET_I2S_SOURCE();\r\n      switch (srcclk)\r\n      {\r\n      /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */\r\n      case RCC_I2SAPBCLKSOURCE_EXT:\r\n        {\r\n          /* Set the I2S clock to the external clock  value */\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n      /* Check if I2S clock selection is PLL VCO Output divided by PLLR used as I2S clock */\r\n      case RCC_I2SAPBCLKSOURCE_PLLR:\r\n        {\r\n          /* Configure the PLL division factor R */\r\n          /* PLL_VCO Input  = PLL_SOURCE/PLLM */\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n          else\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n\r\n          /* PLL_VCO Output = PLL_VCO Input * PLLN */\r\n          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6U) & (RCC_PLLCFGR_PLLN >> 6U)));\r\n          /* I2S_CLK = PLL_VCO Output/PLLR */\r\n          frequency = (uint32_t)(vcooutput /(((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 28U) & (RCC_PLLCFGR_PLLR >> 28U)));\r\n          break;\r\n        }\r\n      /* Check if I2S clock selection is HSI or HSE depending from PLL source Clock */\r\n      case RCC_I2SAPBCLKSOURCE_PLLSRC:\r\n        {\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            frequency = HSE_VALUE;\r\n          }\r\n          else\r\n          {\r\n            frequency = HSI_VALUE;\r\n          }\r\n          break;\r\n        }\r\n        /* Clock not enabled for I2S*/\r\n      default:\r\n        {\r\n          frequency = 0U;\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  }\r\n  return frequency;\r\n}\r\n#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */\r\n\r\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\r\n/**\r\n  * @brief  Initializes the RCC extended peripherals clocks according to the specified\r\n  *         parameters in the RCC_PeriphCLKInitTypeDef.\r\n  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  *         contains the configuration information for the Extended Peripherals\r\n  *         clocks(I2S, SAI, LTDC RTC and TIM).\r\n  *\r\n  * @note   Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to select\r\n  *         the RTC clock source; in this case the Backup domain will be reset in\r\n  *         order to modify the RTC Clock source, as consequence RTC registers (including\r\n  *         the backup registers) and RCC_BDCR register are set to their reset values.\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tickstart = 0U;\r\n  uint32_t tmpreg1 = 0U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));\r\n\r\n  /*----------------------- SAI/I2S Configuration (PLLI2S) -------------------*/\r\n  /*----------------------- Common configuration SAI/I2S ---------------------*/\r\n  /* In Case of SAI or I2S Clock Configuration through PLLI2S, PLLI2SN division\r\n     factor is common parameters for both peripherals */\r\n  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||\r\n     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLI2S) == RCC_PERIPHCLK_SAI_PLLI2S) ||\r\n     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))\r\n  {\r\n    /* check for Parameters */\r\n    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));\r\n\r\n    /* Disable the PLLI2S */\r\n    __HAL_RCC_PLLI2S_DISABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLI2S is disabled */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /*---------------------------- I2S configuration -------------------------*/\r\n    /* In Case of I2S Clock Configuration through PLLI2S, PLLI2SR must be added\r\n      only for I2S configuration */\r\n    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))\r\n    {\r\n      /* check for Parameters */\r\n      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLM) */\r\n      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */\r\n      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);\r\n    }\r\n\r\n    /*---------------------------- SAI configuration -------------------------*/\r\n    /* In Case of SAI Clock Configuration through PLLI2S, PLLI2SQ and PLLI2S_DIVQ must\r\n       be added only for SAI configuration */\r\n    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLI2S) == (RCC_PERIPHCLK_SAI_PLLI2S))\r\n    {\r\n      /* Check the PLLI2S division factors */\r\n      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));\r\n      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));\r\n\r\n      /* Read PLLI2SR value from PLLI2SCFGR register (this value is not need for SAI configuration) */\r\n      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);\r\n      /* Configure the PLLI2S division factors */\r\n      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */\r\n      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */\r\n      __HAL_RCC_PLLI2S_SAICLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SQ , tmpreg1);\r\n      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */\r\n      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);\r\n    }\r\n\r\n    /*----------------- In Case of PLLI2S is just selected  -----------------*/\r\n    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)\r\n    {\r\n      /* Check for Parameters */\r\n      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));\r\n      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));\r\n\r\n      /* Configure the PLLI2S multiplication and division factors */\r\n      __HAL_RCC_PLLI2S_SAICLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);\r\n    }\r\n\r\n    /* Enable the PLLI2S */\r\n    __HAL_RCC_PLLI2S_ENABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLI2S is ready */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*----------------------- SAI/LTDC Configuration (PLLSAI) ------------------*/\r\n  /*----------------------- Common configuration SAI/LTDC --------------------*/\r\n  /* In Case of SAI or LTDC Clock Configuration through PLLSAI, PLLSAIN division\r\n     factor is common parameters for both peripherals */\r\n  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == RCC_PERIPHCLK_SAI_PLLSAI) ||\r\n     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC))\r\n  {\r\n    /* Check the PLLSAI division factors */\r\n    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));\r\n\r\n    /* Disable PLLSAI Clock */\r\n    __HAL_RCC_PLLSAI_DISABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLSAI is disabled */\r\n    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /*---------------------------- SAI configuration -------------------------*/\r\n    /* In Case of SAI Clock Configuration through PLLSAI, PLLSAIQ and PLLSAI_DIVQ must\r\n       be added only for SAI configuration */\r\n    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == (RCC_PERIPHCLK_SAI_PLLSAI))\r\n    {\r\n      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));\r\n      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));\r\n\r\n      /* Read PLLSAIR value from PLLSAICFGR register (this value is not need for SAI configuration) */\r\n      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);\r\n      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */\r\n      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */\r\n      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */\r\n      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);\r\n      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */\r\n      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);\r\n    }\r\n\r\n    /*---------------------------- LTDC configuration ------------------------*/\r\n    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))\r\n    {\r\n      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));\r\n      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));\r\n\r\n      /* Read PLLSAIR value from PLLSAICFGR register (this value is not need for SAI configuration) */\r\n      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);\r\n      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */\r\n      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */\r\n      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */\r\n      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, PeriphClkInit->PLLSAI.PLLSAIR);\r\n      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */\r\n      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);\r\n    }\r\n    /* Enable PLLSAI Clock */\r\n    __HAL_RCC_PLLSAI_ENABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLSAI is ready */\r\n    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*---------------------------- RTC configuration ---------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))\r\n  {\r\n    /* Check for RTC Parameters used to output RTCCLK */\r\n    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));\r\n\r\n    /* Enable Power Clock*/\r\n    __HAL_RCC_PWR_CLK_ENABLE();\r\n\r\n    /* Enable write access to Backup domain */\r\n    PWR->CR |= PWR_CR_DBP;\r\n\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n\r\n    while((PWR->CR & PWR_CR_DBP) == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */\r\n    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);\r\n    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))\r\n    {\r\n      /* Store the content of BDCR register before the reset of Backup Domain */\r\n      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));\r\n      /* RTC Clock selection can be changed only if the Backup Domain is reset */\r\n      __HAL_RCC_BACKUPRESET_FORCE();\r\n      __HAL_RCC_BACKUPRESET_RELEASE();\r\n      /* Restore the Content of BDCR register */\r\n      RCC->BDCR = tmpreg1;\r\n\r\n      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */\r\n      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))\r\n      {\r\n        /* Get tick */\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till LSE is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);\r\n  }\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /*---------------------------- TIM configuration ---------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))\r\n  {\r\n    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the PeriphClkInit according to the internal\r\n  * RCC configuration registers.\r\n  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  *         will be configured.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tempreg;\r\n\r\n  /* Set all possible values for the extended clock type parameter------------*/\r\n  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S | RCC_PERIPHCLK_SAI_PLLSAI | RCC_PERIPHCLK_SAI_PLLI2S | RCC_PERIPHCLK_LTDC | RCC_PERIPHCLK_TIM | RCC_PERIPHCLK_RTC;\r\n\r\n  /* Get the PLLI2S Clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SQ = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);\r\n  /* Get the PLLSAI Clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->PLLSAI.PLLSAIN = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> RCC_PLLSAICFGR_PLLSAIN_Pos);\r\n  PeriphClkInit->PLLSAI.PLLSAIR = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);\r\n  PeriphClkInit->PLLSAI.PLLSAIQ = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);\r\n  /* Get the PLLSAI/PLLI2S division factors -----------------------------------------------*/\r\n  PeriphClkInit->PLLI2SDivQ = (uint32_t)((RCC->DCKCFGR & RCC_DCKCFGR_PLLI2SDIVQ) >> RCC_DCKCFGR_PLLI2SDIVQ_Pos);\r\n  PeriphClkInit->PLLSAIDivQ = (uint32_t)((RCC->DCKCFGR & RCC_DCKCFGR_PLLSAIDIVQ) >> RCC_DCKCFGR_PLLSAIDIVQ_Pos);\r\n  PeriphClkInit->PLLSAIDivR = (uint32_t)(RCC->DCKCFGR & RCC_DCKCFGR_PLLSAIDIVR);\r\n  /* Get the RTC Clock configuration -----------------------------------------------*/\r\n  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);\r\n  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));\r\n\r\n  if ((RCC->DCKCFGR & RCC_DCKCFGR_TIMPRE) == RESET)\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;\r\n  }\r\n  else\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Return the peripheral clock frequency for a given peripheral(SAI..)\r\n  * @note   Return 0 if peripheral clock identifier not managed by this API\r\n  * @param  PeriphClk Peripheral clock identifier\r\n  *         This parameter can be one of the following values:\r\n  *            @arg RCC_PERIPHCLK_I2S: I2S peripheral clock\r\n  * @retval Frequency in KHz\r\n  */\r\nuint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)\r\n{\r\n  /* This variable used to store the I2S clock frequency (value in Hz) */\r\n  uint32_t frequency = 0U;\r\n  /* This variable used to store the VCO Input (value in Hz) */\r\n  uint32_t vcoinput = 0U;\r\n  uint32_t srcclk = 0U;\r\n  /* This variable used to store the VCO Output (value in Hz) */\r\n  uint32_t vcooutput = 0U;\r\n  switch (PeriphClk)\r\n  {\r\n  case RCC_PERIPHCLK_I2S:\r\n    {\r\n      /* Get the current I2S source */\r\n      srcclk = __HAL_RCC_GET_I2S_SOURCE();\r\n      switch (srcclk)\r\n      {\r\n      /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */\r\n      case RCC_I2SCLKSOURCE_EXT:\r\n        {\r\n          /* Set the I2S clock to the external clock  value */\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n      /* Check if I2S clock selection is PLLI2S VCO output clock divided by PLLI2SR used as I2S clock */\r\n      case RCC_I2SCLKSOURCE_PLLI2S:\r\n        {\r\n          /* Configure the PLLI2S division factor */\r\n          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n          else\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n\r\n          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));\r\n          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */\r\n          frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));\r\n          break;\r\n        }\r\n        /* Clock not enabled for I2S*/\r\n      default:\r\n        {\r\n          frequency = 0U;\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  }\r\n  return frequency;\r\n}\r\n#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */\r\n\r\n#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx) ||\\\r\n    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)\r\n/**\r\n  * @brief  Initializes the RCC extended peripherals clocks according to the specified parameters in the\r\n  *         RCC_PeriphCLKInitTypeDef.\r\n  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  *         contains the configuration information for the Extended Peripherals clocks(I2S and RTC clocks).\r\n  *\r\n  * @note   A caution to be taken when HAL_RCCEx_PeriphCLKConfig() is used to select RTC clock selection, in this case\r\n  *         the Reset of Backup domain will be applied in order to modify the RTC Clock source as consequence all backup\r\n  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tickstart = 0U;\r\n  uint32_t tmpreg1 = 0U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));\r\n\r\n  /*---------------------------- I2S configuration ---------------------------*/\r\n  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||\r\n     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))\r\n  {\r\n    /* check for Parameters */\r\n    assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));\r\n    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));\r\n#if defined(STM32F411xE)\r\n    assert_param(IS_RCC_PLLI2SM_VALUE(PeriphClkInit->PLLI2S.PLLI2SM));\r\n#endif /* STM32F411xE */\r\n    /* Disable the PLLI2S */\r\n    __HAL_RCC_PLLI2S_DISABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLI2S is disabled */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n#if defined(STM32F411xE)\r\n    /* Configure the PLLI2S division factors */\r\n    /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */\r\n    /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */\r\n    __HAL_RCC_PLLI2S_I2SCLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SR);\r\n#else\r\n    /* Configure the PLLI2S division factors */\r\n    /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLM) */\r\n    /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */\r\n    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);\r\n#endif /* STM32F411xE */\r\n\r\n    /* Enable the PLLI2S */\r\n    __HAL_RCC_PLLI2S_ENABLE();\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLLI2S is ready */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)\r\n      {\r\n        /* return in case of Timeout detected */\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n\r\n  /*---------------------------- RTC configuration ---------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))\r\n  {\r\n    /* Check for RTC Parameters used to output RTCCLK */\r\n    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));\r\n\r\n    /* Enable Power Clock*/\r\n    __HAL_RCC_PWR_CLK_ENABLE();\r\n\r\n    /* Enable write access to Backup domain */\r\n    PWR->CR |= PWR_CR_DBP;\r\n\r\n    /* Get tick */\r\n    tickstart = HAL_GetTick();\r\n\r\n    while((PWR->CR & PWR_CR_DBP) == RESET)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */\r\n    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);\r\n    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))\r\n    {\r\n      /* Store the content of BDCR register before the reset of Backup Domain */\r\n      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));\r\n      /* RTC Clock selection can be changed only if the Backup Domain is reset */\r\n      __HAL_RCC_BACKUPRESET_FORCE();\r\n      __HAL_RCC_BACKUPRESET_RELEASE();\r\n      /* Restore the Content of BDCR register */\r\n      RCC->BDCR = tmpreg1;\r\n\r\n      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */\r\n      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))\r\n      {\r\n        /* Get tick */\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till LSE is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);\r\n  }\r\n#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)\r\n  /*---------------------------- TIM configuration ---------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))\r\n  {\r\n    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);\r\n  }\r\n#endif /* STM32F401xC || STM32F401xE || STM32F411xE */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the RCC_OscInitStruct according to the internal\r\n  * RCC configuration registers.\r\n  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  * will be configured.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tempreg;\r\n\r\n  /* Set all possible values for the extended clock type parameter------------*/\r\n  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S | RCC_PERIPHCLK_RTC;\r\n\r\n  /* Get the PLLI2S Clock configuration --------------------------------------*/\r\n  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);\r\n  PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);\r\n#if defined(STM32F411xE)\r\n  PeriphClkInit->PLLI2S.PLLI2SM = (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM);\r\n#endif /* STM32F411xE */\r\n  /* Get the RTC Clock configuration -----------------------------------------*/\r\n  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);\r\n  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));\r\n\r\n#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)\r\n  /* Get the TIM Prescaler configuration -------------------------------------*/\r\n  if ((RCC->DCKCFGR & RCC_DCKCFGR_TIMPRE) == RESET)\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;\r\n  }\r\n  else\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;\r\n  }\r\n#endif /* STM32F401xC || STM32F401xE || STM32F411xE */\r\n}\r\n\r\n/**\r\n  * @brief  Return the peripheral clock frequency for a given peripheral(SAI..)\r\n  * @note   Return 0 if peripheral clock identifier not managed by this API\r\n  * @param  PeriphClk Peripheral clock identifier\r\n  *         This parameter can be one of the following values:\r\n  *            @arg RCC_PERIPHCLK_I2S: I2S peripheral clock\r\n  * @retval Frequency in KHz\r\n  */\r\nuint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)\r\n{\r\n  /* This variable used to store the I2S clock frequency (value in Hz) */\r\n  uint32_t frequency = 0U;\r\n  /* This variable used to store the VCO Input (value in Hz) */\r\n  uint32_t vcoinput = 0U;\r\n  uint32_t srcclk = 0U;\r\n  /* This variable used to store the VCO Output (value in Hz) */\r\n  uint32_t vcooutput = 0U;\r\n  switch (PeriphClk)\r\n  {\r\n  case RCC_PERIPHCLK_I2S:\r\n    {\r\n      /* Get the current I2S source */\r\n      srcclk = __HAL_RCC_GET_I2S_SOURCE();\r\n      switch (srcclk)\r\n      {\r\n      /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */\r\n      case RCC_I2SCLKSOURCE_EXT:\r\n        {\r\n          /* Set the I2S clock to the external clock  value */\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n      /* Check if I2S clock selection is PLLI2S VCO output clock divided by PLLI2SR used as I2S clock */\r\n      case RCC_I2SCLKSOURCE_PLLI2S:\r\n        {\r\n#if defined(STM32F411xE)\r\n          /* Configure the PLLI2S division factor */\r\n          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));\r\n          }\r\n          else\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));\r\n          }\r\n#else\r\n          /* Configure the PLLI2S division factor */\r\n          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */\r\n          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n          else\r\n          {\r\n            /* Get the I2S source clock value */\r\n            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));\r\n          }\r\n#endif /* STM32F411xE */\r\n          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */\r\n          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));\r\n          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */\r\n          frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));\r\n          break;\r\n        }\r\n        /* Clock not enabled for I2S*/\r\n      default:\r\n        {\r\n          frequency = 0U;\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  }\r\n  return frequency;\r\n}\r\n#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F401xC || STM32F401xE  || STM32F411xE */\r\n\r\n#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||\\\r\n    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)\r\n/**\r\n  * @brief  Select LSE mode\r\n  *\r\n  * @note   This mode is only available for STM32F410xx/STM32F411xx/STM32F446xx/STM32F469xx/STM32F479xx/STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx  devices.\r\n  *\r\n  * @param  Mode specifies the LSE mode.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg RCC_LSE_LOWPOWER_MODE:  LSE oscillator in low power mode selection\r\n  *            @arg RCC_LSE_HIGHDRIVE_MODE: LSE oscillator in High Drive mode selection\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_SelectLSEMode(uint8_t Mode)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_LSE_MODE(Mode));\r\n  if(Mode == RCC_LSE_HIGHDRIVE_MODE)\r\n  {\r\n    SET_BIT(RCC->BDCR, RCC_BDCR_LSEMOD);\r\n  }\r\n  else\r\n  {\r\n    CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEMOD);\r\n  }\r\n}\r\n\r\n#endif /* STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */\r\n\r\n/** @defgroup RCCEx_Exported_Functions_Group2 Extended Clock management functions\r\n *  @brief  Extended Clock management functions\r\n *\r\n@verbatim   \r\n ===============================================================================\r\n                ##### Extended clock management functions  #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to control the \r\n    activation or deactivation of PLLI2S, PLLSAI.\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n#if defined(RCC_PLLI2S_SUPPORT)\r\n/**\r\n  * @brief  Enable PLLI2S.\r\n  * @param  PLLI2SInit  pointer to an RCC_PLLI2SInitTypeDef structure that\r\n  *         contains the configuration information for the PLLI2S\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_EnablePLLI2S(RCC_PLLI2SInitTypeDef  *PLLI2SInit)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Check for parameters */\r\n  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SInit->PLLI2SN));\r\n  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SInit->PLLI2SR));\r\n#if defined(RCC_PLLI2SCFGR_PLLI2SM)\r\n  assert_param(IS_RCC_PLLI2SM_VALUE(PLLI2SInit->PLLI2SM));\r\n#endif /* RCC_PLLI2SCFGR_PLLI2SM */\r\n#if defined(RCC_PLLI2SCFGR_PLLI2SP)\r\n  assert_param(IS_RCC_PLLI2SP_VALUE(PLLI2SInit->PLLI2SP));\r\n#endif /* RCC_PLLI2SCFGR_PLLI2SP */\r\n#if defined(RCC_PLLI2SCFGR_PLLI2SQ)\r\n  assert_param(IS_RCC_PLLI2SQ_VALUE(PLLI2SInit->PLLI2SQ));\r\n#endif /* RCC_PLLI2SCFGR_PLLI2SQ */\r\n\r\n  /* Disable the PLLI2S */\r\n  __HAL_RCC_PLLI2S_DISABLE();\r\n\r\n  /* Wait till PLLI2S is disabled */\r\n  tickstart = HAL_GetTick();\r\n  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY) != RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)\r\n    {\r\n      /* return in case of Timeout detected */\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Configure the PLLI2S division factors */\r\n#if defined(STM32F446xx)\r\n  /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */\r\n  /* I2SPCLK = PLLI2S_VCO / PLLI2SP */\r\n  /* I2SQCLK = PLLI2S_VCO / PLLI2SQ */\r\n  /* I2SRCLK = PLLI2S_VCO / PLLI2SR */\r\n  __HAL_RCC_PLLI2S_CONFIG(PLLI2SInit->PLLI2SM, PLLI2SInit->PLLI2SN, \\\r\n                          PLLI2SInit->PLLI2SP, PLLI2SInit->PLLI2SQ, PLLI2SInit->PLLI2SR);\r\n#elif defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\\\r\n      defined(STM32F413xx) || defined(STM32F423xx)\r\n  /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM)*/\r\n  /* I2SQCLK = PLLI2S_VCO / PLLI2SQ */\r\n  /* I2SRCLK = PLLI2S_VCO / PLLI2SR */\r\n  __HAL_RCC_PLLI2S_CONFIG(PLLI2SInit->PLLI2SM, PLLI2SInit->PLLI2SN, \\\r\n                          PLLI2SInit->PLLI2SQ, PLLI2SInit->PLLI2SR);\r\n#elif defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\\\r\n      defined(STM32F469xx) || defined(STM32F479xx)\r\n  /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * PLLI2SN */\r\n  /* I2SQCLK = PLLI2S_VCO / PLLI2SQ */\r\n  /* I2SRCLK = PLLI2S_VCO / PLLI2SR */\r\n  __HAL_RCC_PLLI2S_SAICLK_CONFIG(PLLI2SInit->PLLI2SN, PLLI2SInit->PLLI2SQ, PLLI2SInit->PLLI2SR);\r\n#elif defined(STM32F411xE)\r\n  /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */\r\n  /* I2SRCLK = PLLI2S_VCO / PLLI2SR */\r\n  __HAL_RCC_PLLI2S_I2SCLK_CONFIG(PLLI2SInit->PLLI2SM, PLLI2SInit->PLLI2SN, PLLI2SInit->PLLI2SR);\r\n#else\r\n  /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x PLLI2SN */\r\n  /* I2SRCLK = PLLI2S_VCO / PLLI2SR */\r\n  __HAL_RCC_PLLI2S_CONFIG(PLLI2SInit->PLLI2SN, PLLI2SInit->PLLI2SR);\r\n#endif /* STM32F446xx */\r\n\r\n  /* Enable the PLLI2S */\r\n  __HAL_RCC_PLLI2S_ENABLE();\r\n\r\n  /* Wait till PLLI2S is ready */\r\n  tickstart = HAL_GetTick();\r\n  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY) == RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)\r\n    {\r\n      /* return in case of Timeout detected */\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Disable PLLI2S.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_DisablePLLI2S(void)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Disable the PLLI2S */\r\n  __HAL_RCC_PLLI2S_DISABLE();\r\n\r\n  /* Wait till PLLI2S is disabled */\r\n  tickstart = HAL_GetTick();\r\n  while(READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)\r\n    {\r\n      /* return in case of Timeout detected */\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n#endif /* RCC_PLLI2S_SUPPORT */\r\n\r\n#if defined(RCC_PLLSAI_SUPPORT)\r\n/**\r\n  * @brief  Enable PLLSAI.\r\n  * @param  PLLSAIInit  pointer to an RCC_PLLSAIInitTypeDef structure that\r\n  *         contains the configuration information for the PLLSAI\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI(RCC_PLLSAIInitTypeDef  *PLLSAIInit)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Check for parameters */\r\n  assert_param(IS_RCC_PLLSAIN_VALUE(PLLSAIInit->PLLSAIN));\r\n  assert_param(IS_RCC_PLLSAIQ_VALUE(PLLSAIInit->PLLSAIQ));\r\n#if defined(RCC_PLLSAICFGR_PLLSAIM)\r\n  assert_param(IS_RCC_PLLSAIM_VALUE(PLLSAIInit->PLLSAIM));\r\n#endif /* RCC_PLLSAICFGR_PLLSAIM */\r\n#if defined(RCC_PLLSAICFGR_PLLSAIP)\r\n  assert_param(IS_RCC_PLLSAIP_VALUE(PLLSAIInit->PLLSAIP));\r\n#endif /* RCC_PLLSAICFGR_PLLSAIP */\r\n#if defined(RCC_PLLSAICFGR_PLLSAIR)\r\n  assert_param(IS_RCC_PLLSAIR_VALUE(PLLSAIInit->PLLSAIR));\r\n#endif /* RCC_PLLSAICFGR_PLLSAIR */\r\n\r\n  /* Disable the PLLSAI */\r\n  __HAL_RCC_PLLSAI_DISABLE();\r\n\r\n  /* Wait till PLLSAI is disabled */\r\n  tickstart = HAL_GetTick();\r\n  while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)\r\n    {\r\n      /* return in case of Timeout detected */\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Configure the PLLSAI division factors */\r\n#if defined(STM32F446xx)\r\n  /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) * (PLLSAIN/PLLSAIM) */\r\n  /* SAIPCLK = PLLSAI_VCO / PLLSAIP */\r\n  /* SAIQCLK = PLLSAI_VCO / PLLSAIQ */\r\n  /* SAIRCLK = PLLSAI_VCO / PLLSAIR */\r\n  __HAL_RCC_PLLSAI_CONFIG(PLLSAIInit->PLLSAIM, PLLSAIInit->PLLSAIN, \\\r\n                          PLLSAIInit->PLLSAIP, PLLSAIInit->PLLSAIQ, 0U);\r\n#elif defined(STM32F469xx) || defined(STM32F479xx)\r\n  /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) * PLLSAIN */\r\n  /* SAIPCLK = PLLSAI_VCO / PLLSAIP */\r\n  /* SAIQCLK = PLLSAI_VCO / PLLSAIQ */\r\n  /* SAIRCLK = PLLSAI_VCO / PLLSAIR */\r\n  __HAL_RCC_PLLSAI_CONFIG(PLLSAIInit->PLLSAIN, PLLSAIInit->PLLSAIP, \\\r\n                          PLLSAIInit->PLLSAIQ, PLLSAIInit->PLLSAIR);\r\n#else\r\n  /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x PLLSAIN */\r\n  /* SAIQCLK = PLLSAI_VCO / PLLSAIQ */\r\n  /* SAIRCLK = PLLSAI_VCO / PLLSAIR */\r\n  __HAL_RCC_PLLSAI_CONFIG(PLLSAIInit->PLLSAIN, PLLSAIInit->PLLSAIQ, PLLSAIInit->PLLSAIR);\r\n#endif /* STM32F446xx */\r\n\r\n  /* Enable the PLLSAI */\r\n  __HAL_RCC_PLLSAI_ENABLE();\r\n\r\n  /* Wait till PLLSAI is ready */\r\n  tickstart = HAL_GetTick();\r\n  while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)\r\n    {\r\n      /* return in case of Timeout detected */\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Disable PLLSAI.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI(void)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Disable the PLLSAI */\r\n  __HAL_RCC_PLLSAI_DISABLE();\r\n\r\n  /* Wait till PLLSAI is disabled */\r\n  tickstart = HAL_GetTick();\r\n  while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)\r\n  {\r\n    if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)\r\n    {\r\n      /* return in case of Timeout detected */\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n#endif /* RCC_PLLSAI_SUPPORT */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#if defined(STM32F446xx)\r\n/**\r\n  * @brief  Returns the SYSCLK frequency\r\n  *\r\n  * @note   This function implementation is valid only for STM32F446xx devices.\r\n  * @note   This function add the PLL/PLLR System clock source\r\n  *\r\n  * @note   The system frequency computed by this function is not the real\r\n  *         frequency in the chip. It is calculated based on the predefined\r\n  *         constant and the selected clock source:\r\n  * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)\r\n  * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)\r\n  * @note     If SYSCLK source is PLL or PLLR, function returns values based on HSE_VALUE(**)\r\n  *           or HSI_VALUE(*) multiplied/divided by the PLL factors.\r\n  * @note     (*) HSI_VALUE is a constant defined in stm32f4xx_hal_conf.h file (default value\r\n  *               16 MHz) but the real value may vary depending on the variations\r\n  *               in voltage and temperature.\r\n  * @note     (**) HSE_VALUE is a constant defined in stm32f4xx_hal_conf.h file (default value\r\n  *                25 MHz), user has to ensure that HSE_VALUE is same as the real\r\n  *                frequency of the crystal used. Otherwise, this function may\r\n  *                have wrong result.\r\n  *\r\n  * @note   The result of this function could be not correct when using fractional\r\n  *         value for HSE crystal.\r\n  *\r\n  * @note   This function can be used by the user application to compute the\r\n  *         baudrate for the communication peripherals or configure other parameters.\r\n  *\r\n  * @note   Each time SYSCLK changes, this function must be called to update the\r\n  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.\r\n  *\r\n  *\r\n  * @retval SYSCLK frequency\r\n  */\r\nuint32_t HAL_RCC_GetSysClockFreq(void)\r\n{\r\n  uint32_t pllm = 0U;\r\n  uint32_t pllvco = 0U;\r\n  uint32_t pllp = 0U;\r\n  uint32_t pllr = 0U;\r\n  uint32_t sysclockfreq = 0U;\r\n\r\n  /* Get SYSCLK source -------------------------------------------------------*/\r\n  switch (RCC->CFGR & RCC_CFGR_SWS)\r\n  {\r\n    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */\r\n    {\r\n      sysclockfreq = HSI_VALUE;\r\n       break;\r\n    }\r\n    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */\r\n    {\r\n      sysclockfreq = HSE_VALUE;\r\n      break;\r\n    }\r\n    case RCC_CFGR_SWS_PLL:  /* PLL/PLLP used as system clock  source */\r\n    {\r\n      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN\r\n      SYSCLK = PLL_VCO / PLLP */\r\n      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;\r\n      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)\r\n      {\r\n        /* HSE used as PLL clock source */\r\n        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);\r\n      }\r\n      else\r\n      {\r\n        /* HSI used as PLL clock source */\r\n        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);\r\n      }\r\n      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);\r\n\r\n      sysclockfreq = pllvco/pllp;\r\n      break;\r\n    }\r\n    case RCC_CFGR_SWS_PLLR:  /* PLL/PLLR used as system clock  source */\r\n    {\r\n      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN\r\n      SYSCLK = PLL_VCO / PLLR */\r\n      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;\r\n      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)\r\n      {\r\n        /* HSE used as PLL clock source */\r\n        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);\r\n      }\r\n      else\r\n      {\r\n        /* HSI used as PLL clock source */\r\n        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);\r\n      }\r\n      pllr = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos);\r\n\r\n      sysclockfreq = pllvco/pllr;\r\n      break;\r\n    }\r\n    default:\r\n    {\r\n      sysclockfreq = HSI_VALUE;\r\n      break;\r\n    }\r\n  }\r\n  return sysclockfreq;\r\n}\r\n#endif /* STM32F446xx */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @brief  Resets the RCC clock configuration to the default reset state.\r\n  * @note   The default reset state of the clock configuration is given below:\r\n  *            - HSI ON and used as system clock source\r\n  *            - HSE, PLL, PLLI2S and PLLSAI OFF\r\n  *            - AHB, APB1 and APB2 prescaler set to 1.\r\n  *            - CSS, MCO1 and MCO2 OFF\r\n  *            - All interrupts disabled\r\n  * @note   This function doesn't modify the configuration of the\r\n  *            - Peripheral clocks\r\n  *            - LSI, LSE and RTC clocks\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCC_DeInit(void)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Set HSION bit to the reset value */\r\n  SET_BIT(RCC->CR, RCC_CR_HSION);\r\n\r\n  /* Wait till HSI is ready */\r\n  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Set HSITRIM[4:0] bits to the reset value */\r\n  SET_BIT(RCC->CR, RCC_CR_HSITRIM_4);\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Reset CFGR register */\r\n  CLEAR_REG(RCC->CFGR);\r\n\r\n  /* Wait till clock switch is ready */\r\n  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Clear HSEON, HSEBYP and CSSON bits */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_CSSON);\r\n\r\n  /* Wait till HSE is disabled */\r\n  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Clear PLLON bit */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);\r\n\r\n  /* Wait till PLL is disabled */\r\n  while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n#if defined(RCC_PLLI2S_SUPPORT)\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Reset PLLI2SON bit */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_PLLI2SON);\r\n\r\n  /* Wait till PLLI2S is disabled */\r\n  while (READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n#endif /* RCC_PLLI2S_SUPPORT */\r\n\r\n#if defined(RCC_PLLSAI_SUPPORT)\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Reset PLLSAI bit */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_PLLSAION);\r\n\r\n  /* Wait till PLLSAI is disabled */\r\n  while (READ_BIT(RCC->CR, RCC_CR_PLLSAIRDY) != RESET)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n#endif /* RCC_PLLSAI_SUPPORT */\r\n\r\n  /* Once PLL, PLLI2S and PLLSAI are OFF, reset PLLCFGR register to default value */\r\n#if defined(STM32F412Cx) || defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || \\\r\n    defined(STM32F423xx) || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)\r\n  RCC->PLLCFGR = RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2 | RCC_PLLCFGR_PLLR_1;\r\n#elif defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)\r\n  RCC->PLLCFGR = RCC_PLLCFGR_PLLR_0 | RCC_PLLCFGR_PLLR_1 | RCC_PLLCFGR_PLLR_2 | RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_0 | RCC_PLLCFGR_PLLQ_1 | RCC_PLLCFGR_PLLQ_2 | RCC_PLLCFGR_PLLQ_3;\r\n#else\r\n  RCC->PLLCFGR = RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2;\r\n#endif /* STM32F412Cx || STM32F412Rx || STM32F412Vx || STM32F412Zx || STM32F413xx || STM32F423xx || STM32F446xx || STM32F469xx || STM32F479xx */\r\n\r\n  /* Reset PLLI2SCFGR register to default value */\r\n#if defined(STM32F412Cx) || defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || \\\r\n    defined(STM32F423xx) || defined(STM32F446xx)\r\n  RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SM_4 | RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SQ_2 | RCC_PLLI2SCFGR_PLLI2SR_1;\r\n#elif defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)\r\n  RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SR_1;\r\n#elif defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)\r\n  RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SQ_2 | RCC_PLLI2SCFGR_PLLI2SR_1;\r\n#elif defined(STM32F411xE)\r\n  RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SM_4 | RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SR_1;\r\n#endif /* STM32F412Cx || STM32F412Rx || STM32F412Vx || STM32F412Zx || STM32F413xx || STM32F423xx || STM32F446xx */\r\n\r\n  /* Reset PLLSAICFGR register */\r\n#if defined(STM32F427xx) || defined(STM32F429xx) || defined(STM32F437xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)\r\n  RCC->PLLSAICFGR = RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7 | RCC_PLLSAICFGR_PLLSAIQ_2 | RCC_PLLSAICFGR_PLLSAIR_1;\r\n#elif defined(STM32F446xx)\r\n  RCC->PLLSAICFGR = RCC_PLLSAICFGR_PLLSAIM_4 | RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7 | RCC_PLLSAICFGR_PLLSAIQ_2;\r\n#endif /* STM32F427xx || STM32F429xx || STM32F437xx || STM32F439xx || STM32F469xx || STM32F479xx */\r\n\r\n  /* Disable all interrupts */\r\n  CLEAR_BIT(RCC->CIR, RCC_CIR_LSIRDYIE | RCC_CIR_LSERDYIE | RCC_CIR_HSIRDYIE | RCC_CIR_HSERDYIE | RCC_CIR_PLLRDYIE);\r\n\r\n#if defined(RCC_CIR_PLLI2SRDYIE)\r\n  CLEAR_BIT(RCC->CIR, RCC_CIR_PLLI2SRDYIE);\r\n#endif /* RCC_CIR_PLLI2SRDYIE */\r\n\r\n#if defined(RCC_CIR_PLLSAIRDYIE)\r\n  CLEAR_BIT(RCC->CIR, RCC_CIR_PLLSAIRDYIE);\r\n#endif /* RCC_CIR_PLLSAIRDYIE */\r\n\r\n  /* Clear all interrupt flags */\r\n  SET_BIT(RCC->CIR, RCC_CIR_LSIRDYC | RCC_CIR_LSERDYC | RCC_CIR_HSIRDYC | RCC_CIR_HSERDYC | RCC_CIR_PLLRDYC | RCC_CIR_CSSC);\r\n\r\n#if defined(RCC_CIR_PLLI2SRDYC)\r\n  SET_BIT(RCC->CIR, RCC_CIR_PLLI2SRDYC);\r\n#endif /* RCC_CIR_PLLI2SRDYC */\r\n\r\n#if defined(RCC_CIR_PLLSAIRDYC)\r\n  SET_BIT(RCC->CIR, RCC_CIR_PLLSAIRDYC);\r\n#endif /* RCC_CIR_PLLSAIRDYC */\r\n\r\n  /* Clear LSION bit */\r\n  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);\r\n\r\n  /* Reset all CSR flags */\r\n  SET_BIT(RCC->CSR, RCC_CSR_RMVF);\r\n\r\n  /* Update the SystemCoreClock global variable */\r\n  SystemCoreClock = HSI_VALUE;\r\n\r\n  /* Adapt Systick interrupt period */\r\n  if(HAL_InitTick(uwTickPrio) != HAL_OK)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    return HAL_OK;\r\n  }\r\n}\r\n\r\n#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||\\\r\n    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)\r\n/**\r\n  * @brief  Initializes the RCC Oscillators according to the specified parameters in the\r\n  *         RCC_OscInitTypeDef.\r\n  * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that\r\n  *         contains the configuration information for the RCC Oscillators.\r\n  * @note   The PLL is not disabled when used as system clock.\r\n  * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not\r\n  *         supported by this API. User should request a transition to LSE Off\r\n  *         first and then LSE On or LSE Bypass.\r\n  * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not\r\n  *         supported by this API. User should request a transition to HSE Off\r\n  *         first and then HSE On or HSE Bypass.\r\n  * @note   This function add the PLL/PLLR factor management during PLL configuration this feature\r\n  *         is only available in STM32F410xx/STM32F446xx/STM32F469xx/STM32F479xx/STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx devices\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)\r\n{\r\n  uint32_t tickstart, pll_config;\r\n\r\n  /* Check Null pointer */\r\n  if(RCC_OscInitStruct == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));\r\n  /*------------------------------- HSE Configuration ------------------------*/\r\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));\r\n    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */\r\n#if defined(STM32F446xx)\r\n    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\\\r\n      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)) ||\\\r\n      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))\r\n#else\r\n    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\\\r\n      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))\r\n#endif /* STM32F446xx */\r\n    {\r\n      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Set the new HSE configuration ---------------------------------------*/\r\n      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);\r\n\r\n      /* Check the HSE State */\r\n      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)\r\n      {\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSE is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSE is bypassed or disabled */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /*----------------------------- HSI Configuration --------------------------*/\r\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));\r\n    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));\r\n\r\n    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */\r\n#if defined(STM32F446xx)\r\n    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\\\r\n      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)) ||\\\r\n      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))\r\n#else\r\n    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\\\r\n      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))\r\n#endif /* STM32F446xx */\r\n    {\r\n      /* When HSI is used as system clock it will not disabled */\r\n      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      /* Otherwise, just the calibration is allowed */\r\n      else\r\n      {\r\n        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/\r\n        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Check the HSI State */\r\n      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)\r\n      {\r\n        /* Enable the Internal High Speed oscillator (HSI). */\r\n        __HAL_RCC_HSI_ENABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSI is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n\r\n        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/\r\n        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);\r\n      }\r\n      else\r\n      {\r\n        /* Disable the Internal High Speed oscillator (HSI). */\r\n        __HAL_RCC_HSI_DISABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSI is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /*------------------------------ LSI Configuration -------------------------*/\r\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));\r\n\r\n    /* Check the LSI State */\r\n    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)\r\n    {\r\n      /* Enable the Internal Low Speed oscillator (LSI). */\r\n      __HAL_RCC_LSI_ENABLE();\r\n\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSI is ready */\r\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)\r\n      {\r\n        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Disable the Internal Low Speed oscillator (LSI). */\r\n      __HAL_RCC_LSI_DISABLE();\r\n\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSI is ready */\r\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)\r\n      {\r\n        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /*------------------------------ LSE Configuration -------------------------*/\r\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)\r\n  {\r\n    FlagStatus       pwrclkchanged = RESET;\r\n\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));\r\n\r\n    /* Update LSE configuration in Backup Domain control register    */\r\n    /* Requires to enable write access to Backup Domain of necessary */\r\n    if(__HAL_RCC_PWR_IS_CLK_DISABLED())\r\n    {\r\n      __HAL_RCC_PWR_CLK_ENABLE();\r\n      pwrclkchanged = SET;\r\n    }\r\n\r\n    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))\r\n    {\r\n      /* Enable write access to Backup domain */\r\n      SET_BIT(PWR->CR, PWR_CR_DBP);\r\n\r\n      /* Wait for Backup domain Write protection disable */\r\n      tickstart = HAL_GetTick();\r\n\r\n      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))\r\n      {\r\n        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Set the new LSE configuration -----------------------------------------*/\r\n    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);\r\n    /* Check the LSE State */\r\n    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)\r\n    {\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSE is ready */\r\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)\r\n      {\r\n        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSE is ready */\r\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)\r\n      {\r\n        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Restore clock configuration if changed */\r\n    if(pwrclkchanged == SET)\r\n    {\r\n      __HAL_RCC_PWR_CLK_DISABLE();\r\n    }\r\n  }\r\n  /*-------------------------------- PLL Configuration -----------------------*/\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));\r\n  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)\r\n  {\r\n    /* Check if the PLL is used as system clock or not */\r\n    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)\r\n    {\r\n      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)\r\n      {\r\n        /* Check the parameters */\r\n        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));\r\n        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));\r\n        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));\r\n        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));\r\n        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));\r\n        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));\r\n\r\n        /* Disable the main PLL. */\r\n        __HAL_RCC_PLL_DISABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till PLL is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n\r\n        /* Configure the main PLL clock source, multiplication and division factors. */\r\n        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \\\r\n                                 RCC_OscInitStruct->PLL.PLLM                                                 | \\\r\n                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)                       | \\\r\n                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)        | \\\r\n                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)                       | \\\r\n                                 (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)));\r\n        /* Enable the main PLL. */\r\n        __HAL_RCC_PLL_ENABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till PLL is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Disable the main PLL. */\r\n        __HAL_RCC_PLL_DISABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till PLL is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Check if there is a request to disable the PLL used as System clock source */\r\n      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      else\r\n      {\r\n        /* Do not return HAL_ERROR if request repeats the current configuration */\r\n        pll_config = RCC->PLLCFGR;\r\n#if defined (RCC_PLLCFGR_PLLR)\r\n        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))\r\n#else\r\n        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||\r\n            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))\r\n#endif\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the RCC_OscInitStruct according to the internal\r\n  * RCC configuration registers.\r\n  * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that will be configured.\r\n  *\r\n  * @note   This function is only available in case of STM32F410xx/STM32F446xx/STM32F469xx/STM32F479xx/STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx devices.\r\n  * @note   This function add the PLL/PLLR factor management\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)\r\n{\r\n  /* Set all possible values for the Oscillator type parameter ---------------*/\r\n  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;\r\n\r\n  /* Get the HSE configuration -----------------------------------------------*/\r\n  if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;\r\n  }\r\n  else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;\r\n  }\r\n\r\n  /* Get the HSI configuration -----------------------------------------------*/\r\n  if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)\r\n  {\r\n    RCC_OscInitStruct->HSIState = RCC_HSI_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;\r\n  }\r\n\r\n  RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR &RCC_CR_HSITRIM) >> RCC_CR_HSITRIM_Pos);\r\n\r\n  /* Get the LSE configuration -----------------------------------------------*/\r\n  if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;\r\n  }\r\n  else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;\r\n  }\r\n\r\n  /* Get the LSI configuration -----------------------------------------------*/\r\n  if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)\r\n  {\r\n    RCC_OscInitStruct->LSIState = RCC_LSI_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;\r\n  }\r\n\r\n  /* Get the PLL configuration -----------------------------------------------*/\r\n  if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)\r\n  {\r\n    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;\r\n  }\r\n  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);\r\n  RCC_OscInitStruct->PLL.PLLM = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);\r\n  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);\r\n  RCC_OscInitStruct->PLL.PLLP = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) + RCC_PLLCFGR_PLLP_0) << 1U) >> RCC_PLLCFGR_PLLP_Pos);\r\n  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos);\r\n  RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos);\r\n}\r\n#endif /* STM32F410xx || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */\r\n\r\n#endif /* HAL_RCC_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_tim.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_tim.c\r\n  * @author  MCD Application Team\r\n  * @brief   TIM HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Timer (TIM) peripheral:\r\n  *           + TIM Time Base Initialization\r\n  *           + TIM Time Base Start\r\n  *           + TIM Time Base Start Interruption\r\n  *           + TIM Time Base Start DMA\r\n  *           + TIM Output Compare/PWM Initialization\r\n  *           + TIM Output Compare/PWM Channel Configuration\r\n  *           + TIM Output Compare/PWM  Start\r\n  *           + TIM Output Compare/PWM  Start Interruption\r\n  *           + TIM Output Compare/PWM Start DMA\r\n  *           + TIM Input Capture Initialization\r\n  *           + TIM Input Capture Channel Configuration\r\n  *           + TIM Input Capture Start\r\n  *           + TIM Input Capture Start Interruption\r\n  *           + TIM Input Capture Start DMA\r\n  *           + TIM One Pulse Initialization\r\n  *           + TIM One Pulse Channel Configuration\r\n  *           + TIM One Pulse Start\r\n  *           + TIM Encoder Interface Initialization\r\n  *           + TIM Encoder Interface Start\r\n  *           + TIM Encoder Interface Start Interruption\r\n  *           + TIM Encoder Interface Start DMA\r\n  *           + Commutation Event configuration with Interruption and DMA\r\n  *           + TIM OCRef clear configuration\r\n  *           + TIM External Clock configuration\r\n  @verbatim\r\n  ==============================================================================\r\n                      ##### TIMER Generic features #####\r\n  ==============================================================================\r\n  [..] The Timer features include:\r\n       (#) 16-bit up, down, up/down auto-reload counter.\r\n       (#) 16-bit programmable prescaler allowing dividing (also on the fly) the\r\n           counter clock frequency either by any factor between 1 and 65536.\r\n       (#) Up to 4 independent channels for:\r\n           (++) Input Capture\r\n           (++) Output Compare\r\n           (++) PWM generation (Edge and Center-aligned Mode)\r\n           (++) One-pulse mode output\r\n       (#) Synchronization circuit to control the timer with external signals and to interconnect\r\n            several timers together.\r\n       (#) Supports incremental encoder for positioning purposes\r\n\r\n            ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n     (#) Initialize the TIM low level resources by implementing the following functions\r\n         depending on the selected feature:\r\n           (++) Time Base : HAL_TIM_Base_MspInit()\r\n           (++) Input Capture : HAL_TIM_IC_MspInit()\r\n           (++) Output Compare : HAL_TIM_OC_MspInit()\r\n           (++) PWM generation : HAL_TIM_PWM_MspInit()\r\n           (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()\r\n           (++) Encoder mode output : HAL_TIM_Encoder_MspInit()\r\n\r\n     (#) Initialize the TIM low level resources :\r\n        (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();\r\n        (##) TIM pins configuration\r\n            (+++) Enable the clock for the TIM GPIOs using the following function:\r\n             __HAL_RCC_GPIOx_CLK_ENABLE();\r\n            (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();\r\n\r\n     (#) The external Clock can be configured, if needed (the default clock is the\r\n         internal clock from the APBx), using the following function:\r\n         HAL_TIM_ConfigClockSource, the clock configuration should be done before\r\n         any start function.\r\n\r\n     (#) Configure the TIM in the desired functioning mode using one of the\r\n       Initialization function of this driver:\r\n       (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base\r\n       (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an\r\n            Output Compare signal.\r\n       (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a\r\n            PWM signal.\r\n       (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an\r\n            external signal.\r\n       (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer\r\n            in One Pulse Mode.\r\n       (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.\r\n\r\n     (#) Activate the TIM peripheral using one of the start functions depending from the feature used:\r\n           (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()\r\n           (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()\r\n           (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()\r\n           (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()\r\n           (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()\r\n           (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().\r\n\r\n     (#) The DMA Burst is managed with the two following functions:\r\n         HAL_TIM_DMABurst_WriteStart()\r\n         HAL_TIM_DMABurst_ReadStart()\r\n\r\n    *** Callback registration ***\r\n  =============================================\r\n\r\n  [..]\r\n  The compilation define  USE_HAL_TIM_REGISTER_CALLBACKS when set to 1\r\n  allows the user to configure dynamically the driver callbacks.\r\n\r\n  [..]\r\n  Use Function HAL_TIM_RegisterCallback() to register a callback.\r\n  HAL_TIM_RegisterCallback() takes as parameters the HAL peripheral handle,\r\n  the Callback ID and a pointer to the user callback function.\r\n\r\n  [..]\r\n  Use function HAL_TIM_UnRegisterCallback() to reset a callback to the default\r\n  weak function.\r\n  HAL_TIM_UnRegisterCallback takes as parameters the HAL peripheral handle,\r\n  and the Callback ID.\r\n\r\n  [..]\r\n  These functions allow to register/unregister following callbacks:\r\n    (+) Base_MspInitCallback              : TIM Base Msp Init Callback.\r\n    (+) Base_MspDeInitCallback            : TIM Base Msp DeInit Callback.\r\n    (+) IC_MspInitCallback                : TIM IC Msp Init Callback.\r\n    (+) IC_MspDeInitCallback              : TIM IC Msp DeInit Callback.\r\n    (+) OC_MspInitCallback                : TIM OC Msp Init Callback.\r\n    (+) OC_MspDeInitCallback              : TIM OC Msp DeInit Callback.\r\n    (+) PWM_MspInitCallback               : TIM PWM Msp Init Callback.\r\n    (+) PWM_MspDeInitCallback             : TIM PWM Msp DeInit Callback.\r\n    (+) OnePulse_MspInitCallback          : TIM One Pulse Msp Init Callback.\r\n    (+) OnePulse_MspDeInitCallback        : TIM One Pulse Msp DeInit Callback.\r\n    (+) Encoder_MspInitCallback           : TIM Encoder Msp Init Callback.\r\n    (+) Encoder_MspDeInitCallback         : TIM Encoder Msp DeInit Callback.\r\n    (+) HallSensor_MspInitCallback        : TIM Hall Sensor Msp Init Callback.\r\n    (+) HallSensor_MspDeInitCallback      : TIM Hall Sensor Msp DeInit Callback.\r\n    (+) PeriodElapsedCallback             : TIM Period Elapsed Callback.\r\n    (+) PeriodElapsedHalfCpltCallback     : TIM Period Elapsed half complete Callback.\r\n    (+) TriggerCallback                   : TIM Trigger Callback.\r\n    (+) TriggerHalfCpltCallback           : TIM Trigger half complete Callback.\r\n    (+) IC_CaptureCallback                : TIM Input Capture Callback.\r\n    (+) IC_CaptureHalfCpltCallback        : TIM Input Capture half complete Callback.\r\n    (+) OC_DelayElapsedCallback           : TIM Output Compare Delay Elapsed Callback.\r\n    (+) PWM_PulseFinishedCallback         : TIM PWM Pulse Finished Callback.\r\n    (+) PWM_PulseFinishedHalfCpltCallback : TIM PWM Pulse Finished half complete Callback.\r\n    (+) ErrorCallback                     : TIM Error Callback.\r\n    (+) CommutationCallback               : TIM Commutation Callback.\r\n    (+) CommutationHalfCpltCallback       : TIM Commutation half complete Callback.\r\n    (+) BreakCallback                     : TIM Break Callback.\r\n\r\n  [..]\r\nBy default, after the Init and when the state is HAL_TIM_STATE_RESET\r\nall interrupt callbacks are set to the corresponding weak functions:\r\n  examples HAL_TIM_TriggerCallback(), HAL_TIM_ErrorCallback().\r\n\r\n  [..]\r\n  Exception done for MspInit and MspDeInit functions that are reset to the legacy weak\r\n  functionalities in the Init / DeInit only when these callbacks are null\r\n  (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init / DeInit\r\n    keep and use the user MspInit / MspDeInit callbacks(registered beforehand)\r\n\r\n  [..]\r\n    Callbacks can be registered / unregistered in HAL_TIM_STATE_READY state only.\r\n    Exception done MspInit / MspDeInit that can be registered / unregistered\r\n    in HAL_TIM_STATE_READY or HAL_TIM_STATE_RESET state,\r\n    thus registered(user) MspInit / DeInit callbacks can be used during the Init / DeInit.\r\n  In that case first register the MspInit/MspDeInit user callbacks\r\n      using HAL_TIM_RegisterCallback() before calling DeInit or Init function.\r\n\r\n  [..]\r\n      When The compilation define USE_HAL_TIM_REGISTER_CALLBACKS is set to 0 or\r\n      not defined, the callback registration feature is not available and all callbacks\r\n      are set to the corresponding weak functions.\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup TIM TIM\r\n  * @brief TIM HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_TIM_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @addtogroup TIM_Private_Functions\r\n  * @{\r\n  */\r\nstatic void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);\r\nstatic void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);\r\nstatic void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);\r\nstatic void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);\r\nstatic void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter);\r\nstatic void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);\r\nstatic void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter);\r\nstatic void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter);\r\nstatic void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource);\r\nstatic void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma);\r\nstatic HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,\r\n                                                  TIM_SlaveConfigTypeDef *sSlaveConfig);\r\n/**\r\n  * @}\r\n  */\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup TIM_Exported_Functions TIM Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group1 TIM Time Base functions\r\n  *  @brief    Time Base functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n              ##### Time Base functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM base.\r\n    (+) De-initialize the TIM base.\r\n    (+) Start the Time Base.\r\n    (+) Stop the Time Base.\r\n    (+) Start the Time Base and enable interrupt.\r\n    (+) Stop the Time Base and disable interrupt.\r\n    (+) Start the Time Base and enable DMA transfer.\r\n    (+) Stop the Time Base and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Time base Unit according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initialize the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->Base_MspInitCallback == NULL)\r\n    {\r\n      htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->Base_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    HAL_TIM_Base_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Set the Time Base configuration */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM Base peripheral\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->Base_MspDeInitCallback == NULL)\r\n  {\r\n    htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->Base_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  HAL_TIM_Base_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Base MSP.\r\n  * @param  htim TIM Base handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_Base_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Base MSP.\r\n  * @param  htim TIM Base handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_Base_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Starts the TIM Base generation.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  /* Check the TIM state */\r\n  if (htim->State != HAL_TIM_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Base generation.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Base generation in interrupt mode.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  /* Check the TIM state */\r\n  if (htim->State != HAL_TIM_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Enable the TIM Update interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Base generation in interrupt mode.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the TIM Update interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Base generation in DMA mode.\r\n  * @param  htim TIM Base handle\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to peripheral.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM state */\r\n  if (htim->State == HAL_TIM_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (htim->State == HAL_TIM_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      htim->State = HAL_TIM_STATE_BUSY;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the DMA Period elapsed callbacks */\r\n  htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;\r\n  htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;\r\n\r\n  /* Set the DMA error callback */\r\n  htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;\r\n\r\n  /* Enable the DMA stream */\r\n  if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR,\r\n                       Length) != HAL_OK)\r\n  {\r\n    /* Return error status */\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Enable the TIM Update DMA request */\r\n  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Base generation in DMA mode.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the TIM Update DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);\r\n\r\n  (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group2 TIM Output Compare functions\r\n  *  @brief    TIM Output Compare functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                  ##### TIM Output Compare functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM Output Compare.\r\n    (+) De-initialize the TIM Output Compare.\r\n    (+) Start the TIM Output Compare.\r\n    (+) Stop the TIM Output Compare.\r\n    (+) Start the TIM Output Compare and enable interrupt.\r\n    (+) Stop the TIM Output Compare and disable interrupt.\r\n    (+) Start the TIM Output Compare and enable DMA transfer.\r\n    (+) Stop the TIM Output Compare and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Output Compare according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->OC_MspInitCallback == NULL)\r\n    {\r\n      htim->OC_MspInitCallback = HAL_TIM_OC_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->OC_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_OC_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Init the base time for the Output Compare */\r\n  TIM_Base_SetConfig(htim->Instance,  &htim->Init);\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM peripheral\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->OC_MspDeInitCallback == NULL)\r\n  {\r\n    htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->OC_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */\r\n  HAL_TIM_OC_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Output Compare MSP.\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OC_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Output Compare MSP.\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OC_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Output compare channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Enable the main output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n  }\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the Output compare channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation in interrupt mode.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Enable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Output compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Enable the main output */\r\n      __HAL_TIM_MOE_ENABLE(htim);\r\n    }\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation in interrupt mode.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Output compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Disable the Main Output */\r\n      __HAL_TIM_MOE_DISABLE(htim);\r\n    }\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation in DMA mode.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to TIM peripheral\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Set the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Enable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Enable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 4 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Output compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Enable the main output */\r\n      __HAL_TIM_MOE_ENABLE(htim);\r\n    }\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation in DMA mode.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Output compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Disable the Main Output */\r\n      __HAL_TIM_MOE_DISABLE(htim);\r\n    }\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group3 TIM PWM functions\r\n  *  @brief    TIM PWM functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                          ##### TIM PWM functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM PWM.\r\n    (+) De-initialize the TIM PWM.\r\n    (+) Start the TIM PWM.\r\n    (+) Stop the TIM PWM.\r\n    (+) Start the TIM PWM and enable interrupt.\r\n    (+) Stop the TIM PWM and disable interrupt.\r\n    (+) Start the TIM PWM and enable DMA transfer.\r\n    (+) Stop the TIM PWM and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM PWM Time Base according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()\r\n  * @param  htim TIM PWM handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->PWM_MspInitCallback == NULL)\r\n    {\r\n      htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->PWM_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_PWM_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Init the base time for the PWM */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM peripheral\r\n  * @param  htim TIM PWM handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->PWM_MspDeInitCallback == NULL)\r\n  {\r\n    htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->PWM_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */\r\n  HAL_TIM_PWM_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM PWM MSP.\r\n  * @param  htim TIM PWM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PWM_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM PWM MSP.\r\n  * @param  htim TIM PWM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PWM_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the PWM signal generation.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Capture compare channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Enable the main output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n  }\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the PWM signal generation.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the Capture compare channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the PWM signal generation in interrupt mode.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Enable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Capture compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Enable the main output */\r\n      __HAL_TIM_MOE_ENABLE(htim);\r\n    }\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the PWM signal generation in interrupt mode.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Capture compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Disable the Main Output */\r\n      __HAL_TIM_MOE_DISABLE(htim);\r\n    }\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM PWM signal generation in DMA mode.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to TIM peripheral\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Set the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Enable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Output Capture/Compare 3 request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 4 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Capture compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Enable the main output */\r\n      __HAL_TIM_MOE_ENABLE(htim);\r\n    }\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM PWM signal generation in DMA mode.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Capture compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Disable the Main Output */\r\n      __HAL_TIM_MOE_DISABLE(htim);\r\n    }\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group4 TIM Input Capture functions\r\n  *  @brief    TIM Input Capture functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n              ##### TIM Input Capture functions #####\r\n  ==============================================================================\r\n [..]\r\n   This section provides functions allowing to:\r\n   (+) Initialize and configure the TIM Input Capture.\r\n   (+) De-initialize the TIM Input Capture.\r\n   (+) Start the TIM Input Capture.\r\n   (+) Stop the TIM Input Capture.\r\n   (+) Start the TIM Input Capture and enable interrupt.\r\n   (+) Stop the TIM Input Capture and disable interrupt.\r\n   (+) Start the TIM Input Capture and enable DMA transfer.\r\n   (+) Stop the TIM Input Capture and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Input Capture Time base according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()\r\n  * @param  htim TIM Input Capture handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->IC_MspInitCallback == NULL)\r\n    {\r\n      htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->IC_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_IC_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Init the base time for the input capture */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM peripheral\r\n  * @param  htim TIM Input Capture handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->IC_MspDeInitCallback == NULL)\r\n  {\r\n    htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->IC_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */\r\n  HAL_TIM_IC_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Input Capture MSP.\r\n  * @param  htim TIM Input Capture handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_IC_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Input Capture MSP.\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_IC_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Input Capture measurement.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Input Capture channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Input Capture measurement.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the Input Capture channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Input Capture measurement in interrupt mode.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Enable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Input Capture channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Input Capture measurement in interrupt mode.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Input Capture channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Input Capture measurement in DMA mode.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @param  pData The destination Buffer address.\r\n  * @param  Length The length of data to be transferred from TIM peripheral to memory.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n  assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel state */\r\n  if ((channel_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n      || (complementary_channel_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if ((channel_state == HAL_TIM_CHANNEL_STATE_READY)\r\n           && (complementary_channel_state == HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Enable the Input Capture channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 2  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 3  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 4  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Input Capture measurement in DMA mode.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n  assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3  DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4  DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group5 TIM One Pulse functions\r\n  *  @brief    TIM One Pulse functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                        ##### TIM One Pulse functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM One Pulse.\r\n    (+) De-initialize the TIM One Pulse.\r\n    (+) Start the TIM One Pulse.\r\n    (+) Stop the TIM One Pulse.\r\n    (+) Start the TIM One Pulse and enable interrupt.\r\n    (+) Stop the TIM One Pulse and disable interrupt.\r\n    (+) Start the TIM One Pulse and enable DMA transfer.\r\n    (+) Stop the TIM One Pulse and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM One Pulse Time Base according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()\r\n  * @note   When the timer instance is initialized in One Pulse mode, timer\r\n  *         channels 1 and channel 2 are reserved and cannot be used for other\r\n  *         purpose.\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OnePulseMode Select the One pulse mode.\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.\r\n  *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_OPM_MODE(OnePulseMode));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->OnePulse_MspInitCallback == NULL)\r\n    {\r\n      htim->OnePulse_MspInitCallback = HAL_TIM_OnePulse_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->OnePulse_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_OnePulse_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Configure the Time base in the One Pulse Mode */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Reset the OPM Bit */\r\n  htim->Instance->CR1 &= ~TIM_CR1_OPM;\r\n\r\n  /* Configure the OPM Mode */\r\n  htim->Instance->CR1 |= OnePulseMode;\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM One Pulse\r\n  * @param  htim TIM One Pulse handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->OnePulse_MspDeInitCallback == NULL)\r\n  {\r\n    htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->OnePulse_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  HAL_TIM_OnePulse_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM One Pulse MSP.\r\n  * @param  htim TIM One Pulse handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OnePulse_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM One Pulse MSP.\r\n  * @param  htim TIM One Pulse handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM One Pulse signal generation.\r\n  * @note Though OutputChannel parameter is deprecated and ignored by the function\r\n  *        it has been kept to avoid HAL_TIM API compatibility break.\r\n  * @note The pulse output channel is determined when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel See note above\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(OutputChannel);\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Capture compare and the Input Capture channels\r\n    (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)\r\n    if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and\r\n    if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output\r\n    whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together\r\n\r\n    No need to enable the counter, it's enabled automatically by hardware\r\n    (the counter starts in response to a stimulus and generate a pulse */\r\n\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Enable the main output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM One Pulse signal generation.\r\n  * @note Though OutputChannel parameter is deprecated and ignored by the function\r\n  *        it has been kept to avoid HAL_TIM API compatibility break.\r\n  * @note The pulse output channel is determined when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel See note above\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(OutputChannel);\r\n\r\n  /* Disable the Capture compare and the Input Capture channels\r\n  (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)\r\n  if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and\r\n  if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output\r\n  whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */\r\n\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM One Pulse signal generation in interrupt mode.\r\n  * @note Though OutputChannel parameter is deprecated and ignored by the function\r\n  *        it has been kept to avoid HAL_TIM API compatibility break.\r\n  * @note The pulse output channel is determined when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel See note above\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(OutputChannel);\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Capture compare and the Input Capture channels\r\n    (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)\r\n    if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and\r\n    if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output\r\n    whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together\r\n\r\n    No need to enable the counter, it's enabled automatically by hardware\r\n    (the counter starts in response to a stimulus and generate a pulse */\r\n\r\n  /* Enable the TIM Capture/Compare 1 interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Enable the TIM Capture/Compare 2 interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Enable the main output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM One Pulse signal generation in interrupt mode.\r\n  * @note Though OutputChannel parameter is deprecated and ignored by the function\r\n  *        it has been kept to avoid HAL_TIM API compatibility break.\r\n  * @note The pulse output channel is determined when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel See note above\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(OutputChannel);\r\n\r\n  /* Disable the TIM Capture/Compare 1 interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Disable the TIM Capture/Compare 2 interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n\r\n  /* Disable the Capture compare and the Input Capture channels\r\n  (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)\r\n  if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and\r\n  if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output\r\n  whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group6 TIM Encoder functions\r\n  *  @brief    TIM Encoder functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                          ##### TIM Encoder functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM Encoder.\r\n    (+) De-initialize the TIM Encoder.\r\n    (+) Start the TIM Encoder.\r\n    (+) Stop the TIM Encoder.\r\n    (+) Start the TIM Encoder and enable interrupt.\r\n    (+) Stop the TIM Encoder and disable interrupt.\r\n    (+) Start the TIM Encoder and enable DMA transfer.\r\n    (+) Stop the TIM Encoder and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Encoder Interface and initialize the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()\r\n  * @note   Encoder mode and External clock mode 2 are not compatible and must not be selected together\r\n  *         Ex: A call for @ref HAL_TIM_Encoder_Init will erase the settings of @ref HAL_TIM_ConfigClockSource\r\n  *         using TIM_CLOCKSOURCE_ETRMODE2 and vice versa\r\n  * @note   When the timer instance is initialized in Encoder mode, timer\r\n  *         channels 1 and channel 2 are reserved and cannot be used for other\r\n  *         purpose.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  sConfig TIM Encoder Interface configuration structure\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef *sConfig)\r\n{\r\n  uint32_t tmpsmcr;\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n  assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));\r\n  assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));\r\n  assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));\r\n  assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC1Polarity));\r\n  assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC2Polarity));\r\n  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));\r\n  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));\r\n  assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));\r\n  assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->Encoder_MspInitCallback == NULL)\r\n    {\r\n      htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->Encoder_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_Encoder_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Reset the SMS and ECE bits */\r\n  htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);\r\n\r\n  /* Configure the Time base in the Encoder Mode */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Get the TIMx SMCR register value */\r\n  tmpsmcr = htim->Instance->SMCR;\r\n\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmr1 = htim->Instance->CCMR1;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = htim->Instance->CCER;\r\n\r\n  /* Set the encoder Mode */\r\n  tmpsmcr |= sConfig->EncoderMode;\r\n\r\n  /* Select the Capture Compare 1 and the Capture Compare 2 as input */\r\n  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);\r\n  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));\r\n\r\n  /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */\r\n  tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);\r\n  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);\r\n  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);\r\n  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);\r\n\r\n  /* Set the TI1 and the TI2 Polarities */\r\n  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);\r\n  tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);\r\n  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);\r\n\r\n  /* Write to TIMx SMCR */\r\n  htim->Instance->SMCR = tmpsmcr;\r\n\r\n  /* Write to TIMx CCMR1 */\r\n  htim->Instance->CCMR1 = tmpccmr1;\r\n\r\n  /* Write to TIMx CCER */\r\n  htim->Instance->CCER = tmpccer;\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM Encoder interface\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->Encoder_MspDeInitCallback == NULL)\r\n  {\r\n    htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->Encoder_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  HAL_TIM_Encoder_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Encoder Interface MSP.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_Encoder_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Encoder Interface MSP.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_Encoder_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Encoder Interface.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    if ((channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n\r\n  /* Enable the encoder interface channels */\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n      break;\r\n    }\r\n\r\n    default :\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n      break;\r\n    }\r\n  }\r\n  /* Enable the Peripheral */\r\n  __HAL_TIM_ENABLE(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Encoder Interface.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channels 1 and 2\r\n    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n      break;\r\n    }\r\n\r\n    default :\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Encoder Interface in interrupt mode.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    if ((channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n\r\n  /* Enable the encoder interface channels */\r\n  /* Enable the capture compare Interrupts 1 and/or 2 */\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    default :\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* Enable the Peripheral */\r\n  __HAL_TIM_ENABLE(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Encoder Interface in interrupt mode.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channels 1 and 2\r\n    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare Interrupts 1 */\r\n    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare Interrupts 2 */\r\n    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n  }\r\n  else\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare Interrupts 1 and 2 */\r\n    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Encoder Interface in DMA mode.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @param  pData1 The destination Buffer address for IC1.\r\n  * @param  pData2 The destination Buffer address for IC2.\r\n  * @param  Length The length of data to be transferred from TIM peripheral to memory.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1,\r\n                                            uint32_t *pData2, uint16_t Length)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n    else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      if ((pData1 == NULL) && (Length > 0U))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      else\r\n      {\r\n        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    if ((channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n    else if ((channel_2_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      if ((pData2 == NULL) && (Length > 0U))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      else\r\n      {\r\n        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n    else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (channel_2_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      else\r\n      {\r\n        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Input Capture DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n\r\n      /* Enable the Capture compare channel */\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n\r\n      /* Enable the Peripheral */\r\n      __HAL_TIM_ENABLE(htim);\r\n\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Input Capture  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n\r\n      /* Enable the Capture compare channel */\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n\r\n      /* Enable the Peripheral */\r\n      __HAL_TIM_ENABLE(htim);\r\n\r\n      break;\r\n    }\r\n\r\n    default:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Enable the TIM Input Capture  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      /* Enable the TIM Input Capture  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n\r\n      /* Enable the Capture compare channel */\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n\r\n      /* Enable the Peripheral */\r\n      __HAL_TIM_ENABLE(htim);\r\n\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Encoder Interface in DMA mode.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channels 1 and 2\r\n    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare DMA Request 1 */\r\n    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare DMA Request 2 */\r\n    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n  }\r\n  else\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare DMA Request 1 and 2 */\r\n    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n/** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management\r\n  *  @brief    TIM IRQ handler management\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                        ##### IRQ handler management #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides Timer IRQ handler function.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  This function handles TIM interrupts requests.\r\n  * @param  htim TIM  handle\r\n  * @retval None\r\n  */\r\nvoid HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Capture compare 1 event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)\r\n    {\r\n      {\r\n        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);\r\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n\r\n        /* Input capture event */\r\n        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)\r\n        {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n          htim->IC_CaptureCallback(htim);\r\n#else\r\n          HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n        }\r\n        /* Output compare event */\r\n        else\r\n        {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n          htim->OC_DelayElapsedCallback(htim);\r\n          htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n          HAL_TIM_OC_DelayElapsedCallback(htim);\r\n          HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n        }\r\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n      }\r\n    }\r\n  }\r\n  /* Capture compare 2 event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n      /* Input capture event */\r\n      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->IC_CaptureCallback(htim);\r\n#else\r\n        HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      /* Output compare event */\r\n      else\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->OC_DelayElapsedCallback(htim);\r\n        htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n        HAL_TIM_OC_DelayElapsedCallback(htim);\r\n        HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n    }\r\n  }\r\n  /* Capture compare 3 event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n      /* Input capture event */\r\n      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->IC_CaptureCallback(htim);\r\n#else\r\n        HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      /* Output compare event */\r\n      else\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->OC_DelayElapsedCallback(htim);\r\n        htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n        HAL_TIM_OC_DelayElapsedCallback(htim);\r\n        HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n    }\r\n  }\r\n  /* Capture compare 4 event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n      /* Input capture event */\r\n      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->IC_CaptureCallback(htim);\r\n#else\r\n        HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      /* Output compare event */\r\n      else\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->OC_DelayElapsedCallback(htim);\r\n        htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n        HAL_TIM_OC_DelayElapsedCallback(htim);\r\n        HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n    }\r\n  }\r\n  /* TIM Update event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n      htim->PeriodElapsedCallback(htim);\r\n#else\r\n      HAL_TIM_PeriodElapsedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* TIM Break input event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n      htim->BreakCallback(htim);\r\n#else\r\n      HAL_TIMEx_BreakCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* TIM Trigger detection event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n      htim->TriggerCallback(htim);\r\n#else\r\n      HAL_TIM_TriggerCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* TIM commutation event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n      htim->CommutationCallback(htim);\r\n#else\r\n      HAL_TIMEx_CommutCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions\r\n  *  @brief    TIM Peripheral Control functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                   ##### Peripheral Control functions #####\r\n  ==============================================================================\r\n [..]\r\n   This section provides functions allowing to:\r\n      (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.\r\n      (+) Configure External Clock source.\r\n      (+) Configure Complementary channels, break features and dead time.\r\n      (+) Configure Master and the Slave synchronization.\r\n      (+) Configure the DMA Burst Mode.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initializes the TIM Output Compare Channels according to the specified\r\n  *         parameters in the TIM_OC_InitTypeDef.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  sConfig TIM Output Compare configuration structure\r\n  * @param  Channel TIM Channels to configure\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,\r\n                                           TIM_OC_InitTypeDef *sConfig,\r\n                                           uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CHANNELS(Channel));\r\n  assert_param(IS_TIM_OC_MODE(sConfig->OCMode));\r\n  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 1 in Output Compare */\r\n      TIM_OC1_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 2 in Output Compare */\r\n      TIM_OC2_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 3 in Output Compare */\r\n      TIM_OC3_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 4 in Output Compare */\r\n      TIM_OC4_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Input Capture Channels according to the specified\r\n  *         parameters in the TIM_IC_InitTypeDef.\r\n  * @param  htim TIM IC handle\r\n  * @param  sConfig TIM Input Capture configuration structure\r\n  * @param  Channel TIM Channel to configure\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef *sConfig, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));\r\n  assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));\r\n  assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));\r\n  assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    /* TI1 Configuration */\r\n    TIM_TI1_SetConfig(htim->Instance,\r\n                      sConfig->ICPolarity,\r\n                      sConfig->ICSelection,\r\n                      sConfig->ICFilter);\r\n\r\n    /* Reset the IC1PSC Bits */\r\n    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;\r\n\r\n    /* Set the IC1PSC value */\r\n    htim->Instance->CCMR1 |= sConfig->ICPrescaler;\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    /* TI2 Configuration */\r\n    assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n    TIM_TI2_SetConfig(htim->Instance,\r\n                      sConfig->ICPolarity,\r\n                      sConfig->ICSelection,\r\n                      sConfig->ICFilter);\r\n\r\n    /* Reset the IC2PSC Bits */\r\n    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;\r\n\r\n    /* Set the IC2PSC value */\r\n    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);\r\n  }\r\n  else if (Channel == TIM_CHANNEL_3)\r\n  {\r\n    /* TI3 Configuration */\r\n    assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));\r\n\r\n    TIM_TI3_SetConfig(htim->Instance,\r\n                      sConfig->ICPolarity,\r\n                      sConfig->ICSelection,\r\n                      sConfig->ICFilter);\r\n\r\n    /* Reset the IC3PSC Bits */\r\n    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;\r\n\r\n    /* Set the IC3PSC value */\r\n    htim->Instance->CCMR2 |= sConfig->ICPrescaler;\r\n  }\r\n  else if (Channel == TIM_CHANNEL_4)\r\n  {\r\n    /* TI4 Configuration */\r\n    assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));\r\n\r\n    TIM_TI4_SetConfig(htim->Instance,\r\n                      sConfig->ICPolarity,\r\n                      sConfig->ICSelection,\r\n                      sConfig->ICFilter);\r\n\r\n    /* Reset the IC4PSC Bits */\r\n    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;\r\n\r\n    /* Set the IC4PSC value */\r\n    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);\r\n  }\r\n  else\r\n  {\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM PWM  channels according to the specified\r\n  *         parameters in the TIM_OC_InitTypeDef.\r\n  * @param  htim TIM PWM handle\r\n  * @param  sConfig TIM PWM configuration structure\r\n  * @param  Channel TIM Channels to be configured\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,\r\n                                            TIM_OC_InitTypeDef *sConfig,\r\n                                            uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CHANNELS(Channel));\r\n  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));\r\n  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));\r\n  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 1 in PWM mode */\r\n      TIM_OC1_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel1 */\r\n      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;\r\n      htim->Instance->CCMR1 |= sConfig->OCFastMode;\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 2 in PWM mode */\r\n      TIM_OC2_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel2 */\r\n      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;\r\n      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 3 in PWM mode */\r\n      TIM_OC3_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel3 */\r\n      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;\r\n      htim->Instance->CCMR2 |= sConfig->OCFastMode;\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 4 in PWM mode */\r\n      TIM_OC4_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel4 */\r\n      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;\r\n      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM One Pulse Channels according to the specified\r\n  *         parameters in the TIM_OnePulse_InitTypeDef.\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  sConfig TIM One Pulse configuration structure\r\n  * @param  OutputChannel TIM output channel to configure\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @param  InputChannel TIM input Channel to configure\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @note  To output a waveform with a minimum delay user can enable the fast\r\n  *        mode by calling the @ref __HAL_TIM_ENABLE_OCxFAST macro. Then CCx\r\n  *        output is forced in response to the edge detection on TIx input,\r\n  *        without taking in account the comparison.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef *sConfig,\r\n                                                 uint32_t OutputChannel,  uint32_t InputChannel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  TIM_OC_InitTypeDef temp1;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));\r\n  assert_param(IS_TIM_OPM_CHANNELS(InputChannel));\r\n\r\n  if (OutputChannel != InputChannel)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(htim);\r\n\r\n    htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n    /* Extract the Output compare configuration from sConfig structure */\r\n    temp1.OCMode = sConfig->OCMode;\r\n    temp1.Pulse = sConfig->Pulse;\r\n    temp1.OCPolarity = sConfig->OCPolarity;\r\n    temp1.OCNPolarity = sConfig->OCNPolarity;\r\n    temp1.OCIdleState = sConfig->OCIdleState;\r\n    temp1.OCNIdleState = sConfig->OCNIdleState;\r\n\r\n    switch (OutputChannel)\r\n    {\r\n      case TIM_CHANNEL_1:\r\n      {\r\n        assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n        TIM_OC1_SetConfig(htim->Instance, &temp1);\r\n        break;\r\n      }\r\n\r\n      case TIM_CHANNEL_2:\r\n      {\r\n        assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n        TIM_OC2_SetConfig(htim->Instance, &temp1);\r\n        break;\r\n      }\r\n\r\n      default:\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n\r\n    if (status == HAL_OK)\r\n    {\r\n      switch (InputChannel)\r\n      {\r\n        case TIM_CHANNEL_1:\r\n        {\r\n          assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n          TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,\r\n                            sConfig->ICSelection, sConfig->ICFilter);\r\n\r\n          /* Reset the IC1PSC Bits */\r\n          htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;\r\n\r\n          /* Select the Trigger source */\r\n          htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n          htim->Instance->SMCR |= TIM_TS_TI1FP1;\r\n\r\n          /* Select the Slave Mode */\r\n          htim->Instance->SMCR &= ~TIM_SMCR_SMS;\r\n          htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;\r\n          break;\r\n        }\r\n\r\n        case TIM_CHANNEL_2:\r\n        {\r\n          assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n          TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,\r\n                            sConfig->ICSelection, sConfig->ICFilter);\r\n\r\n          /* Reset the IC2PSC Bits */\r\n          htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;\r\n\r\n          /* Select the Trigger source */\r\n          htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n          htim->Instance->SMCR |= TIM_TS_TI2FP2;\r\n\r\n          /* Select the Slave Mode */\r\n          htim->Instance->SMCR &= ~TIM_SMCR_SMS;\r\n          htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;\r\n          break;\r\n        }\r\n\r\n        default:\r\n          status = HAL_ERROR;\r\n          break;\r\n      }\r\n    }\r\n\r\n    htim->State = HAL_TIM_STATE_READY;\r\n\r\n    __HAL_UNLOCK(htim);\r\n\r\n    return status;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral\r\n  * @param  htim TIM handle\r\n  * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data write\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMABASE_CR1\r\n  *            @arg TIM_DMABASE_CR2\r\n  *            @arg TIM_DMABASE_SMCR\r\n  *            @arg TIM_DMABASE_DIER\r\n  *            @arg TIM_DMABASE_SR\r\n  *            @arg TIM_DMABASE_EGR\r\n  *            @arg TIM_DMABASE_CCMR1\r\n  *            @arg TIM_DMABASE_CCMR2\r\n  *            @arg TIM_DMABASE_CCER\r\n  *            @arg TIM_DMABASE_CNT\r\n  *            @arg TIM_DMABASE_PSC\r\n  *            @arg TIM_DMABASE_ARR\r\n  *            @arg TIM_DMABASE_RCR\r\n  *            @arg TIM_DMABASE_CCR1\r\n  *            @arg TIM_DMABASE_CCR2\r\n  *            @arg TIM_DMABASE_CCR3\r\n  *            @arg TIM_DMABASE_CCR4\r\n  *            @arg TIM_DMABASE_BDTR\r\n  * @param  BurstRequestSrc TIM DMA Request sources\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source\r\n  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source\r\n  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source\r\n  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source\r\n  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source\r\n  *            @arg TIM_DMA_COM: TIM Commutation DMA source\r\n  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source\r\n  * @param  BurstBuffer The Buffer address.\r\n  * @param  BurstLength DMA Burst length. This parameter can be one value\r\n  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.\r\n  * @note   This function should be used only when BurstLength is equal to DMA data transfer length.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,\r\n                                              uint32_t BurstRequestSrc, uint32_t *BurstBuffer, uint32_t  BurstLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    status = HAL_TIM_DMABurst_MultiWriteStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,\r\n                                              ((BurstLength) >> 8U) + 1U);\r\n  }\r\n\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the DMA Burst to transfer multiple Data from the memory to the TIM peripheral\r\n  * @param  htim TIM handle\r\n  * @param  BurstBaseAddress TIM Base address from where the DMA will start the Data write\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMABASE_CR1\r\n  *            @arg TIM_DMABASE_CR2\r\n  *            @arg TIM_DMABASE_SMCR\r\n  *            @arg TIM_DMABASE_DIER\r\n  *            @arg TIM_DMABASE_SR\r\n  *            @arg TIM_DMABASE_EGR\r\n  *            @arg TIM_DMABASE_CCMR1\r\n  *            @arg TIM_DMABASE_CCMR2\r\n  *            @arg TIM_DMABASE_CCER\r\n  *            @arg TIM_DMABASE_CNT\r\n  *            @arg TIM_DMABASE_PSC\r\n  *            @arg TIM_DMABASE_ARR\r\n  *            @arg TIM_DMABASE_RCR\r\n  *            @arg TIM_DMABASE_CCR1\r\n  *            @arg TIM_DMABASE_CCR2\r\n  *            @arg TIM_DMABASE_CCR3\r\n  *            @arg TIM_DMABASE_CCR4\r\n  *            @arg TIM_DMABASE_BDTR\r\n  * @param  BurstRequestSrc TIM DMA Request sources\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source\r\n  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source\r\n  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source\r\n  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source\r\n  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source\r\n  *            @arg TIM_DMA_COM: TIM Commutation DMA source\r\n  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source\r\n  * @param  BurstBuffer The Buffer address.\r\n  * @param  BurstLength DMA Burst length. This parameter can be one value\r\n  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.\r\n  * @param  DataLength Data length. This parameter can be one value\r\n  *         between 1 and 0xFFFF.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_MultiWriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,\r\n                                                   uint32_t BurstRequestSrc, uint32_t *BurstBuffer,\r\n                                                   uint32_t  BurstLength,  uint32_t  DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));\r\n  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));\r\n  assert_param(IS_TIM_DMA_LENGTH(BurstLength));\r\n  assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));\r\n\r\n  if (htim->DMABurstState == HAL_DMA_BURST_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (htim->DMABurstState == HAL_DMA_BURST_STATE_READY)\r\n  {\r\n    if ((BurstBuffer == NULL) && (BurstLength > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      htim->DMABurstState = HAL_DMA_BURST_STATE_BUSY;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n  switch (BurstRequestSrc)\r\n  {\r\n    case TIM_DMA_UPDATE:\r\n    {\r\n      /* Set the DMA Period elapsed callbacks */\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC4:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_COM:\r\n    {\r\n      /* Set the DMA commutation callbacks */\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_TRIGGER:\r\n    {\r\n      /* Set the DMA trigger callbacks */\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Configure the DMA Burst Mode */\r\n    htim->Instance->DCR = (BurstBaseAddress | BurstLength);\r\n    /* Enable the TIM DMA Request */\r\n    __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM DMA Burst mode\r\n  * @param  htim TIM handle\r\n  * @param  BurstRequestSrc TIM DMA Request sources to disable\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));\r\n\r\n  /* Abort the DMA transfer (at least disable the DMA stream) */\r\n  switch (BurstRequestSrc)\r\n  {\r\n    case TIM_DMA_UPDATE:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC1:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC2:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC3:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC4:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n    case TIM_DMA_COM:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);\r\n      break;\r\n    }\r\n    case TIM_DMA_TRIGGER:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the TIM Update DMA request */\r\n    __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);\r\n\r\n    /* Change the DMA burst operation state */\r\n    htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory\r\n  * @param  htim TIM handle\r\n  * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMABASE_CR1\r\n  *            @arg TIM_DMABASE_CR2\r\n  *            @arg TIM_DMABASE_SMCR\r\n  *            @arg TIM_DMABASE_DIER\r\n  *            @arg TIM_DMABASE_SR\r\n  *            @arg TIM_DMABASE_EGR\r\n  *            @arg TIM_DMABASE_CCMR1\r\n  *            @arg TIM_DMABASE_CCMR2\r\n  *            @arg TIM_DMABASE_CCER\r\n  *            @arg TIM_DMABASE_CNT\r\n  *            @arg TIM_DMABASE_PSC\r\n  *            @arg TIM_DMABASE_ARR\r\n  *            @arg TIM_DMABASE_RCR\r\n  *            @arg TIM_DMABASE_CCR1\r\n  *            @arg TIM_DMABASE_CCR2\r\n  *            @arg TIM_DMABASE_CCR3\r\n  *            @arg TIM_DMABASE_CCR4\r\n  *            @arg TIM_DMABASE_BDTR\r\n  * @param  BurstRequestSrc TIM DMA Request sources\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source\r\n  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source\r\n  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source\r\n  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source\r\n  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source\r\n  *            @arg TIM_DMA_COM: TIM Commutation DMA source\r\n  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source\r\n  * @param  BurstBuffer The Buffer address.\r\n  * @param  BurstLength DMA Burst length. This parameter can be one value\r\n  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.\r\n  * @note   This function should be used only when BurstLength is equal to DMA data transfer length.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,\r\n                                             uint32_t BurstRequestSrc, uint32_t  *BurstBuffer, uint32_t  BurstLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    status = HAL_TIM_DMABurst_MultiReadStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,\r\n                                             ((BurstLength) >> 8U) + 1U);\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory\r\n  * @param  htim TIM handle\r\n  * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMABASE_CR1\r\n  *            @arg TIM_DMABASE_CR2\r\n  *            @arg TIM_DMABASE_SMCR\r\n  *            @arg TIM_DMABASE_DIER\r\n  *            @arg TIM_DMABASE_SR\r\n  *            @arg TIM_DMABASE_EGR\r\n  *            @arg TIM_DMABASE_CCMR1\r\n  *            @arg TIM_DMABASE_CCMR2\r\n  *            @arg TIM_DMABASE_CCER\r\n  *            @arg TIM_DMABASE_CNT\r\n  *            @arg TIM_DMABASE_PSC\r\n  *            @arg TIM_DMABASE_ARR\r\n  *            @arg TIM_DMABASE_RCR\r\n  *            @arg TIM_DMABASE_CCR1\r\n  *            @arg TIM_DMABASE_CCR2\r\n  *            @arg TIM_DMABASE_CCR3\r\n  *            @arg TIM_DMABASE_CCR4\r\n  *            @arg TIM_DMABASE_BDTR\r\n  * @param  BurstRequestSrc TIM DMA Request sources\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source\r\n  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source\r\n  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source\r\n  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source\r\n  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source\r\n  *            @arg TIM_DMA_COM: TIM Commutation DMA source\r\n  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source\r\n  * @param  BurstBuffer The Buffer address.\r\n  * @param  BurstLength DMA Burst length. This parameter can be one value\r\n  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.\r\n  * @param  DataLength Data length. This parameter can be one value\r\n  *         between 1 and 0xFFFF.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_MultiReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,\r\n                                                  uint32_t BurstRequestSrc, uint32_t  *BurstBuffer,\r\n                                                  uint32_t  BurstLength, uint32_t  DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));\r\n  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));\r\n  assert_param(IS_TIM_DMA_LENGTH(BurstLength));\r\n  assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));\r\n\r\n  if (htim->DMABurstState == HAL_DMA_BURST_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (htim->DMABurstState == HAL_DMA_BURST_STATE_READY)\r\n  {\r\n    if ((BurstBuffer == NULL) && (BurstLength > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      htim->DMABurstState = HAL_DMA_BURST_STATE_BUSY;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n  switch (BurstRequestSrc)\r\n  {\r\n    case TIM_DMA_UPDATE:\r\n    {\r\n      /* Set the DMA Period elapsed callbacks */\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC1:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC2:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC3:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC4:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_COM:\r\n    {\r\n      /* Set the DMA commutation callbacks */\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_TRIGGER:\r\n    {\r\n      /* Set the DMA trigger callbacks */\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Configure the DMA Burst Mode */\r\n    htim->Instance->DCR = (BurstBaseAddress | BurstLength);\r\n\r\n    /* Enable the TIM DMA Request */\r\n    __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stop the DMA burst reading\r\n  * @param  htim TIM handle\r\n  * @param  BurstRequestSrc TIM DMA Request sources to disable.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));\r\n\r\n  /* Abort the DMA transfer (at least disable the DMA stream) */\r\n  switch (BurstRequestSrc)\r\n  {\r\n    case TIM_DMA_UPDATE:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC1:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC2:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC3:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC4:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n    case TIM_DMA_COM:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);\r\n      break;\r\n    }\r\n    case TIM_DMA_TRIGGER:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the TIM Update DMA request */\r\n    __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);\r\n\r\n    /* Change the DMA burst operation state */\r\n    htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Generate a software event\r\n  * @param  htim TIM handle\r\n  * @param  EventSource specifies the event source.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source\r\n  *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source\r\n  *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source\r\n  *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source\r\n  *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source\r\n  *            @arg TIM_EVENTSOURCE_COM: Timer COM event source\r\n  *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source\r\n  *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source\r\n  * @note   Basic timers can only generate an update event.\r\n  * @note   TIM_EVENTSOURCE_COM is relevant only with advanced timer instances.\r\n  * @note   TIM_EVENTSOURCE_BREAK are relevant only for timer instances\r\n  *         supporting a break input.\r\n  * @retval HAL status\r\n  */\r\n\r\nHAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_EVENT_SOURCE(EventSource));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  /* Change the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Set the event sources */\r\n  htim->Instance->EGR = EventSource;\r\n\r\n  /* Change the TIM state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the OCRef clear feature\r\n  * @param  htim TIM handle\r\n  * @param  sClearInputConfig pointer to a TIM_ClearInputConfigTypeDef structure that\r\n  *         contains the OCREF clear feature and parameters for the TIM peripheral.\r\n  * @param  Channel specifies the TIM Channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,\r\n                                           TIM_ClearInputConfigTypeDef *sClearInputConfig,\r\n                                           uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  switch (sClearInputConfig->ClearInputSource)\r\n  {\r\n    case TIM_CLEARINPUTSOURCE_NONE:\r\n    {\r\n      /* Clear the OCREF clear selection bit and the the ETR Bits */\r\n      CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));\r\n      break;\r\n    }\r\n\r\n    case TIM_CLEARINPUTSOURCE_ETR:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));\r\n      assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));\r\n      assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));\r\n\r\n      /* When OCRef clear feature is used with ETR source, ETR prescaler must be off */\r\n      if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)\r\n      {\r\n        htim->State = HAL_TIM_STATE_READY;\r\n        __HAL_UNLOCK(htim);\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      TIM_ETR_SetConfig(htim->Instance,\r\n                        sClearInputConfig->ClearInputPrescaler,\r\n                        sClearInputConfig->ClearInputPolarity,\r\n                        sClearInputConfig->ClearInputFilter);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    switch (Channel)\r\n    {\r\n      case TIM_CHANNEL_1:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 1 */\r\n          SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 1 */\r\n          CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);\r\n        }\r\n        break;\r\n      }\r\n      case TIM_CHANNEL_2:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 2 */\r\n          SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 2 */\r\n          CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);\r\n        }\r\n        break;\r\n      }\r\n      case TIM_CHANNEL_3:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 3 */\r\n          SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 3 */\r\n          CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);\r\n        }\r\n        break;\r\n      }\r\n      case TIM_CHANNEL_4:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 4 */\r\n          SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 4 */\r\n          CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief   Configures the clock source to be used\r\n  * @param  htim TIM handle\r\n  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that\r\n  *         contains the clock source information for the TIM peripheral.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));\r\n\r\n  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */\r\n  tmpsmcr = htim->Instance->SMCR;\r\n  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);\r\n  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);\r\n  htim->Instance->SMCR = tmpsmcr;\r\n\r\n  switch (sClockSourceConfig->ClockSource)\r\n  {\r\n    case TIM_CLOCKSOURCE_INTERNAL:\r\n    {\r\n      assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_ETRMODE1:\r\n    {\r\n      /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/\r\n      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));\r\n\r\n      /* Check ETR input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      /* Configure the ETR Clock source */\r\n      TIM_ETR_SetConfig(htim->Instance,\r\n                        sClockSourceConfig->ClockPrescaler,\r\n                        sClockSourceConfig->ClockPolarity,\r\n                        sClockSourceConfig->ClockFilter);\r\n\r\n      /* Select the External clock mode1 and the ETRF trigger */\r\n      tmpsmcr = htim->Instance->SMCR;\r\n      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);\r\n      /* Write to TIMx SMCR */\r\n      htim->Instance->SMCR = tmpsmcr;\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_ETRMODE2:\r\n    {\r\n      /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/\r\n      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));\r\n\r\n      /* Check ETR input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      /* Configure the ETR Clock source */\r\n      TIM_ETR_SetConfig(htim->Instance,\r\n                        sClockSourceConfig->ClockPrescaler,\r\n                        sClockSourceConfig->ClockPolarity,\r\n                        sClockSourceConfig->ClockFilter);\r\n      /* Enable the External clock mode2 */\r\n      htim->Instance->SMCR |= TIM_SMCR_ECE;\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_TI1:\r\n    {\r\n      /* Check whether or not the timer instance supports external clock mode 1 */\r\n      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));\r\n\r\n      /* Check TI1 input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      TIM_TI1_ConfigInputStage(htim->Instance,\r\n                               sClockSourceConfig->ClockPolarity,\r\n                               sClockSourceConfig->ClockFilter);\r\n      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_TI2:\r\n    {\r\n      /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/\r\n      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));\r\n\r\n      /* Check TI2 input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      TIM_TI2_ConfigInputStage(htim->Instance,\r\n                               sClockSourceConfig->ClockPolarity,\r\n                               sClockSourceConfig->ClockFilter);\r\n      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_TI1ED:\r\n    {\r\n      /* Check whether or not the timer instance supports external clock mode 1 */\r\n      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));\r\n\r\n      /* Check TI1 input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      TIM_TI1_ConfigInputStage(htim->Instance,\r\n                               sClockSourceConfig->ClockPolarity,\r\n                               sClockSourceConfig->ClockFilter);\r\n      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_ITR0:\r\n    case TIM_CLOCKSOURCE_ITR1:\r\n    case TIM_CLOCKSOURCE_ITR2:\r\n    case TIM_CLOCKSOURCE_ITR3:\r\n    {\r\n      /* Check whether or not the timer instance supports internal trigger input */\r\n      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));\r\n\r\n      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Selects the signal connected to the TI1 input: direct from CH1_input\r\n  *         or a XOR combination between CH1_input, CH2_input & CH3_input\r\n  * @param  htim TIM handle.\r\n  * @param  TI1_Selection Indicate whether or not channel 1 is connected to the\r\n  *         output of a XOR gate.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input\r\n  *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3\r\n  *            pins are connected to the TI1 input (XOR combination)\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)\r\n{\r\n  uint32_t tmpcr2;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_TI1SELECTION(TI1_Selection));\r\n\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 = htim->Instance->CR2;\r\n\r\n  /* Reset the TI1 selection */\r\n  tmpcr2 &= ~TIM_CR2_TI1S;\r\n\r\n  /* Set the TI1 selection */\r\n  tmpcr2 |= TI1_Selection;\r\n\r\n  /* Write to TIMxCR2 */\r\n  htim->Instance->CR2 = tmpcr2;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the TIM in Slave mode\r\n  * @param  htim TIM handle.\r\n  * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that\r\n  *         contains the selected trigger (internal trigger input, filtered\r\n  *         timer input or external trigger input) and the Slave mode\r\n  *         (Disable, Reset, Gated, Trigger, External clock mode 1).\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef *sSlaveConfig)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));\r\n  assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n    __HAL_UNLOCK(htim);\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Disable Trigger Interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);\r\n\r\n  /* Disable Trigger DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);\r\n\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the TIM in Slave mode in interrupt mode\r\n  * @param  htim TIM handle.\r\n  * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that\r\n  *         contains the selected trigger (internal trigger input, filtered\r\n  *         timer input or external trigger input) and the Slave mode\r\n  *         (Disable, Reset, Gated, Trigger, External clock mode 1).\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim,\r\n                                                TIM_SlaveConfigTypeDef *sSlaveConfig)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));\r\n  assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n    __HAL_UNLOCK(htim);\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Enable Trigger Interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);\r\n\r\n  /* Disable Trigger DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);\r\n\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Read the captured value from Capture Compare unit\r\n  * @param  htim TIM handle.\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval Captured value\r\n  */\r\nuint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpreg = 0U;\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n      /* Return the capture 1 value */\r\n      tmpreg =  htim->Instance->CCR1;\r\n\r\n      break;\r\n    }\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n      /* Return the capture 2 value */\r\n      tmpreg =   htim->Instance->CCR2;\r\n\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));\r\n\r\n      /* Return the capture 3 value */\r\n      tmpreg =   htim->Instance->CCR3;\r\n\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));\r\n\r\n      /* Return the capture 4 value */\r\n      tmpreg =   htim->Instance->CCR4;\r\n\r\n      break;\r\n    }\r\n\r\n    default:\r\n      break;\r\n  }\r\n\r\n  return tmpreg;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions\r\n  *  @brief    TIM Callbacks functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                        ##### TIM Callbacks functions #####\r\n  ==============================================================================\r\n [..]\r\n   This section provides TIM callback functions:\r\n   (+) TIM Period elapsed callback\r\n   (+) TIM Output Compare callback\r\n   (+) TIM Input capture callback\r\n   (+) TIM Trigger callback\r\n   (+) TIM Error callback\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Period elapsed callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PeriodElapsedCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Period elapsed half complete callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Output Compare callback in non-blocking mode\r\n  * @param  htim TIM OC handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Input Capture callback in non-blocking mode\r\n  * @param  htim TIM IC handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_IC_CaptureCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Input Capture half complete callback in non-blocking mode\r\n  * @param  htim TIM IC handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  PWM Pulse finished callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  PWM Pulse finished half complete callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Hall Trigger detection callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_TriggerCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Hall Trigger detection half complete callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Timer error callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_ErrorCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n/**\r\n  * @brief  Register a User TIM callback to be used instead of the weak predefined callback\r\n  * @param htim tim handle\r\n  * @param CallbackID ID of the callback to be registered\r\n  *        This parameter can be one of the following values:\r\n  *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID\r\n  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID\r\n  *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID\r\n  *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID\r\n  *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID\r\n  *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID\r\n  *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID\r\n  *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID\r\n  *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID\r\n  *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID\r\n  *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID\r\n  *          @param pCallback pointer to the callback function\r\n  *          @retval status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_RegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID,\r\n                                           pTIM_CallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  /* Process locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  if (htim->State == HAL_TIM_STATE_READY)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_TIM_BASE_MSPINIT_CB_ID :\r\n        htim->Base_MspInitCallback                 = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BASE_MSPDEINIT_CB_ID :\r\n        htim->Base_MspDeInitCallback               = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPINIT_CB_ID :\r\n        htim->IC_MspInitCallback                   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPDEINIT_CB_ID :\r\n        htim->IC_MspDeInitCallback                 = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPINIT_CB_ID :\r\n        htim->OC_MspInitCallback                   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPDEINIT_CB_ID :\r\n        htim->OC_MspDeInitCallback                 = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPINIT_CB_ID :\r\n        htim->PWM_MspInitCallback                  = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPDEINIT_CB_ID :\r\n        htim->PWM_MspDeInitCallback                = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :\r\n        htim->OnePulse_MspInitCallback             = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :\r\n        htim->OnePulse_MspDeInitCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPINIT_CB_ID :\r\n        htim->Encoder_MspInitCallback              = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :\r\n        htim->Encoder_MspDeInitCallback            = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :\r\n        htim->HallSensor_MspInitCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :\r\n        htim->HallSensor_MspDeInitCallback         = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PERIOD_ELAPSED_CB_ID :\r\n        htim->PeriodElapsedCallback                = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :\r\n        htim->PeriodElapsedHalfCpltCallback        = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_TRIGGER_CB_ID :\r\n        htim->TriggerCallback                      = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_TRIGGER_HALF_CB_ID :\r\n        htim->TriggerHalfCpltCallback              = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_CAPTURE_CB_ID :\r\n        htim->IC_CaptureCallback                   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_CAPTURE_HALF_CB_ID :\r\n        htim->IC_CaptureHalfCpltCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :\r\n        htim->OC_DelayElapsedCallback              = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :\r\n        htim->PWM_PulseFinishedCallback            = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :\r\n        htim->PWM_PulseFinishedHalfCpltCallback    = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ERROR_CB_ID :\r\n        htim->ErrorCallback                        = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_COMMUTATION_CB_ID :\r\n        htim->CommutationCallback                  = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_COMMUTATION_HALF_CB_ID :\r\n        htim->CommutationHalfCpltCallback          = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BREAK_CB_ID :\r\n        htim->BreakCallback                        = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Return error status */\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_TIM_BASE_MSPINIT_CB_ID :\r\n        htim->Base_MspInitCallback         = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BASE_MSPDEINIT_CB_ID :\r\n        htim->Base_MspDeInitCallback       = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPINIT_CB_ID :\r\n        htim->IC_MspInitCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPDEINIT_CB_ID :\r\n        htim->IC_MspDeInitCallback         = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPINIT_CB_ID :\r\n        htim->OC_MspInitCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPDEINIT_CB_ID :\r\n        htim->OC_MspDeInitCallback         = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPINIT_CB_ID :\r\n        htim->PWM_MspInitCallback          = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPDEINIT_CB_ID :\r\n        htim->PWM_MspDeInitCallback        = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :\r\n        htim->OnePulse_MspInitCallback     = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :\r\n        htim->OnePulse_MspDeInitCallback   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPINIT_CB_ID :\r\n        htim->Encoder_MspInitCallback      = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :\r\n        htim->Encoder_MspDeInitCallback    = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :\r\n        htim->HallSensor_MspInitCallback   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :\r\n        htim->HallSensor_MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Return error status */\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Return error status */\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Unregister a TIM callback\r\n  *         TIM callback is redirected to the weak predefined callback\r\n  * @param htim tim handle\r\n  * @param CallbackID ID of the callback to be unregistered\r\n  *        This parameter can be one of the following values:\r\n  *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID\r\n  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID\r\n  *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID\r\n  *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID\r\n  *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID\r\n  *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID\r\n  *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID\r\n  *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID\r\n  *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID\r\n  *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID\r\n  *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID\r\n  *          @retval status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_UnRegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  if (htim->State == HAL_TIM_STATE_READY)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_TIM_BASE_MSPINIT_CB_ID :\r\n        /* Legacy weak Base MspInit Callback */\r\n        htim->Base_MspInitCallback              = HAL_TIM_Base_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_BASE_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Base Msp DeInit Callback */\r\n        htim->Base_MspDeInitCallback            = HAL_TIM_Base_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPINIT_CB_ID :\r\n        /* Legacy weak IC Msp Init Callback */\r\n        htim->IC_MspInitCallback                = HAL_TIM_IC_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPDEINIT_CB_ID :\r\n        /* Legacy weak IC Msp DeInit Callback */\r\n        htim->IC_MspDeInitCallback              = HAL_TIM_IC_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPINIT_CB_ID :\r\n        /* Legacy weak OC Msp Init Callback */\r\n        htim->OC_MspInitCallback                = HAL_TIM_OC_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPDEINIT_CB_ID :\r\n        /* Legacy weak OC Msp DeInit Callback */\r\n        htim->OC_MspDeInitCallback              = HAL_TIM_OC_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPINIT_CB_ID :\r\n        /* Legacy weak PWM Msp Init Callback */\r\n        htim->PWM_MspInitCallback               = HAL_TIM_PWM_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPDEINIT_CB_ID :\r\n        /* Legacy weak PWM Msp DeInit Callback */\r\n        htim->PWM_MspDeInitCallback             = HAL_TIM_PWM_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :\r\n        /* Legacy weak One Pulse Msp Init Callback */\r\n        htim->OnePulse_MspInitCallback          = HAL_TIM_OnePulse_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :\r\n        /* Legacy weak One Pulse Msp DeInit Callback */\r\n        htim->OnePulse_MspDeInitCallback        = HAL_TIM_OnePulse_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPINIT_CB_ID :\r\n        /* Legacy weak Encoder Msp Init Callback */\r\n        htim->Encoder_MspInitCallback           = HAL_TIM_Encoder_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Encoder Msp DeInit Callback */\r\n        htim->Encoder_MspDeInitCallback         = HAL_TIM_Encoder_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :\r\n        /* Legacy weak Hall Sensor Msp Init Callback */\r\n        htim->HallSensor_MspInitCallback        = HAL_TIMEx_HallSensor_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Hall Sensor Msp DeInit Callback */\r\n        htim->HallSensor_MspDeInitCallback      = HAL_TIMEx_HallSensor_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_PERIOD_ELAPSED_CB_ID :\r\n        /* Legacy weak Period Elapsed Callback */\r\n        htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :\r\n        /* Legacy weak Period Elapsed half complete Callback */\r\n        htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_TRIGGER_CB_ID :\r\n        /* Legacy weak Trigger Callback */\r\n        htim->TriggerCallback                   = HAL_TIM_TriggerCallback;\r\n        break;\r\n\r\n      case HAL_TIM_TRIGGER_HALF_CB_ID :\r\n        /* Legacy weak Trigger half complete Callback */\r\n        htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_CAPTURE_CB_ID :\r\n        /* Legacy weak IC Capture Callback */\r\n        htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_CAPTURE_HALF_CB_ID :\r\n        /* Legacy weak IC Capture half complete Callback */\r\n        htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :\r\n        /* Legacy weak OC Delay Elapsed Callback */\r\n        htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :\r\n        /* Legacy weak PWM Pulse Finished Callback */\r\n        htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :\r\n        /* Legacy weak PWM Pulse Finished half complete Callback */\r\n        htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ERROR_CB_ID :\r\n        /* Legacy weak Error Callback */\r\n        htim->ErrorCallback                     = HAL_TIM_ErrorCallback;\r\n        break;\r\n\r\n      case HAL_TIM_COMMUTATION_CB_ID :\r\n        /* Legacy weak Commutation Callback */\r\n        htim->CommutationCallback               = HAL_TIMEx_CommutCallback;\r\n        break;\r\n\r\n      case HAL_TIM_COMMUTATION_HALF_CB_ID :\r\n        /* Legacy weak Commutation half complete Callback */\r\n        htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BREAK_CB_ID :\r\n        /* Legacy weak Break Callback */\r\n        htim->BreakCallback                     = HAL_TIMEx_BreakCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Return error status */\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_TIM_BASE_MSPINIT_CB_ID :\r\n        /* Legacy weak Base MspInit Callback */\r\n        htim->Base_MspInitCallback         = HAL_TIM_Base_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_BASE_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Base Msp DeInit Callback */\r\n        htim->Base_MspDeInitCallback       = HAL_TIM_Base_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPINIT_CB_ID :\r\n        /* Legacy weak IC Msp Init Callback */\r\n        htim->IC_MspInitCallback           = HAL_TIM_IC_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPDEINIT_CB_ID :\r\n        /* Legacy weak IC Msp DeInit Callback */\r\n        htim->IC_MspDeInitCallback         = HAL_TIM_IC_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPINIT_CB_ID :\r\n        /* Legacy weak OC Msp Init Callback */\r\n        htim->OC_MspInitCallback           = HAL_TIM_OC_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPDEINIT_CB_ID :\r\n        /* Legacy weak OC Msp DeInit Callback */\r\n        htim->OC_MspDeInitCallback         = HAL_TIM_OC_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPINIT_CB_ID :\r\n        /* Legacy weak PWM Msp Init Callback */\r\n        htim->PWM_MspInitCallback          = HAL_TIM_PWM_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPDEINIT_CB_ID :\r\n        /* Legacy weak PWM Msp DeInit Callback */\r\n        htim->PWM_MspDeInitCallback        = HAL_TIM_PWM_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :\r\n        /* Legacy weak One Pulse Msp Init Callback */\r\n        htim->OnePulse_MspInitCallback     = HAL_TIM_OnePulse_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :\r\n        /* Legacy weak One Pulse Msp DeInit Callback */\r\n        htim->OnePulse_MspDeInitCallback   = HAL_TIM_OnePulse_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPINIT_CB_ID :\r\n        /* Legacy weak Encoder Msp Init Callback */\r\n        htim->Encoder_MspInitCallback      = HAL_TIM_Encoder_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Encoder Msp DeInit Callback */\r\n        htim->Encoder_MspDeInitCallback    = HAL_TIM_Encoder_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :\r\n        /* Legacy weak Hall Sensor Msp Init Callback */\r\n        htim->HallSensor_MspInitCallback   = HAL_TIMEx_HallSensor_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Hall Sensor Msp DeInit Callback */\r\n        htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;\r\n        break;\r\n\r\n      default :\r\n        /* Return error status */\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Return error status */\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions\r\n  *  @brief   TIM Peripheral State functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                        ##### Peripheral State functions #####\r\n  ==============================================================================\r\n    [..]\r\n    This subsection permits to get in run-time the status of the peripheral\r\n    and the data flow.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return the TIM Base handle state.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM OC handle state.\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM PWM handle state.\r\n  * @param  htim TIM handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM Input Capture handle state.\r\n  * @param  htim TIM IC handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM One Pulse Mode handle state.\r\n  * @param  htim TIM OPM handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM Encoder Mode handle state.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM Encoder Mode handle state.\r\n  * @param  htim TIM handle\r\n  * @retval Active channel\r\n  */\r\nHAL_TIM_ActiveChannel HAL_TIM_GetActiveChannel(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->Channel;\r\n}\r\n\r\n/**\r\n  * @brief  Return actual state of the TIM channel.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6\r\n  * @retval TIM Channel state\r\n  */\r\nHAL_TIM_ChannelStateTypeDef HAL_TIM_GetChannelState(TIM_HandleTypeDef *htim,  uint32_t Channel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_state;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);\r\n\r\n  return channel_state;\r\n}\r\n\r\n/**\r\n  * @brief  Return actual state of a DMA burst operation.\r\n  * @param  htim TIM handle\r\n  * @retval DMA burst state\r\n  */\r\nHAL_TIM_DMABurstStateTypeDef HAL_TIM_DMABurstState(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));\r\n\r\n  return htim->DMABurstState;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Private_Functions TIM Private Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  TIM DMA error callback\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIM_DMAError(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->ErrorCallback(htim);\r\n#else\r\n  HAL_TIM_ErrorCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Delay Pulse complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n  HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Delay Pulse half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PWM_PulseFinishedHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Capture complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->IC_CaptureCallback(htim);\r\n#else\r\n  HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Capture half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->IC_CaptureHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIM_IC_CaptureHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Period Elapse complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (htim->hdma[TIM_DMA_ID_UPDATE]->Init.Mode == DMA_NORMAL)\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PeriodElapsedCallback(htim);\r\n#else\r\n  HAL_TIM_PeriodElapsedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Period Elapse half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PeriodElapsedHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIM_PeriodElapsedHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Trigger callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (htim->hdma[TIM_DMA_ID_TRIGGER]->Init.Mode == DMA_NORMAL)\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->TriggerCallback(htim);\r\n#else\r\n  HAL_TIM_TriggerCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Trigger half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->TriggerHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIM_TriggerHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  Time Base configuration\r\n  * @param  TIMx TIM peripheral\r\n  * @param  Structure TIM Base configuration structure\r\n  * @retval None\r\n  */\r\nvoid TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)\r\n{\r\n  uint32_t tmpcr1;\r\n  tmpcr1 = TIMx->CR1;\r\n\r\n  /* Set TIM Time Base Unit parameters ---------------------------------------*/\r\n  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))\r\n  {\r\n    /* Select the Counter Mode */\r\n    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);\r\n    tmpcr1 |= Structure->CounterMode;\r\n  }\r\n\r\n  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))\r\n  {\r\n    /* Set the clock division */\r\n    tmpcr1 &= ~TIM_CR1_CKD;\r\n    tmpcr1 |= (uint32_t)Structure->ClockDivision;\r\n  }\r\n\r\n  /* Set the auto-reload preload */\r\n  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);\r\n\r\n  TIMx->CR1 = tmpcr1;\r\n\r\n  /* Set the Autoreload value */\r\n  TIMx->ARR = (uint32_t)Structure->Period ;\r\n\r\n  /* Set the Prescaler value */\r\n  TIMx->PSC = Structure->Prescaler;\r\n\r\n  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))\r\n  {\r\n    /* Set the Repetition Counter value */\r\n    TIMx->RCR = Structure->RepetitionCounter;\r\n  }\r\n\r\n  /* Generate an update event to reload the Prescaler\r\n     and the repetition counter (only for advanced timer) value immediately */\r\n  TIMx->EGR = TIM_EGR_UG;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 1 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nstatic void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the Channel 1: Reset the CC1E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC1E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmrx = TIMx->CCMR1;\r\n\r\n  /* Reset the Output Compare Mode Bits */\r\n  tmpccmrx &= ~TIM_CCMR1_OC1M;\r\n  tmpccmrx &= ~TIM_CCMR1_CC1S;\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= OC_Config->OCMode;\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= ~TIM_CCER_CC1P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= OC_Config->OCPolarity;\r\n\r\n  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));\r\n\r\n    /* Reset the Output N Polarity level */\r\n    tmpccer &= ~TIM_CCER_CC1NP;\r\n    /* Set the Output N Polarity */\r\n    tmpccer |= OC_Config->OCNPolarity;\r\n    /* Reset the Output N State */\r\n    tmpccer &= ~TIM_CCER_CC1NE;\r\n  }\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));\r\n    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));\r\n\r\n    /* Reset the Output Compare and Output Compare N IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS1;\r\n    tmpcr2 &= ~TIM_CR2_OIS1N;\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= OC_Config->OCIdleState;\r\n    /* Set the Output N Idle state */\r\n    tmpcr2 |= OC_Config->OCNIdleState;\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR1 */\r\n  TIMx->CCMR1 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR1 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 2 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nvoid TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the Channel 2: Reset the CC2E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC2E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmrx = TIMx->CCMR1;\r\n\r\n  /* Reset the Output Compare mode and Capture/Compare selection Bits */\r\n  tmpccmrx &= ~TIM_CCMR1_OC2M;\r\n  tmpccmrx &= ~TIM_CCMR1_CC2S;\r\n\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= (OC_Config->OCMode << 8U);\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= ~TIM_CCER_CC2P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= (OC_Config->OCPolarity << 4U);\r\n\r\n  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))\r\n  {\r\n    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));\r\n\r\n    /* Reset the Output N Polarity level */\r\n    tmpccer &= ~TIM_CCER_CC2NP;\r\n    /* Set the Output N Polarity */\r\n    tmpccer |= (OC_Config->OCNPolarity << 4U);\r\n    /* Reset the Output N State */\r\n    tmpccer &= ~TIM_CCER_CC2NE;\r\n\r\n  }\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));\r\n    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));\r\n\r\n    /* Reset the Output Compare and Output Compare N IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS2;\r\n    tmpcr2 &= ~TIM_CR2_OIS2N;\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= (OC_Config->OCIdleState << 2U);\r\n    /* Set the Output N Idle state */\r\n    tmpcr2 |= (OC_Config->OCNIdleState << 2U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR1 */\r\n  TIMx->CCMR1 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR2 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 3 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nstatic void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the Channel 3: Reset the CC2E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC3E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n\r\n  /* Get the TIMx CCMR2 register value */\r\n  tmpccmrx = TIMx->CCMR2;\r\n\r\n  /* Reset the Output Compare mode and Capture/Compare selection Bits */\r\n  tmpccmrx &= ~TIM_CCMR2_OC3M;\r\n  tmpccmrx &= ~TIM_CCMR2_CC3S;\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= OC_Config->OCMode;\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= ~TIM_CCER_CC3P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= (OC_Config->OCPolarity << 8U);\r\n\r\n  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))\r\n  {\r\n    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));\r\n\r\n    /* Reset the Output N Polarity level */\r\n    tmpccer &= ~TIM_CCER_CC3NP;\r\n    /* Set the Output N Polarity */\r\n    tmpccer |= (OC_Config->OCNPolarity << 8U);\r\n    /* Reset the Output N State */\r\n    tmpccer &= ~TIM_CCER_CC3NE;\r\n  }\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));\r\n    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));\r\n\r\n    /* Reset the Output Compare and Output Compare N IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS3;\r\n    tmpcr2 &= ~TIM_CR2_OIS3N;\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= (OC_Config->OCIdleState << 4U);\r\n    /* Set the Output N Idle state */\r\n    tmpcr2 |= (OC_Config->OCNIdleState << 4U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR2 */\r\n  TIMx->CCMR2 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR3 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 4 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nstatic void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the Channel 4: Reset the CC4E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC4E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n\r\n  /* Get the TIMx CCMR2 register value */\r\n  tmpccmrx = TIMx->CCMR2;\r\n\r\n  /* Reset the Output Compare mode and Capture/Compare selection Bits */\r\n  tmpccmrx &= ~TIM_CCMR2_OC4M;\r\n  tmpccmrx &= ~TIM_CCMR2_CC4S;\r\n\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= (OC_Config->OCMode << 8U);\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= ~TIM_CCER_CC4P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= (OC_Config->OCPolarity << 12U);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));\r\n\r\n    /* Reset the Output Compare IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS4;\r\n\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= (OC_Config->OCIdleState << 6U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR2 */\r\n  TIMx->CCMR2 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR4 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Slave Timer configuration function\r\n  * @param  htim TIM handle\r\n  * @param  sSlaveConfig Slave timer configuration\r\n  * @retval None\r\n  */\r\nstatic HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,\r\n                                                  TIM_SlaveConfigTypeDef *sSlaveConfig)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Get the TIMx SMCR register value */\r\n  tmpsmcr = htim->Instance->SMCR;\r\n\r\n  /* Reset the Trigger Selection Bits */\r\n  tmpsmcr &= ~TIM_SMCR_TS;\r\n  /* Set the Input Trigger source */\r\n  tmpsmcr |= sSlaveConfig->InputTrigger;\r\n\r\n  /* Reset the slave mode Bits */\r\n  tmpsmcr &= ~TIM_SMCR_SMS;\r\n  /* Set the slave mode */\r\n  tmpsmcr |= sSlaveConfig->SlaveMode;\r\n\r\n  /* Write to TIMx SMCR */\r\n  htim->Instance->SMCR = tmpsmcr;\r\n\r\n  /* Configure the trigger prescaler, filter, and polarity */\r\n  switch (sSlaveConfig->InputTrigger)\r\n  {\r\n    case TIM_TS_ETRF:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));\r\n      assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));\r\n      assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));\r\n      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));\r\n      /* Configure the ETR Trigger source */\r\n      TIM_ETR_SetConfig(htim->Instance,\r\n                        sSlaveConfig->TriggerPrescaler,\r\n                        sSlaveConfig->TriggerPolarity,\r\n                        sSlaveConfig->TriggerFilter);\r\n      break;\r\n    }\r\n\r\n    case TIM_TS_TI1F_ED:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));\r\n\r\n      if (sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Disable the Channel 1: Reset the CC1E Bit */\r\n      tmpccer = htim->Instance->CCER;\r\n      htim->Instance->CCER &= ~TIM_CCER_CC1E;\r\n      tmpccmr1 = htim->Instance->CCMR1;\r\n\r\n      /* Set the filter */\r\n      tmpccmr1 &= ~TIM_CCMR1_IC1F;\r\n      tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);\r\n\r\n      /* Write to TIMx CCMR1 and CCER registers */\r\n      htim->Instance->CCMR1 = tmpccmr1;\r\n      htim->Instance->CCER = tmpccer;\r\n      break;\r\n    }\r\n\r\n    case TIM_TS_TI1FP1:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n      assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));\r\n      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));\r\n\r\n      /* Configure TI1 Filter and Polarity */\r\n      TIM_TI1_ConfigInputStage(htim->Instance,\r\n                               sSlaveConfig->TriggerPolarity,\r\n                               sSlaveConfig->TriggerFilter);\r\n      break;\r\n    }\r\n\r\n    case TIM_TS_TI2FP2:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n      assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));\r\n      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));\r\n\r\n      /* Configure TI2 Filter and Polarity */\r\n      TIM_TI2_ConfigInputStage(htim->Instance,\r\n                               sSlaveConfig->TriggerPolarity,\r\n                               sSlaveConfig->TriggerFilter);\r\n      break;\r\n    }\r\n\r\n    case TIM_TS_ITR0:\r\n    case TIM_TS_ITR1:\r\n    case TIM_TS_ITR2:\r\n    case TIM_TS_ITR3:\r\n    {\r\n      /* Check the parameter */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TI1 as Input.\r\n  * @param  TIMx to select the TIM peripheral.\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICSelection specifies the input to be used.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 1 is selected to be connected to IC1.\r\n  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 1 is selected to be connected to IC2.\r\n  *            @arg TIM_ICSELECTION_TRC: TIM Input 1 is selected to be connected to TRC.\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1\r\n  *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be\r\n  *        protected against un-initialized filter and polarity values.\r\n  */\r\nvoid TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                       uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 1: Reset the CC1E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC1E;\r\n  tmpccmr1 = TIMx->CCMR1;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Select the Input */\r\n  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)\r\n  {\r\n    tmpccmr1 &= ~TIM_CCMR1_CC1S;\r\n    tmpccmr1 |= TIM_ICSelection;\r\n  }\r\n  else\r\n  {\r\n    tmpccmr1 |= TIM_CCMR1_CC1S_0;\r\n  }\r\n\r\n  /* Set the filter */\r\n  tmpccmr1 &= ~TIM_CCMR1_IC1F;\r\n  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);\r\n\r\n  /* Select the Polarity and set the CC1E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);\r\n  tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));\r\n\r\n  /* Write to TIMx CCMR1 and CCER registers */\r\n  TIMx->CCMR1 = tmpccmr1;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the Polarity and Filter for TI1.\r\n  * @param  TIMx to select the TIM peripheral.\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  */\r\nstatic void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 1: Reset the CC1E Bit */\r\n  tmpccer = TIMx->CCER;\r\n  TIMx->CCER &= ~TIM_CCER_CC1E;\r\n  tmpccmr1 = TIMx->CCMR1;\r\n\r\n  /* Set the filter */\r\n  tmpccmr1 &= ~TIM_CCMR1_IC1F;\r\n  tmpccmr1 |= (TIM_ICFilter << 4U);\r\n\r\n  /* Select the Polarity and set the CC1E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);\r\n  tmpccer |= TIM_ICPolarity;\r\n\r\n  /* Write to TIMx CCMR1 and CCER registers */\r\n  TIMx->CCMR1 = tmpccmr1;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TI2 as Input.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICSelection specifies the input to be used.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 2 is selected to be connected to IC2.\r\n  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.\r\n  *            @arg TIM_ICSELECTION_TRC: TIM Input 2 is selected to be connected to TRC.\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2\r\n  *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be\r\n  *        protected against un-initialized filter and polarity values.\r\n  */\r\nstatic void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 2: Reset the CC2E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC2E;\r\n  tmpccmr1 = TIMx->CCMR1;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Select the Input */\r\n  tmpccmr1 &= ~TIM_CCMR1_CC2S;\r\n  tmpccmr1 |= (TIM_ICSelection << 8U);\r\n\r\n  /* Set the filter */\r\n  tmpccmr1 &= ~TIM_CCMR1_IC2F;\r\n  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);\r\n\r\n  /* Select the Polarity and set the CC2E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);\r\n  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));\r\n\r\n  /* Write to TIMx CCMR1 and CCER registers */\r\n  TIMx->CCMR1 = tmpccmr1 ;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the Polarity and Filter for TI2.\r\n  * @param  TIMx to select the TIM peripheral.\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  */\r\nstatic void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 2: Reset the CC2E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC2E;\r\n  tmpccmr1 = TIMx->CCMR1;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Set the filter */\r\n  tmpccmr1 &= ~TIM_CCMR1_IC2F;\r\n  tmpccmr1 |= (TIM_ICFilter << 12U);\r\n\r\n  /* Select the Polarity and set the CC2E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);\r\n  tmpccer |= (TIM_ICPolarity << 4U);\r\n\r\n  /* Write to TIMx CCMR1 and CCER registers */\r\n  TIMx->CCMR1 = tmpccmr1 ;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TI3 as Input.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICSelection specifies the input to be used.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 3 is selected to be connected to IC3.\r\n  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.\r\n  *            @arg TIM_ICSELECTION_TRC: TIM Input 3 is selected to be connected to TRC.\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4\r\n  *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be\r\n  *        protected against un-initialized filter and polarity values.\r\n  */\r\nstatic void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr2;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 3: Reset the CC3E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC3E;\r\n  tmpccmr2 = TIMx->CCMR2;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Select the Input */\r\n  tmpccmr2 &= ~TIM_CCMR2_CC3S;\r\n  tmpccmr2 |= TIM_ICSelection;\r\n\r\n  /* Set the filter */\r\n  tmpccmr2 &= ~TIM_CCMR2_IC3F;\r\n  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);\r\n\r\n  /* Select the Polarity and set the CC3E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);\r\n  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));\r\n\r\n  /* Write to TIMx CCMR2 and CCER registers */\r\n  TIMx->CCMR2 = tmpccmr2;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TI4 as Input.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICSelection specifies the input to be used.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 4 is selected to be connected to IC4.\r\n  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.\r\n  *            @arg TIM_ICSELECTION_TRC: TIM Input 4 is selected to be connected to TRC.\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3\r\n  *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be\r\n  *        protected against un-initialized filter and polarity values.\r\n  * @retval None\r\n  */\r\nstatic void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr2;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 4: Reset the CC4E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC4E;\r\n  tmpccmr2 = TIMx->CCMR2;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Select the Input */\r\n  tmpccmr2 &= ~TIM_CCMR2_CC4S;\r\n  tmpccmr2 |= (TIM_ICSelection << 8U);\r\n\r\n  /* Set the filter */\r\n  tmpccmr2 &= ~TIM_CCMR2_IC4F;\r\n  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);\r\n\r\n  /* Select the Polarity and set the CC4E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);\r\n  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));\r\n\r\n  /* Write to TIMx CCMR2 and CCER registers */\r\n  TIMx->CCMR2 = tmpccmr2;\r\n  TIMx->CCER = tmpccer ;\r\n}\r\n\r\n/**\r\n  * @brief  Selects the Input Trigger source\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  InputTriggerSource The Input Trigger source.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TS_ITR0: Internal Trigger 0\r\n  *            @arg TIM_TS_ITR1: Internal Trigger 1\r\n  *            @arg TIM_TS_ITR2: Internal Trigger 2\r\n  *            @arg TIM_TS_ITR3: Internal Trigger 3\r\n  *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector\r\n  *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1\r\n  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2\r\n  *            @arg TIM_TS_ETRF: External Trigger input\r\n  * @retval None\r\n  */\r\nstatic void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Get the TIMx SMCR register value */\r\n  tmpsmcr = TIMx->SMCR;\r\n  /* Reset the TS Bits */\r\n  tmpsmcr &= ~TIM_SMCR_TS;\r\n  /* Set the Input Trigger source and the slave mode*/\r\n  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);\r\n  /* Write to TIMx SMCR */\r\n  TIMx->SMCR = tmpsmcr;\r\n}\r\n/**\r\n  * @brief  Configures the TIMx External Trigger (ETR).\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  TIM_ExtTRGPrescaler The external Trigger Prescaler.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.\r\n  *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.\r\n  *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.\r\n  *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.\r\n  * @param  TIM_ExtTRGPolarity The external Trigger Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.\r\n  *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.\r\n  * @param  ExtTRGFilter External Trigger Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F\r\n  * @retval None\r\n  */\r\nvoid TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,\r\n                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  tmpsmcr = TIMx->SMCR;\r\n\r\n  /* Reset the ETR Bits */\r\n  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);\r\n\r\n  /* Set the Prescaler, the Filter value and the Polarity */\r\n  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));\r\n\r\n  /* Write to TIMx SMCR */\r\n  TIMx->SMCR = tmpsmcr;\r\n}\r\n\r\n/**\r\n  * @brief  Enables or disables the TIM Capture Compare Channel x.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  Channel specifies the TIM Channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4\r\n  * @param  ChannelState specifies the TIM Channel CCxE bit new state.\r\n  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.\r\n  * @retval None\r\n  */\r\nvoid TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)\r\n{\r\n  uint32_t tmp;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CC1_INSTANCE(TIMx));\r\n  assert_param(IS_TIM_CHANNELS(Channel));\r\n\r\n  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */\r\n\r\n  /* Reset the CCxE Bit */\r\n  TIMx->CCER &= ~tmp;\r\n\r\n  /* Set or reset the CCxE Bit */\r\n  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */\r\n}\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n/**\r\n  * @brief  Reset interrupt callbacks to the legacy weak callbacks.\r\n  * @param  htim pointer to a TIM_HandleTypeDef structure that contains\r\n  *                the configuration information for TIM module.\r\n  * @retval None\r\n  */\r\nvoid TIM_ResetCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Reset the TIM callback to the legacy weak callbacks */\r\n  htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;\r\n  htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;\r\n  htim->TriggerCallback                   = HAL_TIM_TriggerCallback;\r\n  htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;\r\n  htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;\r\n  htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;\r\n  htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;\r\n  htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;\r\n  htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback;\r\n  htim->ErrorCallback                     = HAL_TIM_ErrorCallback;\r\n  htim->CommutationCallback               = HAL_TIMEx_CommutCallback;\r\n  htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;\r\n  htim->BreakCallback                     = HAL_TIMEx_BreakCallback;\r\n}\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_TIM_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_tim_ex.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_tim_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   TIM HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Timer Extended peripheral:\r\n  *           + Time Hall Sensor Interface Initialization\r\n  *           + Time Hall Sensor Interface Start\r\n  *           + Time Complementary signal break and dead time configuration\r\n  *           + Time Master and Slave synchronization configuration\r\n  *           + Timer remapping capabilities configuration\r\n  @verbatim\r\n  ==============================================================================\r\n                      ##### TIMER Extended features #####\r\n  ==============================================================================\r\n  [..]\r\n    The Timer Extended features include:\r\n    (#) Complementary outputs with programmable dead-time for :\r\n        (++) Output Compare\r\n        (++) PWM generation (Edge and Center-aligned Mode)\r\n        (++) One-pulse mode output\r\n    (#) Synchronization circuit to control the timer with external signals and to\r\n        interconnect several timers together.\r\n    (#) Break input to put the timer output signals in reset state or in a known state.\r\n    (#) Supports incremental (quadrature) encoder and hall-sensor circuitry for\r\n        positioning purposes\r\n\r\n            ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n     (#) Initialize the TIM low level resources by implementing the following functions\r\n         depending on the selected feature:\r\n           (++) Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()\r\n\r\n     (#) Initialize the TIM low level resources :\r\n        (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();\r\n        (##) TIM pins configuration\r\n            (+++) Enable the clock for the TIM GPIOs using the following function:\r\n              __HAL_RCC_GPIOx_CLK_ENABLE();\r\n            (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();\r\n\r\n     (#) The external Clock can be configured, if needed (the default clock is the\r\n         internal clock from the APBx), using the following function:\r\n         HAL_TIM_ConfigClockSource, the clock configuration should be done before\r\n         any start function.\r\n\r\n     (#) Configure the TIM in the desired functioning mode using one of the\r\n         initialization function of this driver:\r\n          (++) HAL_TIMEx_HallSensor_Init() and HAL_TIMEx_ConfigCommutEvent(): to use the\r\n               Timer Hall Sensor Interface and the commutation event with the corresponding\r\n               Interrupt and DMA request if needed (Note that One Timer is used to interface\r\n               with the Hall sensor Interface and another Timer should be used to use\r\n               the commutation event).\r\n\r\n     (#) Activate the TIM peripheral using one of the start functions:\r\n           (++) Complementary Output Compare : HAL_TIMEx_OCN_Start(), HAL_TIMEx_OCN_Start_DMA(),\r\n                HAL_TIMEx_OCN_Start_IT()\r\n           (++) Complementary PWM generation : HAL_TIMEx_PWMN_Start(), HAL_TIMEx_PWMN_Start_DMA(),\r\n                HAL_TIMEx_PWMN_Start_IT()\r\n           (++) Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(), HAL_TIMEx_OnePulseN_Start_IT()\r\n           (++) Hall Sensor output : HAL_TIMEx_HallSensor_Start(), HAL_TIMEx_HallSensor_Start_DMA(),\r\n                HAL_TIMEx_HallSensor_Start_IT().\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/** @addtogroup STM32F4xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup TIMEx TIMEx\r\n  * @brief TIM Extended HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_TIM_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\nstatic void TIM_DMADelayPulseNCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMAErrorCCxN(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState);\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup TIMEx_Exported_Functions TIM Extended Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group1 Extended Timer Hall Sensor functions\r\n  * @brief    Timer Hall Sensor functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                      ##### Timer Hall Sensor functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure TIM HAL Sensor.\r\n    (+) De-initialize TIM HAL Sensor.\r\n    (+) Start the Hall Sensor Interface.\r\n    (+) Stop the Hall Sensor Interface.\r\n    (+) Start the Hall Sensor Interface and enable interrupts.\r\n    (+) Stop the Hall Sensor Interface and disable interrupts.\r\n    (+) Start the Hall Sensor Interface and enable DMA transfers.\r\n    (+) Stop the Hall Sensor Interface and disable DMA transfers.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Hall Sensor Interface and initialize the associated handle.\r\n  * @note   When the timer instance is initialized in Hall Sensor Interface mode,\r\n  *         timer channels 1 and channel 2 are reserved and cannot be used for\r\n  *         other purpose.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @param  sConfig TIM Hall Sensor configuration structure\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef *sConfig)\r\n{\r\n  TIM_OC_InitTypeDef OC_Config;\r\n\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n  assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));\r\n  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));\r\n  assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy week callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->HallSensor_MspInitCallback == NULL)\r\n    {\r\n      htim->HallSensor_MspInitCallback = HAL_TIMEx_HallSensor_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->HallSensor_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIMEx_HallSensor_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Configure the Time base in the Encoder Mode */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */\r\n  TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);\r\n\r\n  /* Reset the IC1PSC Bits */\r\n  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;\r\n  /* Set the IC1PSC value */\r\n  htim->Instance->CCMR1 |= sConfig->IC1Prescaler;\r\n\r\n  /* Enable the Hall sensor interface (XOR function of the three inputs) */\r\n  htim->Instance->CR2 |= TIM_CR2_TI1S;\r\n\r\n  /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */\r\n  htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n  htim->Instance->SMCR |= TIM_TS_TI1F_ED;\r\n\r\n  /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */\r\n  htim->Instance->SMCR &= ~TIM_SMCR_SMS;\r\n  htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;\r\n\r\n  /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/\r\n  OC_Config.OCFastMode = TIM_OCFAST_DISABLE;\r\n  OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;\r\n  OC_Config.OCMode = TIM_OCMODE_PWM2;\r\n  OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;\r\n  OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;\r\n  OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;\r\n  OC_Config.Pulse = sConfig->Commutation_Delay;\r\n\r\n  TIM_OC2_SetConfig(htim->Instance, &OC_Config);\r\n\r\n  /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2\r\n    register to 101 */\r\n  htim->Instance->CR2 &= ~TIM_CR2_MMS;\r\n  htim->Instance->CR2 |= TIM_TRGO_OC2REF;\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM Hall Sensor interface\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->HallSensor_MspDeInitCallback == NULL)\r\n  {\r\n    htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->HallSensor_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  HAL_TIMEx_HallSensor_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Hall Sensor MSP.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Hall Sensor MSP.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Hall Sensor Interface.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)\r\n{\r\n  uint32_t tmpsmcr;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Hall sensor Interface.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channels 1, 2 and 3\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Hall Sensor Interface in interrupt mode.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)\r\n{\r\n  uint32_t tmpsmcr;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the capture compare Interrupts 1 event */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Enable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Hall Sensor Interface in interrupt mode.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the capture compare Interrupts event */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Hall Sensor Interface in DMA mode.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @param  pData The destination Buffer address.\r\n  * @param  Length The length of data to be transferred from TIM peripheral to memory.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)\r\n{\r\n  uint32_t tmpsmcr;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel state */\r\n  if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n      || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)\r\n           && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Enable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n\r\n  /* Set the DMA Input Capture 1 Callbacks */\r\n  htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n  htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n  /* Set the DMA error callback */\r\n  htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n  /* Enable the DMA stream for Capture 1*/\r\n  if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)\r\n  {\r\n    /* Return error status */\r\n    return HAL_ERROR;\r\n  }\r\n  /* Enable the capture compare 1 Interrupt */\r\n  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Hall Sensor Interface in DMA mode.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n\r\n  /* Disable the capture compare Interrupts 1 event */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n\r\n  (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group2 Extended Timer Complementary Output Compare functions\r\n  *  @brief   Timer Complementary Output Compare functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n              ##### Timer Complementary Output Compare functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Start the Complementary Output Compare/PWM.\r\n    (+) Stop the Complementary Output Compare/PWM.\r\n    (+) Start the Complementary Output Compare/PWM and enable interrupts.\r\n    (+) Stop the Complementary Output Compare/PWM and disable interrupts.\r\n    (+) Start the Complementary Output Compare/PWM and enable DMA transfers.\r\n    (+) Stop the Complementary Output Compare/PWM and disable DMA transfers.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation on the complementary\r\n  *         output.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Capture compare channel N */\r\n  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n  /* Enable the Main Output */\r\n  __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation on the complementary\r\n  *         output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the Capture compare channel N */\r\n  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n  /* Disable the Main Output */\r\n  __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation in interrupt mode\r\n  *         on the complementary output.\r\n  * @param  htim TIM OC handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Output Compare interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Output Compare interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Output Compare interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the TIM Break interrupt */\r\n    __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);\r\n\r\n    /* Enable the Capture compare channel N */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n    /* Enable the Main Output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation in interrupt mode\r\n  *         on the complementary output.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpccer;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Output Compare interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Output Compare interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Output Compare interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Capture compare channel N */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n    /* Disable the TIM Break interrupt (only if no more channel is active) */\r\n    tmpccer = htim->Instance->CCER;\r\n    if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)\r\n    {\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);\r\n    }\r\n\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM complementary channel state */\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation in DMA mode\r\n  *         on the complementary output.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to TIM peripheral\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Set the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Output Compare DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Output Compare DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Output Compare DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Capture compare channel N */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n    /* Enable the Main Output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation in DMA mode\r\n  *         on the complementary output.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Output Compare DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Output Compare DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Output Compare DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Capture compare channel N */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM complementary channel state */\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group3 Extended Timer Complementary PWM functions\r\n  * @brief    Timer Complementary PWM functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                 ##### Timer Complementary PWM functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Start the Complementary PWM.\r\n    (+) Stop the Complementary PWM.\r\n    (+) Start the Complementary PWM and enable interrupts.\r\n    (+) Stop the Complementary PWM and disable interrupts.\r\n    (+) Start the Complementary PWM and enable DMA transfers.\r\n    (+) Stop the Complementary PWM and disable DMA transfers.\r\n    (+) Start the Complementary Input Capture measurement.\r\n    (+) Stop the Complementary Input Capture.\r\n    (+) Start the Complementary Input Capture and enable interrupts.\r\n    (+) Stop the Complementary Input Capture and disable interrupts.\r\n    (+) Start the Complementary Input Capture and enable DMA transfers.\r\n    (+) Stop the Complementary Input Capture and disable DMA transfers.\r\n    (+) Start the Complementary One Pulse generation.\r\n    (+) Stop the Complementary One Pulse.\r\n    (+) Start the Complementary One Pulse and enable interrupts.\r\n    (+) Stop the Complementary One Pulse and disable interrupts.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Starts the PWM signal generation on the complementary output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the complementary PWM output  */\r\n  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n  /* Enable the Main Output */\r\n  __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the PWM signal generation on the complementary output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the complementary PWM output  */\r\n  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n  /* Disable the Main Output */\r\n  __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the PWM signal generation in interrupt mode on the\r\n  *         complementary output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the TIM Break interrupt */\r\n    __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);\r\n\r\n    /* Enable the complementary PWM output  */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n    /* Enable the Main Output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the PWM signal generation in interrupt mode on the\r\n  *         complementary output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpccer;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the complementary PWM output  */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n    /* Disable the TIM Break interrupt (only if no more channel is active) */\r\n    tmpccer = htim->Instance->CCER;\r\n    if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)\r\n    {\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);\r\n    }\r\n\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM complementary channel state */\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM PWM signal generation in DMA mode on the\r\n  *         complementary output\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to TIM peripheral\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Set the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the complementary PWM output  */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n    /* Enable the Main Output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM PWM signal generation in DMA mode on the complementary\r\n  *         output\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the complementary PWM output */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM complementary channel state */\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group4 Extended Timer Complementary One Pulse functions\r\n  * @brief    Timer Complementary One Pulse functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                ##### Timer Complementary One Pulse functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Start the Complementary One Pulse generation.\r\n    (+) Stop the Complementary One Pulse.\r\n    (+) Start the Complementary One Pulse and enable interrupts.\r\n    (+) Stop the Complementary One Pulse and disable interrupts.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Starts the TIM One Pulse signal generation on the complementary\r\n  *         output.\r\n  * @note OutputChannel must match the pulse output channel chosen when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel pulse output channel to enable\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the complementary One Pulse output channel and the Input Capture channel */\r\n  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Main Output */\r\n  __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM One Pulse signal generation on the complementary\r\n  *         output.\r\n  * @note OutputChannel must match the pulse output channel chosen when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel pulse output channel to disable\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));\r\n\r\n  /* Disable the complementary One Pulse output channel and the Input Capture channel */\r\n  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the Main Output */\r\n  __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM  channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM One Pulse signal generation in interrupt mode on the\r\n  *         complementary channel.\r\n  * @note OutputChannel must match the pulse output channel chosen when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel pulse output channel to enable\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the TIM Capture/Compare 1 interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Enable the TIM Capture/Compare 2 interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n\r\n  /* Enable the complementary One Pulse output channel and the Input Capture channel */\r\n  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Main Output */\r\n  __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM One Pulse signal generation in interrupt mode on the\r\n  *         complementary channel.\r\n  * @note OutputChannel must match the pulse output channel chosen when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel pulse output channel to disable\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));\r\n\r\n  /* Disable the TIM Capture/Compare 1 interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Disable the TIM Capture/Compare 2 interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n\r\n  /* Disable the complementary One Pulse output channel and the Input Capture channel */\r\n  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the Main Output */\r\n  __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM  channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group5 Extended Peripheral Control functions\r\n  * @brief    Peripheral Control functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                    ##### Peripheral Control functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n      (+) Configure the commutation event in case of use of the Hall sensor interface.\r\n      (+) Configure Output channels for OC and PWM mode.\r\n\r\n      (+) Configure Complementary channels, break features and dead time.\r\n      (+) Configure Master synchronization.\r\n      (+) Configure timer remapping capabilities.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Configure the TIM commutation event sequence.\r\n  * @note  This function is mandatory to use the commutation event in order to\r\n  *        update the configuration at each commutation detection on the TRGI input of the Timer,\r\n  *        the typical use of this feature is with the use of another Timer(interface Timer)\r\n  *        configured in Hall sensor interface, this interface Timer will generate the\r\n  *        commutation at its TRGO output (connected to Timer used in this function) each time\r\n  *        the TI1 of the Interface Timer detect a commutation at its input TI1.\r\n  * @param  htim TIM handle\r\n  * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TS_ITR0: Internal trigger 0 selected\r\n  *            @arg TIM_TS_ITR1: Internal trigger 1 selected\r\n  *            @arg TIM_TS_ITR2: Internal trigger 2 selected\r\n  *            @arg TIM_TS_ITR3: Internal trigger 3 selected\r\n  *            @arg TIM_TS_NONE: No trigger is needed\r\n  * @param  CommutationSource the Commutation Event source\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer\r\n  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,\r\n                                              uint32_t  CommutationSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||\r\n      (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))\r\n  {\r\n    /* Select the Input trigger */\r\n    htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n    htim->Instance->SMCR |= InputTrigger;\r\n  }\r\n\r\n  /* Select the Capture Compare preload feature */\r\n  htim->Instance->CR2 |= TIM_CR2_CCPC;\r\n  /* Select the Commutation event source */\r\n  htim->Instance->CR2 &= ~TIM_CR2_CCUS;\r\n  htim->Instance->CR2 |= CommutationSource;\r\n\r\n  /* Disable Commutation Interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);\r\n\r\n  /* Disable Commutation DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIM commutation event sequence with interrupt.\r\n  * @note  This function is mandatory to use the commutation event in order to\r\n  *        update the configuration at each commutation detection on the TRGI input of the Timer,\r\n  *        the typical use of this feature is with the use of another Timer(interface Timer)\r\n  *        configured in Hall sensor interface, this interface Timer will generate the\r\n  *        commutation at its TRGO output (connected to Timer used in this function) each time\r\n  *        the TI1 of the Interface Timer detect a commutation at its input TI1.\r\n  * @param  htim TIM handle\r\n  * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TS_ITR0: Internal trigger 0 selected\r\n  *            @arg TIM_TS_ITR1: Internal trigger 1 selected\r\n  *            @arg TIM_TS_ITR2: Internal trigger 2 selected\r\n  *            @arg TIM_TS_ITR3: Internal trigger 3 selected\r\n  *            @arg TIM_TS_NONE: No trigger is needed\r\n  * @param  CommutationSource the Commutation Event source\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer\r\n  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,\r\n                                                 uint32_t  CommutationSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||\r\n      (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))\r\n  {\r\n    /* Select the Input trigger */\r\n    htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n    htim->Instance->SMCR |= InputTrigger;\r\n  }\r\n\r\n  /* Select the Capture Compare preload feature */\r\n  htim->Instance->CR2 |= TIM_CR2_CCPC;\r\n  /* Select the Commutation event source */\r\n  htim->Instance->CR2 &= ~TIM_CR2_CCUS;\r\n  htim->Instance->CR2 |= CommutationSource;\r\n\r\n  /* Disable Commutation DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);\r\n\r\n  /* Enable the Commutation Interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIM commutation event sequence with DMA.\r\n  * @note  This function is mandatory to use the commutation event in order to\r\n  *        update the configuration at each commutation detection on the TRGI input of the Timer,\r\n  *        the typical use of this feature is with the use of another Timer(interface Timer)\r\n  *        configured in Hall sensor interface, this interface Timer will generate the\r\n  *        commutation at its TRGO output (connected to Timer used in this function) each time\r\n  *        the TI1 of the Interface Timer detect a commutation at its input TI1.\r\n  * @note  The user should configure the DMA in his own software, in This function only the COMDE bit is set\r\n  * @param  htim TIM handle\r\n  * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TS_ITR0: Internal trigger 0 selected\r\n  *            @arg TIM_TS_ITR1: Internal trigger 1 selected\r\n  *            @arg TIM_TS_ITR2: Internal trigger 2 selected\r\n  *            @arg TIM_TS_ITR3: Internal trigger 3 selected\r\n  *            @arg TIM_TS_NONE: No trigger is needed\r\n  * @param  CommutationSource the Commutation Event source\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer\r\n  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,\r\n                                                  uint32_t  CommutationSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||\r\n      (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))\r\n  {\r\n    /* Select the Input trigger */\r\n    htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n    htim->Instance->SMCR |= InputTrigger;\r\n  }\r\n\r\n  /* Select the Capture Compare preload feature */\r\n  htim->Instance->CR2 |= TIM_CR2_CCPC;\r\n  /* Select the Commutation event source */\r\n  htim->Instance->CR2 &= ~TIM_CR2_CCUS;\r\n  htim->Instance->CR2 |= CommutationSource;\r\n\r\n  /* Enable the Commutation DMA Request */\r\n  /* Set the DMA Commutation Callback */\r\n  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;\r\n  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback = TIMEx_DMACommutationHalfCplt;\r\n  /* Set the DMA error callback */\r\n  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;\r\n\r\n  /* Disable Commutation Interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);\r\n\r\n  /* Enable the Commutation DMA Request */\r\n  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the TIM in master mode.\r\n  * @param  htim TIM handle.\r\n  * @param  sMasterConfig pointer to a TIM_MasterConfigTypeDef structure that\r\n  *         contains the selected trigger output (TRGO) and the Master/Slave\r\n  *         mode.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,\r\n                                                        TIM_MasterConfigTypeDef *sMasterConfig)\r\n{\r\n  uint32_t tmpcr2;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));\r\n  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));\r\n\r\n  /* Check input state */\r\n  __HAL_LOCK(htim);\r\n\r\n  /* Change the handler state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 = htim->Instance->CR2;\r\n\r\n  /* Get the TIMx SMCR register value */\r\n  tmpsmcr = htim->Instance->SMCR;\r\n\r\n  /* Reset the MMS Bits */\r\n  tmpcr2 &= ~TIM_CR2_MMS;\r\n  /* Select the TRGO source */\r\n  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;\r\n\r\n  /* Update TIMx CR2 */\r\n  htim->Instance->CR2 = tmpcr2;\r\n\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    /* Reset the MSM Bit */\r\n    tmpsmcr &= ~TIM_SMCR_MSM;\r\n    /* Set master mode */\r\n    tmpsmcr |= sMasterConfig->MasterSlaveMode;\r\n\r\n    /* Update TIMx SMCR */\r\n    htim->Instance->SMCR = tmpsmcr;\r\n  }\r\n\r\n  /* Change the htim state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the Break feature, dead time, Lock level, OSSI/OSSR State\r\n  *         and the AOE(automatic output enable).\r\n  * @param  htim TIM handle\r\n  * @param  sBreakDeadTimeConfig pointer to a TIM_ConfigBreakDeadConfigTypeDef structure that\r\n  *         contains the BDTR Register configuration  information for the TIM peripheral.\r\n  * @note   Interrupts can be generated when an active level is detected on the\r\n  *         break input, the break 2 input or the system break input. Break\r\n  *         interrupt can be enabled by calling the @ref __HAL_TIM_ENABLE_IT macro.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,\r\n                                                TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)\r\n{\r\n  /* Keep this variable initialized to 0 as it is used to configure BDTR register */\r\n  uint32_t tmpbdtr = 0U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));\r\n  assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));\r\n  assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));\r\n  assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));\r\n  assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));\r\n  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));\r\n  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));\r\n\r\n  /* Check input state */\r\n  __HAL_LOCK(htim);\r\n\r\n  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,\r\n     the OSSI State, the dead time value and the Automatic Output Enable Bit */\r\n\r\n  /* Set the BDTR bits */\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);\r\n\r\n\r\n  /* Set TIMx_BDTR */\r\n  htim->Instance->BDTR = tmpbdtr;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the TIMx Remapping input capabilities.\r\n  * @param  htim TIM handle.\r\n  * @param  Remap specifies the TIM remapping source.\r\n  *         For TIM1, the parameter can have the following values:                   (**)\r\n  *           @arg TIM_TIM1_TIM3_TRGO:  TIM1 ITR2 is connected to TIM3 TRGO\r\n  *           @arg TIM_TIM1_LPTIM:      TIM1 ITR2 is connected to LPTIM1 output\r\n  *\r\n  *         For TIM2, the parameter can have the following values:                   (**)\r\n  *           @arg TIM_TIM2_TIM8_TRGO:  TIM2 ITR1 is connected to TIM8 TRGO          (*)\r\n  *           @arg TIM_TIM2_ETH_PTP:    TIM2 ITR1 is connected to PTP trigger output (*)\r\n  *           @arg TIM_TIM2_USBFS_SOF:  TIM2 ITR1 is connected to OTG FS SOF\r\n  *           @arg TIM_TIM2_USBHS_SOF:  TIM2 ITR1 is connected to OTG FS SOF\r\n  *\r\n  *         For TIM5, the parameter can have the following values:\r\n  *           @arg TIM_TIM5_GPIO:       TIM5 TI4 is connected to GPIO\r\n  *           @arg TIM_TIM5_LSI:        TIM5 TI4 is connected to LSI\r\n  *           @arg TIM_TIM5_LSE:        TIM5 TI4 is connected to LSE\r\n  *           @arg TIM_TIM5_RTC:        TIM5 TI4 is connected to the RTC wakeup interrupt\r\n  *           @arg TIM_TIM5_TIM3_TRGO:  TIM5 ITR1 is connected to TIM3 TRGO          (*)\r\n  *           @arg TIM_TIM5_LPTIM:      TIM5 ITR1 is connected to LPTIM1 output      (*)\r\n  *\r\n  *         For TIM9, the parameter can have the following values:                   (**)\r\n  *           @arg TIM_TIM9_TIM3_TRGO:  TIM9 ITR1 is connected to TIM3 TRGO\r\n  *           @arg TIM_TIM9_LPTIM:      TIM9 ITR1 is connected to LPTIM1 output\r\n  *\r\n  *         For TIM11, the parameter can have the following values:\r\n  *           @arg TIM_TIM11_GPIO:     TIM11 TI1 is connected to GPIO\r\n  *           @arg TIM_TIM11_HSE:      TIM11 TI1 is connected to HSE_RTC clock\r\n  *           @arg TIM_TIM11_SPDIFRX:  TIM11 TI1 is connected to SPDIFRX_FRAME_SYNC  (*)\r\n  *\r\n  *         (*)  Value not defined in all devices. \\n\r\n  *         (**) Register not available in all devices.\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap)\r\n{\r\n  __HAL_LOCK(htim);\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_TIM_REMAP(htim->Instance, Remap));\r\n\r\n#if defined(LPTIM_OR_TIM1_ITR2_RMP) && defined(LPTIM_OR_TIM5_ITR1_RMP) && defined(LPTIM_OR_TIM9_ITR1_RMP)\r\n  if ((Remap & LPTIM_REMAP_MASK) == LPTIM_REMAP_MASK)\r\n  {\r\n    /* Connect TIMx internal trigger to LPTIM1 output */\r\n    __HAL_RCC_LPTIM1_CLK_ENABLE();\r\n    MODIFY_REG(LPTIM1->OR,\r\n               (LPTIM_OR_TIM1_ITR2_RMP | LPTIM_OR_TIM5_ITR1_RMP | LPTIM_OR_TIM9_ITR1_RMP),\r\n               Remap & ~(LPTIM_REMAP_MASK));\r\n  }\r\n  else\r\n  {\r\n    /* Set the Timer remapping configuration */\r\n    WRITE_REG(htim->Instance->OR, Remap);\r\n  }\r\n#else\r\n  /* Set the Timer remapping configuration */\r\n  WRITE_REG(htim->Instance->OR, Remap);\r\n#endif /* LPTIM_OR_TIM1_ITR2_RMP &&  LPTIM_OR_TIM5_ITR1_RMP && LPTIM_OR_TIM9_ITR1_RMP */\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group6 Extended Callbacks functions\r\n  * @brief    Extended Callbacks functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                    ##### Extended Callbacks functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides Extended TIM callback functions:\r\n    (+) Timer Commutation callback\r\n    (+) Timer Break callback\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Hall commutation changed callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_CommutCallback could be implemented in the user file\r\n   */\r\n}\r\n/**\r\n  * @brief  Hall commutation changed half complete callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_CommutHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_CommutHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Hall Break detection callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_BreakCallback could be implemented in the user file\r\n   */\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group7 Extended Peripheral State functions\r\n  * @brief    Extended Peripheral State functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                ##### Extended Peripheral State functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This subsection permits to get in run-time the status of the peripheral\r\n    and the data flow.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return the TIM Hall Sensor interface handle state.\r\n  * @param  htim TIM Hall Sensor handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return actual state of the TIM complementary channel.\r\n  * @param  htim TIM handle\r\n  * @param  ChannelN TIM Complementary channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  * @retval TIM Complementary channel state\r\n  */\r\nHAL_TIM_ChannelStateTypeDef HAL_TIMEx_GetChannelNState(TIM_HandleTypeDef *htim,  uint32_t ChannelN)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_state;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, ChannelN));\r\n\r\n  channel_state = TIM_CHANNEL_N_STATE_GET(htim, ChannelN);\r\n\r\n  return channel_state;\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private functions ---------------------------------------------------------*/\r\n/** @defgroup TIMEx_Private_Functions TIMEx Private Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  TIM DMA Commutation callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  /* Change the htim state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->CommutationCallback(htim);\r\n#else\r\n  HAL_TIMEx_CommutCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Commutation half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIMEx_DMACommutationHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  /* Change the htim state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->CommutationHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIMEx_CommutHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n\r\n/**\r\n  * @brief  TIM DMA Delay Pulse complete callback (complementary channel).\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMADelayPulseNCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n  HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA error callback (complementary channel)\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMAErrorCCxN(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->ErrorCallback(htim);\r\n#else\r\n  HAL_TIM_ErrorCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  Enables or disables the TIM Capture Compare Channel xN.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  Channel specifies the TIM Channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  * @param  ChannelNState specifies the TIM Channel CCxNE bit new state.\r\n  *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable.\r\n  * @retval None\r\n  */\r\nstatic void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState)\r\n{\r\n  uint32_t tmp;\r\n\r\n  tmp = TIM_CCER_CC1NE << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */\r\n\r\n  /* Reset the CCxNE Bit */\r\n  TIMx->CCER &=  ~tmp;\r\n\r\n  /* Set or reset the CCxNE Bit */\r\n  TIMx->CCER |= (uint32_t)(ChannelNState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_TIM_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_hal_timebase_tim.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Core\\Src","tag":"","groupDisplay":"Other files","code":"/* USER CODE BEGIN Header */\r\n/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_hal_timebase_TIM.c\r\n  * @brief   HAL time base based on the hardware TIM.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2024 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* USER CODE END Header */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_hal.h\"\r\n#include \"stm32f4xx_hal_tim.h\"\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\nTIM_HandleTypeDef        htim5;\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/**\r\n  * @brief  This function configures the TIM5 as a time base source.\r\n  *         The time source is configured  to have 1ms time base with a dedicated\r\n  *         Tick interrupt priority.\r\n  * @note   This function is called  automatically at the beginning of program after\r\n  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().\r\n  * @param  TickPriority: Tick interrupt priority.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)\r\n{\r\n  RCC_ClkInitTypeDef    clkconfig;\r\n  uint32_t              uwTimclock = 0;\r\n  uint32_t              uwPrescalerValue = 0;\r\n  uint32_t              pFLatency;\r\n  /*Configure the TIM5 IRQ priority */\r\n  HAL_NVIC_SetPriority(TIM5_IRQn, TickPriority ,0);\r\n\r\n  /* Enable the TIM5 global Interrupt */\r\n  HAL_NVIC_EnableIRQ(TIM5_IRQn);\r\n\r\n  /* Enable TIM5 clock */\r\n  __HAL_RCC_TIM5_CLK_ENABLE();\r\n\r\n  /* Get clock configuration */\r\n  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);\r\n\r\n  /* Compute TIM5 clock */\r\n  uwTimclock = 2*HAL_RCC_GetPCLK1Freq();\r\n  /* Compute the prescaler value to have TIM5 counter clock equal to 1MHz */\r\n  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);\r\n\r\n  /* Initialize TIM5 */\r\n  htim5.Instance = TIM5;\r\n\r\n  /* Initialize TIMx peripheral as follow:\r\n  + Period = [(TIM5CLK/1000) - 1]. to have a (1/1000) s time base.\r\n  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.\r\n  + ClockDivision = 0\r\n  + Counter direction = Up\r\n  */\r\n  htim5.Init.Period = (1000000U / 1000U) - 1U;\r\n  htim5.Init.Prescaler = uwPrescalerValue;\r\n  htim5.Init.ClockDivision = 0;\r\n  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;\r\n\r\n  if(HAL_TIM_Base_Init(&htim5) == HAL_OK)\r\n  {\r\n    /* Start the TIM time Base generation in interrupt mode */\r\n    return HAL_TIM_Base_Start_IT(&htim5);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_ERROR;\r\n}\r\n\r\n/**\r\n  * @brief  Suspend Tick increment.\r\n  * @note   Disable the tick increment by disabling TIM5 update interrupt.\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid HAL_SuspendTick(void)\r\n{\r\n  /* Disable TIM5 update Interrupt */\r\n  __HAL_TIM_DISABLE_IT(&htim5, TIM_IT_UPDATE);\r\n}\r\n\r\n/**\r\n  * @brief  Resume Tick increment.\r\n  * @note   Enable the tick increment by Enabling TIM5 update interrupt.\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid HAL_ResumeTick(void)\r\n{\r\n  /* Enable TIM5 Update interrupt */\r\n  __HAL_TIM_ENABLE_IT(&htim5, TIM_IT_UPDATE);\r\n}\r\n\r\n"},{"name":"stm32f4xx_it.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Core\\Src","tag":"","groupDisplay":"Other files","code":"/* USER CODE BEGIN Header */\r\n/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_it.c\r\n  * @brief   Interrupt Service Routines.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2024 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* USER CODE END Header */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"main.h\"\r\n#include \"stm32f4xx_it.h\"\r\n/* Private includes ----------------------------------------------------------*/\r\n/* USER CODE BEGIN Includes */\r\n/* USER CODE END Includes */\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* USER CODE BEGIN TD */\r\n\r\n/* USER CODE END TD */\r\n\r\n/* Private define ------------------------------------------------------------*/\r\n/* USER CODE BEGIN PD */\r\n\r\n/* USER CODE END PD */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* USER CODE BEGIN PM */\r\n\r\n/* USER CODE END PM */\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/* USER CODE BEGIN PV */\r\n\r\n/* USER CODE END PV */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* USER CODE BEGIN PFP */\r\n\r\n/* USER CODE END PFP */\r\n\r\n/* Private user code ---------------------------------------------------------*/\r\n/* USER CODE BEGIN 0 */\r\n\r\n/* USER CODE END 0 */\r\n\r\n/* External variables --------------------------------------------------------*/\r\nextern TIM_HandleTypeDef htim5;\r\n\r\n/* USER CODE BEGIN EV */\r\n\r\n/* USER CODE END EV */\r\n\r\n/******************************************************************************/\r\n/*           Cortex-M4 Processor Interruption and Exception Handlers          */\r\n/******************************************************************************/\r\n/**\r\n  * @brief This function handles Non maskable interrupt.\r\n  */\r\n__attribute__((weak)) void NMI_Handler (void)\r\n{\r\n  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */\r\n\r\n  /* USER CODE END NonMaskableInt_IRQn 0 */\r\n  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */\r\n  while (1)\r\n  {\r\n  }\r\n  /* USER CODE END NonMaskableInt_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles Hard fault interrupt.\r\n  */\r\n__attribute__((weak)) void HardFault_Handler (void)\r\n{\r\n  /* USER CODE BEGIN HardFault_IRQn 0 */\r\n\r\n  /* USER CODE END HardFault_IRQn 0 */\r\n  while (1)\r\n  {\r\n    /* USER CODE BEGIN W1_HardFault_IRQn 0 */\r\n    /* USER CODE END W1_HardFault_IRQn 0 */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief This function handles Memory management fault.\r\n  */\r\n__attribute__((weak)) void MemManage_Handler (void)\r\n{\r\n  /* USER CODE BEGIN MemoryManagement_IRQn 0 */\r\n\r\n  /* USER CODE END MemoryManagement_IRQn 0 */\r\n  while (1)\r\n  {\r\n    /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */\r\n    /* USER CODE END W1_MemoryManagement_IRQn 0 */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief This function handles Pre-fetch fault, memory access fault.\r\n  */\r\n__attribute__((weak)) void BusFault_Handler (void)\r\n{\r\n  /* USER CODE BEGIN BusFault_IRQn 0 */\r\n\r\n  /* USER CODE END BusFault_IRQn 0 */\r\n  while (1)\r\n  {\r\n    /* USER CODE BEGIN W1_BusFault_IRQn 0 */\r\n    /* USER CODE END W1_BusFault_IRQn 0 */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief This function handles Undefined instruction or illegal state.\r\n  */\r\n__attribute__((weak)) void UsageFault_Handler (void)\r\n{\r\n  /* USER CODE BEGIN UsageFault_IRQn 0 */\r\n\r\n  /* USER CODE END UsageFault_IRQn 0 */\r\n  while (1)\r\n  {\r\n    /* USER CODE BEGIN W1_UsageFault_IRQn 0 */\r\n    /* USER CODE END W1_UsageFault_IRQn 0 */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief This function handles System service call via SWI instruction.\r\n  */\r\n__attribute__((weak)) void SVC_Handler (void)\r\n{\r\n  /* USER CODE BEGIN SVCall_IRQn 0 */\r\n\r\n  /* USER CODE END SVCall_IRQn 0 */\r\n  /* USER CODE BEGIN SVCall_IRQn 1 */\r\n\r\n  /* USER CODE END SVCall_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles Debug monitor.\r\n  */\r\n__attribute__((weak)) void DebugMon_Handler (void)\r\n{\r\n  /* USER CODE BEGIN DebugMonitor_IRQn 0 */\r\n\r\n  /* USER CODE END DebugMonitor_IRQn 0 */\r\n  /* USER CODE BEGIN DebugMonitor_IRQn 1 */\r\n\r\n  /* USER CODE END DebugMonitor_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles Pendable request for system service.\r\n  */\r\n__attribute__((weak)) void PendSV_Handler (void)\r\n{\r\n  /* USER CODE BEGIN PendSV_IRQn 0 */\r\n\r\n  /* USER CODE END PendSV_IRQn 0 */\r\n  /* USER CODE BEGIN PendSV_IRQn 1 */\r\n\r\n  /* USER CODE END PendSV_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles System tick timer.\r\n  */\r\n__attribute__((weak)) void SysTick_Handler (void)\r\n{\r\n  /* USER CODE BEGIN SysTick_IRQn 0 */\r\n\r\n  /* USER CODE END SysTick_IRQn 0 */\r\n\r\n  /* USER CODE BEGIN SysTick_IRQn 1 */\r\n\r\n  /* USER CODE END SysTick_IRQn 1 */\r\n}\r\n\r\n/******************************************************************************/\r\n/* STM32F4xx Peripheral Interrupt Handlers                                    */\r\n/* Add here the Interrupt Handlers for the used peripherals.                  */\r\n/* For the available peripheral interrupt handler names,                      */\r\n/* please refer to the startup file (startup_stm32f4xx.s).                    */\r\n/******************************************************************************/\r\n\r\n/**\r\n  * @brief This function handles DMA1 stream5 global interrupt.\r\n  */\r\n__attribute__((weak)) void DMA1_Stream5_IRQHandler (void)\r\n{\r\n  /* USER CODE BEGIN DMA1_Stream5_IRQn 0 */\r\n\r\n  /* USER CODE END DMA1_Stream5_IRQn 0 */\r\n\r\n  /* USER CODE BEGIN DMA1_Stream5_IRQn 1 */\r\n\r\n  /* USER CODE END DMA1_Stream5_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles TIM5 global interrupt.\r\n  */\r\n__attribute__((weak)) void TIM5_IRQHandler (void)\r\n{\r\n  /* USER CODE BEGIN TIM5_IRQn 0 */\r\n\r\n  /* USER CODE END TIM5_IRQn 0 */\r\n  HAL_TIM_IRQHandler(&htim5);\r\n  /* USER CODE BEGIN TIM5_IRQn 1 */\r\n\r\n  /* USER CODE END TIM5_IRQn 1 */\r\n}\r\n\r\n/* USER CODE BEGIN 1 */\r\n\r\n/* USER CODE END 1 */\r\n\r\n"},{"name":"stm32f4xx_ll_adc.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_ll_adc.c\r\n  * @author  MCD Application Team\r\n  * @brief   ADC LL module driver\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_ll_adc.h\"\r\n#include \"stm32f4xx_ll_bus.h\"\r\n\r\n#ifdef  USE_FULL_ASSERT\r\n  #include \"stm32_assert.h\"\r\n#else\r\n  #define assert_param(expr) ((void)0U)\r\n#endif\r\n\r\n/** @addtogroup STM32F4xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined (ADC1) || defined (ADC2) || defined (ADC3)\r\n\r\n/** @addtogroup ADC_LL ADC\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n\r\n/** @addtogroup ADC_LL_Private_Macros\r\n  * @{\r\n  */\r\n\r\n/* Check of parameters for configuration of ADC hierarchical scope:           */\r\n/* common to several ADC instances.                                           */\r\n#define IS_LL_ADC_COMMON_CLOCK(__CLOCK__)                                      \\\r\n  (   ((__CLOCK__) == LL_ADC_CLOCK_SYNC_PCLK_DIV2)                             \\\r\n   || ((__CLOCK__) == LL_ADC_CLOCK_SYNC_PCLK_DIV4)                             \\\r\n   || ((__CLOCK__) == LL_ADC_CLOCK_SYNC_PCLK_DIV6)                             \\\r\n   || ((__CLOCK__) == LL_ADC_CLOCK_SYNC_PCLK_DIV8)                             \\\r\n  )\r\n\r\n/* Check of parameters for configuration of ADC hierarchical scope:           */\r\n/* ADC instance.                                                              */\r\n#define IS_LL_ADC_RESOLUTION(__RESOLUTION__)                                   \\\r\n  (   ((__RESOLUTION__) == LL_ADC_RESOLUTION_12B)                              \\\r\n   || ((__RESOLUTION__) == LL_ADC_RESOLUTION_10B)                              \\\r\n   || ((__RESOLUTION__) == LL_ADC_RESOLUTION_8B)                               \\\r\n   || ((__RESOLUTION__) == LL_ADC_RESOLUTION_6B)                               \\\r\n  )\r\n\r\n#define IS_LL_ADC_DATA_ALIGN(__DATA_ALIGN__)                                   \\\r\n  (   ((__DATA_ALIGN__) == LL_ADC_DATA_ALIGN_RIGHT)                            \\\r\n   || ((__DATA_ALIGN__) == LL_ADC_DATA_ALIGN_LEFT)                             \\\r\n  )\r\n\r\n#define IS_LL_ADC_SCAN_SELECTION(__SCAN_SELECTION__)                           \\\r\n  (   ((__SCAN_SELECTION__) == LL_ADC_SEQ_SCAN_DISABLE)                        \\\r\n   || ((__SCAN_SELECTION__) == LL_ADC_SEQ_SCAN_ENABLE)                         \\\r\n  )\r\n\r\n#define IS_LL_ADC_SEQ_SCAN_MODE(__SEQ_SCAN_MODE__)                             \\\r\n  (   ((__SCAN_MODE__) == LL_ADC_SEQ_SCAN_DISABLE)                             \\\r\n   || ((__SCAN_MODE__) == LL_ADC_SEQ_SCAN_ENABLE)                              \\\r\n  )\r\n\r\n/* Check of parameters for configuration of ADC hierarchical scope:           */\r\n/* ADC group regular                                                          */\r\n#define IS_LL_ADC_REG_TRIG_SOURCE(__REG_TRIG_SOURCE__)                         \\\r\n  (   ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                      \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH1)                  \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH2)                  \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH3)                  \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH2)                  \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH3)                  \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH4)                  \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_TRGO)                 \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_CH1)                  \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_TRGO)                 \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_CH4)                  \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM5_CH1)                  \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM5_CH2)                  \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM5_CH3)                  \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_CH1)                  \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_TRGO)                 \\\r\n   || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_EXTI_LINE11)               \\\r\n  )\r\n#define IS_LL_ADC_REG_CONTINUOUS_MODE(__REG_CONTINUOUS_MODE__)                 \\\r\n  (   ((__REG_CONTINUOUS_MODE__) == LL_ADC_REG_CONV_SINGLE)                    \\\r\n   || ((__REG_CONTINUOUS_MODE__) == LL_ADC_REG_CONV_CONTINUOUS)                \\\r\n  )\r\n\r\n#define IS_LL_ADC_REG_DMA_TRANSFER(__REG_DMA_TRANSFER__)                       \\\r\n  (   ((__REG_DMA_TRANSFER__) == LL_ADC_REG_DMA_TRANSFER_NONE)                 \\\r\n   || ((__REG_DMA_TRANSFER__) == LL_ADC_REG_DMA_TRANSFER_LIMITED)              \\\r\n   || ((__REG_DMA_TRANSFER__) == LL_ADC_REG_DMA_TRANSFER_UNLIMITED)            \\\r\n  )\r\n\r\n#define IS_LL_ADC_REG_FLAG_EOC_SELECTION(__REG_FLAG_EOC_SELECTION__)           \\\r\n  (   ((__REG_FLAG_EOC_SELECTION__) == LL_ADC_REG_FLAG_EOC_SEQUENCE_CONV)      \\\r\n   || ((__REG_FLAG_EOC_SELECTION__) == LL_ADC_REG_FLAG_EOC_UNITARY_CONV)       \\\r\n  )\r\n\r\n#define IS_LL_ADC_REG_SEQ_SCAN_LENGTH(__REG_SEQ_SCAN_LENGTH__)                 \\\r\n  (   ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_DISABLE)               \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS)         \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS)         \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS)         \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS)         \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS)         \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS)         \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS)         \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS)         \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS)        \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS)        \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS)        \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS)        \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS)        \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS)        \\\r\n   || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS)        \\\r\n  )\r\n\r\n#define IS_LL_ADC_REG_SEQ_SCAN_DISCONT_MODE(__REG_SEQ_DISCONT_MODE__)          \\\r\n  (   ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_DISABLE)           \\\r\n   || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_1RANK)             \\\r\n   || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_2RANKS)            \\\r\n   || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_3RANKS)            \\\r\n   || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_4RANKS)            \\\r\n   || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_5RANKS)            \\\r\n   || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_6RANKS)            \\\r\n   || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_7RANKS)            \\\r\n   || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_8RANKS)            \\\r\n  )\r\n\r\n/* Check of parameters for configuration of ADC hierarchical scope:           */\r\n/* ADC group injected                                                         */\r\n#define IS_LL_ADC_INJ_TRIG_SOURCE(__INJ_TRIG_SOURCE__)                         \\\r\n  (   ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_SOFTWARE)                      \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH4)                  \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO)                 \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_CH1)                  \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_TRGO)                 \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH2)                  \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH4)                  \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_CH1)                  \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_CH2)                  \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_CH3)                  \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_TRGO)                 \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM5_CH4)                  \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM5_TRGO)                 \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_CH2)                  \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_CH3)                  \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_CH4)                  \\\r\n   || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_EXTI_LINE15)               \\\r\n  )\r\n\r\n#define IS_LL_ADC_INJ_TRIG_EXT_EDGE(__INJ_TRIG_EXT_EDGE__)                     \\\r\n  (   ((__INJ_TRIG_EXT_EDGE__) == LL_ADC_INJ_TRIG_EXT_RISING)                  \\\r\n   || ((__INJ_TRIG_EXT_EDGE__) == LL_ADC_INJ_TRIG_EXT_FALLING)                 \\\r\n   || ((__INJ_TRIG_EXT_EDGE__) == LL_ADC_INJ_TRIG_EXT_RISINGFALLING)           \\\r\n  )\r\n\r\n#define IS_LL_ADC_INJ_TRIG_AUTO(__INJ_TRIG_AUTO__)                             \\\r\n  (   ((__INJ_TRIG_AUTO__) == LL_ADC_INJ_TRIG_INDEPENDENT)                     \\\r\n   || ((__INJ_TRIG_AUTO__) == LL_ADC_INJ_TRIG_FROM_GRP_REGULAR)                \\\r\n  )\r\n\r\n#define IS_LL_ADC_INJ_SEQ_SCAN_LENGTH(__INJ_SEQ_SCAN_LENGTH__)                 \\\r\n  (   ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_DISABLE)               \\\r\n   || ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS)         \\\r\n   || ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_ENABLE_3RANKS)         \\\r\n   || ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_ENABLE_4RANKS)         \\\r\n  )\r\n\r\n#define IS_LL_ADC_INJ_SEQ_SCAN_DISCONT_MODE(__INJ_SEQ_DISCONT_MODE__)          \\\r\n  (   ((__INJ_SEQ_DISCONT_MODE__) == LL_ADC_INJ_SEQ_DISCONT_DISABLE)           \\\r\n   || ((__INJ_SEQ_DISCONT_MODE__) == LL_ADC_INJ_SEQ_DISCONT_1RANK)             \\\r\n  )\r\n\r\n#if defined(ADC_MULTIMODE_SUPPORT)\r\n/* Check of parameters for configuration of ADC hierarchical scope:           */\r\n/* multimode.                                                                 */\r\n#if defined(ADC3)\r\n#define IS_LL_ADC_MULTI_MODE(__MULTI_MODE__)                                   \\\r\n  (   ((__MULTI_MODE__) == LL_ADC_MULTI_INDEPENDENT)                           \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_SIMULT)                       \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_INTERL)                       \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_INJ_SIMULT)                       \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_INJ_ALTERN)                       \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM)                  \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT)                  \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM)                  \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_TRIPLE_REG_SIM_INJ_SIM)                \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_TRIPLE_REG_SIM_INJ_ALT)                \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_TRIPLE_INJ_SIMULT)                     \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_TRIPLE_REG_SIMULT)                     \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_TRIPLE_REG_INTERL)                     \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_TRIPLE_INJ_ALTERN)                     \\\r\n  )\r\n#else\r\n#define IS_LL_ADC_MULTI_MODE(__MULTI_MODE__)                                   \\\r\n  (   ((__MULTI_MODE__) == LL_ADC_MULTI_INDEPENDENT)                           \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_SIMULT)                       \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_INTERL)                       \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_INJ_SIMULT)                       \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_INJ_ALTERN)                       \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM)                  \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT)                  \\\r\n   || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM)                  \\\r\n  )\r\n#endif\r\n\r\n#define IS_LL_ADC_MULTI_DMA_TRANSFER(__MULTI_DMA_TRANSFER__)                   \\\r\n  (   ((__MULTI_DMA_TRANSFER__) == LL_ADC_MULTI_REG_DMA_EACH_ADC)              \\\r\n   || ((__MULTI_DMA_TRANSFER__) == LL_ADC_MULTI_REG_DMA_LIMIT_1)               \\\r\n   || ((__MULTI_DMA_TRANSFER__) == LL_ADC_MULTI_REG_DMA_LIMIT_2)               \\\r\n   || ((__MULTI_DMA_TRANSFER__) == LL_ADC_MULTI_REG_DMA_LIMIT_3)               \\\r\n   || ((__MULTI_DMA_TRANSFER__) == LL_ADC_MULTI_REG_DMA_UNLMT_1)               \\\r\n   || ((__MULTI_DMA_TRANSFER__) == LL_ADC_MULTI_REG_DMA_UNLMT_2)               \\\r\n   || ((__MULTI_DMA_TRANSFER__) == LL_ADC_MULTI_REG_DMA_UNLMT_3)               \\\r\n  )\r\n\r\n#define IS_LL_ADC_MULTI_TWOSMP_DELAY(__MULTI_TWOSMP_DELAY__)                   \\\r\n  (   ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_5CYCLES)          \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_6CYCLES)          \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_7CYCLES)          \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_8CYCLES)          \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_9CYCLES)          \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_10CYCLES)         \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_11CYCLES)         \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_12CYCLES)         \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_13CYCLES)         \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_14CYCLES)         \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_15CYCLES)         \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_16CYCLES)         \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_17CYCLES)         \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_18CYCLES)         \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_19CYCLES)         \\\r\n   || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_20CYCLES)         \\\r\n  )\r\n\r\n#define IS_LL_ADC_MULTI_MASTER_SLAVE(__MULTI_MASTER_SLAVE__)                   \\\r\n  (   ((__MULTI_MASTER_SLAVE__) == LL_ADC_MULTI_MASTER)                        \\\r\n   || ((__MULTI_MASTER_SLAVE__) == LL_ADC_MULTI_SLAVE)                         \\\r\n   || ((__MULTI_MASTER_SLAVE__) == LL_ADC_MULTI_MASTER_SLAVE)                  \\\r\n  )\r\n\r\n#endif /* ADC_MULTIMODE_SUPPORT */\r\n/**\r\n  * @}\r\n  */\r\n\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup ADC_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup ADC_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  De-initialize registers of all ADC instances belonging to\r\n  *         the same ADC common instance to their default reset values.\r\n  * @param  ADCxy_COMMON ADC common instance\r\n  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: ADC common registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nErrorStatus LL_ADC_CommonDeInit(ADC_Common_TypeDef *ADCxy_COMMON)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_ADC_COMMON_INSTANCE(ADCxy_COMMON));\r\n  \r\n\r\n  /* Force reset of ADC clock (core clock) */\r\n  LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_ADC);\r\n  \r\n  /* Release reset of ADC clock (core clock) */\r\n  LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_ADC);\r\n  \r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Initialize some features of ADC common parameters\r\n  *         (all ADC instances belonging to the same ADC common instance)\r\n  *         and multimode (for devices with several ADC instances available).\r\n  * @note   The setting of ADC common parameters is conditioned to\r\n  *         ADC instances state:\r\n  *         All ADC instances belonging to the same ADC common instance\r\n  *         must be disabled.\r\n  * @param  ADCxy_COMMON ADC common instance\r\n  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )\r\n  * @param  ADC_CommonInitStruct Pointer to a @ref LL_ADC_CommonInitTypeDef structure\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: ADC common registers are initialized\r\n  *          - ERROR: ADC common registers are not initialized\r\n  */\r\nErrorStatus LL_ADC_CommonInit(ADC_Common_TypeDef *ADCxy_COMMON, LL_ADC_CommonInitTypeDef *ADC_CommonInitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_ADC_COMMON_INSTANCE(ADCxy_COMMON));\r\n  assert_param(IS_LL_ADC_COMMON_CLOCK(ADC_CommonInitStruct->CommonClock));\r\n  \r\n#if defined(ADC_MULTIMODE_SUPPORT)\r\n  assert_param(IS_LL_ADC_MULTI_MODE(ADC_CommonInitStruct->Multimode));\r\n  if(ADC_CommonInitStruct->Multimode != LL_ADC_MULTI_INDEPENDENT)\r\n  {\r\n    assert_param(IS_LL_ADC_MULTI_DMA_TRANSFER(ADC_CommonInitStruct->MultiDMATransfer));\r\n    assert_param(IS_LL_ADC_MULTI_TWOSMP_DELAY(ADC_CommonInitStruct->MultiTwoSamplingDelay));\r\n  }\r\n#endif /* ADC_MULTIMODE_SUPPORT */\r\n\r\n  /* Note: Hardware constraint (refer to description of functions             */\r\n  /*       \"LL_ADC_SetCommonXXX()\" and \"LL_ADC_SetMultiXXX()\"):               */\r\n  /*       On this STM32 series, setting of these features is conditioned to  */\r\n  /*       ADC state:                                                         */\r\n  /*       All ADC instances of the ADC common group must be disabled.        */\r\n  if(__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(ADCxy_COMMON) == 0UL)\r\n  {\r\n    /* Configuration of ADC hierarchical scope:                               */\r\n    /*  - common to several ADC                                               */\r\n    /*    (all ADC instances belonging to the same ADC common instance)       */\r\n    /*    - Set ADC clock (conversion clock)                                  */\r\n    /*  - multimode (if several ADC instances available on the                */\r\n    /*    selected device)                                                    */\r\n    /*    - Set ADC multimode configuration                                   */\r\n    /*    - Set ADC multimode DMA transfer                                    */\r\n    /*    - Set ADC multimode: delay between 2 sampling phases                */\r\n#if defined(ADC_MULTIMODE_SUPPORT)\r\n    if(ADC_CommonInitStruct->Multimode != LL_ADC_MULTI_INDEPENDENT)\r\n    {\r\n      MODIFY_REG(ADCxy_COMMON->CCR,\r\n                   ADC_CCR_ADCPRE\r\n                 | ADC_CCR_MULTI\r\n                 | ADC_CCR_DMA\r\n                 | ADC_CCR_DDS\r\n                 | ADC_CCR_DELAY\r\n                ,\r\n                   ADC_CommonInitStruct->CommonClock\r\n                 | ADC_CommonInitStruct->Multimode\r\n                 | ADC_CommonInitStruct->MultiDMATransfer\r\n                 | ADC_CommonInitStruct->MultiTwoSamplingDelay\r\n                );\r\n    }\r\n    else\r\n    {\r\n      MODIFY_REG(ADCxy_COMMON->CCR,\r\n                   ADC_CCR_ADCPRE\r\n                 | ADC_CCR_MULTI\r\n                 | ADC_CCR_DMA\r\n                 | ADC_CCR_DDS\r\n                 | ADC_CCR_DELAY\r\n                ,\r\n                   ADC_CommonInitStruct->CommonClock\r\n                 | LL_ADC_MULTI_INDEPENDENT\r\n                );\r\n    }\r\n#else\r\n    LL_ADC_SetCommonClock(ADCxy_COMMON, ADC_CommonInitStruct->CommonClock);\r\n#endif\r\n  }\r\n  else\r\n  {\r\n    /* Initialization error: One or several ADC instances belonging to        */\r\n    /* the same ADC common instance are not disabled.                         */\r\n    status = ERROR;\r\n  }\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Set each @ref LL_ADC_CommonInitTypeDef field to default value.\r\n  * @param  ADC_CommonInitStruct Pointer to a @ref LL_ADC_CommonInitTypeDef structure\r\n  *                              whose fields will be set to default values.\r\n  * @retval None\r\n  */\r\nvoid LL_ADC_CommonStructInit(LL_ADC_CommonInitTypeDef *ADC_CommonInitStruct)\r\n{\r\n  /* Set ADC_CommonInitStruct fields to default values */\r\n  /* Set fields of ADC common */\r\n  /* (all ADC instances belonging to the same ADC common instance) */\r\n  ADC_CommonInitStruct->CommonClock = LL_ADC_CLOCK_SYNC_PCLK_DIV2;\r\n  \r\n#if defined(ADC_MULTIMODE_SUPPORT)\r\n  /* Set fields of ADC multimode */\r\n  ADC_CommonInitStruct->Multimode             = LL_ADC_MULTI_INDEPENDENT;\r\n    ADC_CommonInitStruct->MultiDMATransfer      = LL_ADC_MULTI_REG_DMA_EACH_ADC;\r\n  ADC_CommonInitStruct->MultiTwoSamplingDelay = LL_ADC_MULTI_TWOSMP_DELAY_5CYCLES;\r\n#endif /* ADC_MULTIMODE_SUPPORT */\r\n}\r\n\r\n/**\r\n  * @brief  De-initialize registers of the selected ADC instance\r\n  *         to their default reset values.\r\n  * @note   To reset all ADC instances quickly (perform a hard reset),\r\n  *         use function @ref LL_ADC_CommonDeInit().\r\n  * @param  ADCx ADC instance\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: ADC registers are de-initialized\r\n  *          - ERROR: ADC registers are not de-initialized\r\n  */\r\nErrorStatus LL_ADC_DeInit(ADC_TypeDef *ADCx)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_ADC_ALL_INSTANCE(ADCx));\r\n  \r\n  /* Disable ADC instance if not already disabled.                            */\r\n  if(LL_ADC_IsEnabled(ADCx) == 1UL)\r\n  {\r\n    /* Set ADC group regular trigger source to SW start to ensure to not      */\r\n    /* have an external trigger event occurring during the conversion stop    */\r\n    /* ADC disable process.                                                   */\r\n    LL_ADC_REG_SetTriggerSource(ADCx, LL_ADC_REG_TRIG_SOFTWARE);\r\n    \r\n    /* Set ADC group injected trigger source to SW start to ensure to not     */\r\n    /* have an external trigger event occurring during the conversion stop    */\r\n    /* ADC disable process.                                                   */\r\n    LL_ADC_INJ_SetTriggerSource(ADCx, LL_ADC_INJ_TRIG_SOFTWARE);\r\n    \r\n    /* Disable the ADC instance */\r\n    LL_ADC_Disable(ADCx);\r\n  }\r\n  \r\n  /* Check whether ADC state is compliant with expected state */\r\n  /* (hardware requirements of bits state to reset registers below) */\r\n  if(READ_BIT(ADCx->CR2, ADC_CR2_ADON) == 0UL)\r\n  {\r\n    /* ========== Reset ADC registers ========== */\r\n    /* Reset register SR */\r\n    CLEAR_BIT(ADCx->SR,\r\n              (  LL_ADC_FLAG_STRT\r\n               | LL_ADC_FLAG_JSTRT\r\n               | LL_ADC_FLAG_EOCS\r\n               | LL_ADC_FLAG_OVR\r\n               | LL_ADC_FLAG_JEOS\r\n               | LL_ADC_FLAG_AWD1 )\r\n             );\r\n    \r\n    /* Reset register CR1 */\r\n    CLEAR_BIT(ADCx->CR1,\r\n              (  ADC_CR1_OVRIE   | ADC_CR1_RES     | ADC_CR1_AWDEN\r\n               | ADC_CR1_JAWDEN\r\n               | ADC_CR1_DISCNUM | ADC_CR1_JDISCEN | ADC_CR1_DISCEN\r\n               | ADC_CR1_JAUTO   | ADC_CR1_AWDSGL  | ADC_CR1_SCAN\r\n               | ADC_CR1_JEOCIE  | ADC_CR1_AWDIE   | ADC_CR1_EOCIE\r\n               | ADC_CR1_AWDCH                                     )\r\n             );\r\n    \r\n    /* Reset register CR2 */\r\n    CLEAR_BIT(ADCx->CR2,\r\n              (  ADC_CR2_SWSTART  | ADC_CR2_EXTEN  | ADC_CR2_EXTSEL\r\n               | ADC_CR2_JSWSTART | ADC_CR2_JEXTEN | ADC_CR2_JEXTSEL\r\n               | ADC_CR2_ALIGN    | ADC_CR2_EOCS\r\n               | ADC_CR2_DDS      | ADC_CR2_DMA\r\n               | ADC_CR2_CONT     | ADC_CR2_ADON                    )\r\n             );\r\n    \r\n    /* Reset register SMPR1 */\r\n    CLEAR_BIT(ADCx->SMPR1,\r\n              (  ADC_SMPR1_SMP18 | ADC_SMPR1_SMP17 | ADC_SMPR1_SMP16\r\n               | ADC_SMPR1_SMP15 | ADC_SMPR1_SMP14 | ADC_SMPR1_SMP13\r\n               | ADC_SMPR1_SMP12 | ADC_SMPR1_SMP11 | ADC_SMPR1_SMP10)\r\n             );\r\n    \r\n    /* Reset register SMPR2 */\r\n    CLEAR_BIT(ADCx->SMPR2,\r\n              (  ADC_SMPR2_SMP9\r\n               | ADC_SMPR2_SMP8 | ADC_SMPR2_SMP7 | ADC_SMPR2_SMP6\r\n               | ADC_SMPR2_SMP5 | ADC_SMPR2_SMP4 | ADC_SMPR2_SMP3\r\n               | ADC_SMPR2_SMP2 | ADC_SMPR2_SMP1 | ADC_SMPR2_SMP0)\r\n             );\r\n    \r\n    /* Reset register JOFR1 */\r\n    CLEAR_BIT(ADCx->JOFR1, ADC_JOFR1_JOFFSET1);\r\n    /* Reset register JOFR2 */\r\n    CLEAR_BIT(ADCx->JOFR2, ADC_JOFR2_JOFFSET2);\r\n    /* Reset register JOFR3 */\r\n    CLEAR_BIT(ADCx->JOFR3, ADC_JOFR3_JOFFSET3);\r\n    /* Reset register JOFR4 */\r\n    CLEAR_BIT(ADCx->JOFR4, ADC_JOFR4_JOFFSET4);\r\n    \r\n    /* Reset register HTR */\r\n    SET_BIT(ADCx->HTR, ADC_HTR_HT);\r\n    /* Reset register LTR */\r\n    CLEAR_BIT(ADCx->LTR, ADC_LTR_LT);\r\n    \r\n    /* Reset register SQR1 */\r\n    CLEAR_BIT(ADCx->SQR1,\r\n              (  ADC_SQR1_L\r\n               | ADC_SQR1_SQ16\r\n               | ADC_SQR1_SQ15 | ADC_SQR1_SQ14 | ADC_SQR1_SQ13)\r\n             );\r\n             \r\n    /* Reset register SQR2 */\r\n    CLEAR_BIT(ADCx->SQR2,\r\n              (  ADC_SQR2_SQ12 | ADC_SQR2_SQ11 | ADC_SQR2_SQ10\r\n               | ADC_SQR2_SQ9 | ADC_SQR2_SQ8 | ADC_SQR2_SQ7)\r\n             );\r\n\r\n    /* Reset register SQR3 */\r\n    CLEAR_BIT(ADCx->SQR3,\r\n              (  ADC_SQR3_SQ6 | ADC_SQR3_SQ5 | ADC_SQR3_SQ4\r\n               | ADC_SQR3_SQ3 | ADC_SQR3_SQ2 | ADC_SQR3_SQ1)\r\n             );\r\n\r\n    /* Reset register JSQR */\r\n    CLEAR_BIT(ADCx->JSQR,\r\n              (  ADC_JSQR_JL\r\n               | ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3\r\n               | ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  )\r\n             );\r\n    \r\n    /* Reset register DR */\r\n    /* bits in access mode read only, no direct reset applicable */\r\n    \r\n    /* Reset registers JDR1, JDR2, JDR3, JDR4 */\r\n    /* bits in access mode read only, no direct reset applicable */\r\n    \r\n    /* Reset register CCR */\r\n    CLEAR_BIT(ADC->CCR, ADC_CCR_TSVREFE | ADC_CCR_ADCPRE);\r\n  }\r\n  \r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Initialize some features of ADC instance.\r\n  * @note   These parameters have an impact on ADC scope: ADC instance.\r\n  *         Affects both group regular and group injected (availability\r\n  *         of ADC group injected depends on STM32 families).\r\n  *         Refer to corresponding unitary functions into\r\n  *         @ref ADC_LL_EF_Configuration_ADC_Instance .\r\n  * @note   The setting of these parameters by function @ref LL_ADC_Init()\r\n  *         is conditioned to ADC state:\r\n  *         ADC instance must be disabled.\r\n  *         This condition is applied to all ADC features, for efficiency\r\n  *         and compatibility over all STM32 families. However, the different\r\n  *         features can be set under different ADC state conditions\r\n  *         (setting possible with ADC enabled without conversion on going,\r\n  *         ADC enabled with conversion on going, ...)\r\n  *         Each feature can be updated afterwards with a unitary function\r\n  *         and potentially with ADC in a different state than disabled,\r\n  *         refer to description of each function for setting\r\n  *         conditioned to ADC state.\r\n  * @note   After using this function, some other features must be configured\r\n  *         using LL unitary functions.\r\n  *         The minimum configuration remaining to be done is:\r\n  *          - Set ADC group regular or group injected sequencer:\r\n  *            map channel on the selected sequencer rank.\r\n  *            Refer to function @ref LL_ADC_REG_SetSequencerRanks().\r\n  *          - Set ADC channel sampling time\r\n  *            Refer to function LL_ADC_SetChannelSamplingTime();\r\n  * @param  ADCx ADC instance\r\n  * @param  ADC_InitStruct Pointer to a @ref LL_ADC_REG_InitTypeDef structure\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: ADC registers are initialized\r\n  *          - ERROR: ADC registers are not initialized\r\n  */\r\nErrorStatus LL_ADC_Init(ADC_TypeDef *ADCx, LL_ADC_InitTypeDef *ADC_InitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_ADC_ALL_INSTANCE(ADCx));\r\n  \r\n  assert_param(IS_LL_ADC_RESOLUTION(ADC_InitStruct->Resolution));\r\n  assert_param(IS_LL_ADC_DATA_ALIGN(ADC_InitStruct->DataAlignment));\r\n  assert_param(IS_LL_ADC_SCAN_SELECTION(ADC_InitStruct->SequencersScanMode));\r\n  \r\n  /* Note: Hardware constraint (refer to description of this function):       */\r\n  /*       ADC instance must be disabled.                                     */\r\n  if(LL_ADC_IsEnabled(ADCx) == 0UL)\r\n  {\r\n    /* Configuration of ADC hierarchical scope:                               */\r\n    /*  - ADC instance                                                        */\r\n    /*    - Set ADC data resolution                                           */\r\n    /*    - Set ADC conversion data alignment                                 */\r\n    MODIFY_REG(ADCx->CR1,\r\n                 ADC_CR1_RES\r\n               | ADC_CR1_SCAN\r\n              ,\r\n                 ADC_InitStruct->Resolution\r\n               | ADC_InitStruct->SequencersScanMode\r\n              );\r\n    \r\n    MODIFY_REG(ADCx->CR2,\r\n                 ADC_CR2_ALIGN\r\n              ,\r\n                 ADC_InitStruct->DataAlignment\r\n              );\r\n\r\n  }\r\n  else\r\n  {\r\n    /* Initialization error: ADC instance is not disabled. */\r\n    status = ERROR;\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Set each @ref LL_ADC_InitTypeDef field to default value.\r\n  * @param  ADC_InitStruct Pointer to a @ref LL_ADC_InitTypeDef structure\r\n  *                        whose fields will be set to default values.\r\n  * @retval None\r\n  */\r\nvoid LL_ADC_StructInit(LL_ADC_InitTypeDef *ADC_InitStruct)\r\n{\r\n  /* Set ADC_InitStruct fields to default values */\r\n  /* Set fields of ADC instance */\r\n  ADC_InitStruct->Resolution    = LL_ADC_RESOLUTION_12B;\r\n  ADC_InitStruct->DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;\r\n  \r\n  /* Enable scan mode to have a generic behavior with ADC of other            */\r\n  /* STM32 families, without this setting available:                          */\r\n  /* ADC group regular sequencer and ADC group injected sequencer depend      */\r\n  /* only of their own configuration.                                         */\r\n  ADC_InitStruct->SequencersScanMode      = LL_ADC_SEQ_SCAN_ENABLE;\r\n  \r\n}\r\n\r\n/**\r\n  * @brief  Initialize some features of ADC group regular.\r\n  * @note   These parameters have an impact on ADC scope: ADC group regular.\r\n  *         Refer to corresponding unitary functions into\r\n  *         @ref ADC_LL_EF_Configuration_ADC_Group_Regular\r\n  *         (functions with prefix \"REG\").\r\n  * @note   The setting of these parameters by function @ref LL_ADC_Init()\r\n  *         is conditioned to ADC state:\r\n  *         ADC instance must be disabled.\r\n  *         This condition is applied to all ADC features, for efficiency\r\n  *         and compatibility over all STM32 families. However, the different\r\n  *         features can be set under different ADC state conditions\r\n  *         (setting possible with ADC enabled without conversion on going,\r\n  *         ADC enabled with conversion on going, ...)\r\n  *         Each feature can be updated afterwards with a unitary function\r\n  *         and potentially with ADC in a different state than disabled,\r\n  *         refer to description of each function for setting\r\n  *         conditioned to ADC state.\r\n  * @note   After using this function, other features must be configured\r\n  *         using LL unitary functions.\r\n  *         The minimum configuration remaining to be done is:\r\n  *          - Set ADC group regular or group injected sequencer:\r\n  *            map channel on the selected sequencer rank.\r\n  *            Refer to function @ref LL_ADC_REG_SetSequencerRanks().\r\n  *          - Set ADC channel sampling time\r\n  *            Refer to function LL_ADC_SetChannelSamplingTime();\r\n  * @param  ADCx ADC instance\r\n  * @param  ADC_REG_InitStruct Pointer to a @ref LL_ADC_REG_InitTypeDef structure\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: ADC registers are initialized\r\n  *          - ERROR: ADC registers are not initialized\r\n  */\r\nErrorStatus LL_ADC_REG_Init(ADC_TypeDef *ADCx, LL_ADC_REG_InitTypeDef *ADC_REG_InitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_ADC_ALL_INSTANCE(ADCx));\r\n  assert_param(IS_LL_ADC_REG_TRIG_SOURCE(ADC_REG_InitStruct->TriggerSource));\r\n  assert_param(IS_LL_ADC_REG_SEQ_SCAN_LENGTH(ADC_REG_InitStruct->SequencerLength));\r\n  if(ADC_REG_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)\r\n  {\r\n    assert_param(IS_LL_ADC_REG_SEQ_SCAN_DISCONT_MODE(ADC_REG_InitStruct->SequencerDiscont));\r\n  }\r\n  assert_param(IS_LL_ADC_REG_CONTINUOUS_MODE(ADC_REG_InitStruct->ContinuousMode));\r\n  assert_param(IS_LL_ADC_REG_DMA_TRANSFER(ADC_REG_InitStruct->DMATransfer));\r\n  \r\n  /* ADC group regular continuous mode and discontinuous mode                 */\r\n  /* can not be enabled simultenaeously                                       */\r\n  assert_param((ADC_REG_InitStruct->ContinuousMode == LL_ADC_REG_CONV_SINGLE)\r\n               || (ADC_REG_InitStruct->SequencerDiscont == LL_ADC_REG_SEQ_DISCONT_DISABLE));\r\n  \r\n  /* Note: Hardware constraint (refer to description of this function):       */\r\n  /*       ADC instance must be disabled.                                     */\r\n  if(LL_ADC_IsEnabled(ADCx) == 0UL)\r\n  {\r\n    /* Configuration of ADC hierarchical scope:                               */\r\n    /*  - ADC group regular                                                   */\r\n    /*    - Set ADC group regular trigger source                              */\r\n    /*    - Set ADC group regular sequencer length                            */\r\n    /*    - Set ADC group regular sequencer discontinuous mode                */\r\n    /*    - Set ADC group regular continuous mode                             */\r\n    /*    - Set ADC group regular conversion data transfer: no transfer or    */\r\n    /*      transfer by DMA, and DMA requests mode                            */\r\n    /* Note: On this STM32 series, ADC trigger edge is set when starting      */\r\n    /*       ADC conversion.                                                  */\r\n    /*       Refer to function @ref LL_ADC_REG_StartConversionExtTrig().      */\r\n    if(ADC_REG_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)\r\n    {\r\n      MODIFY_REG(ADCx->CR1,\r\n                   ADC_CR1_DISCEN\r\n                 | ADC_CR1_DISCNUM\r\n                ,\r\n                   ADC_REG_InitStruct->SequencerDiscont\r\n                );\r\n    }\r\n    else\r\n    {\r\n      MODIFY_REG(ADCx->CR1,\r\n                   ADC_CR1_DISCEN\r\n                 | ADC_CR1_DISCNUM\r\n                ,\r\n                   LL_ADC_REG_SEQ_DISCONT_DISABLE\r\n                );\r\n    }\r\n    \r\n    MODIFY_REG(ADCx->CR2,\r\n                 ADC_CR2_EXTSEL\r\n               | ADC_CR2_EXTEN\r\n               | ADC_CR2_CONT\r\n               | ADC_CR2_DMA\r\n               | ADC_CR2_DDS\r\n              ,\r\n                (ADC_REG_InitStruct->TriggerSource & ADC_CR2_EXTSEL)\r\n               | ADC_REG_InitStruct->ContinuousMode\r\n               | ADC_REG_InitStruct->DMATransfer\r\n              );\r\n\r\n    /* Set ADC group regular sequencer length and scan direction */\r\n    /* Note: Hardware constraint (refer to description of this function):     */\r\n    /* Note: If ADC instance feature scan mode is disabled                    */\r\n    /*       (refer to  ADC instance initialization structure                 */\r\n    /*       parameter @ref SequencersScanMode                                */\r\n    /*       or function @ref LL_ADC_SetSequencersScanMode() ),               */\r\n    /*       this parameter is discarded.                                     */\r\n    LL_ADC_REG_SetSequencerLength(ADCx, ADC_REG_InitStruct->SequencerLength);\r\n  }\r\n  else\r\n  {\r\n    /* Initialization error: ADC instance is not disabled. */\r\n    status = ERROR;\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Set each @ref LL_ADC_REG_InitTypeDef field to default value.\r\n  * @param  ADC_REG_InitStruct Pointer to a @ref LL_ADC_REG_InitTypeDef structure\r\n  *                            whose fields will be set to default values.\r\n  * @retval None\r\n  */\r\nvoid LL_ADC_REG_StructInit(LL_ADC_REG_InitTypeDef *ADC_REG_InitStruct)\r\n{\r\n  /* Set ADC_REG_InitStruct fields to default values */\r\n  /* Set fields of ADC group regular */\r\n  /* Note: On this STM32 series, ADC trigger edge is set when starting        */\r\n  /*       ADC conversion.                                                    */\r\n  /*       Refer to function @ref LL_ADC_REG_StartConversionExtTrig().        */\r\n  ADC_REG_InitStruct->TriggerSource    = LL_ADC_REG_TRIG_SOFTWARE;\r\n  ADC_REG_InitStruct->SequencerLength  = LL_ADC_REG_SEQ_SCAN_DISABLE;\r\n  ADC_REG_InitStruct->SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;\r\n  ADC_REG_InitStruct->ContinuousMode   = LL_ADC_REG_CONV_SINGLE;\r\n  ADC_REG_InitStruct->DMATransfer      = LL_ADC_REG_DMA_TRANSFER_NONE;\r\n}\r\n\r\n/**\r\n  * @brief  Initialize some features of ADC group injected.\r\n  * @note   These parameters have an impact on ADC scope: ADC group injected.\r\n  *         Refer to corresponding unitary functions into\r\n  *         @ref ADC_LL_EF_Configuration_ADC_Group_Regular\r\n  *         (functions with prefix \"INJ\").\r\n  * @note   The setting of these parameters by function @ref LL_ADC_Init()\r\n  *         is conditioned to ADC state:\r\n  *         ADC instance must be disabled.\r\n  *         This condition is applied to all ADC features, for efficiency\r\n  *         and compatibility over all STM32 families. However, the different\r\n  *         features can be set under different ADC state conditions\r\n  *         (setting possible with ADC enabled without conversion on going,\r\n  *         ADC enabled with conversion on going, ...)\r\n  *         Each feature can be updated afterwards with a unitary function\r\n  *         and potentially with ADC in a different state than disabled,\r\n  *         refer to description of each function for setting\r\n  *         conditioned to ADC state.\r\n  * @note   After using this function, other features must be configured\r\n  *         using LL unitary functions.\r\n  *         The minimum configuration remaining to be done is:\r\n  *          - Set ADC group injected sequencer:\r\n  *            map channel on the selected sequencer rank.\r\n  *            Refer to function @ref LL_ADC_INJ_SetSequencerRanks().\r\n  *          - Set ADC channel sampling time\r\n  *            Refer to function LL_ADC_SetChannelSamplingTime();\r\n  * @param  ADCx ADC instance\r\n  * @param  ADC_INJ_InitStruct Pointer to a @ref LL_ADC_INJ_InitTypeDef structure\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: ADC registers are initialized\r\n  *          - ERROR: ADC registers are not initialized\r\n  */\r\nErrorStatus LL_ADC_INJ_Init(ADC_TypeDef *ADCx, LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  \r\n  /* Check the parameters */\r\n  assert_param(IS_ADC_ALL_INSTANCE(ADCx));\r\n  assert_param(IS_LL_ADC_INJ_TRIG_SOURCE(ADC_INJ_InitStruct->TriggerSource));\r\n  assert_param(IS_LL_ADC_INJ_SEQ_SCAN_LENGTH(ADC_INJ_InitStruct->SequencerLength));\r\n  if(ADC_INJ_InitStruct->SequencerLength != LL_ADC_INJ_SEQ_SCAN_DISABLE)\r\n  {\r\n    assert_param(IS_LL_ADC_INJ_SEQ_SCAN_DISCONT_MODE(ADC_INJ_InitStruct->SequencerDiscont));\r\n  }\r\n  assert_param(IS_LL_ADC_INJ_TRIG_AUTO(ADC_INJ_InitStruct->TrigAuto));\r\n  \r\n  /* Note: Hardware constraint (refer to description of this function):       */\r\n  /*       ADC instance must be disabled.                                     */\r\n  if(LL_ADC_IsEnabled(ADCx) == 0UL)\r\n  {\r\n    /* Configuration of ADC hierarchical scope:                               */\r\n    /*  - ADC group injected                                                  */\r\n    /*    - Set ADC group injected trigger source                             */\r\n    /*    - Set ADC group injected sequencer length                           */\r\n    /*    - Set ADC group injected sequencer discontinuous mode               */\r\n    /*    - Set ADC group injected conversion trigger: independent or         */\r\n    /*      from ADC group regular                                            */\r\n    /* Note: On this STM32 series, ADC trigger edge is set when starting      */\r\n    /*       ADC conversion.                                                  */\r\n    /*       Refer to function @ref LL_ADC_INJ_StartConversionExtTrig().      */\r\n    if(ADC_INJ_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)\r\n    {\r\n      MODIFY_REG(ADCx->CR1,\r\n                   ADC_CR1_JDISCEN\r\n                 | ADC_CR1_JAUTO\r\n                ,\r\n                   ADC_INJ_InitStruct->SequencerDiscont\r\n                 | ADC_INJ_InitStruct->TrigAuto\r\n                );\r\n    }\r\n    else\r\n    {\r\n      MODIFY_REG(ADCx->CR1,\r\n                   ADC_CR1_JDISCEN\r\n                 | ADC_CR1_JAUTO\r\n                ,\r\n                   LL_ADC_REG_SEQ_DISCONT_DISABLE\r\n                 | ADC_INJ_InitStruct->TrigAuto\r\n                );\r\n    }\r\n    \r\n    MODIFY_REG(ADCx->CR2,\r\n                 ADC_CR2_JEXTSEL\r\n               | ADC_CR2_JEXTEN\r\n              ,\r\n                (ADC_INJ_InitStruct->TriggerSource & ADC_CR2_JEXTSEL)\r\n              );\r\n    \r\n    /* Note: Hardware constraint (refer to description of this function):     */\r\n    /* Note: If ADC instance feature scan mode is disabled                    */\r\n    /*       (refer to  ADC instance initialization structure                 */\r\n    /*       parameter @ref SequencersScanMode                                */\r\n    /*       or function @ref LL_ADC_SetSequencersScanMode() ),               */\r\n    /*       this parameter is discarded.                                     */\r\n    LL_ADC_INJ_SetSequencerLength(ADCx, ADC_INJ_InitStruct->SequencerLength);\r\n  }\r\n  else\r\n  {\r\n    /* Initialization error: ADC instance is not disabled. */\r\n    status = ERROR;\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Set each @ref LL_ADC_INJ_InitTypeDef field to default value.\r\n  * @param  ADC_INJ_InitStruct Pointer to a @ref LL_ADC_INJ_InitTypeDef structure\r\n  *                            whose fields will be set to default values.\r\n  * @retval None\r\n  */\r\nvoid LL_ADC_INJ_StructInit(LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct)\r\n{\r\n  /* Set ADC_INJ_InitStruct fields to default values */\r\n  /* Set fields of ADC group injected */\r\n  ADC_INJ_InitStruct->TriggerSource    = LL_ADC_INJ_TRIG_SOFTWARE;\r\n  ADC_INJ_InitStruct->SequencerLength  = LL_ADC_INJ_SEQ_SCAN_DISABLE;\r\n  ADC_INJ_InitStruct->SequencerDiscont = LL_ADC_INJ_SEQ_DISCONT_DISABLE;\r\n  ADC_INJ_InitStruct->TrigAuto         = LL_ADC_INJ_TRIG_INDEPENDENT;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* ADC1 || ADC2 || ADC3 */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_ll_dma.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_ll_dma.c\r\n  * @author  MCD Application Team\r\n  * @brief   DMA LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_ll_dma.h\"\r\n#include \"stm32f4xx_ll_bus.h\"\r\n#ifdef  USE_FULL_ASSERT\r\n#include \"stm32_assert.h\"\r\n#else\r\n#define assert_param(expr) ((void)0U)\r\n#endif\r\n\r\n/** @addtogroup STM32F4xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined (DMA1) || defined (DMA2)\r\n\r\n/** @defgroup DMA_LL DMA\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup DMA_LL_Private_Macros\r\n  * @{\r\n  */\r\n#define IS_LL_DMA_DIRECTION(__VALUE__)          (((__VALUE__) == LL_DMA_DIRECTION_PERIPH_TO_MEMORY) || \\\r\n                                                 ((__VALUE__) == LL_DMA_DIRECTION_MEMORY_TO_PERIPH) || \\\r\n                                                 ((__VALUE__) == LL_DMA_DIRECTION_MEMORY_TO_MEMORY))\r\n\r\n#define IS_LL_DMA_MODE(__VALUE__)               (((__VALUE__) == LL_DMA_MODE_NORMAL)    || \\\r\n                                                 ((__VALUE__) == LL_DMA_MODE_CIRCULAR)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_MODE_PFCTRL))\r\n\r\n#define IS_LL_DMA_PERIPHINCMODE(__VALUE__)      (((__VALUE__) == LL_DMA_PERIPH_INCREMENT) || \\\r\n                                                 ((__VALUE__) == LL_DMA_PERIPH_NOINCREMENT))\r\n\r\n#define IS_LL_DMA_MEMORYINCMODE(__VALUE__)      (((__VALUE__) == LL_DMA_MEMORY_INCREMENT) || \\\r\n                                                 ((__VALUE__) == LL_DMA_MEMORY_NOINCREMENT))\r\n\r\n#define IS_LL_DMA_PERIPHDATASIZE(__VALUE__)     (((__VALUE__) == LL_DMA_PDATAALIGN_BYTE)      || \\\r\n                                                 ((__VALUE__) == LL_DMA_PDATAALIGN_HALFWORD)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_PDATAALIGN_WORD))\r\n\r\n#define IS_LL_DMA_MEMORYDATASIZE(__VALUE__)     (((__VALUE__) == LL_DMA_MDATAALIGN_BYTE)      || \\\r\n                                                 ((__VALUE__) == LL_DMA_MDATAALIGN_HALFWORD)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_MDATAALIGN_WORD))\r\n\r\n#define IS_LL_DMA_NBDATA(__VALUE__)             ((__VALUE__)  <= 0x0000FFFFU)\r\n\r\n#define IS_LL_DMA_CHANNEL(__VALUE__)            (((__VALUE__) == LL_DMA_CHANNEL_0)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_1)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_2)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_3)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_4)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_5)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_6)  || \\\r\n                                                 ((__VALUE__) == LL_DMA_CHANNEL_7))\r\n\r\n#define IS_LL_DMA_PRIORITY(__VALUE__)           (((__VALUE__) == LL_DMA_PRIORITY_LOW)    || \\\r\n                                                 ((__VALUE__) == LL_DMA_PRIORITY_MEDIUM) || \\\r\n                                                 ((__VALUE__) == LL_DMA_PRIORITY_HIGH)   || \\\r\n                                                 ((__VALUE__) == LL_DMA_PRIORITY_VERYHIGH))\r\n\r\n#define IS_LL_DMA_ALL_STREAM_INSTANCE(INSTANCE, STREAM)   ((((INSTANCE) == DMA1) && \\\r\n                                                           (((STREAM) == LL_DMA_STREAM_0) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_1) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_2) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_3) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_4) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_5) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_6) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_7) || \\\r\n                                                            ((STREAM) == LL_DMA_STREAM_ALL))) ||\\\r\n                                                            (((INSTANCE) == DMA2) && \\\r\n                                                          (((STREAM) == LL_DMA_STREAM_0) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_1) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_2) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_3) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_4) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_5) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_6) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_7) || \\\r\n                                                           ((STREAM) == LL_DMA_STREAM_ALL))))\r\n\r\n#define IS_LL_DMA_FIFO_MODE_STATE(STATE) (((STATE) == LL_DMA_FIFOMODE_DISABLE ) || \\\r\n                                          ((STATE) == LL_DMA_FIFOMODE_ENABLE))\r\n\r\n#define IS_LL_DMA_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == LL_DMA_FIFOTHRESHOLD_1_4) || \\\r\n                                             ((THRESHOLD) == LL_DMA_FIFOTHRESHOLD_1_2)  || \\\r\n                                             ((THRESHOLD) == LL_DMA_FIFOTHRESHOLD_3_4)  || \\\r\n                                             ((THRESHOLD) == LL_DMA_FIFOTHRESHOLD_FULL))\r\n\r\n#define IS_LL_DMA_MEMORY_BURST(BURST) (((BURST) == LL_DMA_MBURST_SINGLE) || \\\r\n                                       ((BURST) == LL_DMA_MBURST_INC4)   || \\\r\n                                       ((BURST) == LL_DMA_MBURST_INC8)   || \\\r\n                                       ((BURST) == LL_DMA_MBURST_INC16))\r\n\r\n#define IS_LL_DMA_PERIPHERAL_BURST(BURST) (((BURST) == LL_DMA_PBURST_SINGLE) || \\\r\n                                           ((BURST) == LL_DMA_PBURST_INC4)   || \\\r\n                                           ((BURST) == LL_DMA_PBURST_INC8)   || \\\r\n                                           ((BURST) == LL_DMA_PBURST_INC16))\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup DMA_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup DMA_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  De-initialize the DMA registers to their default reset values.\r\n  * @param  DMAx DMAx Instance\r\n  * @param  Stream This parameter can be one of the following values:\r\n  *         @arg @ref LL_DMA_STREAM_0\r\n  *         @arg @ref LL_DMA_STREAM_1\r\n  *         @arg @ref LL_DMA_STREAM_2\r\n  *         @arg @ref LL_DMA_STREAM_3\r\n  *         @arg @ref LL_DMA_STREAM_4\r\n  *         @arg @ref LL_DMA_STREAM_5\r\n  *         @arg @ref LL_DMA_STREAM_6\r\n  *         @arg @ref LL_DMA_STREAM_7\r\n  *         @arg @ref LL_DMA_STREAM_ALL\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: DMA registers are de-initialized\r\n  *          - ERROR: DMA registers are not de-initialized\r\n  */\r\nuint32_t LL_DMA_DeInit(DMA_TypeDef *DMAx, uint32_t Stream)\r\n{\r\n  DMA_Stream_TypeDef *tmp = (DMA_Stream_TypeDef *)DMA1_Stream0;\r\n  ErrorStatus status = SUCCESS;\r\n\r\n  /* Check the DMA Instance DMAx and Stream parameters*/\r\n  assert_param(IS_LL_DMA_ALL_STREAM_INSTANCE(DMAx, Stream));\r\n\r\n  if (Stream == LL_DMA_STREAM_ALL)\r\n  {\r\n    if (DMAx == DMA1)\r\n    {\r\n      /* Force reset of DMA clock */\r\n      LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_DMA1);\r\n\r\n      /* Release reset of DMA clock */\r\n      LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_DMA1);\r\n    }\r\n    else if (DMAx == DMA2)\r\n    {\r\n      /* Force reset of DMA clock */\r\n      LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_DMA2);\r\n\r\n      /* Release reset of DMA clock */\r\n      LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_DMA2);\r\n    }\r\n    else\r\n    {\r\n      status = ERROR;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Disable the selected Stream */\r\n    LL_DMA_DisableStream(DMAx,Stream);\r\n\r\n    /* Get the DMA Stream Instance */\r\n    tmp = (DMA_Stream_TypeDef *)(__LL_DMA_GET_STREAM_INSTANCE(DMAx, Stream));\r\n\r\n    /* Reset DMAx_Streamy configuration register */\r\n    LL_DMA_WriteReg(tmp, CR, 0U);\r\n\r\n    /* Reset DMAx_Streamy remaining bytes register */\r\n    LL_DMA_WriteReg(tmp, NDTR, 0U);\r\n\r\n    /* Reset DMAx_Streamy peripheral address register */\r\n    LL_DMA_WriteReg(tmp, PAR, 0U);\r\n\r\n    /* Reset DMAx_Streamy memory address register */\r\n    LL_DMA_WriteReg(tmp, M0AR, 0U);\r\n\r\n    /* Reset DMAx_Streamy memory address register */\r\n    LL_DMA_WriteReg(tmp, M1AR, 0U);\r\n\r\n    /* Reset DMAx_Streamy FIFO control register */\r\n    LL_DMA_WriteReg(tmp, FCR, 0x00000021U);\r\n\r\n    /* Reset Channel register field for DMAx Stream*/\r\n    LL_DMA_SetChannelSelection(DMAx, Stream, LL_DMA_CHANNEL_0);\r\n\r\n    if(Stream == LL_DMA_STREAM_0)\r\n    {\r\n       /* Reset the Stream0 pending flags */\r\n       DMAx->LIFCR = 0x0000003FU;\r\n    }\r\n    else if(Stream == LL_DMA_STREAM_1)\r\n    {\r\n       /* Reset the Stream1 pending flags */\r\n       DMAx->LIFCR = 0x00000F40U;\r\n    }\r\n    else if(Stream == LL_DMA_STREAM_2)\r\n    {\r\n       /* Reset the Stream2 pending flags */\r\n       DMAx->LIFCR = 0x003F0000U;\r\n    }\r\n    else if(Stream == LL_DMA_STREAM_3)\r\n    {\r\n       /* Reset the Stream3 pending flags */\r\n       DMAx->LIFCR = 0x0F400000U;\r\n    }\r\n    else if(Stream == LL_DMA_STREAM_4)\r\n    {\r\n       /* Reset the Stream4 pending flags */\r\n       DMAx->HIFCR = 0x0000003FU;\r\n    }\r\n    else if(Stream == LL_DMA_STREAM_5)\r\n    {\r\n       /* Reset the Stream5 pending flags */\r\n       DMAx->HIFCR = 0x00000F40U;\r\n    }\r\n    else if(Stream == LL_DMA_STREAM_6)\r\n    {\r\n       /* Reset the Stream6 pending flags */\r\n       DMAx->HIFCR = 0x003F0000U;\r\n    }\r\n    else if(Stream == LL_DMA_STREAM_7)\r\n    {\r\n       /* Reset the Stream7 pending flags */\r\n       DMAx->HIFCR = 0x0F400000U;\r\n    }\r\n    else\r\n    {\r\n      status = ERROR;\r\n    }\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Initialize the DMA registers according to the specified parameters in DMA_InitStruct.\r\n  * @note   To convert DMAx_Streamy Instance to DMAx Instance and Streamy, use helper macros :\r\n  *         @arg @ref __LL_DMA_GET_INSTANCE\r\n  *         @arg @ref __LL_DMA_GET_STREAM\r\n  * @param  DMAx DMAx Instance\r\n  * @param  Stream This parameter can be one of the following values:\r\n  *         @arg @ref LL_DMA_STREAM_0\r\n  *         @arg @ref LL_DMA_STREAM_1\r\n  *         @arg @ref LL_DMA_STREAM_2\r\n  *         @arg @ref LL_DMA_STREAM_3\r\n  *         @arg @ref LL_DMA_STREAM_4\r\n  *         @arg @ref LL_DMA_STREAM_5\r\n  *         @arg @ref LL_DMA_STREAM_6\r\n  *         @arg @ref LL_DMA_STREAM_7\r\n  * @param  DMA_InitStruct pointer to a @ref LL_DMA_InitTypeDef structure.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: DMA registers are initialized\r\n  *          - ERROR: Not applicable\r\n  */\r\nuint32_t LL_DMA_Init(DMA_TypeDef *DMAx, uint32_t Stream, LL_DMA_InitTypeDef *DMA_InitStruct)\r\n{\r\n  /* Check the DMA Instance DMAx and Stream parameters*/\r\n  assert_param(IS_LL_DMA_ALL_STREAM_INSTANCE(DMAx, Stream));\r\n\r\n  /* Check the DMA parameters from DMA_InitStruct */\r\n  assert_param(IS_LL_DMA_DIRECTION(DMA_InitStruct->Direction));\r\n  assert_param(IS_LL_DMA_MODE(DMA_InitStruct->Mode));\r\n  assert_param(IS_LL_DMA_PERIPHINCMODE(DMA_InitStruct->PeriphOrM2MSrcIncMode));\r\n  assert_param(IS_LL_DMA_MEMORYINCMODE(DMA_InitStruct->MemoryOrM2MDstIncMode));\r\n  assert_param(IS_LL_DMA_PERIPHDATASIZE(DMA_InitStruct->PeriphOrM2MSrcDataSize));\r\n  assert_param(IS_LL_DMA_MEMORYDATASIZE(DMA_InitStruct->MemoryOrM2MDstDataSize));\r\n  assert_param(IS_LL_DMA_NBDATA(DMA_InitStruct->NbData));\r\n  assert_param(IS_LL_DMA_CHANNEL(DMA_InitStruct->Channel));\r\n  assert_param(IS_LL_DMA_PRIORITY(DMA_InitStruct->Priority));\r\n  assert_param(IS_LL_DMA_FIFO_MODE_STATE(DMA_InitStruct->FIFOMode));\r\n  /* Check the memory burst, peripheral burst and FIFO threshold parameters only\r\n     when FIFO mode is enabled */\r\n  if(DMA_InitStruct->FIFOMode != LL_DMA_FIFOMODE_DISABLE)\r\n  {\r\n    assert_param(IS_LL_DMA_FIFO_THRESHOLD(DMA_InitStruct->FIFOThreshold));\r\n    assert_param(IS_LL_DMA_MEMORY_BURST(DMA_InitStruct->MemBurst));\r\n    assert_param(IS_LL_DMA_PERIPHERAL_BURST(DMA_InitStruct->PeriphBurst));\r\n  }\r\n\r\n  /*---------------------------- DMAx SxCR Configuration ------------------------\r\n   * Configure DMAx_Streamy: data transfer direction, data transfer mode,\r\n   *                          peripheral and memory increment mode,\r\n   *                          data size alignment and  priority level with parameters :\r\n   * - Direction:      DMA_SxCR_DIR[1:0] bits\r\n   * - Mode:           DMA_SxCR_CIRC bit\r\n   * - PeriphOrM2MSrcIncMode:  DMA_SxCR_PINC bit\r\n   * - MemoryOrM2MDstIncMode:  DMA_SxCR_MINC bit\r\n   * - PeriphOrM2MSrcDataSize: DMA_SxCR_PSIZE[1:0] bits\r\n   * - MemoryOrM2MDstDataSize: DMA_SxCR_MSIZE[1:0] bits\r\n   * - Priority:               DMA_SxCR_PL[1:0] bits\r\n   */\r\n  LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \\\r\n                        DMA_InitStruct->Mode                    | \\\r\n                        DMA_InitStruct->PeriphOrM2MSrcIncMode   | \\\r\n                        DMA_InitStruct->MemoryOrM2MDstIncMode   | \\\r\n                        DMA_InitStruct->PeriphOrM2MSrcDataSize  | \\\r\n                        DMA_InitStruct->MemoryOrM2MDstDataSize  | \\\r\n                        DMA_InitStruct->Priority\r\n                        );\r\n\r\n  if(DMA_InitStruct->FIFOMode != LL_DMA_FIFOMODE_DISABLE)\r\n  {\r\n    /*---------------------------- DMAx SxFCR Configuration ------------------------\r\n     * Configure DMAx_Streamy:  fifo mode and fifo threshold with parameters :\r\n     * - FIFOMode:                DMA_SxFCR_DMDIS bit\r\n     * - FIFOThreshold:           DMA_SxFCR_FTH[1:0] bits\r\n     */\r\n    LL_DMA_ConfigFifo(DMAx, Stream, DMA_InitStruct->FIFOMode, DMA_InitStruct->FIFOThreshold);   \r\n\r\n    /*---------------------------- DMAx SxCR Configuration --------------------------\r\n     * Configure DMAx_Streamy:  memory burst transfer with parameters :\r\n     * - MemBurst:                DMA_SxCR_MBURST[1:0] bits\r\n     */\r\n    LL_DMA_SetMemoryBurstxfer(DMAx,Stream,DMA_InitStruct->MemBurst); \r\n\r\n    /*---------------------------- DMAx SxCR Configuration --------------------------\r\n     * Configure DMAx_Streamy:  peripheral burst transfer with parameters :\r\n     * - PeriphBurst:             DMA_SxCR_PBURST[1:0] bits\r\n     */\r\n    LL_DMA_SetPeriphBurstxfer(DMAx,Stream,DMA_InitStruct->PeriphBurst);\r\n  }\r\n\r\n  /*-------------------------- DMAx SxM0AR Configuration --------------------------\r\n   * Configure the memory or destination base address with parameter :\r\n   * - MemoryOrM2MDstAddress:     DMA_SxM0AR_M0A[31:0] bits\r\n   */\r\n  LL_DMA_SetMemoryAddress(DMAx, Stream, DMA_InitStruct->MemoryOrM2MDstAddress);\r\n\r\n  /*-------------------------- DMAx SxPAR Configuration ---------------------------\r\n   * Configure the peripheral or source base address with parameter :\r\n   * - PeriphOrM2MSrcAddress:     DMA_SxPAR_PA[31:0] bits\r\n   */\r\n  LL_DMA_SetPeriphAddress(DMAx, Stream, DMA_InitStruct->PeriphOrM2MSrcAddress);\r\n\r\n  /*--------------------------- DMAx SxNDTR Configuration -------------------------\r\n   * Configure the peripheral base address with parameter :\r\n   * - NbData:                    DMA_SxNDT[15:0] bits\r\n   */\r\n  LL_DMA_SetDataLength(DMAx, Stream, DMA_InitStruct->NbData);\r\n\r\n  /*--------------------------- DMA SxCR_CHSEL Configuration ----------------------\r\n   * Configure the peripheral base address with parameter :\r\n   * - PeriphRequest:             DMA_SxCR_CHSEL[2:0] bits\r\n   */\r\n  LL_DMA_SetChannelSelection(DMAx, Stream, DMA_InitStruct->Channel);\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Set each @ref LL_DMA_InitTypeDef field to default value.\r\n  * @param  DMA_InitStruct Pointer to a @ref LL_DMA_InitTypeDef structure.\r\n  * @retval None\r\n  */\r\nvoid LL_DMA_StructInit(LL_DMA_InitTypeDef *DMA_InitStruct)\r\n{\r\n  /* Set DMA_InitStruct fields to default values */\r\n  DMA_InitStruct->PeriphOrM2MSrcAddress  = 0x00000000U;\r\n  DMA_InitStruct->MemoryOrM2MDstAddress  = 0x00000000U;\r\n  DMA_InitStruct->Direction              = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;\r\n  DMA_InitStruct->Mode                   = LL_DMA_MODE_NORMAL;\r\n  DMA_InitStruct->PeriphOrM2MSrcIncMode  = LL_DMA_PERIPH_NOINCREMENT;\r\n  DMA_InitStruct->MemoryOrM2MDstIncMode  = LL_DMA_MEMORY_NOINCREMENT;\r\n  DMA_InitStruct->PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;\r\n  DMA_InitStruct->MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;\r\n  DMA_InitStruct->NbData                 = 0x00000000U;\r\n  DMA_InitStruct->Channel                = LL_DMA_CHANNEL_0;\r\n  DMA_InitStruct->Priority               = LL_DMA_PRIORITY_LOW;\r\n  DMA_InitStruct->FIFOMode               = LL_DMA_FIFOMODE_DISABLE;\r\n  DMA_InitStruct->FIFOThreshold          = LL_DMA_FIFOTHRESHOLD_1_4;\r\n  DMA_InitStruct->MemBurst               = LL_DMA_MBURST_SINGLE;\r\n  DMA_InitStruct->PeriphBurst            = LL_DMA_PBURST_SINGLE;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* DMA1 || DMA2 */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_ll_exti.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_ll_exti.c\r\n  * @author  MCD Application Team\r\n  * @brief   EXTI LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_ll_exti.h\"\r\n#ifdef  USE_FULL_ASSERT\r\n#include \"stm32_assert.h\"\r\n#else\r\n#define assert_param(expr) ((void)0U)\r\n#endif\r\n\r\n/** @addtogroup STM32F4xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined (EXTI)\r\n\r\n/** @defgroup EXTI_LL EXTI\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup EXTI_LL_Private_Macros\r\n  * @{\r\n  */\r\n\r\n#define IS_LL_EXTI_LINE_0_31(__VALUE__)              (((__VALUE__) & ~LL_EXTI_LINE_ALL_0_31) == 0x00000000U)\r\n\r\n#define IS_LL_EXTI_MODE(__VALUE__)                   (((__VALUE__) == LL_EXTI_MODE_IT)            \\\r\n                                                   || ((__VALUE__) == LL_EXTI_MODE_EVENT)         \\\r\n                                                   || ((__VALUE__) == LL_EXTI_MODE_IT_EVENT))\r\n\r\n\r\n#define IS_LL_EXTI_TRIGGER(__VALUE__)                (((__VALUE__) == LL_EXTI_TRIGGER_NONE)       \\\r\n                                                   || ((__VALUE__) == LL_EXTI_TRIGGER_RISING)     \\\r\n                                                   || ((__VALUE__) == LL_EXTI_TRIGGER_FALLING)    \\\r\n                                                   || ((__VALUE__) == LL_EXTI_TRIGGER_RISING_FALLING))\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup EXTI_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup EXTI_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  De-initialize the EXTI registers to their default reset values.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: EXTI registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nuint32_t LL_EXTI_DeInit(void)\r\n{\r\n  /* Interrupt mask register set to default reset values */\r\n  LL_EXTI_WriteReg(IMR,   0x00000000U);\r\n  /* Event mask register set to default reset values */\r\n  LL_EXTI_WriteReg(EMR,   0x00000000U);\r\n  /* Rising Trigger selection register set to default reset values */\r\n  LL_EXTI_WriteReg(RTSR,  0x00000000U);\r\n  /* Falling Trigger selection register set to default reset values */\r\n  LL_EXTI_WriteReg(FTSR,  0x00000000U);\r\n  /* Software interrupt event register set to default reset values */\r\n  LL_EXTI_WriteReg(SWIER, 0x00000000U);\r\n  /* Pending register set to default reset values */\r\n  LL_EXTI_WriteReg(PR,    0x00FFFFFFU);\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Initialize the EXTI registers according to the specified parameters in EXTI_InitStruct.\r\n  * @param  EXTI_InitStruct pointer to a @ref LL_EXTI_InitTypeDef structure.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: EXTI registers are initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nuint32_t LL_EXTI_Init(LL_EXTI_InitTypeDef *EXTI_InitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  /* Check the parameters */\r\n  assert_param(IS_LL_EXTI_LINE_0_31(EXTI_InitStruct->Line_0_31));\r\n  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->LineCommand));\r\n  assert_param(IS_LL_EXTI_MODE(EXTI_InitStruct->Mode));\r\n\r\n  /* ENABLE LineCommand */\r\n  if (EXTI_InitStruct->LineCommand != DISABLE)\r\n  {\r\n    assert_param(IS_LL_EXTI_TRIGGER(EXTI_InitStruct->Trigger));\r\n\r\n    /* Configure EXTI Lines in range from 0 to 31 */\r\n    if (EXTI_InitStruct->Line_0_31 != LL_EXTI_LINE_NONE)\r\n    {\r\n      switch (EXTI_InitStruct->Mode)\r\n      {\r\n        case LL_EXTI_MODE_IT:\r\n          /* First Disable Event on provided Lines */\r\n          LL_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);\r\n          /* Then Enable IT on provided Lines */\r\n          LL_EXTI_EnableIT_0_31(EXTI_InitStruct->Line_0_31);\r\n          break;\r\n        case LL_EXTI_MODE_EVENT:\r\n          /* First Disable IT on provided Lines */\r\n          LL_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);\r\n          /* Then Enable Event on provided Lines */\r\n          LL_EXTI_EnableEvent_0_31(EXTI_InitStruct->Line_0_31);\r\n          break;\r\n        case LL_EXTI_MODE_IT_EVENT:\r\n          /* Directly Enable IT & Event on provided Lines */\r\n          LL_EXTI_EnableIT_0_31(EXTI_InitStruct->Line_0_31);\r\n          LL_EXTI_EnableEvent_0_31(EXTI_InitStruct->Line_0_31);\r\n          break;\r\n        default:\r\n          status = ERROR;\r\n          break;\r\n      }\r\n      if (EXTI_InitStruct->Trigger != LL_EXTI_TRIGGER_NONE)\r\n      {\r\n        switch (EXTI_InitStruct->Trigger)\r\n        {\r\n          case LL_EXTI_TRIGGER_RISING:\r\n            /* First Disable Falling Trigger on provided Lines */\r\n            LL_EXTI_DisableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            /* Then Enable Rising Trigger on provided Lines */\r\n            LL_EXTI_EnableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            break;\r\n          case LL_EXTI_TRIGGER_FALLING:\r\n            /* First Disable Rising Trigger on provided Lines */\r\n            LL_EXTI_DisableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            /* Then Enable Falling Trigger on provided Lines */\r\n            LL_EXTI_EnableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            break;\r\n          case LL_EXTI_TRIGGER_RISING_FALLING:\r\n            LL_EXTI_EnableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            LL_EXTI_EnableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            break;\r\n          default:\r\n            status = ERROR;\r\n            break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /* DISABLE LineCommand */\r\n  else\r\n  {\r\n    /* De-configure EXTI Lines in range from 0 to 31 */\r\n    LL_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);\r\n    LL_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Set each @ref LL_EXTI_InitTypeDef field to default value.\r\n  * @param  EXTI_InitStruct Pointer to a @ref LL_EXTI_InitTypeDef structure.\r\n  * @retval None\r\n  */\r\nvoid LL_EXTI_StructInit(LL_EXTI_InitTypeDef *EXTI_InitStruct)\r\n{\r\n  EXTI_InitStruct->Line_0_31      = LL_EXTI_LINE_NONE;\r\n  EXTI_InitStruct->LineCommand    = DISABLE;\r\n  EXTI_InitStruct->Mode           = LL_EXTI_MODE_IT;\r\n  EXTI_InitStruct->Trigger        = LL_EXTI_TRIGGER_FALLING;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* defined (EXTI) */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_ll_gpio.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_ll_gpio.c\r\n  * @author  MCD Application Team\r\n  * @brief   GPIO LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_ll_gpio.h\"\r\n#include \"stm32f4xx_ll_bus.h\"\r\n#ifdef  USE_FULL_ASSERT\r\n#include \"stm32_assert.h\"\r\n#else\r\n#define assert_param(expr) ((void)0U)\r\n#endif\r\n\r\n/** @addtogroup STM32F4xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined (GPIOA) || defined (GPIOB) || defined (GPIOC) || defined (GPIOD) || defined (GPIOE) || defined (GPIOF) || defined (GPIOG) || defined (GPIOH) || defined (GPIOI) || defined (GPIOJ) || defined (GPIOK)\r\n\r\n/** @addtogroup GPIO_LL\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup GPIO_LL_Private_Macros\r\n  * @{\r\n  */\r\n#define IS_LL_GPIO_PIN(__VALUE__)          (((0x00000000U) < (__VALUE__)) && ((__VALUE__) <= (LL_GPIO_PIN_ALL)))\r\n\r\n#define IS_LL_GPIO_MODE(__VALUE__)         (((__VALUE__) == LL_GPIO_MODE_INPUT)     ||\\\r\n                                            ((__VALUE__) == LL_GPIO_MODE_OUTPUT)    ||\\\r\n                                            ((__VALUE__) == LL_GPIO_MODE_ALTERNATE) ||\\\r\n                                            ((__VALUE__) == LL_GPIO_MODE_ANALOG))\r\n\r\n#define IS_LL_GPIO_OUTPUT_TYPE(__VALUE__)  (((__VALUE__) == LL_GPIO_OUTPUT_PUSHPULL)  ||\\\r\n                                            ((__VALUE__) == LL_GPIO_OUTPUT_OPENDRAIN))\r\n\r\n#define IS_LL_GPIO_SPEED(__VALUE__)        (((__VALUE__) == LL_GPIO_SPEED_FREQ_LOW)       ||\\\r\n                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_MEDIUM)    ||\\\r\n                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_HIGH)      ||\\\r\n                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_VERY_HIGH))\r\n\r\n#define IS_LL_GPIO_PULL(__VALUE__)         (((__VALUE__) == LL_GPIO_PULL_NO)   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_PULL_UP)   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_PULL_DOWN))\r\n\r\n#define IS_LL_GPIO_ALTERNATE(__VALUE__)    (((__VALUE__) == LL_GPIO_AF_0  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_1  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_2  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_3  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_4  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_5  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_6  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_7  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_8  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_9  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_10 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_11 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_12 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_13 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_14 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_15 ))\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup GPIO_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup GPIO_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  De-initialize GPIO registers (Registers restored to their default values).\r\n  * @param  GPIOx GPIO Port\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: GPIO registers are de-initialized\r\n  *          - ERROR:   Wrong GPIO Port\r\n  */\r\nErrorStatus LL_GPIO_DeInit(GPIO_TypeDef *GPIOx)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\r\n\r\n  /* Force and Release reset on clock of GPIOx Port */\r\n  if (GPIOx == GPIOA)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOA);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOA);\r\n  }\r\n  else if (GPIOx == GPIOB)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOB);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOB);\r\n  }\r\n  else if (GPIOx == GPIOC)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOC);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOC);\r\n  }\r\n#if defined(GPIOD)\r\n  else if (GPIOx == GPIOD)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOD);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOD);\r\n  }\r\n#endif /* GPIOD */\r\n#if defined(GPIOE)\r\n  else if (GPIOx == GPIOE)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOE);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOE);\r\n  }\r\n#endif /* GPIOE */\r\n#if defined(GPIOF)\r\n  else if (GPIOx == GPIOF)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOF);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOF);\r\n  }\r\n#endif /* GPIOF */\r\n#if defined(GPIOG)\r\n  else if (GPIOx == GPIOG)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOG);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOG);\r\n  }\r\n#endif /* GPIOG */\r\n#if defined(GPIOH)\r\n  else if (GPIOx == GPIOH)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOH);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOH);\r\n  }\r\n#endif /* GPIOH */\r\n#if defined(GPIOI)\r\n  else if (GPIOx == GPIOI)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOI);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOI);\r\n  }\r\n#endif /* GPIOI */\r\n#if defined(GPIOJ)\r\n  else if (GPIOx == GPIOJ)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOJ);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOJ);\r\n  }\r\n#endif /* GPIOJ */\r\n#if defined(GPIOK)\r\n  else if (GPIOx == GPIOK)\r\n  {\r\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_GPIOK);\r\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_GPIOK);\r\n  }\r\n#endif /* GPIOK */\r\n  else\r\n  {\r\n    status = ERROR;\r\n  }\r\n\r\n  return (status);\r\n}\r\n\r\n/**\r\n  * @brief  Initialize GPIO registers according to the specified parameters in GPIO_InitStruct.\r\n  * @param  GPIOx GPIO Port\r\n  * @param  GPIO_InitStruct pointer to a @ref LL_GPIO_InitTypeDef structure\r\n  *         that contains the configuration information for the specified GPIO peripheral.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content\r\n  *          - ERROR:   Not applicable\r\n  */\r\nErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)\r\n{\r\n  uint32_t pinpos     = 0x00000000U;\r\n  uint32_t currentpin = 0x00000000U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\r\n  assert_param(IS_LL_GPIO_PIN(GPIO_InitStruct->Pin));\r\n  assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));\r\n  assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));\r\n\r\n  /* ------------------------- Configure the port pins ---------------- */\r\n  /* Initialize  pinpos on first pin set */\r\n  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);\r\n  \r\n  /* Configure the port pins */\r\n  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)\r\n  {\r\n    /* Get current io position */\r\n    currentpin = (GPIO_InitStruct->Pin) & (0x00000001U << pinpos);\r\n    \r\n    if (currentpin)\r\n    {\r\n      \r\n      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))\r\n      {\r\n        /* Check Speed mode parameters */\r\n        assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));\r\n        \r\n        /* Speed mode configuration */\r\n        LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);\r\n        \r\n        /* Check Output mode parameters */\r\n        assert_param(IS_LL_GPIO_OUTPUT_TYPE(GPIO_InitStruct->OutputType));\r\n        \r\n        /* Output mode configuration*/\r\n        LL_GPIO_SetPinOutputType(GPIOx, currentpin, GPIO_InitStruct->OutputType);\r\n      }\r\n      \r\n      /* Pull-up Pull down resistor configuration*/\r\n      LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);\r\n      \r\n      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)\r\n      {\r\n        /* Check Alternate parameter */\r\n        assert_param(IS_LL_GPIO_ALTERNATE(GPIO_InitStruct->Alternate));\r\n        \r\n        /* Speed mode configuration */\r\n        if (POSITION_VAL(currentpin) < 0x00000008U)\r\n        {\r\n          LL_GPIO_SetAFPin_0_7(GPIOx, currentpin, GPIO_InitStruct->Alternate);\r\n        }\r\n        else\r\n        {\r\n          LL_GPIO_SetAFPin_8_15(GPIOx, currentpin, GPIO_InitStruct->Alternate);\r\n        }\r\n      }\r\n      \r\n      /* Pin Mode configuration */\r\n      LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);\r\n    }\r\n    pinpos++;\r\n  }\r\n\r\n  return (SUCCESS);\r\n}\r\n\r\n/**\r\n  * @brief Set each @ref LL_GPIO_InitTypeDef field to default value.\r\n  * @param GPIO_InitStruct pointer to a @ref LL_GPIO_InitTypeDef structure\r\n  *                          whose fields will be set to default values.\r\n  * @retval None\r\n  */\r\n\r\nvoid LL_GPIO_StructInit(LL_GPIO_InitTypeDef *GPIO_InitStruct)\r\n{\r\n  /* Reset GPIO init structure parameters values */\r\n  GPIO_InitStruct->Pin        = LL_GPIO_PIN_ALL;\r\n  GPIO_InitStruct->Mode       = LL_GPIO_MODE_ANALOG;\r\n  GPIO_InitStruct->Speed      = LL_GPIO_SPEED_FREQ_LOW;\r\n  GPIO_InitStruct->OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct->Pull       = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct->Alternate  = LL_GPIO_AF_0;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* defined (GPIOA) || defined (GPIOB) || defined (GPIOC) || defined (GPIOD) || defined (GPIOE) || defined (GPIOF) || defined (GPIOG) || defined (GPIOH) || defined (GPIOI) || defined (GPIOJ) || defined (GPIOK) */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_ll_rcc.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_ll_rcc.c\r\n  * @author  MCD Application Team\r\n  * @brief   RCC LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_ll_rcc.h\"\r\n#ifdef  USE_FULL_ASSERT\r\n  #include \"stm32_assert.h\"\r\n#else\r\n  #define assert_param(expr) ((void)0U)\r\n#endif\r\n/** @addtogroup STM32F4xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined(RCC)\r\n\r\n/** @addtogroup RCC_LL\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup RCC_LL_Private_Macros\r\n  * @{\r\n  */\r\n#if defined(FMPI2C1)\r\n#define IS_LL_RCC_FMPI2C_CLKSOURCE(__VALUE__)     ((__VALUE__) == LL_RCC_FMPI2C1_CLKSOURCE)\r\n#endif /* FMPI2C1 */\r\n\r\n#if defined(LPTIM1)\r\n#define IS_LL_RCC_LPTIM_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_LPTIM1_CLKSOURCE))\r\n#endif /* LPTIM1 */\r\n\r\n#if defined(SAI1)\r\n#if defined(RCC_DCKCFGR_SAI1SRC)\r\n#define IS_LL_RCC_SAI_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_SAI1_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_SAI2_CLKSOURCE))\r\n#elif defined(RCC_DCKCFGR_SAI1ASRC)\r\n#define IS_LL_RCC_SAI_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_SAI1_A_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_SAI1_B_CLKSOURCE))\r\n#endif /* RCC_DCKCFGR_SAI1SRC */\r\n#endif /* SAI1 */\r\n\r\n#if defined(SDIO)\r\n#define IS_LL_RCC_SDIO_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_SDIO_CLKSOURCE))\r\n#endif /* SDIO */\r\n\r\n#if defined(RNG)\r\n#define IS_LL_RCC_RNG_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_RNG_CLKSOURCE))\r\n#endif /* RNG */\r\n\r\n#if defined(USB_OTG_FS) || defined(USB_OTG_HS)\r\n#define IS_LL_RCC_USB_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_USB_CLKSOURCE))\r\n#endif /* USB_OTG_FS || USB_OTG_HS */\r\n\r\n#if defined(DFSDM2_Channel0)\r\n#define IS_LL_RCC_DFSDM_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_DFSDM1_CLKSOURCE))\r\n\r\n#define IS_LL_RCC_DFSDM_AUDIO_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_DFSDM1_AUDIO_CLKSOURCE) \\\r\n                                                    || ((__VALUE__) == LL_RCC_DFSDM2_AUDIO_CLKSOURCE))\r\n#elif defined(DFSDM1_Channel0)\r\n#define IS_LL_RCC_DFSDM_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_DFSDM1_CLKSOURCE))\r\n\r\n#define IS_LL_RCC_DFSDM_AUDIO_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_DFSDM1_AUDIO_CLKSOURCE))\r\n#endif /* DFSDM2_Channel0 */\r\n\r\n#if defined(RCC_DCKCFGR_I2S2SRC)\r\n#define IS_LL_RCC_I2S_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2S1_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_I2S2_CLKSOURCE))\r\n#else\r\n#define IS_LL_RCC_I2S_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2S1_CLKSOURCE))\r\n#endif /* RCC_DCKCFGR_I2S2SRC */\r\n\r\n#if defined(CEC)\r\n#define IS_LL_RCC_CEC_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_CEC_CLKSOURCE))\r\n#endif /* CEC */\r\n\r\n#if defined(DSI)\r\n#define IS_LL_RCC_DSI_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_DSI_CLKSOURCE))\r\n#endif /* DSI */\r\n\r\n#if defined(LTDC)\r\n#define IS_LL_RCC_LTDC_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_LTDC_CLKSOURCE))\r\n#endif /* LTDC */\r\n\r\n#if defined(SPDIFRX)\r\n#define IS_LL_RCC_SPDIFRX_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_SPDIFRX1_CLKSOURCE))\r\n#endif /* SPDIFRX */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @defgroup RCC_LL_Private_Functions RCC Private functions\r\n  * @{\r\n  */\r\nuint32_t RCC_GetSystemClockFreq(void);\r\nuint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency);\r\nuint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency);\r\nuint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency);\r\nuint32_t RCC_PLL_GetFreqDomain_SYS(uint32_t SYSCLK_Source);\r\nuint32_t RCC_PLL_GetFreqDomain_48M(void);\r\n#if defined(RCC_DCKCFGR_I2SSRC) || defined(RCC_DCKCFGR_I2S1SRC)\r\nuint32_t RCC_PLL_GetFreqDomain_I2S(void);\r\n#endif /* RCC_DCKCFGR_I2SSRC || RCC_DCKCFGR_I2S1SRC */\r\n#if defined(SPDIFRX)\r\nuint32_t RCC_PLL_GetFreqDomain_SPDIFRX(void);\r\n#endif /* SPDIFRX */\r\n#if defined(RCC_PLLCFGR_PLLR)\r\n#if defined(SAI1)\r\nuint32_t RCC_PLL_GetFreqDomain_SAI(void);\r\n#endif /* SAI1 */\r\n#endif /* RCC_PLLCFGR_PLLR */\r\n#if defined(DSI)\r\nuint32_t RCC_PLL_GetFreqDomain_DSI(void);\r\n#endif /* DSI */\r\n#if defined(RCC_PLLSAI_SUPPORT)\r\nuint32_t RCC_PLLSAI_GetFreqDomain_SAI(void);\r\n#if defined(RCC_PLLSAICFGR_PLLSAIP)\r\nuint32_t RCC_PLLSAI_GetFreqDomain_48M(void);\r\n#endif /* RCC_PLLSAICFGR_PLLSAIP */\r\n#if defined(LTDC)\r\nuint32_t RCC_PLLSAI_GetFreqDomain_LTDC(void);\r\n#endif /* LTDC */\r\n#endif /* RCC_PLLSAI_SUPPORT */\r\n#if defined(RCC_PLLI2S_SUPPORT)\r\nuint32_t RCC_PLLI2S_GetFreqDomain_I2S(void);\r\n#if defined(RCC_PLLI2SCFGR_PLLI2SQ) && !defined(RCC_DCKCFGR_PLLI2SDIVQ)\r\nuint32_t RCC_PLLI2S_GetFreqDomain_48M(void);\r\n#endif /* RCC_PLLI2SCFGR_PLLI2SQ && !RCC_DCKCFGR_PLLI2SDIVQ */\r\n#if defined(SAI1)\r\nuint32_t RCC_PLLI2S_GetFreqDomain_SAI(void);\r\n#endif /* SAI1 */\r\n#if defined(SPDIFRX)\r\nuint32_t RCC_PLLI2S_GetFreqDomain_SPDIFRX(void);\r\n#endif /* SPDIFRX */\r\n#endif /* RCC_PLLI2S_SUPPORT */\r\n/**\r\n  * @}\r\n  */\r\n\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup RCC_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup RCC_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Reset the RCC clock configuration to the default reset state.\r\n  * @note   The default reset state of the clock configuration is given below:\r\n  *         - HSI ON and used as system clock source\r\n  *         - HSE and PLL OFF\r\n  *         - AHB, APB1 and APB2 prescaler set to 1.\r\n  *         - CSS, MCO OFF\r\n  *         - All interrupts disabled\r\n  * @note   This function doesn't modify the configuration of the\r\n  *         - Peripheral clocks\r\n  *         - LSI, LSE and RTC clocks\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: RCC registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nErrorStatus LL_RCC_DeInit(void)\r\n{\r\n  __IO uint32_t vl_mask;\r\n\r\n  /* Set HSION bit */\r\n  LL_RCC_HSI_Enable();\r\n\r\n  /* Wait for HSI READY bit */\r\n  while(LL_RCC_HSI_IsReady() != 1U)\r\n  {}\r\n\r\n  /* Reset CFGR register */\r\n  LL_RCC_WriteReg(CFGR, 0x00000000U);\r\n\r\n  /* Read CR register */\r\n  vl_mask = LL_RCC_ReadReg(CR);\r\n\r\n  /* Reset HSEON, HSEBYP, PLLON, CSSON bits */\r\n  CLEAR_BIT(vl_mask,\r\n            (RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_PLLON | RCC_CR_CSSON));\r\n\r\n#if defined(RCC_PLLSAI_SUPPORT)\r\n  /* Reset PLLSAION bit */\r\n  CLEAR_BIT(vl_mask, RCC_CR_PLLSAION);\r\n#endif /* RCC_PLLSAI_SUPPORT */\r\n\r\n#if defined(RCC_PLLI2S_SUPPORT)\r\n  /* Reset PLLI2SON bit */\r\n  CLEAR_BIT(vl_mask, RCC_CR_PLLI2SON);\r\n#endif /* RCC_PLLI2S_SUPPORT */\r\n\r\n  /* Write new value in CR register */\r\n  LL_RCC_WriteReg(CR, vl_mask);\r\n\r\n  /* Set HSITRIM bits to the reset value*/\r\n  LL_RCC_HSI_SetCalibTrimming(0x10U);\r\n\r\n  /* Wait for PLL READY bit to be reset */\r\n  while(LL_RCC_PLL_IsReady() != 0U)\r\n  {}\r\n\r\n  /* Reset PLLCFGR register */\r\n  LL_RCC_WriteReg(PLLCFGR, RCC_PLLCFGR_RST_VALUE);\r\n\r\n#if defined(RCC_PLLI2S_SUPPORT)\r\n  /* Reset PLLI2SCFGR register */\r\n  LL_RCC_WriteReg(PLLI2SCFGR, RCC_PLLI2SCFGR_RST_VALUE);\r\n#endif /* RCC_PLLI2S_SUPPORT */\r\n\r\n#if defined(RCC_PLLSAI_SUPPORT)\r\n  /* Reset PLLSAICFGR register */\r\n  LL_RCC_WriteReg(PLLSAICFGR, RCC_PLLSAICFGR_RST_VALUE);\r\n#endif /* RCC_PLLSAI_SUPPORT */\r\n\r\n  /* Disable all interrupts */\r\n  CLEAR_BIT(RCC->CIR, RCC_CIR_LSIRDYIE | RCC_CIR_LSERDYIE | RCC_CIR_HSIRDYIE | RCC_CIR_HSERDYIE | RCC_CIR_PLLRDYIE);\r\n\r\n#if defined(RCC_CIR_PLLI2SRDYIE)\r\n  CLEAR_BIT(RCC->CIR, RCC_CIR_PLLI2SRDYIE);\r\n#endif /* RCC_CIR_PLLI2SRDYIE */\r\n\r\n#if defined(RCC_CIR_PLLSAIRDYIE)\r\n  CLEAR_BIT(RCC->CIR, RCC_CIR_PLLSAIRDYIE);\r\n#endif /* RCC_CIR_PLLSAIRDYIE */\r\n\r\n  /* Clear all interrupt flags */\r\n  SET_BIT(RCC->CIR, RCC_CIR_LSIRDYC | RCC_CIR_LSERDYC | RCC_CIR_HSIRDYC | RCC_CIR_HSERDYC | RCC_CIR_PLLRDYC | RCC_CIR_CSSC);\r\n\r\n#if defined(RCC_CIR_PLLI2SRDYC)\r\n  SET_BIT(RCC->CIR, RCC_CIR_PLLI2SRDYC);\r\n#endif /* RCC_CIR_PLLI2SRDYC */\r\n\r\n#if defined(RCC_CIR_PLLSAIRDYC)\r\n  SET_BIT(RCC->CIR, RCC_CIR_PLLSAIRDYC);\r\n#endif /* RCC_CIR_PLLSAIRDYC */\r\n\r\n  /* Clear LSION bit */\r\n  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);\r\n\r\n  /* Reset all CSR flags */\r\n  SET_BIT(RCC->CSR, RCC_CSR_RMVF);\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup RCC_LL_EF_Get_Freq\r\n  * @brief  Return the frequencies of different on chip clocks;  System, AHB, APB1 and APB2 buses clocks\r\n  *         and different peripheral clocks available on the device.\r\n  * @note   If SYSCLK source is HSI, function returns values based on HSI_VALUE(**)\r\n  * @note   If SYSCLK source is HSE, function returns values based on HSE_VALUE(***)\r\n  * @note   If SYSCLK source is PLL, function returns values based on HSE_VALUE(***)\r\n  *         or HSI_VALUE(**) multiplied/divided by the PLL factors.\r\n  * @note   (**) HSI_VALUE is a constant defined in this file (default value\r\n  *              16 MHz) but the real value may vary depending on the variations\r\n  *              in voltage and temperature.\r\n  * @note   (***) HSE_VALUE is a constant defined in this file (default value\r\n  *               25 MHz), user has to ensure that HSE_VALUE is same as the real\r\n  *               frequency of the crystal used. Otherwise, this function may\r\n  *               have wrong result.\r\n  * @note   The result of this function could be incorrect when using fractional\r\n  *         value for HSE crystal.\r\n  * @note   This function can be used by the user application to compute the\r\n  *         baud-rate for the communication peripherals or configure other parameters.\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return the frequencies of different on chip clocks;  System, AHB, APB1 and APB2 buses clocks\r\n  * @note   Each time SYSCLK, HCLK, PCLK1 and/or PCLK2 clock changes, this function\r\n  *         must be called to update structure fields. Otherwise, any\r\n  *         configuration based on this function will be incorrect.\r\n  * @param  RCC_Clocks pointer to a @ref LL_RCC_ClocksTypeDef structure which will hold the clocks frequencies\r\n  * @retval None\r\n  */\r\nvoid LL_RCC_GetSystemClocksFreq(LL_RCC_ClocksTypeDef *RCC_Clocks)\r\n{\r\n  /* Get SYSCLK frequency */\r\n  RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();\r\n\r\n  /* HCLK clock frequency */\r\n  RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);\r\n\r\n  /* PCLK1 clock frequency */\r\n  RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);\r\n\r\n  /* PCLK2 clock frequency */\r\n  RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);\r\n}\r\n\r\n#if defined(FMPI2C1)\r\n/**\r\n  * @brief  Return FMPI2Cx clock frequency\r\n  * @param  FMPI2CxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_FMPI2C1_CLKSOURCE\r\n  * @retval FMPI2C clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that HSI oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetFMPI2CClockFreq(uint32_t FMPI2CxSource)\r\n{\r\n  uint32_t FMPI2C_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_FMPI2C_CLKSOURCE(FMPI2CxSource));\r\n\r\n  if (FMPI2CxSource == LL_RCC_FMPI2C1_CLKSOURCE)\r\n  {\r\n    /* FMPI2C1 CLK clock frequency */\r\n    switch (LL_RCC_GetFMPI2CClockSource(FMPI2CxSource))\r\n    {\r\n      case LL_RCC_FMPI2C1_CLKSOURCE_SYSCLK: /* FMPI2C1 Clock is System Clock */\r\n        FMPI2C_frequency = RCC_GetSystemClockFreq();\r\n        break;\r\n\r\n      case LL_RCC_FMPI2C1_CLKSOURCE_HSI:    /* FMPI2C1 Clock is HSI Osc. */\r\n        if (LL_RCC_HSI_IsReady())\r\n        {\r\n          FMPI2C_frequency = HSI_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_FMPI2C1_CLKSOURCE_PCLK1:  /* FMPI2C1 Clock is PCLK1 */\r\n      default:\r\n        FMPI2C_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n        break;\r\n    }\r\n  }\r\n\r\n  return FMPI2C_frequency;\r\n}\r\n#endif /* FMPI2C1 */\r\n\r\n/**\r\n  * @brief  Return I2Sx clock frequency\r\n  * @param  I2SxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_I2S1_CLKSOURCE\r\n  *         @arg @ref LL_RCC_I2S2_CLKSOURCE (*)\r\n  *\r\n  *         (*) value not defined in all devices.\r\n  * @retval I2S clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetI2SClockFreq(uint32_t I2SxSource)\r\n{\r\n  uint32_t i2s_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_I2S_CLKSOURCE(I2SxSource));\r\n\r\n  if (I2SxSource == LL_RCC_I2S1_CLKSOURCE)\r\n  {\r\n    /* I2S1 CLK clock frequency */\r\n    switch (LL_RCC_GetI2SClockSource(I2SxSource))\r\n    {\r\n#if defined(RCC_PLLI2S_SUPPORT)\r\n      case LL_RCC_I2S1_CLKSOURCE_PLLI2S:       /* I2S1 Clock is PLLI2S */\r\n        if (LL_RCC_PLLI2S_IsReady())\r\n        {\r\n          i2s_frequency = RCC_PLLI2S_GetFreqDomain_I2S();\r\n        }\r\n        break;\r\n#endif /* RCC_PLLI2S_SUPPORT */\r\n\r\n#if defined(RCC_DCKCFGR_I2SSRC) || defined(RCC_DCKCFGR_I2S1SRC)\r\n      case LL_RCC_I2S1_CLKSOURCE_PLL:          /* I2S1 Clock is PLL */\r\n        if (LL_RCC_PLL_IsReady())\r\n        {\r\n          i2s_frequency = RCC_PLL_GetFreqDomain_I2S();\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_I2S1_CLKSOURCE_PLLSRC:       /* I2S1 Clock is PLL Main source */\r\n        switch (LL_RCC_PLL_GetMainSource())\r\n        {\r\n           case LL_RCC_PLLSOURCE_HSE:          /* I2S1 Clock is HSE Osc. */\r\n             if (LL_RCC_HSE_IsReady())\r\n             {\r\n               i2s_frequency = HSE_VALUE;\r\n             }\r\n             break;\r\n\r\n           case LL_RCC_PLLSOURCE_HSI:          /* I2S1 Clock is HSI Osc. */\r\n           default:\r\n             if (LL_RCC_HSI_IsReady())\r\n             {\r\n               i2s_frequency = HSI_VALUE;\r\n             }\r\n             break;\r\n        }\r\n        break;\r\n#endif /* RCC_DCKCFGR_I2SSRC || RCC_DCKCFGR_I2S1SRC */\r\n\r\n      case LL_RCC_I2S1_CLKSOURCE_PIN:          /* I2S1 Clock is External clock */\r\n      default:\r\n        i2s_frequency = EXTERNAL_CLOCK_VALUE;\r\n        break;\r\n    }\r\n  }\r\n#if defined(RCC_DCKCFGR_I2S2SRC)\r\n  else\r\n  {\r\n    /* I2S2 CLK clock frequency */\r\n    switch (LL_RCC_GetI2SClockSource(I2SxSource))\r\n    {\r\n      case LL_RCC_I2S2_CLKSOURCE_PLLI2S:       /* I2S2 Clock is PLLI2S */\r\n        if (LL_RCC_PLLI2S_IsReady())\r\n        {\r\n          i2s_frequency = RCC_PLLI2S_GetFreqDomain_I2S();\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_I2S2_CLKSOURCE_PLL:          /* I2S2 Clock is PLL */\r\n        if (LL_RCC_PLL_IsReady())\r\n        {\r\n          i2s_frequency = RCC_PLL_GetFreqDomain_I2S();\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_I2S2_CLKSOURCE_PLLSRC:       /* I2S2 Clock is PLL Main source */\r\n        switch (LL_RCC_PLL_GetMainSource())\r\n        {\r\n           case LL_RCC_PLLSOURCE_HSE:          /* I2S2 Clock is HSE Osc. */\r\n             if (LL_RCC_HSE_IsReady())\r\n             {\r\n               i2s_frequency = HSE_VALUE;\r\n             }\r\n             break;\r\n\r\n           case LL_RCC_PLLSOURCE_HSI:          /* I2S2 Clock is HSI Osc. */\r\n           default:\r\n             if (LL_RCC_HSI_IsReady())\r\n             {\r\n               i2s_frequency = HSI_VALUE;\r\n             }\r\n             break;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_I2S2_CLKSOURCE_PIN:          /* I2S2 Clock is External clock */\r\n      default:\r\n        i2s_frequency = EXTERNAL_CLOCK_VALUE;\r\n        break;\r\n    } \r\n  }\r\n#endif /* RCC_DCKCFGR_I2S2SRC */\r\n\r\n  return i2s_frequency;\r\n}\r\n\r\n#if defined(LPTIM1)\r\n/**\r\n  * @brief  Return LPTIMx clock frequency\r\n  * @param  LPTIMxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_LPTIM1_CLKSOURCE\r\n  * @retval LPTIM clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI, LSI or LSE) is not ready\r\n  */\r\nuint32_t LL_RCC_GetLPTIMClockFreq(uint32_t LPTIMxSource)\r\n{\r\n  uint32_t lptim_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_LPTIM_CLKSOURCE(LPTIMxSource));\r\n\r\n  if (LPTIMxSource == LL_RCC_LPTIM1_CLKSOURCE)\r\n  {\r\n    /* LPTIM1CLK clock frequency */\r\n    switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))\r\n    {\r\n      case LL_RCC_LPTIM1_CLKSOURCE_LSI:    /* LPTIM1 Clock is LSI Osc. */\r\n        if (LL_RCC_LSI_IsReady())\r\n        {\r\n          lptim_frequency = LSI_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_LPTIM1_CLKSOURCE_HSI:    /* LPTIM1 Clock is HSI Osc. */\r\n        if (LL_RCC_HSI_IsReady())\r\n        {\r\n          lptim_frequency = HSI_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_LPTIM1_CLKSOURCE_LSE:    /* LPTIM1 Clock is LSE Osc. */\r\n        if (LL_RCC_LSE_IsReady())\r\n        {\r\n          lptim_frequency = LSE_VALUE;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_LPTIM1_CLKSOURCE_PCLK1:  /* LPTIM1 Clock is PCLK1 */\r\n      default:\r\n        lptim_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n        break;\r\n    }\r\n  }\r\n\r\n  return lptim_frequency;\r\n}\r\n#endif /* LPTIM1 */\r\n\r\n#if defined(SAI1)\r\n/**\r\n  * @brief  Return SAIx clock frequency\r\n  * @param  SAIxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_SAI1_CLKSOURCE (*)\r\n  *         @arg @ref LL_RCC_SAI2_CLKSOURCE (*)\r\n  *         @arg @ref LL_RCC_SAI1_A_CLKSOURCE (*)\r\n  *         @arg @ref LL_RCC_SAI1_B_CLKSOURCE (*)\r\n  *\r\n  *         (*) value not defined in all devices.\r\n  * @retval SAI clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetSAIClockFreq(uint32_t SAIxSource)\r\n{\r\n  uint32_t sai_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_SAI_CLKSOURCE(SAIxSource));\r\n\r\n#if defined(RCC_DCKCFGR_SAI1SRC)\r\n  if ((SAIxSource == LL_RCC_SAI1_CLKSOURCE) || (SAIxSource == LL_RCC_SAI2_CLKSOURCE))\r\n  {\r\n    /* SAI1CLK clock frequency */\r\n    switch (LL_RCC_GetSAIClockSource(SAIxSource))\r\n    {\r\n      case LL_RCC_SAI1_CLKSOURCE_PLLSAI:     /* PLLSAI clock used as SAI1 clock source */\r\n      case LL_RCC_SAI2_CLKSOURCE_PLLSAI:     /* PLLSAI clock used as SAI2 clock source */\r\n        if (LL_RCC_PLLSAI_IsReady())\r\n        {\r\n          sai_frequency = RCC_PLLSAI_GetFreqDomain_SAI();\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_SAI1_CLKSOURCE_PLLI2S:     /* PLLI2S clock used as SAI1 clock source */\r\n      case LL_RCC_SAI2_CLKSOURCE_PLLI2S:     /* PLLI2S clock used as SAI2 clock source */\r\n        if (LL_RCC_PLLI2S_IsReady())\r\n        {\r\n          sai_frequency = RCC_PLLI2S_GetFreqDomain_SAI();\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_SAI1_CLKSOURCE_PLL:        /* PLL clock used as SAI1 clock source */\r\n      case LL_RCC_SAI2_CLKSOURCE_PLL:        /* PLL clock used as SAI2 clock source */\r\n        if (LL_RCC_PLL_IsReady())\r\n        {\r\n          sai_frequency = RCC_PLL_GetFreqDomain_SAI();\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_SAI2_CLKSOURCE_PLLSRC:\r\n        switch (LL_RCC_PLL_GetMainSource())\r\n        {\r\n           case LL_RCC_PLLSOURCE_HSE:        /* HSE clock used as SAI2 clock source */\r\n             if (LL_RCC_HSE_IsReady())\r\n             {\r\n               sai_frequency = HSE_VALUE;\r\n             }\r\n             break;\r\n\r\n           case LL_RCC_PLLSOURCE_HSI:        /* HSI clock used as SAI2 clock source */\r\n           default:\r\n             if (LL_RCC_HSI_IsReady())\r\n             {\r\n               sai_frequency = HSI_VALUE;\r\n             }\r\n             break;\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_SAI1_CLKSOURCE_PIN:        /* External input clock used as SAI1 clock source */\r\n      default:\r\n        sai_frequency = EXTERNAL_CLOCK_VALUE;\r\n        break;\r\n    }\r\n  }\r\n#endif /* RCC_DCKCFGR_SAI1SRC */\r\n#if defined(RCC_DCKCFGR_SAI1ASRC)\r\n  if ((SAIxSource == LL_RCC_SAI1_A_CLKSOURCE) || (SAIxSource == LL_RCC_SAI1_B_CLKSOURCE))\r\n  {\r\n    /* SAI1CLK clock frequency */\r\n    switch (LL_RCC_GetSAIClockSource(SAIxSource))\r\n    {\r\n#if defined(RCC_PLLSAI_SUPPORT)\r\n      case LL_RCC_SAI1_A_CLKSOURCE_PLLSAI:     /* PLLSAI clock used as SAI1 Block A clock source */\r\n      case LL_RCC_SAI1_B_CLKSOURCE_PLLSAI:     /* PLLSAI clock used as SAI1 Block B clock source */\r\n        if (LL_RCC_PLLSAI_IsReady())\r\n        {\r\n          sai_frequency = RCC_PLLSAI_GetFreqDomain_SAI();\r\n        }\r\n        break;\r\n#endif /* RCC_PLLSAI_SUPPORT */\r\n\r\n      case LL_RCC_SAI1_A_CLKSOURCE_PLLI2S:     /* PLLI2S clock used as SAI1 Block A clock source */\r\n      case LL_RCC_SAI1_B_CLKSOURCE_PLLI2S:     /* PLLI2S clock used as SAI1 Block B clock source */\r\n        if (LL_RCC_PLLI2S_IsReady())\r\n        {\r\n          sai_frequency = RCC_PLLI2S_GetFreqDomain_SAI();\r\n        }\r\n        break;\r\n\r\n#if defined(RCC_SAI1A_PLLSOURCE_SUPPORT)\r\n      case LL_RCC_SAI1_A_CLKSOURCE_PLL:        /* PLL clock used as SAI1 Block A clock source */\r\n      case LL_RCC_SAI1_B_CLKSOURCE_PLL:        /* PLL clock used as SAI1 Block B clock source */\r\n        if (LL_RCC_PLL_IsReady())\r\n        {\r\n          sai_frequency = RCC_PLL_GetFreqDomain_SAI();\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_SAI1_A_CLKSOURCE_PLLSRC:\r\n      case LL_RCC_SAI1_B_CLKSOURCE_PLLSRC:\r\n        switch (LL_RCC_PLL_GetMainSource())\r\n        {\r\n           case LL_RCC_PLLSOURCE_HSE:          /* HSE clock used as SAI1 Block A or B clock source */\r\n             if (LL_RCC_HSE_IsReady())\r\n             {\r\n               sai_frequency = HSE_VALUE;\r\n             }\r\n             break;\r\n\r\n           case LL_RCC_PLLSOURCE_HSI:          /* HSI clock used as SAI1 Block A or B clock source */\r\n           default:\r\n             if (LL_RCC_HSI_IsReady())\r\n             {\r\n               sai_frequency = HSI_VALUE;\r\n             }\r\n             break;\r\n        }\r\n        break;\r\n#endif /* RCC_SAI1A_PLLSOURCE_SUPPORT */\r\n\r\n      case LL_RCC_SAI1_A_CLKSOURCE_PIN:        /* External input clock used as SAI1 Block A clock source */\r\n      case LL_RCC_SAI1_B_CLKSOURCE_PIN:        /* External input clock used as SAI1 Block B clock source */\r\n      default:\r\n        sai_frequency = EXTERNAL_CLOCK_VALUE;\r\n        break;\r\n    }\r\n  }\r\n#endif /* RCC_DCKCFGR_SAI1ASRC */\r\n\r\n  return sai_frequency;\r\n}\r\n#endif /* SAI1 */\r\n\r\n#if defined(SDIO)\r\n/**\r\n  * @brief  Return SDIOx clock frequency\r\n  * @param  SDIOxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_SDIO_CLKSOURCE\r\n  * @retval SDIO clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetSDIOClockFreq(uint32_t SDIOxSource)\r\n{\r\n  uint32_t SDIO_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_SDIO_CLKSOURCE(SDIOxSource));\r\n\r\n  if (SDIOxSource == LL_RCC_SDIO_CLKSOURCE)\r\n  {\r\n#if defined(RCC_DCKCFGR_SDIOSEL) || defined(RCC_DCKCFGR2_SDIOSEL)\r\n    /* SDIOCLK clock frequency */\r\n    switch (LL_RCC_GetSDIOClockSource(SDIOxSource))\r\n    {\r\n      case LL_RCC_SDIO_CLKSOURCE_PLL48CLK:         /* PLL48M clock used as SDIO clock source */\r\n        switch (LL_RCC_GetCK48MClockSource(LL_RCC_CK48M_CLKSOURCE))\r\n        {\r\n          case LL_RCC_CK48M_CLKSOURCE_PLL:         /* PLL clock used as 48Mhz domain clock */\r\n            if (LL_RCC_PLL_IsReady())\r\n            {\r\n              SDIO_frequency = RCC_PLL_GetFreqDomain_48M();\r\n            }\r\n          break;\r\n\r\n#if defined(RCC_PLLSAI_SUPPORT)\r\n          case LL_RCC_CK48M_CLKSOURCE_PLLSAI:      /* PLLSAI clock used as 48Mhz domain clock */\r\n          default:\r\n            if (LL_RCC_PLLSAI_IsReady())\r\n            {\r\n              SDIO_frequency = RCC_PLLSAI_GetFreqDomain_48M();\r\n            }\r\n            break;\r\n#endif /* RCC_PLLSAI_SUPPORT */\r\n\r\n#if defined(RCC_PLLI2SCFGR_PLLI2SQ) && !defined(RCC_DCKCFGR_PLLI2SDIVQ)\r\n          case LL_RCC_CK48M_CLKSOURCE_PLLI2S:      /* PLLI2S clock used as 48Mhz domain clock */\r\n          default:\r\n            if (LL_RCC_PLLI2S_IsReady())\r\n            {\r\n              SDIO_frequency = RCC_PLLI2S_GetFreqDomain_48M();\r\n            }\r\n            break;\r\n#endif /* RCC_PLLI2SCFGR_PLLI2SQ && !RCC_DCKCFGR_PLLI2SDIVQ */\r\n        }\r\n        break;\r\n\r\n      case LL_RCC_SDIO_CLKSOURCE_SYSCLK:           /* PLL clock used as SDIO clock source */\r\n      default:\r\n      SDIO_frequency = RCC_GetSystemClockFreq();\r\n      break;\r\n    }\r\n#else\r\n    /* PLL clock used as 48Mhz domain clock */\r\n    if (LL_RCC_PLL_IsReady())\r\n    {\r\n      SDIO_frequency = RCC_PLL_GetFreqDomain_48M();\r\n    }\r\n#endif /* RCC_DCKCFGR_SDIOSEL || RCC_DCKCFGR2_SDIOSEL */\r\n  }\r\n\r\n  return SDIO_frequency;\r\n}\r\n#endif /* SDIO */\r\n\r\n#if defined(RNG)\r\n/**\r\n  * @brief  Return RNGx clock frequency\r\n  * @param  RNGxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_RNG_CLKSOURCE\r\n  * @retval RNG clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetRNGClockFreq(uint32_t RNGxSource)\r\n{\r\n  uint32_t rng_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_RNG_CLKSOURCE(RNGxSource));\r\n\r\n#if defined(RCC_DCKCFGR_CK48MSEL) || defined(RCC_DCKCFGR2_CK48MSEL)\r\n  /* RNGCLK clock frequency */\r\n  switch (LL_RCC_GetRNGClockSource(RNGxSource))\r\n  {\r\n#if defined(RCC_PLLI2SCFGR_PLLI2SQ) && !defined(RCC_DCKCFGR_PLLI2SDIVQ)\r\n    case LL_RCC_RNG_CLKSOURCE_PLLI2S:        /* PLLI2S clock used as RNG clock source */\r\n      if (LL_RCC_PLLI2S_IsReady())\r\n      {\r\n        rng_frequency = RCC_PLLI2S_GetFreqDomain_48M();\r\n      }\r\n      break;\r\n#endif /* RCC_PLLI2SCFGR_PLLI2SQ && !RCC_DCKCFGR_PLLI2SDIVQ */\r\n\r\n#if defined(RCC_PLLSAI_SUPPORT)\r\n    case LL_RCC_RNG_CLKSOURCE_PLLSAI:        /* PLLSAI clock used as RNG clock source */\r\n      if (LL_RCC_PLLSAI_IsReady())\r\n      {\r\n        rng_frequency = RCC_PLLSAI_GetFreqDomain_48M();\r\n      }\r\n      break;\r\n#endif /* RCC_PLLSAI_SUPPORT */\r\n\r\n    case LL_RCC_RNG_CLKSOURCE_PLL:           /* PLL clock used as RNG clock source */\r\n    default:\r\n      if (LL_RCC_PLL_IsReady())\r\n      {\r\n        rng_frequency = RCC_PLL_GetFreqDomain_48M();\r\n      }\r\n      break;\r\n  }\r\n#else\r\n  /* PLL clock used as RNG clock source */\r\n  if (LL_RCC_PLL_IsReady())\r\n  {\r\n    rng_frequency = RCC_PLL_GetFreqDomain_48M();\r\n  }\r\n#endif /* RCC_DCKCFGR_CK48MSEL || RCC_DCKCFGR2_CK48MSEL */\r\n\r\n  return rng_frequency;\r\n}\r\n#endif /* RNG */\r\n\r\n#if defined(CEC)\r\n/**\r\n  * @brief  Return CEC clock frequency\r\n  * @param  CECxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_CEC_CLKSOURCE\r\n  * @retval CEC clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI or LSE) is not ready\r\n  */\r\nuint32_t LL_RCC_GetCECClockFreq(uint32_t CECxSource)\r\n{\r\n  uint32_t cec_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_CEC_CLKSOURCE(CECxSource));\r\n\r\n  /* CECCLK clock frequency */\r\n  switch (LL_RCC_GetCECClockSource(CECxSource))\r\n  {\r\n    case LL_RCC_CEC_CLKSOURCE_LSE:           /* CEC Clock is LSE Osc. */\r\n      if (LL_RCC_LSE_IsReady())\r\n      {\r\n        cec_frequency = LSE_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_CEC_CLKSOURCE_HSI_DIV488:    /* CEC Clock is HSI Osc. */\r\n    default:\r\n      if (LL_RCC_HSI_IsReady())\r\n      {\r\n        cec_frequency = HSI_VALUE/488U;\r\n      }\r\n      break;\r\n  }\r\n\r\n  return cec_frequency;\r\n}\r\n#endif /* CEC */\r\n\r\n#if defined(USB_OTG_FS) || defined(USB_OTG_HS)\r\n/**\r\n  * @brief  Return USBx clock frequency\r\n  * @param  USBxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_USB_CLKSOURCE\r\n  * @retval USB clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetUSBClockFreq(uint32_t USBxSource)\r\n{\r\n  uint32_t usb_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_USB_CLKSOURCE(USBxSource));\r\n\r\n#if defined(RCC_DCKCFGR_CK48MSEL) || defined(RCC_DCKCFGR2_CK48MSEL)\r\n  /* USBCLK clock frequency */\r\n  switch (LL_RCC_GetUSBClockSource(USBxSource))\r\n  {\r\n#if defined(RCC_PLLI2SCFGR_PLLI2SQ) && !defined(RCC_DCKCFGR_PLLI2SDIVQ)\r\n    case LL_RCC_USB_CLKSOURCE_PLLI2S:       /* PLLI2S clock used as USB clock source */\r\n      if (LL_RCC_PLLI2S_IsReady())\r\n      {\r\n        usb_frequency = RCC_PLLI2S_GetFreqDomain_48M();\r\n      }\r\n      break;\r\n\r\n#endif /* RCC_PLLI2SCFGR_PLLI2SQ && !RCC_DCKCFGR_PLLI2SDIVQ */\r\n\r\n#if defined(RCC_PLLSAI_SUPPORT)\r\n    case LL_RCC_USB_CLKSOURCE_PLLSAI:       /* PLLSAI clock used as USB clock source */\r\n      if (LL_RCC_PLLSAI_IsReady())\r\n      {\r\n        usb_frequency = RCC_PLLSAI_GetFreqDomain_48M();\r\n      }\r\n      break;\r\n#endif /* RCC_PLLSAI_SUPPORT */\r\n\r\n    case LL_RCC_USB_CLKSOURCE_PLL:          /* PLL clock used as USB clock source */\r\n    default:\r\n      if (LL_RCC_PLL_IsReady())\r\n      {\r\n        usb_frequency = RCC_PLL_GetFreqDomain_48M();\r\n      }\r\n      break;\r\n  }\r\n#else\r\n  /* PLL clock used as USB clock source */\r\n  if (LL_RCC_PLL_IsReady())\r\n  {\r\n    usb_frequency = RCC_PLL_GetFreqDomain_48M();\r\n  }\r\n#endif /* RCC_DCKCFGR_CK48MSEL || RCC_DCKCFGR2_CK48MSEL */\r\n\r\n  return usb_frequency;\r\n}\r\n#endif /* USB_OTG_FS || USB_OTG_HS */\r\n\r\n#if defined(DFSDM1_Channel0)\r\n/**\r\n  * @brief  Return DFSDMx clock frequency\r\n  * @param  DFSDMxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_DFSDM1_CLKSOURCE\r\n  *         @arg @ref LL_RCC_DFSDM2_CLKSOURCE (*)\r\n  *\r\n  *         (*) value not defined in all devices.\r\n  * @retval DFSDM clock frequency (in Hz)\r\n  */\r\nuint32_t LL_RCC_GetDFSDMClockFreq(uint32_t DFSDMxSource)\r\n{\r\n  uint32_t dfsdm_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_DFSDM_CLKSOURCE(DFSDMxSource));\r\n\r\n  if (DFSDMxSource == LL_RCC_DFSDM1_CLKSOURCE)\r\n  {\r\n    /* DFSDM1CLK clock frequency */\r\n    switch (LL_RCC_GetDFSDMClockSource(DFSDMxSource))\r\n    {\r\n      case LL_RCC_DFSDM1_CLKSOURCE_SYSCLK:      /* DFSDM1 Clock is SYSCLK */\r\n        dfsdm_frequency = RCC_GetSystemClockFreq();\r\n        break;\r\n\r\n      case LL_RCC_DFSDM1_CLKSOURCE_PCLK2:       /* DFSDM1 Clock is PCLK2 */\r\n      default:\r\n        dfsdm_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n        break;\r\n    }\r\n  }\r\n#if defined(DFSDM2_Channel0)\r\n  else\r\n  {\r\n    /* DFSDM2CLK clock frequency */\r\n    switch (LL_RCC_GetDFSDMClockSource(DFSDMxSource))\r\n    {\r\n      case LL_RCC_DFSDM2_CLKSOURCE_SYSCLK:      /* DFSDM2 Clock is SYSCLK */\r\n        dfsdm_frequency = RCC_GetSystemClockFreq();\r\n        break;\r\n\r\n      case LL_RCC_DFSDM2_CLKSOURCE_PCLK2:       /* DFSDM2 Clock is PCLK2 */\r\n      default:\r\n        dfsdm_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));\r\n        break;\r\n    }\r\n  }\r\n#endif /* DFSDM2_Channel0 */\r\n\r\n  return dfsdm_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return DFSDMx Audio clock frequency\r\n  * @param  DFSDMxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_DFSDM1_AUDIO_CLKSOURCE\r\n  *         @arg @ref LL_RCC_DFSDM2_AUDIO_CLKSOURCE (*)\r\n  *\r\n  *         (*) value not defined in all devices.\r\n  * @retval DFSDM clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetDFSDMAudioClockFreq(uint32_t DFSDMxSource)\r\n{\r\n  uint32_t dfsdm_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_DFSDM_AUDIO_CLKSOURCE(DFSDMxSource));\r\n\r\n  if (DFSDMxSource == LL_RCC_DFSDM1_AUDIO_CLKSOURCE)\r\n  {\r\n    /* DFSDM1CLK clock frequency */\r\n    switch (LL_RCC_GetDFSDMAudioClockSource(DFSDMxSource))\r\n    {\r\n      case LL_RCC_DFSDM1_AUDIO_CLKSOURCE_I2S1:     /* I2S1 clock used as DFSDM1 clock */\r\n        dfsdm_frequency = LL_RCC_GetI2SClockFreq(LL_RCC_I2S1_CLKSOURCE);\r\n        break;\r\n\r\n      case LL_RCC_DFSDM1_AUDIO_CLKSOURCE_I2S2:     /* I2S2 clock used as DFSDM1 clock */\r\n      default:\r\n        dfsdm_frequency = LL_RCC_GetI2SClockFreq(LL_RCC_I2S2_CLKSOURCE);\r\n        break;\r\n    }\r\n  }\r\n#if defined(DFSDM2_Channel0)\r\n  else\r\n  {\r\n    /* DFSDM2CLK clock frequency */\r\n    switch (LL_RCC_GetDFSDMAudioClockSource(DFSDMxSource))\r\n    {\r\n      case LL_RCC_DFSDM2_AUDIO_CLKSOURCE_I2S1:     /* I2S1 clock used as DFSDM2 clock */\r\n        dfsdm_frequency = LL_RCC_GetI2SClockFreq(LL_RCC_I2S1_CLKSOURCE);\r\n        break;\r\n\r\n      case LL_RCC_DFSDM2_AUDIO_CLKSOURCE_I2S2:     /* I2S2 clock used as DFSDM2 clock */\r\n      default:\r\n        dfsdm_frequency = LL_RCC_GetI2SClockFreq(LL_RCC_I2S2_CLKSOURCE);\r\n        break;\r\n    }\r\n  }\r\n#endif /* DFSDM2_Channel0 */\r\n\r\n  return dfsdm_frequency;\r\n}\r\n#endif /* DFSDM1_Channel0 */\r\n\r\n#if defined(DSI)\r\n/**\r\n  * @brief  Return DSI clock frequency\r\n  * @param  DSIxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_DSI_CLKSOURCE\r\n  * @retval DSI clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NA indicates that external clock is used\r\n  */\r\nuint32_t LL_RCC_GetDSIClockFreq(uint32_t DSIxSource)\r\n{\r\n  uint32_t dsi_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_DSI_CLKSOURCE(DSIxSource));\r\n\r\n  /* DSICLK clock frequency */\r\n  switch (LL_RCC_GetDSIClockSource(DSIxSource))\r\n  {\r\n    case LL_RCC_DSI_CLKSOURCE_PLL:     /* DSI Clock is PLL Osc. */\r\n      if (LL_RCC_PLL_IsReady())\r\n      {\r\n        dsi_frequency = RCC_PLL_GetFreqDomain_DSI();\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_DSI_CLKSOURCE_PHY:    /* DSI Clock is DSI physical clock. */\r\n    default:\r\n      dsi_frequency = LL_RCC_PERIPH_FREQUENCY_NA;\r\n      break;\r\n  }\r\n\r\n  return dsi_frequency;\r\n}\r\n#endif /* DSI */\r\n\r\n#if defined(LTDC)\r\n/**\r\n  * @brief  Return LTDC clock frequency\r\n  * @param  LTDCxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_LTDC_CLKSOURCE\r\n  * @retval LTDC clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator PLLSAI is not ready\r\n  */\r\nuint32_t LL_RCC_GetLTDCClockFreq(uint32_t LTDCxSource)\r\n{\r\n  uint32_t ltdc_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_LTDC_CLKSOURCE(LTDCxSource));\r\n\r\n  if (LL_RCC_PLLSAI_IsReady())\r\n  {\r\n     ltdc_frequency = RCC_PLLSAI_GetFreqDomain_LTDC();\r\n  }\r\n\r\n  return ltdc_frequency;\r\n}\r\n#endif /* LTDC */\r\n\r\n#if defined(SPDIFRX)\r\n/**\r\n  * @brief  Return SPDIFRX clock frequency\r\n  * @param  SPDIFRXxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_SPDIFRX1_CLKSOURCE\r\n  * @retval SPDIFRX clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetSPDIFRXClockFreq(uint32_t SPDIFRXxSource)\r\n{\r\n  uint32_t spdifrx_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_SPDIFRX_CLKSOURCE(SPDIFRXxSource));\r\n\r\n  /* SPDIFRX1CLK clock frequency */\r\n  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))\r\n  {\r\n    case LL_RCC_SPDIFRX1_CLKSOURCE_PLLI2S:  /* SPDIFRX Clock is PLLI2S Osc. */\r\n      if (LL_RCC_PLLI2S_IsReady())\r\n      {\r\n        spdifrx_frequency = RCC_PLLI2S_GetFreqDomain_SPDIFRX();\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SPDIFRX1_CLKSOURCE_PLL:     /* SPDIFRX Clock is PLL Osc. */\r\n    default:\r\n      if (LL_RCC_PLL_IsReady())\r\n      {\r\n        spdifrx_frequency = RCC_PLL_GetFreqDomain_SPDIFRX();\r\n      }\r\n      break;\r\n  }\r\n\r\n  return spdifrx_frequency;\r\n}\r\n#endif /* SPDIFRX */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup RCC_LL_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return SYSTEM clock frequency\r\n  * @retval SYSTEM clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_GetSystemClockFreq(void)\r\n{\r\n  uint32_t frequency = 0U;\r\n\r\n  /* Get SYSCLK source -------------------------------------------------------*/\r\n  switch (LL_RCC_GetSysClkSource())\r\n  {\r\n    case LL_RCC_SYS_CLKSOURCE_STATUS_HSI:  /* HSI used as system clock  source */\r\n      frequency = HSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */\r\n      frequency = HSE_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_SYS_CLKSOURCE_STATUS_PLL:  /* PLL used as system clock  source */\r\n      frequency = RCC_PLL_GetFreqDomain_SYS(LL_RCC_SYS_CLKSOURCE_STATUS_PLL);\r\n      break;\r\n\r\n#if defined(RCC_PLLR_SYSCLK_SUPPORT)\r\n    case LL_RCC_SYS_CLKSOURCE_STATUS_PLLR: /* PLLR used as system clock  source */\r\n      frequency = RCC_PLL_GetFreqDomain_SYS(LL_RCC_SYS_CLKSOURCE_STATUS_PLLR);\r\n      break;\r\n#endif /* RCC_PLLR_SYSCLK_SUPPORT */\r\n\r\n    default:\r\n      frequency = HSI_VALUE;\r\n      break;\r\n  }\r\n\r\n  return frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return HCLK clock frequency\r\n  * @param  SYSCLK_Frequency SYSCLK clock frequency\r\n  * @retval HCLK clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)\r\n{\r\n  /* HCLK clock frequency */\r\n  return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());\r\n}\r\n\r\n/**\r\n  * @brief  Return PCLK1 clock frequency\r\n  * @param  HCLK_Frequency HCLK clock frequency\r\n  * @retval PCLK1 clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)\r\n{\r\n  /* PCLK1 clock frequency */\r\n  return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());\r\n}\r\n\r\n/**\r\n  * @brief  Return PCLK2 clock frequency\r\n  * @param  HCLK_Frequency HCLK clock frequency\r\n  * @retval PCLK2 clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)\r\n{\r\n  /* PCLK2 clock frequency */\r\n  return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());\r\n}\r\n\r\n/**\r\n  * @brief  Return PLL clock frequency used for system domain\r\n  * @param  SYSCLK_Source System clock source\r\n  * @retval PLL clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLL_GetFreqDomain_SYS(uint32_t SYSCLK_Source)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U, plloutputfreq = 0U;\r\n\r\n  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN\r\n     SYSCLK = PLL_VCO / (PLLP or PLLR)\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n\r\n  if (SYSCLK_Source == LL_RCC_SYS_CLKSOURCE_STATUS_PLL)\r\n  {\r\n    plloutputfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetP());\r\n  }\r\n#if defined(RCC_PLLR_SYSCLK_SUPPORT)\r\n  else\r\n  {\r\n    plloutputfreq = __LL_RCC_CALC_PLLRCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());\r\n  }\r\n#endif /* RCC_PLLR_SYSCLK_SUPPORT */\r\n\r\n  return plloutputfreq;\r\n}\r\n\r\n/**\r\n  * @brief  Return PLL clock frequency used for 48 MHz domain\r\n  * @retval PLL clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLL_GetFreqDomain_48M(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM ) * PLLN\r\n     48M Domain clock = PLL_VCO / PLLQ\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLCLK_48M_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetQ());\r\n}\r\n\r\n#if defined(DSI)\r\n/**\r\n  * @brief  Return PLL clock frequency used for DSI clock\r\n  * @retval PLL clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLL_GetFreqDomain_DSI(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN\r\n     DSICLK = PLL_VCO / PLLR\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLCLK_DSI_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());\r\n}\r\n#endif /* DSI */\r\n\r\n#if defined(RCC_DCKCFGR_I2SSRC) || defined(RCC_DCKCFGR_I2S1SRC)\r\n/**\r\n  * @brief  Return PLL clock frequency used for I2S clock\r\n  * @retval PLL clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLL_GetFreqDomain_I2S(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN\r\n     I2SCLK = PLL_VCO / PLLR\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLCLK_I2S_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());\r\n}\r\n#endif /* RCC_DCKCFGR_I2SSRC || RCC_DCKCFGR_I2S1SRC */\r\n\r\n#if defined(SPDIFRX)\r\n/**\r\n  * @brief  Return PLL clock frequency used for SPDIFRX clock\r\n  * @retval PLL clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLL_GetFreqDomain_SPDIFRX(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN\r\n     SPDIFRXCLK = PLL_VCO / PLLR\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLCLK_SPDIFRX_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());\r\n}\r\n#endif /* SPDIFRX */\r\n\r\n#if defined(RCC_PLLCFGR_PLLR)\r\n#if defined(SAI1)\r\n/**\r\n  * @brief  Return PLL clock frequency used for SAI clock\r\n  * @retval PLL clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLL_GetFreqDomain_SAI(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U, plloutputfreq = 0U;\r\n\r\n  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN\r\n     SAICLK = (PLL_VCO / PLLR) / PLLDIVR\r\n     or\r\n     SAICLK = PLL_VCO / PLLR\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n\r\n#if defined(RCC_DCKCFGR_PLLDIVR)\r\n  plloutputfreq = __LL_RCC_CALC_PLLCLK_SAI_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR(), LL_RCC_PLL_GetDIVR());\r\n#else\r\n  plloutputfreq = __LL_RCC_CALC_PLLCLK_SAI_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),\r\n                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());\r\n#endif /* RCC_DCKCFGR_PLLDIVR */\r\n\r\n  return plloutputfreq;\r\n}\r\n#endif /* SAI1 */\r\n#endif /* RCC_PLLCFGR_PLLR */\r\n\r\n#if defined(RCC_PLLSAI_SUPPORT)\r\n/**\r\n  * @brief  Return PLLSAI clock frequency used for SAI domain\r\n  * @retval PLLSAI clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLLSAI_GetFreqDomain_SAI(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLLSAI_VCO = (HSE_VALUE or HSI_VALUE / PLLSAIM) * PLLSAIN\r\n     SAI domain clock  = (PLLSAI_VCO / PLLSAIQ) / PLLSAIDIVQ\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI clock source */\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLSAI_SAI_FREQ(pllinputfreq, LL_RCC_PLLSAI_GetDivider(),\r\n                                        LL_RCC_PLLSAI_GetN(), LL_RCC_PLLSAI_GetQ(), LL_RCC_PLLSAI_GetDIVQ());\r\n}\r\n\r\n#if defined(RCC_PLLSAICFGR_PLLSAIP)\r\n/**\r\n  * @brief  Return PLLSAI clock frequency used for 48Mhz domain\r\n  * @retval PLLSAI clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLLSAI_GetFreqDomain_48M(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLLSAI_VCO = (HSE_VALUE or HSI_VALUE / PLLSAIM) * PLLSAIN\r\n     48M Domain clock  = PLLSAI_VCO / PLLSAIP\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI clock source */\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLSAI_48M_FREQ(pllinputfreq, LL_RCC_PLLSAI_GetDivider(),\r\n                                        LL_RCC_PLLSAI_GetN(), LL_RCC_PLLSAI_GetP());\r\n}\r\n#endif /* RCC_PLLSAICFGR_PLLSAIP */\r\n\r\n#if defined(LTDC)\r\n/**\r\n  * @brief  Return PLLSAI clock frequency used for LTDC domain\r\n  * @retval PLLSAI clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLLSAI_GetFreqDomain_LTDC(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLLSAI_VCO = (HSE_VALUE or HSI_VALUE / PLLSAIM) * PLLSAIN\r\n     LTDC Domain clock  = (PLLSAI_VCO / PLLSAIR) / PLLSAIDIVR\r\n  */\r\n  pllsource = LL_RCC_PLL_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI clock source */\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n  return __LL_RCC_CALC_PLLSAI_LTDC_FREQ(pllinputfreq, LL_RCC_PLLSAI_GetDivider(),\r\n                                        LL_RCC_PLLSAI_GetN(), LL_RCC_PLLSAI_GetR(), LL_RCC_PLLSAI_GetDIVR());\r\n}\r\n#endif /* LTDC */\r\n#endif /* RCC_PLLSAI_SUPPORT */\r\n\r\n#if defined(RCC_PLLI2S_SUPPORT)\r\n#if defined(SAI1)\r\n/**\r\n  * @brief  Return PLLI2S clock frequency used for SAI domains\r\n  * @retval PLLI2S clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLLI2S_GetFreqDomain_SAI(void)\r\n{\r\n  uint32_t plli2sinputfreq = 0U, plli2ssource = 0U, plli2soutputfreq = 0U;\r\n\r\n  /* PLLI2S_VCO = (HSE_VALUE or HSI_VALUE / PLLI2SM) * PLLI2SN\r\n     SAI domain clock  = (PLLI2S_VCO / PLLI2SQ) / PLLI2SDIVQ\r\n     or\r\n     SAI domain clock  = (PLLI2S_VCO / PLLI2SR) / PLLI2SDIVR\r\n  */\r\n  plli2ssource = LL_RCC_PLLI2S_GetMainSource();\r\n\r\n  switch (plli2ssource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSE:     /* HSE used as PLLI2S clock source */\r\n      plli2sinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n#if defined(RCC_PLLI2SCFGR_PLLI2SSRC)\r\n    case LL_RCC_PLLI2SSOURCE_PIN:  /* External pin input clock used as PLLI2S clock source */\r\n      plli2sinputfreq = EXTERNAL_CLOCK_VALUE;\r\n      break;\r\n#endif /* RCC_PLLI2SCFGR_PLLI2SSRC */\r\n\r\n    case LL_RCC_PLLSOURCE_HSI:     /* HSI used as PLLI2S clock source */\r\n    default:\r\n      plli2sinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n\r\n#if defined(RCC_DCKCFGR_PLLI2SDIVQ)\r\n  plli2soutputfreq = __LL_RCC_CALC_PLLI2S_SAI_FREQ(plli2sinputfreq, LL_RCC_PLLI2S_GetDivider(),\r\n                                          LL_RCC_PLLI2S_GetN(), LL_RCC_PLLI2S_GetQ(), LL_RCC_PLLI2S_GetDIVQ());\r\n#else\r\n  plli2soutputfreq = __LL_RCC_CALC_PLLI2S_SAI_FREQ(plli2sinputfreq, LL_RCC_PLLI2S_GetDivider(),\r\n                                          LL_RCC_PLLI2S_GetN(), LL_RCC_PLLI2S_GetR(), LL_RCC_PLLI2S_GetDIVR());\r\n#endif /* RCC_DCKCFGR_PLLI2SDIVQ */\r\n\r\n  return plli2soutputfreq;\r\n}\r\n#endif /* SAI1 */\r\n\r\n#if defined(SPDIFRX)\r\n/**\r\n  * @brief  Return PLLI2S clock frequency used for SPDIFRX domain\r\n  * @retval PLLI2S clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLLI2S_GetFreqDomain_SPDIFRX(void)\r\n{\r\n  uint32_t pllinputfreq = 0U, pllsource = 0U;\r\n\r\n  /* PLLI2S_VCO = (HSE_VALUE or HSI_VALUE / PLLI2SM) * PLLI2SN\r\n     SPDIFRX Domain clock  = PLLI2S_VCO / PLLI2SP\r\n  */\r\n  pllsource = LL_RCC_PLLI2S_GetMainSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLI2S clock source */\r\n      pllinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLI2S clock source */\r\n    default:\r\n      pllinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n\r\n  return __LL_RCC_CALC_PLLI2S_SPDIFRX_FREQ(pllinputfreq, LL_RCC_PLLI2S_GetDivider(),\r\n                                           LL_RCC_PLLI2S_GetN(), LL_RCC_PLLI2S_GetP());\r\n}\r\n#endif /* SPDIFRX */\r\n\r\n/**\r\n  * @brief  Return PLLI2S clock frequency used for I2S domain\r\n  * @retval PLLI2S clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLLI2S_GetFreqDomain_I2S(void)\r\n{\r\n  uint32_t plli2sinputfreq = 0U, plli2ssource = 0U, plli2soutputfreq = 0U;\r\n\r\n  /* PLLI2S_VCO = (HSE_VALUE or HSI_VALUE / PLLI2SM) * PLLI2SN\r\n     I2S Domain clock  = PLLI2S_VCO / PLLI2SR\r\n  */\r\n  plli2ssource = LL_RCC_PLLI2S_GetMainSource();\r\n\r\n  switch (plli2ssource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSE:     /* HSE used as PLLI2S clock source */\r\n      plli2sinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n#if defined(RCC_PLLI2SCFGR_PLLI2SSRC)\r\n    case LL_RCC_PLLI2SSOURCE_PIN:  /* External pin input clock used as PLLI2S clock source */\r\n      plli2sinputfreq = EXTERNAL_CLOCK_VALUE;\r\n      break;\r\n#endif /* RCC_PLLI2SCFGR_PLLI2SSRC */\r\n\r\n    case LL_RCC_PLLSOURCE_HSI:     /* HSI used as PLLI2S clock source */\r\n    default:\r\n      plli2sinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n\r\n  plli2soutputfreq = __LL_RCC_CALC_PLLI2S_I2S_FREQ(plli2sinputfreq, LL_RCC_PLLI2S_GetDivider(),\r\n                                                   LL_RCC_PLLI2S_GetN(), LL_RCC_PLLI2S_GetR());\r\n\r\n  return plli2soutputfreq;\r\n}\r\n\r\n#if defined(RCC_PLLI2SCFGR_PLLI2SQ) && !defined(RCC_DCKCFGR_PLLI2SDIVQ)\r\n/**\r\n  * @brief  Return PLLI2S clock frequency used for 48Mhz domain\r\n  * @retval PLLI2S clock frequency (in Hz)\r\n  */\r\nuint32_t RCC_PLLI2S_GetFreqDomain_48M(void)\r\n{\r\n  uint32_t plli2sinputfreq = 0U, plli2ssource = 0U, plli2soutputfreq = 0U;\r\n\r\n  /* PLL48M_VCO = (HSE_VALUE or HSI_VALUE / PLLI2SM) * PLLI2SN\r\n     48M Domain clock  = PLLI2S_VCO / PLLI2SQ\r\n  */\r\n  plli2ssource = LL_RCC_PLLI2S_GetMainSource();\r\n\r\n  switch (plli2ssource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSE:     /* HSE used as PLLI2S clock source */\r\n      plli2sinputfreq = HSE_VALUE;\r\n      break;\r\n\r\n#if defined(RCC_PLLI2SCFGR_PLLI2SSRC)\r\n    case LL_RCC_PLLI2SSOURCE_PIN:  /* External pin input clock used as PLLI2S clock source */\r\n      plli2sinputfreq = EXTERNAL_CLOCK_VALUE;\r\n      break;\r\n#endif /* RCC_PLLI2SCFGR_PLLI2SSRC */\r\n\r\n    case LL_RCC_PLLSOURCE_HSI:     /* HSI used as PLLI2S clock source */\r\n    default:\r\n      plli2sinputfreq = HSI_VALUE;\r\n      break;\r\n  }\r\n\r\n  plli2soutputfreq = __LL_RCC_CALC_PLLI2S_48M_FREQ(plli2sinputfreq, LL_RCC_PLLI2S_GetDivider(),\r\n                                                   LL_RCC_PLLI2S_GetN(), LL_RCC_PLLI2S_GetQ());\r\n\r\n  return plli2soutputfreq;\r\n}\r\n#endif /* RCC_PLLI2SCFGR_PLLI2SQ && !RCC_DCKCFGR_PLLI2SDIVQ */\r\n#endif /* RCC_PLLI2S_SUPPORT */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* defined(RCC) */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_ll_tim.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_ll_tim.c\r\n  * @author  MCD Application Team\r\n  * @brief   TIM LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_ll_tim.h\"\r\n#include \"stm32f4xx_ll_bus.h\"\r\n\r\n#ifdef  USE_FULL_ASSERT\r\n#include \"stm32_assert.h\"\r\n#else\r\n#define assert_param(expr) ((void)0U)\r\n#endif /* USE_FULL_ASSERT */\r\n\r\n/** @addtogroup STM32F4xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined (TIM1) || defined (TIM2) || defined (TIM3) || defined (TIM4) || defined (TIM5) || defined (TIM6) || defined (TIM7) || defined (TIM8) || defined (TIM9) || defined (TIM10) || defined (TIM11) || defined (TIM12) || defined (TIM13) || defined (TIM14)\r\n\r\n/** @addtogroup TIM_LL\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup TIM_LL_Private_Macros\r\n  * @{\r\n  */\r\n#define IS_LL_TIM_COUNTERMODE(__VALUE__) (((__VALUE__) == LL_TIM_COUNTERMODE_UP) \\\r\n                                          || ((__VALUE__) == LL_TIM_COUNTERMODE_DOWN) \\\r\n                                          || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_UP) \\\r\n                                          || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_DOWN) \\\r\n                                          || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_UP_DOWN))\r\n\r\n#define IS_LL_TIM_CLOCKDIVISION(__VALUE__) (((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV1) \\\r\n                                            || ((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV2) \\\r\n                                            || ((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV4))\r\n\r\n#define IS_LL_TIM_OCMODE(__VALUE__) (((__VALUE__) == LL_TIM_OCMODE_FROZEN) \\\r\n                                     || ((__VALUE__) == LL_TIM_OCMODE_ACTIVE) \\\r\n                                     || ((__VALUE__) == LL_TIM_OCMODE_INACTIVE) \\\r\n                                     || ((__VALUE__) == LL_TIM_OCMODE_TOGGLE) \\\r\n                                     || ((__VALUE__) == LL_TIM_OCMODE_FORCED_INACTIVE) \\\r\n                                     || ((__VALUE__) == LL_TIM_OCMODE_FORCED_ACTIVE) \\\r\n                                     || ((__VALUE__) == LL_TIM_OCMODE_PWM1) \\\r\n                                     || ((__VALUE__) == LL_TIM_OCMODE_PWM2))\r\n\r\n#define IS_LL_TIM_OCSTATE(__VALUE__) (((__VALUE__) == LL_TIM_OCSTATE_DISABLE) \\\r\n                                      || ((__VALUE__) == LL_TIM_OCSTATE_ENABLE))\r\n\r\n#define IS_LL_TIM_OCPOLARITY(__VALUE__) (((__VALUE__) == LL_TIM_OCPOLARITY_HIGH) \\\r\n                                         || ((__VALUE__) == LL_TIM_OCPOLARITY_LOW))\r\n\r\n#define IS_LL_TIM_OCIDLESTATE(__VALUE__) (((__VALUE__) == LL_TIM_OCIDLESTATE_LOW) \\\r\n                                          || ((__VALUE__) == LL_TIM_OCIDLESTATE_HIGH))\r\n\r\n#define IS_LL_TIM_ACTIVEINPUT(__VALUE__) (((__VALUE__) == LL_TIM_ACTIVEINPUT_DIRECTTI) \\\r\n                                          || ((__VALUE__) == LL_TIM_ACTIVEINPUT_INDIRECTTI) \\\r\n                                          || ((__VALUE__) == LL_TIM_ACTIVEINPUT_TRC))\r\n\r\n#define IS_LL_TIM_ICPSC(__VALUE__) (((__VALUE__) == LL_TIM_ICPSC_DIV1) \\\r\n                                    || ((__VALUE__) == LL_TIM_ICPSC_DIV2) \\\r\n                                    || ((__VALUE__) == LL_TIM_ICPSC_DIV4) \\\r\n                                    || ((__VALUE__) == LL_TIM_ICPSC_DIV8))\r\n\r\n#define IS_LL_TIM_IC_FILTER(__VALUE__) (((__VALUE__) == LL_TIM_IC_FILTER_FDIV1) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N2) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N4) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N8) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV2_N6) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV2_N8) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV4_N6) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV4_N8) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV8_N6) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV8_N8) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N5) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N6) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N8) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N5) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N6) \\\r\n                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N8))\r\n\r\n#define IS_LL_TIM_IC_POLARITY(__VALUE__) (((__VALUE__) == LL_TIM_IC_POLARITY_RISING) \\\r\n                                          || ((__VALUE__) == LL_TIM_IC_POLARITY_FALLING) \\\r\n                                          || ((__VALUE__) == LL_TIM_IC_POLARITY_BOTHEDGE))\r\n\r\n#define IS_LL_TIM_ENCODERMODE(__VALUE__) (((__VALUE__) == LL_TIM_ENCODERMODE_X2_TI1) \\\r\n                                          || ((__VALUE__) == LL_TIM_ENCODERMODE_X2_TI2) \\\r\n                                          || ((__VALUE__) == LL_TIM_ENCODERMODE_X4_TI12))\r\n\r\n#define IS_LL_TIM_IC_POLARITY_ENCODER(__VALUE__) (((__VALUE__) == LL_TIM_IC_POLARITY_RISING) \\\r\n                                                  || ((__VALUE__) == LL_TIM_IC_POLARITY_FALLING))\r\n\r\n#define IS_LL_TIM_OSSR_STATE(__VALUE__) (((__VALUE__) == LL_TIM_OSSR_DISABLE) \\\r\n                                         || ((__VALUE__) == LL_TIM_OSSR_ENABLE))\r\n\r\n#define IS_LL_TIM_OSSI_STATE(__VALUE__) (((__VALUE__) == LL_TIM_OSSI_DISABLE) \\\r\n                                         || ((__VALUE__) == LL_TIM_OSSI_ENABLE))\r\n\r\n#define IS_LL_TIM_LOCK_LEVEL(__VALUE__) (((__VALUE__) == LL_TIM_LOCKLEVEL_OFF) \\\r\n                                         || ((__VALUE__) == LL_TIM_LOCKLEVEL_1)   \\\r\n                                         || ((__VALUE__) == LL_TIM_LOCKLEVEL_2)   \\\r\n                                         || ((__VALUE__) == LL_TIM_LOCKLEVEL_3))\r\n\r\n#define IS_LL_TIM_BREAK_STATE(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_DISABLE) \\\r\n                                          || ((__VALUE__) == LL_TIM_BREAK_ENABLE))\r\n\r\n#define IS_LL_TIM_BREAK_POLARITY(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_POLARITY_LOW) \\\r\n                                             || ((__VALUE__) == LL_TIM_BREAK_POLARITY_HIGH))\r\n\r\n#define IS_LL_TIM_AUTOMATIC_OUTPUT_STATE(__VALUE__) (((__VALUE__) == LL_TIM_AUTOMATICOUTPUT_DISABLE) \\\r\n                                                     || ((__VALUE__) == LL_TIM_AUTOMATICOUTPUT_ENABLE))\r\n/**\r\n  * @}\r\n  */\r\n\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @defgroup TIM_LL_Private_Functions TIM Private Functions\r\n  * @{\r\n  */\r\nstatic ErrorStatus OC1Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);\r\nstatic ErrorStatus OC2Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);\r\nstatic ErrorStatus OC3Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);\r\nstatic ErrorStatus OC4Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);\r\nstatic ErrorStatus IC1Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);\r\nstatic ErrorStatus IC2Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);\r\nstatic ErrorStatus IC3Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);\r\nstatic ErrorStatus IC4Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup TIM_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup TIM_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Set TIMx registers to their reset values.\r\n  * @param  TIMx Timer instance\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: TIMx registers are de-initialized\r\n  *          - ERROR: invalid TIMx instance\r\n  */\r\nErrorStatus LL_TIM_DeInit(TIM_TypeDef *TIMx)\r\n{\r\n  ErrorStatus result = SUCCESS;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(TIMx));\r\n\r\n  if (TIMx == TIM1)\r\n  {\r\n    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM1);\r\n    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM1);\r\n  }\r\n#if defined(TIM2)\r\n  else if (TIMx == TIM2)\r\n  {\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM2);\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM2);\r\n  }\r\n#endif /* TIM2 */\r\n#if defined(TIM3)\r\n  else if (TIMx == TIM3)\r\n  {\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM3);\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM3);\r\n  }\r\n#endif /* TIM3 */\r\n#if defined(TIM4)\r\n  else if (TIMx == TIM4)\r\n  {\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM4);\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM4);\r\n  }\r\n#endif /* TIM4 */\r\n#if defined(TIM5)\r\n  else if (TIMx == TIM5)\r\n  {\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM5);\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM5);\r\n  }\r\n#endif /* TIM5 */\r\n#if defined(TIM6)\r\n  else if (TIMx == TIM6)\r\n  {\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM6);\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM6);\r\n  }\r\n#endif /* TIM6 */\r\n#if defined (TIM7)\r\n  else if (TIMx == TIM7)\r\n  {\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM7);\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM7);\r\n  }\r\n#endif /* TIM7 */\r\n#if defined(TIM8)\r\n  else if (TIMx == TIM8)\r\n  {\r\n    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM8);\r\n    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM8);\r\n  }\r\n#endif /* TIM8 */\r\n#if defined(TIM9)\r\n  else if (TIMx == TIM9)\r\n  {\r\n    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM9);\r\n    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM9);\r\n  }\r\n#endif /* TIM9 */\r\n#if defined(TIM10)\r\n  else if (TIMx == TIM10)\r\n  {\r\n    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM10);\r\n    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM10);\r\n  }\r\n#endif /* TIM10 */\r\n#if defined(TIM11)\r\n  else if (TIMx == TIM11)\r\n  {\r\n    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM11);\r\n    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM11);\r\n  }\r\n#endif /* TIM11 */\r\n#if defined(TIM12)\r\n  else if (TIMx == TIM12)\r\n  {\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM12);\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM12);\r\n  }\r\n#endif /* TIM12 */\r\n#if defined(TIM13)\r\n  else if (TIMx == TIM13)\r\n  {\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM13);\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM13);\r\n  }\r\n#endif /* TIM13 */\r\n#if defined(TIM14)\r\n  else if (TIMx == TIM14)\r\n  {\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM14);\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM14);\r\n  }\r\n#endif /* TIM14 */\r\n  else\r\n  {\r\n    result = ERROR;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n  * @brief  Set the fields of the time base unit configuration data structure\r\n  *         to their default values.\r\n  * @param  TIM_InitStruct pointer to a @ref LL_TIM_InitTypeDef structure (time base unit configuration data structure)\r\n  * @retval None\r\n  */\r\nvoid LL_TIM_StructInit(LL_TIM_InitTypeDef *TIM_InitStruct)\r\n{\r\n  /* Set the default configuration */\r\n  TIM_InitStruct->Prescaler         = (uint16_t)0x0000;\r\n  TIM_InitStruct->CounterMode       = LL_TIM_COUNTERMODE_UP;\r\n  TIM_InitStruct->Autoreload        = 0xFFFFFFFFU;\r\n  TIM_InitStruct->ClockDivision     = LL_TIM_CLOCKDIVISION_DIV1;\r\n  TIM_InitStruct->RepetitionCounter = 0x00000000U;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIMx time base unit.\r\n  * @param  TIMx Timer Instance\r\n  * @param  TIM_InitStruct pointer to a @ref LL_TIM_InitTypeDef structure\r\n  *         (TIMx time base unit configuration data structure)\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: TIMx registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nErrorStatus LL_TIM_Init(TIM_TypeDef *TIMx, LL_TIM_InitTypeDef *TIM_InitStruct)\r\n{\r\n  uint32_t tmpcr1;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(TIMx));\r\n  assert_param(IS_LL_TIM_COUNTERMODE(TIM_InitStruct->CounterMode));\r\n  assert_param(IS_LL_TIM_CLOCKDIVISION(TIM_InitStruct->ClockDivision));\r\n\r\n  tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);\r\n\r\n  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))\r\n  {\r\n    /* Select the Counter Mode */\r\n    MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);\r\n  }\r\n\r\n  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))\r\n  {\r\n    /* Set the clock division */\r\n    MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);\r\n  }\r\n\r\n  /* Write to TIMx CR1 */\r\n  LL_TIM_WriteReg(TIMx, CR1, tmpcr1);\r\n\r\n  /* Set the Autoreload value */\r\n  LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);\r\n\r\n  /* Set the Prescaler value */\r\n  LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);\r\n\r\n  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))\r\n  {\r\n    /* Set the Repetition Counter value */\r\n    LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);\r\n  }\r\n\r\n  /* Generate an update event to reload the Prescaler\r\n     and the repetition counter value (if applicable) immediately */\r\n  LL_TIM_GenerateEvent_UPDATE(TIMx);\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Set the fields of the TIMx output channel configuration data\r\n  *         structure to their default values.\r\n  * @param  TIM_OC_InitStruct pointer to a @ref LL_TIM_OC_InitTypeDef structure\r\n  *         (the output channel configuration data structure)\r\n  * @retval None\r\n  */\r\nvoid LL_TIM_OC_StructInit(LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct)\r\n{\r\n  /* Set the default configuration */\r\n  TIM_OC_InitStruct->OCMode       = LL_TIM_OCMODE_FROZEN;\r\n  TIM_OC_InitStruct->OCState      = LL_TIM_OCSTATE_DISABLE;\r\n  TIM_OC_InitStruct->OCNState     = LL_TIM_OCSTATE_DISABLE;\r\n  TIM_OC_InitStruct->CompareValue = 0x00000000U;\r\n  TIM_OC_InitStruct->OCPolarity   = LL_TIM_OCPOLARITY_HIGH;\r\n  TIM_OC_InitStruct->OCNPolarity  = LL_TIM_OCPOLARITY_HIGH;\r\n  TIM_OC_InitStruct->OCIdleState  = LL_TIM_OCIDLESTATE_LOW;\r\n  TIM_OC_InitStruct->OCNIdleState = LL_TIM_OCIDLESTATE_LOW;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIMx output channel.\r\n  * @param  TIMx Timer Instance\r\n  * @param  Channel This parameter can be one of the following values:\r\n  *         @arg @ref LL_TIM_CHANNEL_CH1\r\n  *         @arg @ref LL_TIM_CHANNEL_CH2\r\n  *         @arg @ref LL_TIM_CHANNEL_CH3\r\n  *         @arg @ref LL_TIM_CHANNEL_CH4\r\n  * @param  TIM_OC_InitStruct pointer to a @ref LL_TIM_OC_InitTypeDef structure (TIMx output channel configuration\r\n  *         data structure)\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: TIMx output channel is initialized\r\n  *          - ERROR: TIMx output channel is not initialized\r\n  */\r\nErrorStatus LL_TIM_OC_Init(TIM_TypeDef *TIMx, uint32_t Channel, LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct)\r\n{\r\n  ErrorStatus result = ERROR;\r\n\r\n  switch (Channel)\r\n  {\r\n    case LL_TIM_CHANNEL_CH1:\r\n      result = OC1Config(TIMx, TIM_OC_InitStruct);\r\n      break;\r\n    case LL_TIM_CHANNEL_CH2:\r\n      result = OC2Config(TIMx, TIM_OC_InitStruct);\r\n      break;\r\n    case LL_TIM_CHANNEL_CH3:\r\n      result = OC3Config(TIMx, TIM_OC_InitStruct);\r\n      break;\r\n    case LL_TIM_CHANNEL_CH4:\r\n      result = OC4Config(TIMx, TIM_OC_InitStruct);\r\n      break;\r\n    default:\r\n      break;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n  * @brief  Set the fields of the TIMx input channel configuration data\r\n  *         structure to their default values.\r\n  * @param  TIM_ICInitStruct pointer to a @ref LL_TIM_IC_InitTypeDef structure (the input channel configuration\r\n  *         data structure)\r\n  * @retval None\r\n  */\r\nvoid LL_TIM_IC_StructInit(LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)\r\n{\r\n  /* Set the default configuration */\r\n  TIM_ICInitStruct->ICPolarity    = LL_TIM_IC_POLARITY_RISING;\r\n  TIM_ICInitStruct->ICActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;\r\n  TIM_ICInitStruct->ICPrescaler   = LL_TIM_ICPSC_DIV1;\r\n  TIM_ICInitStruct->ICFilter      = LL_TIM_IC_FILTER_FDIV1;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIMx input channel.\r\n  * @param  TIMx Timer Instance\r\n  * @param  Channel This parameter can be one of the following values:\r\n  *         @arg @ref LL_TIM_CHANNEL_CH1\r\n  *         @arg @ref LL_TIM_CHANNEL_CH2\r\n  *         @arg @ref LL_TIM_CHANNEL_CH3\r\n  *         @arg @ref LL_TIM_CHANNEL_CH4\r\n  * @param  TIM_IC_InitStruct pointer to a @ref LL_TIM_IC_InitTypeDef structure (TIMx input channel configuration data\r\n  *         structure)\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: TIMx output channel is initialized\r\n  *          - ERROR: TIMx output channel is not initialized\r\n  */\r\nErrorStatus LL_TIM_IC_Init(TIM_TypeDef *TIMx, uint32_t Channel, LL_TIM_IC_InitTypeDef *TIM_IC_InitStruct)\r\n{\r\n  ErrorStatus result = ERROR;\r\n\r\n  switch (Channel)\r\n  {\r\n    case LL_TIM_CHANNEL_CH1:\r\n      result = IC1Config(TIMx, TIM_IC_InitStruct);\r\n      break;\r\n    case LL_TIM_CHANNEL_CH2:\r\n      result = IC2Config(TIMx, TIM_IC_InitStruct);\r\n      break;\r\n    case LL_TIM_CHANNEL_CH3:\r\n      result = IC3Config(TIMx, TIM_IC_InitStruct);\r\n      break;\r\n    case LL_TIM_CHANNEL_CH4:\r\n      result = IC4Config(TIMx, TIM_IC_InitStruct);\r\n      break;\r\n    default:\r\n      break;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n  * @brief  Fills each TIM_EncoderInitStruct field with its default value\r\n  * @param  TIM_EncoderInitStruct pointer to a @ref LL_TIM_ENCODER_InitTypeDef structure (encoder interface\r\n  *         configuration data structure)\r\n  * @retval None\r\n  */\r\nvoid LL_TIM_ENCODER_StructInit(LL_TIM_ENCODER_InitTypeDef *TIM_EncoderInitStruct)\r\n{\r\n  /* Set the default configuration */\r\n  TIM_EncoderInitStruct->EncoderMode    = LL_TIM_ENCODERMODE_X2_TI1;\r\n  TIM_EncoderInitStruct->IC1Polarity    = LL_TIM_IC_POLARITY_RISING;\r\n  TIM_EncoderInitStruct->IC1ActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;\r\n  TIM_EncoderInitStruct->IC1Prescaler   = LL_TIM_ICPSC_DIV1;\r\n  TIM_EncoderInitStruct->IC1Filter      = LL_TIM_IC_FILTER_FDIV1;\r\n  TIM_EncoderInitStruct->IC2Polarity    = LL_TIM_IC_POLARITY_RISING;\r\n  TIM_EncoderInitStruct->IC2ActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;\r\n  TIM_EncoderInitStruct->IC2Prescaler   = LL_TIM_ICPSC_DIV1;\r\n  TIM_EncoderInitStruct->IC2Filter      = LL_TIM_IC_FILTER_FDIV1;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the encoder interface of the timer instance.\r\n  * @param  TIMx Timer Instance\r\n  * @param  TIM_EncoderInitStruct pointer to a @ref LL_TIM_ENCODER_InitTypeDef structure (TIMx encoder interface\r\n  *         configuration data structure)\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: TIMx registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nErrorStatus LL_TIM_ENCODER_Init(TIM_TypeDef *TIMx, LL_TIM_ENCODER_InitTypeDef *TIM_EncoderInitStruct)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx));\r\n  assert_param(IS_LL_TIM_ENCODERMODE(TIM_EncoderInitStruct->EncoderMode));\r\n  assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_EncoderInitStruct->IC1Polarity));\r\n  assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_EncoderInitStruct->IC1ActiveInput));\r\n  assert_param(IS_LL_TIM_ICPSC(TIM_EncoderInitStruct->IC1Prescaler));\r\n  assert_param(IS_LL_TIM_IC_FILTER(TIM_EncoderInitStruct->IC1Filter));\r\n  assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_EncoderInitStruct->IC2Polarity));\r\n  assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_EncoderInitStruct->IC2ActiveInput));\r\n  assert_param(IS_LL_TIM_ICPSC(TIM_EncoderInitStruct->IC2Prescaler));\r\n  assert_param(IS_LL_TIM_IC_FILTER(TIM_EncoderInitStruct->IC2Filter));\r\n\r\n  /* Disable the CC1 and CC2: Reset the CC1E and CC2E Bits */\r\n  TIMx->CCER &= (uint32_t)~(TIM_CCER_CC1E | TIM_CCER_CC2E);\r\n\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = LL_TIM_ReadReg(TIMx, CCER);\r\n\r\n  /* Configure TI1 */\r\n  tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC1S | TIM_CCMR1_IC1F  | TIM_CCMR1_IC1PSC);\r\n  tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1ActiveInput >> 16U);\r\n  tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1Filter >> 16U);\r\n  tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1Prescaler >> 16U);\r\n\r\n  /* Configure TI2 */\r\n  tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC2S | TIM_CCMR1_IC2F  | TIM_CCMR1_IC2PSC);\r\n  tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2ActiveInput >> 8U);\r\n  tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2Filter >> 8U);\r\n  tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2Prescaler >> 8U);\r\n\r\n  /* Set TI1 and TI2 polarity and enable TI1 and TI2 */\r\n  tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP | TIM_CCER_CC2P | TIM_CCER_CC2NP);\r\n  tmpccer |= (uint32_t)(TIM_EncoderInitStruct->IC1Polarity);\r\n  tmpccer |= (uint32_t)(TIM_EncoderInitStruct->IC2Polarity << 4U);\r\n  tmpccer |= (uint32_t)(TIM_CCER_CC1E | TIM_CCER_CC2E);\r\n\r\n  /* Set encoder mode */\r\n  LL_TIM_SetEncoderMode(TIMx, TIM_EncoderInitStruct->EncoderMode);\r\n\r\n  /* Write to TIMx CCMR1 */\r\n  LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);\r\n\r\n  /* Write to TIMx CCER */\r\n  LL_TIM_WriteReg(TIMx, CCER, tmpccer);\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Set the fields of the TIMx Hall sensor interface configuration data\r\n  *         structure to their default values.\r\n  * @param  TIM_HallSensorInitStruct pointer to a @ref LL_TIM_HALLSENSOR_InitTypeDef structure (HALL sensor interface\r\n  *         configuration data structure)\r\n  * @retval None\r\n  */\r\nvoid LL_TIM_HALLSENSOR_StructInit(LL_TIM_HALLSENSOR_InitTypeDef *TIM_HallSensorInitStruct)\r\n{\r\n  /* Set the default configuration */\r\n  TIM_HallSensorInitStruct->IC1Polarity       = LL_TIM_IC_POLARITY_RISING;\r\n  TIM_HallSensorInitStruct->IC1Prescaler      = LL_TIM_ICPSC_DIV1;\r\n  TIM_HallSensorInitStruct->IC1Filter         = LL_TIM_IC_FILTER_FDIV1;\r\n  TIM_HallSensorInitStruct->CommutationDelay  = 0U;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the Hall sensor interface of the timer instance.\r\n  * @note TIMx CH1, CH2 and CH3 inputs connected through a XOR\r\n  *       to the TI1 input channel\r\n  * @note TIMx slave mode controller is configured in reset mode.\r\n          Selected internal trigger is TI1F_ED.\r\n  * @note Channel 1 is configured as input, IC1 is mapped on TRC.\r\n  * @note Captured value stored in TIMx_CCR1 correspond to the time elapsed\r\n  *       between 2 changes on the inputs. It gives information about motor speed.\r\n  * @note Channel 2 is configured in output PWM 2 mode.\r\n  * @note Compare value stored in TIMx_CCR2 corresponds to the commutation delay.\r\n  * @note OC2REF is selected as trigger output on TRGO.\r\n  * @note LL_TIM_IC_POLARITY_BOTHEDGE must not be used for TI1 when it is used\r\n  *       when TIMx operates in Hall sensor interface mode.\r\n  * @param  TIMx Timer Instance\r\n  * @param  TIM_HallSensorInitStruct pointer to a @ref LL_TIM_HALLSENSOR_InitTypeDef structure (TIMx HALL sensor\r\n  *         interface configuration data structure)\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: TIMx registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nErrorStatus LL_TIM_HALLSENSOR_Init(TIM_TypeDef *TIMx, LL_TIM_HALLSENSOR_InitTypeDef *TIM_HallSensorInitStruct)\r\n{\r\n  uint32_t tmpcr2;\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(TIMx));\r\n  assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_HallSensorInitStruct->IC1Polarity));\r\n  assert_param(IS_LL_TIM_ICPSC(TIM_HallSensorInitStruct->IC1Prescaler));\r\n  assert_param(IS_LL_TIM_IC_FILTER(TIM_HallSensorInitStruct->IC1Filter));\r\n\r\n  /* Disable the CC1 and CC2: Reset the CC1E and CC2E Bits */\r\n  TIMx->CCER &= (uint32_t)~(TIM_CCER_CC1E | TIM_CCER_CC2E);\r\n\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);\r\n\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = LL_TIM_ReadReg(TIMx, CCER);\r\n\r\n  /* Get the TIMx SMCR register value */\r\n  tmpsmcr = LL_TIM_ReadReg(TIMx, SMCR);\r\n\r\n  /* Connect TIMx_CH1, CH2 and CH3 pins to the TI1 input */\r\n  tmpcr2 |= TIM_CR2_TI1S;\r\n\r\n  /* OC2REF signal is used as trigger output (TRGO) */\r\n  tmpcr2 |= LL_TIM_TRGO_OC2REF;\r\n\r\n  /* Configure the slave mode controller */\r\n  tmpsmcr &= (uint32_t)~(TIM_SMCR_TS | TIM_SMCR_SMS);\r\n  tmpsmcr |= LL_TIM_TS_TI1F_ED;\r\n  tmpsmcr |= LL_TIM_SLAVEMODE_RESET;\r\n\r\n  /* Configure input channel 1 */\r\n  tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC1S | TIM_CCMR1_IC1F  | TIM_CCMR1_IC1PSC);\r\n  tmpccmr1 |= (uint32_t)(LL_TIM_ACTIVEINPUT_TRC >> 16U);\r\n  tmpccmr1 |= (uint32_t)(TIM_HallSensorInitStruct->IC1Filter >> 16U);\r\n  tmpccmr1 |= (uint32_t)(TIM_HallSensorInitStruct->IC1Prescaler >> 16U);\r\n\r\n  /* Configure input channel 2 */\r\n  tmpccmr1 &= (uint32_t)~(TIM_CCMR1_OC2M | TIM_CCMR1_OC2FE  | TIM_CCMR1_OC2PE  | TIM_CCMR1_OC2CE);\r\n  tmpccmr1 |= (uint32_t)(LL_TIM_OCMODE_PWM2 << 8U);\r\n\r\n  /* Set Channel 1 polarity and enable Channel 1 and Channel2 */\r\n  tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP | TIM_CCER_CC2P | TIM_CCER_CC2NP);\r\n  tmpccer |= (uint32_t)(TIM_HallSensorInitStruct->IC1Polarity);\r\n  tmpccer |= (uint32_t)(TIM_CCER_CC1E | TIM_CCER_CC2E);\r\n\r\n  /* Write to TIMx CR2 */\r\n  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);\r\n\r\n  /* Write to TIMx SMCR */\r\n  LL_TIM_WriteReg(TIMx, SMCR, tmpsmcr);\r\n\r\n  /* Write to TIMx CCMR1 */\r\n  LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);\r\n\r\n  /* Write to TIMx CCER */\r\n  LL_TIM_WriteReg(TIMx, CCER, tmpccer);\r\n\r\n  /* Write to TIMx CCR2 */\r\n  LL_TIM_OC_SetCompareCH2(TIMx, TIM_HallSensorInitStruct->CommutationDelay);\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Set the fields of the Break and Dead Time configuration data structure\r\n  *         to their default values.\r\n  * @param  TIM_BDTRInitStruct pointer to a @ref LL_TIM_BDTR_InitTypeDef structure (Break and Dead Time configuration\r\n  *         data structure)\r\n  * @retval None\r\n  */\r\nvoid LL_TIM_BDTR_StructInit(LL_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct)\r\n{\r\n  /* Set the default configuration */\r\n  TIM_BDTRInitStruct->OSSRState       = LL_TIM_OSSR_DISABLE;\r\n  TIM_BDTRInitStruct->OSSIState       = LL_TIM_OSSI_DISABLE;\r\n  TIM_BDTRInitStruct->LockLevel       = LL_TIM_LOCKLEVEL_OFF;\r\n  TIM_BDTRInitStruct->DeadTime        = (uint8_t)0x00;\r\n  TIM_BDTRInitStruct->BreakState      = LL_TIM_BREAK_DISABLE;\r\n  TIM_BDTRInitStruct->BreakPolarity   = LL_TIM_BREAK_POLARITY_LOW;\r\n  TIM_BDTRInitStruct->AutomaticOutput = LL_TIM_AUTOMATICOUTPUT_DISABLE;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the Break and Dead Time feature of the timer instance.\r\n  * @note As the bits AOE, BKP, BKE, OSSR, OSSI and DTG[7:0] can be write-locked\r\n  *  depending on the LOCK configuration, it can be necessary to configure all of\r\n  *  them during the first write access to the TIMx_BDTR register.\r\n  * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not\r\n  *       a timer instance provides a break input.\r\n  * @param  TIMx Timer Instance\r\n  * @param  TIM_BDTRInitStruct pointer to a @ref LL_TIM_BDTR_InitTypeDef structure (Break and Dead Time configuration\r\n  *         data structure)\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: Break and Dead Time is initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nErrorStatus LL_TIM_BDTR_Init(TIM_TypeDef *TIMx, LL_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct)\r\n{\r\n  uint32_t tmpbdtr = 0;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_BREAK_INSTANCE(TIMx));\r\n  assert_param(IS_LL_TIM_OSSR_STATE(TIM_BDTRInitStruct->OSSRState));\r\n  assert_param(IS_LL_TIM_OSSI_STATE(TIM_BDTRInitStruct->OSSIState));\r\n  assert_param(IS_LL_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->LockLevel));\r\n  assert_param(IS_LL_TIM_BREAK_STATE(TIM_BDTRInitStruct->BreakState));\r\n  assert_param(IS_LL_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->BreakPolarity));\r\n  assert_param(IS_LL_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->AutomaticOutput));\r\n\r\n  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,\r\n  the OSSI State, the dead time value and the Automatic Output Enable Bit */\r\n\r\n  /* Set the BDTR bits */\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, TIM_BDTRInitStruct->DeadTime);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, TIM_BDTRInitStruct->LockLevel);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, TIM_BDTRInitStruct->OSSIState);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, TIM_BDTRInitStruct->OSSRState);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, TIM_BDTRInitStruct->BreakState);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, TIM_BDTRInitStruct->BreakPolarity);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, TIM_BDTRInitStruct->AutomaticOutput);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, TIM_BDTRInitStruct->AutomaticOutput);\r\n\r\n  /* Set TIMx_BDTR */\r\n  LL_TIM_WriteReg(TIMx, BDTR, tmpbdtr);\r\n\r\n  return SUCCESS;\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup TIM_LL_Private_Functions TIM Private Functions\r\n  *  @brief   Private functions\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Configure the TIMx output channel 1.\r\n  * @param  TIMx Timer Instance\r\n  * @param  TIM_OCInitStruct pointer to the the TIMx output channel 1 configuration data structure\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: TIMx registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nstatic ErrorStatus OC1Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CC1_INSTANCE(TIMx));\r\n  assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));\r\n  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));\r\n  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));\r\n  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));\r\n  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));\r\n\r\n  /* Disable the Channel 1: Reset the CC1E Bit */\r\n  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = LL_TIM_ReadReg(TIMx, CCER);\r\n\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);\r\n\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);\r\n\r\n  /* Reset Capture/Compare selection Bits */\r\n  CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC1S);\r\n\r\n  /* Set the Output Compare Mode */\r\n  MODIFY_REG(tmpccmr1, TIM_CCMR1_OC1M, TIM_OCInitStruct->OCMode);\r\n\r\n  /* Set the Output Compare Polarity */\r\n  MODIFY_REG(tmpccer, TIM_CCER_CC1P, TIM_OCInitStruct->OCPolarity);\r\n\r\n  /* Set the Output State */\r\n  MODIFY_REG(tmpccer, TIM_CCER_CC1E, TIM_OCInitStruct->OCState);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));\r\n    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));\r\n\r\n    /* Set the complementary output Polarity */\r\n    MODIFY_REG(tmpccer, TIM_CCER_CC1NP, TIM_OCInitStruct->OCNPolarity << 2U);\r\n\r\n    /* Set the complementary output State */\r\n    MODIFY_REG(tmpccer, TIM_CCER_CC1NE, TIM_OCInitStruct->OCNState << 2U);\r\n\r\n    /* Set the Output Idle state */\r\n    MODIFY_REG(tmpcr2, TIM_CR2_OIS1, TIM_OCInitStruct->OCIdleState);\r\n\r\n    /* Set the complementary output Idle state */\r\n    MODIFY_REG(tmpcr2, TIM_CR2_OIS1N, TIM_OCInitStruct->OCNIdleState << 1U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);\r\n\r\n  /* Write to TIMx CCMR1 */\r\n  LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);\r\n\r\n  /* Set the Capture Compare Register value */\r\n  LL_TIM_OC_SetCompareCH1(TIMx, TIM_OCInitStruct->CompareValue);\r\n\r\n  /* Write to TIMx CCER */\r\n  LL_TIM_WriteReg(TIMx, CCER, tmpccer);\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIMx output channel 2.\r\n  * @param  TIMx Timer Instance\r\n  * @param  TIM_OCInitStruct pointer to the the TIMx output channel 2 configuration data structure\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: TIMx registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nstatic ErrorStatus OC2Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CC2_INSTANCE(TIMx));\r\n  assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));\r\n  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));\r\n  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));\r\n  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));\r\n  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));\r\n\r\n  /* Disable the Channel 2: Reset the CC2E Bit */\r\n  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer =  LL_TIM_ReadReg(TIMx, CCER);\r\n\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);\r\n\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);\r\n\r\n  /* Reset Capture/Compare selection Bits */\r\n  CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC2S);\r\n\r\n  /* Select the Output Compare Mode */\r\n  MODIFY_REG(tmpccmr1, TIM_CCMR1_OC2M, TIM_OCInitStruct->OCMode << 8U);\r\n\r\n  /* Set the Output Compare Polarity */\r\n  MODIFY_REG(tmpccer, TIM_CCER_CC2P, TIM_OCInitStruct->OCPolarity << 4U);\r\n\r\n  /* Set the Output State */\r\n  MODIFY_REG(tmpccer, TIM_CCER_CC2E, TIM_OCInitStruct->OCState << 4U);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));\r\n    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));\r\n\r\n    /* Set the complementary output Polarity */\r\n    MODIFY_REG(tmpccer, TIM_CCER_CC2NP, TIM_OCInitStruct->OCNPolarity << 6U);\r\n\r\n    /* Set the complementary output State */\r\n    MODIFY_REG(tmpccer, TIM_CCER_CC2NE, TIM_OCInitStruct->OCNState << 6U);\r\n\r\n    /* Set the Output Idle state */\r\n    MODIFY_REG(tmpcr2, TIM_CR2_OIS2, TIM_OCInitStruct->OCIdleState << 2U);\r\n\r\n    /* Set the complementary output Idle state */\r\n    MODIFY_REG(tmpcr2, TIM_CR2_OIS2N, TIM_OCInitStruct->OCNIdleState << 3U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);\r\n\r\n  /* Write to TIMx CCMR1 */\r\n  LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);\r\n\r\n  /* Set the Capture Compare Register value */\r\n  LL_TIM_OC_SetCompareCH2(TIMx, TIM_OCInitStruct->CompareValue);\r\n\r\n  /* Write to TIMx CCER */\r\n  LL_TIM_WriteReg(TIMx, CCER, tmpccer);\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIMx output channel 3.\r\n  * @param  TIMx Timer Instance\r\n  * @param  TIM_OCInitStruct pointer to the the TIMx output channel 3 configuration data structure\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: TIMx registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nstatic ErrorStatus OC3Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)\r\n{\r\n  uint32_t tmpccmr2;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CC3_INSTANCE(TIMx));\r\n  assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));\r\n  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));\r\n  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));\r\n  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));\r\n  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));\r\n\r\n  /* Disable the Channel 3: Reset the CC3E Bit */\r\n  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer =  LL_TIM_ReadReg(TIMx, CCER);\r\n\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);\r\n\r\n  /* Get the TIMx CCMR2 register value */\r\n  tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);\r\n\r\n  /* Reset Capture/Compare selection Bits */\r\n  CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC3S);\r\n\r\n  /* Select the Output Compare Mode */\r\n  MODIFY_REG(tmpccmr2, TIM_CCMR2_OC3M, TIM_OCInitStruct->OCMode);\r\n\r\n  /* Set the Output Compare Polarity */\r\n  MODIFY_REG(tmpccer, TIM_CCER_CC3P, TIM_OCInitStruct->OCPolarity << 8U);\r\n\r\n  /* Set the Output State */\r\n  MODIFY_REG(tmpccer, TIM_CCER_CC3E, TIM_OCInitStruct->OCState << 8U);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));\r\n    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));\r\n\r\n    /* Set the complementary output Polarity */\r\n    MODIFY_REG(tmpccer, TIM_CCER_CC3NP, TIM_OCInitStruct->OCNPolarity << 10U);\r\n\r\n    /* Set the complementary output State */\r\n    MODIFY_REG(tmpccer, TIM_CCER_CC3NE, TIM_OCInitStruct->OCNState << 10U);\r\n\r\n    /* Set the Output Idle state */\r\n    MODIFY_REG(tmpcr2, TIM_CR2_OIS3, TIM_OCInitStruct->OCIdleState << 4U);\r\n\r\n    /* Set the complementary output Idle state */\r\n    MODIFY_REG(tmpcr2, TIM_CR2_OIS3N, TIM_OCInitStruct->OCNIdleState << 5U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);\r\n\r\n  /* Write to TIMx CCMR2 */\r\n  LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);\r\n\r\n  /* Set the Capture Compare Register value */\r\n  LL_TIM_OC_SetCompareCH3(TIMx, TIM_OCInitStruct->CompareValue);\r\n\r\n  /* Write to TIMx CCER */\r\n  LL_TIM_WriteReg(TIMx, CCER, tmpccer);\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIMx output channel 4.\r\n  * @param  TIMx Timer Instance\r\n  * @param  TIM_OCInitStruct pointer to the the TIMx output channel 4 configuration data structure\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: TIMx registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nstatic ErrorStatus OC4Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)\r\n{\r\n  uint32_t tmpccmr2;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CC4_INSTANCE(TIMx));\r\n  assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));\r\n  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));\r\n  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));\r\n  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));\r\n  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));\r\n\r\n  /* Disable the Channel 4: Reset the CC4E Bit */\r\n  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = LL_TIM_ReadReg(TIMx, CCER);\r\n\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  LL_TIM_ReadReg(TIMx, CR2);\r\n\r\n  /* Get the TIMx CCMR2 register value */\r\n  tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);\r\n\r\n  /* Reset Capture/Compare selection Bits */\r\n  CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC4S);\r\n\r\n  /* Select the Output Compare Mode */\r\n  MODIFY_REG(tmpccmr2, TIM_CCMR2_OC4M, TIM_OCInitStruct->OCMode << 8U);\r\n\r\n  /* Set the Output Compare Polarity */\r\n  MODIFY_REG(tmpccer, TIM_CCER_CC4P, TIM_OCInitStruct->OCPolarity << 12U);\r\n\r\n  /* Set the Output State */\r\n  MODIFY_REG(tmpccer, TIM_CCER_CC4E, TIM_OCInitStruct->OCState << 12U);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));\r\n    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));\r\n\r\n    /* Set the Output Idle state */\r\n    MODIFY_REG(tmpcr2, TIM_CR2_OIS4, TIM_OCInitStruct->OCIdleState << 6U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);\r\n\r\n  /* Write to TIMx CCMR2 */\r\n  LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);\r\n\r\n  /* Set the Capture Compare Register value */\r\n  LL_TIM_OC_SetCompareCH4(TIMx, TIM_OCInitStruct->CompareValue);\r\n\r\n  /* Write to TIMx CCER */\r\n  LL_TIM_WriteReg(TIMx, CCER, tmpccer);\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Configure the TIMx input channel 1.\r\n  * @param  TIMx Timer Instance\r\n  * @param  TIM_ICInitStruct pointer to the the TIMx input channel 1 configuration data structure\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: TIMx registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nstatic ErrorStatus IC1Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CC1_INSTANCE(TIMx));\r\n  assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));\r\n  assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));\r\n  assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));\r\n  assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));\r\n\r\n  /* Disable the Channel 1: Reset the CC1E Bit */\r\n  TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;\r\n\r\n  /* Select the Input and set the filter and the prescaler value */\r\n  MODIFY_REG(TIMx->CCMR1,\r\n             (TIM_CCMR1_CC1S | TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC),\r\n             (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 16U);\r\n\r\n  /* Select the Polarity and set the CC1E Bit */\r\n  MODIFY_REG(TIMx->CCER,\r\n             (TIM_CCER_CC1P | TIM_CCER_CC1NP),\r\n             (TIM_ICInitStruct->ICPolarity | TIM_CCER_CC1E));\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIMx input channel 2.\r\n  * @param  TIMx Timer Instance\r\n  * @param  TIM_ICInitStruct pointer to the the TIMx input channel 2 configuration data structure\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: TIMx registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nstatic ErrorStatus IC2Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CC2_INSTANCE(TIMx));\r\n  assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));\r\n  assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));\r\n  assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));\r\n  assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));\r\n\r\n  /* Disable the Channel 2: Reset the CC2E Bit */\r\n  TIMx->CCER &= (uint32_t)~TIM_CCER_CC2E;\r\n\r\n  /* Select the Input and set the filter and the prescaler value */\r\n  MODIFY_REG(TIMx->CCMR1,\r\n             (TIM_CCMR1_CC2S | TIM_CCMR1_IC2F | TIM_CCMR1_IC2PSC),\r\n             (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 8U);\r\n\r\n  /* Select the Polarity and set the CC2E Bit */\r\n  MODIFY_REG(TIMx->CCER,\r\n             (TIM_CCER_CC2P | TIM_CCER_CC2NP),\r\n             ((TIM_ICInitStruct->ICPolarity << 4U) | TIM_CCER_CC2E));\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIMx input channel 3.\r\n  * @param  TIMx Timer Instance\r\n  * @param  TIM_ICInitStruct pointer to the the TIMx input channel 3 configuration data structure\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: TIMx registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nstatic ErrorStatus IC3Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CC3_INSTANCE(TIMx));\r\n  assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));\r\n  assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));\r\n  assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));\r\n  assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));\r\n\r\n  /* Disable the Channel 3: Reset the CC3E Bit */\r\n  TIMx->CCER &= (uint32_t)~TIM_CCER_CC3E;\r\n\r\n  /* Select the Input and set the filter and the prescaler value */\r\n  MODIFY_REG(TIMx->CCMR2,\r\n             (TIM_CCMR2_CC3S | TIM_CCMR2_IC3F | TIM_CCMR2_IC3PSC),\r\n             (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 16U);\r\n\r\n  /* Select the Polarity and set the CC3E Bit */\r\n  MODIFY_REG(TIMx->CCER,\r\n             (TIM_CCER_CC3P | TIM_CCER_CC3NP),\r\n             ((TIM_ICInitStruct->ICPolarity << 8U) | TIM_CCER_CC3E));\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIMx input channel 4.\r\n  * @param  TIMx Timer Instance\r\n  * @param  TIM_ICInitStruct pointer to the the TIMx input channel 4 configuration data structure\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: TIMx registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nstatic ErrorStatus IC4Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CC4_INSTANCE(TIMx));\r\n  assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));\r\n  assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));\r\n  assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));\r\n  assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));\r\n\r\n  /* Disable the Channel 4: Reset the CC4E Bit */\r\n  TIMx->CCER &= (uint32_t)~TIM_CCER_CC4E;\r\n\r\n  /* Select the Input and set the filter and the prescaler value */\r\n  MODIFY_REG(TIMx->CCMR2,\r\n             (TIM_CCMR2_CC4S | TIM_CCMR2_IC4F | TIM_CCMR2_IC4PSC),\r\n             (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 8U);\r\n\r\n  /* Select the Polarity and set the CC2E Bit */\r\n  MODIFY_REG(TIMx->CCER,\r\n             (TIM_CCER_CC4P | TIM_CCER_CC4NP),\r\n             ((TIM_ICInitStruct->ICPolarity << 12U) | TIM_CCER_CC4E));\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* TIM1 || TIM2 || TIM3 || TIM4 || TIM5 || TIM6 || TIM7 || TIM8 || TIM9 || TIM10 || TIM11 || TIM12 || TIM13 || TIM14 */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm32f4xx_ll_usart.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_ll_usart.c\r\n  * @author  MCD Application Team\r\n  * @brief   USART LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_ll_usart.h\"\r\n#include \"stm32f4xx_ll_rcc.h\"\r\n#include \"stm32f4xx_ll_bus.h\"\r\n#ifdef  USE_FULL_ASSERT\r\n#include \"stm32_assert.h\"\r\n#else\r\n#define assert_param(expr) ((void)0U)\r\n#endif\r\n\r\n/** @addtogroup STM32F4xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined (USART1) || defined (USART2) || defined (USART3) || defined (USART6) || defined (UART4) || defined (UART5) || defined (UART7) || defined (UART8) || defined (UART9) || defined (UART10)\r\n\r\n/** @addtogroup USART_LL\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/** @addtogroup USART_LL_Private_Constants\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup USART_LL_Private_Macros\r\n  * @{\r\n  */\r\n\r\n/* __BAUDRATE__ The maximum Baud Rate is derived from the maximum clock available\r\n *              divided by the smallest oversampling used on the USART (i.e. 8)    */\r\n#define IS_LL_USART_BAUDRATE(__BAUDRATE__) ((__BAUDRATE__) <= 12500000U)\r\n\r\n/* __VALUE__ In case of oversampling by 16 and 8, BRR content must be greater than or equal to 16d. */\r\n#define IS_LL_USART_BRR_MIN(__VALUE__) ((__VALUE__) >= 16U)\r\n\r\n#define IS_LL_USART_DIRECTION(__VALUE__) (((__VALUE__) == LL_USART_DIRECTION_NONE) \\\r\n                                          || ((__VALUE__) == LL_USART_DIRECTION_RX) \\\r\n                                          || ((__VALUE__) == LL_USART_DIRECTION_TX) \\\r\n                                          || ((__VALUE__) == LL_USART_DIRECTION_TX_RX))\r\n\r\n#define IS_LL_USART_PARITY(__VALUE__) (((__VALUE__) == LL_USART_PARITY_NONE) \\\r\n                                       || ((__VALUE__) == LL_USART_PARITY_EVEN) \\\r\n                                       || ((__VALUE__) == LL_USART_PARITY_ODD))\r\n\r\n#define IS_LL_USART_DATAWIDTH(__VALUE__) (((__VALUE__) == LL_USART_DATAWIDTH_8B) \\\r\n                                          || ((__VALUE__) == LL_USART_DATAWIDTH_9B))\r\n\r\n#define IS_LL_USART_OVERSAMPLING(__VALUE__) (((__VALUE__) == LL_USART_OVERSAMPLING_16) \\\r\n                                             || ((__VALUE__) == LL_USART_OVERSAMPLING_8))\r\n\r\n#define IS_LL_USART_LASTBITCLKOUTPUT(__VALUE__) (((__VALUE__) == LL_USART_LASTCLKPULSE_NO_OUTPUT) \\\r\n                                                 || ((__VALUE__) == LL_USART_LASTCLKPULSE_OUTPUT))\r\n\r\n#define IS_LL_USART_CLOCKPHASE(__VALUE__) (((__VALUE__) == LL_USART_PHASE_1EDGE) \\\r\n                                           || ((__VALUE__) == LL_USART_PHASE_2EDGE))\r\n\r\n#define IS_LL_USART_CLOCKPOLARITY(__VALUE__) (((__VALUE__) == LL_USART_POLARITY_LOW) \\\r\n                                              || ((__VALUE__) == LL_USART_POLARITY_HIGH))\r\n\r\n#define IS_LL_USART_CLOCKOUTPUT(__VALUE__) (((__VALUE__) == LL_USART_CLOCK_DISABLE) \\\r\n                                            || ((__VALUE__) == LL_USART_CLOCK_ENABLE))\r\n\r\n#define IS_LL_USART_STOPBITS(__VALUE__) (((__VALUE__) == LL_USART_STOPBITS_0_5) \\\r\n                                         || ((__VALUE__) == LL_USART_STOPBITS_1) \\\r\n                                         || ((__VALUE__) == LL_USART_STOPBITS_1_5) \\\r\n                                         || ((__VALUE__) == LL_USART_STOPBITS_2))\r\n\r\n#define IS_LL_USART_HWCONTROL(__VALUE__) (((__VALUE__) == LL_USART_HWCONTROL_NONE) \\\r\n                                          || ((__VALUE__) == LL_USART_HWCONTROL_RTS) \\\r\n                                          || ((__VALUE__) == LL_USART_HWCONTROL_CTS) \\\r\n                                          || ((__VALUE__) == LL_USART_HWCONTROL_RTS_CTS))\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup USART_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup USART_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  De-initialize USART registers (Registers restored to their default values).\r\n  * @param  USARTx USART Instance\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: USART registers are de-initialized\r\n  *          - ERROR: USART registers are not de-initialized\r\n  */\r\nErrorStatus LL_USART_DeInit(USART_TypeDef *USARTx)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_UART_INSTANCE(USARTx));\r\n\r\n  if (USARTx == USART1)\r\n  {\r\n    /* Force reset of USART clock */\r\n    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_USART1);\r\n\r\n    /* Release reset of USART clock */\r\n    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_USART1);\r\n  }\r\n  else if (USARTx == USART2)\r\n  {\r\n    /* Force reset of USART clock */\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_USART2);\r\n\r\n    /* Release reset of USART clock */\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_USART2);\r\n  }\r\n#if defined(USART3)\r\n  else if (USARTx == USART3)\r\n  {\r\n    /* Force reset of USART clock */\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_USART3);\r\n\r\n    /* Release reset of USART clock */\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_USART3);\r\n  }\r\n#endif /* USART3 */\r\n#if defined(USART6)\r\n  else if (USARTx == USART6)\r\n  {\r\n    /* Force reset of USART clock */\r\n    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_USART6);\r\n\r\n    /* Release reset of USART clock */\r\n    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_USART6);\r\n  }\r\n#endif /* USART6 */\r\n#if defined(UART4)\r\n  else if (USARTx == UART4)\r\n  {\r\n    /* Force reset of UART clock */\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_UART4);\r\n\r\n    /* Release reset of UART clock */\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_UART4);\r\n  }\r\n#endif /* UART4 */\r\n#if defined(UART5)\r\n  else if (USARTx == UART5)\r\n  {\r\n    /* Force reset of UART clock */\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_UART5);\r\n\r\n    /* Release reset of UART clock */\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_UART5);\r\n  }\r\n#endif /* UART5 */\r\n#if defined(UART7)\r\n  else if (USARTx == UART7)\r\n  {\r\n    /* Force reset of UART clock */\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_UART7);\r\n\r\n    /* Release reset of UART clock */\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_UART7);\r\n  }\r\n#endif /* UART7 */\r\n#if defined(UART8)\r\n  else if (USARTx == UART8)\r\n  {\r\n    /* Force reset of UART clock */\r\n    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_UART8);\r\n\r\n    /* Release reset of UART clock */\r\n    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_UART8);\r\n  }\r\n#endif /* UART8 */\r\n#if defined(UART9)\r\n  else if (USARTx == UART9)\r\n  {\r\n    /* Force reset of UART clock */\r\n    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_UART9);\r\n\r\n    /* Release reset of UART clock */\r\n    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_UART9);\r\n  }\r\n#endif /* UART9 */\r\n#if defined(UART10)\r\n  else if (USARTx == UART10)\r\n  {\r\n    /* Force reset of UART clock */\r\n    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_UART10);\r\n\r\n    /* Release reset of UART clock */\r\n    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_UART10);\r\n  }\r\n#endif /* UART10 */\r\n  else\r\n  {\r\n    status = ERROR;\r\n  }\r\n\r\n  return (status);\r\n}\r\n\r\n/**\r\n  * @brief  Initialize USART registers according to the specified\r\n  *         parameters in USART_InitStruct.\r\n  * @note   As some bits in USART configuration registers can only be written when the USART is disabled (USART_CR1_UE bit =0),\r\n  *         USART IP should be in disabled state prior calling this function. Otherwise, ERROR result will be returned.\r\n  * @note   Baud rate value stored in USART_InitStruct BaudRate field, should be valid (different from 0).\r\n  * @param  USARTx USART Instance\r\n  * @param  USART_InitStruct pointer to a LL_USART_InitTypeDef structure\r\n  *         that contains the configuration information for the specified USART peripheral.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: USART registers are initialized according to USART_InitStruct content\r\n  *          - ERROR: Problem occurred during USART Registers initialization\r\n  */\r\nErrorStatus LL_USART_Init(USART_TypeDef *USARTx, LL_USART_InitTypeDef *USART_InitStruct)\r\n{\r\n  ErrorStatus status = ERROR;\r\n  uint32_t periphclk = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_RCC_ClocksTypeDef rcc_clocks;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_UART_INSTANCE(USARTx));\r\n  assert_param(IS_LL_USART_BAUDRATE(USART_InitStruct->BaudRate));\r\n  assert_param(IS_LL_USART_DATAWIDTH(USART_InitStruct->DataWidth));\r\n  assert_param(IS_LL_USART_STOPBITS(USART_InitStruct->StopBits));\r\n  assert_param(IS_LL_USART_PARITY(USART_InitStruct->Parity));\r\n  assert_param(IS_LL_USART_DIRECTION(USART_InitStruct->TransferDirection));\r\n  assert_param(IS_LL_USART_HWCONTROL(USART_InitStruct->HardwareFlowControl));\r\n  assert_param(IS_LL_USART_OVERSAMPLING(USART_InitStruct->OverSampling));\r\n\r\n  /* USART needs to be in disabled state, in order to be able to configure some bits in\r\n     CRx registers */\r\n  if (LL_USART_IsEnabled(USARTx) == 0U)\r\n  {\r\n    /*---------------------------- USART CR1 Configuration -----------------------\r\n     * Configure USARTx CR1 (USART Word Length, Parity, Mode and Oversampling bits) with parameters:\r\n     * - DataWidth:          USART_CR1_M bits according to USART_InitStruct->DataWidth value\r\n     * - Parity:             USART_CR1_PCE, USART_CR1_PS bits according to USART_InitStruct->Parity value\r\n     * - TransferDirection:  USART_CR1_TE, USART_CR1_RE bits according to USART_InitStruct->TransferDirection value\r\n     * - Oversampling:       USART_CR1_OVER8 bit according to USART_InitStruct->OverSampling value.\r\n     */\r\n    MODIFY_REG(USARTx->CR1,\r\n               (USART_CR1_M | USART_CR1_PCE | USART_CR1_PS |\r\n                USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),\r\n               (USART_InitStruct->DataWidth | USART_InitStruct->Parity |\r\n                USART_InitStruct->TransferDirection | USART_InitStruct->OverSampling));\r\n\r\n    /*---------------------------- USART CR2 Configuration -----------------------\r\n     * Configure USARTx CR2 (Stop bits) with parameters:\r\n     * - Stop Bits:          USART_CR2_STOP bits according to USART_InitStruct->StopBits value.\r\n     * - CLKEN, CPOL, CPHA and LBCL bits are to be configured using LL_USART_ClockInit().\r\n     */\r\n    LL_USART_SetStopBitsLength(USARTx, USART_InitStruct->StopBits);\r\n\r\n    /*---------------------------- USART CR3 Configuration -----------------------\r\n     * Configure USARTx CR3 (Hardware Flow Control) with parameters:\r\n     * - HardwareFlowControl: USART_CR3_RTSE, USART_CR3_CTSE bits according to USART_InitStruct->HardwareFlowControl value.\r\n     */\r\n    LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);\r\n\r\n    /*---------------------------- USART BRR Configuration -----------------------\r\n     * Retrieve Clock frequency used for USART Peripheral\r\n     */\r\n    LL_RCC_GetSystemClocksFreq(&rcc_clocks);\r\n    if (USARTx == USART1)\r\n    {\r\n      periphclk = rcc_clocks.PCLK2_Frequency;\r\n    }\r\n    else if (USARTx == USART2)\r\n    {\r\n      periphclk = rcc_clocks.PCLK1_Frequency;\r\n    }\r\n#if defined(USART3)\r\n    else if (USARTx == USART3)\r\n    {\r\n      periphclk = rcc_clocks.PCLK1_Frequency;\r\n    }\r\n#endif /* USART3 */\r\n#if defined(USART6)\r\n    else if (USARTx == USART6)\r\n    {\r\n      periphclk = rcc_clocks.PCLK2_Frequency;\r\n    }\r\n#endif /* USART6 */\r\n#if defined(UART4)\r\n    else if (USARTx == UART4)\r\n    {\r\n      periphclk = rcc_clocks.PCLK1_Frequency;\r\n    }\r\n#endif /* UART4 */\r\n#if defined(UART5)\r\n    else if (USARTx == UART5)\r\n    {\r\n      periphclk = rcc_clocks.PCLK1_Frequency;\r\n    }\r\n#endif /* UART5 */\r\n#if defined(UART7)\r\n    else if (USARTx == UART7)\r\n    {\r\n      periphclk = rcc_clocks.PCLK1_Frequency;\r\n    }\r\n#endif /* UART7 */\r\n#if defined(UART8)\r\n    else if (USARTx == UART8)\r\n    {\r\n      periphclk = rcc_clocks.PCLK1_Frequency;\r\n    }\r\n#endif /* UART8 */\r\n#if defined(UART9)\r\n    else if (USARTx == UART9)\r\n    {\r\n      periphclk = rcc_clocks.PCLK2_Frequency;\r\n    }\r\n#endif /* UART9 */\r\n#if defined(UART10)\r\n    else if (USARTx == UART10)\r\n    {\r\n      periphclk = rcc_clocks.PCLK2_Frequency;\r\n    }\r\n#endif /* UART10 */\r\n    else\r\n    {\r\n      /* Nothing to do, as error code is already assigned to ERROR value */\r\n    }\r\n\r\n    /* Configure the USART Baud Rate :\r\n       - valid baud rate value (different from 0) is required\r\n       - Peripheral clock as returned by RCC service, should be valid (different from 0).\r\n    */\r\n    if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)\r\n        && (USART_InitStruct->BaudRate != 0U))\r\n    {\r\n      status = SUCCESS;\r\n      LL_USART_SetBaudRate(USARTx,\r\n                           periphclk,\r\n                           USART_InitStruct->OverSampling,\r\n                           USART_InitStruct->BaudRate);\r\n\r\n      /* Check BRR is greater than or equal to 16d */\r\n      assert_param(IS_LL_USART_BRR_MIN(USARTx->BRR));\r\n    }\r\n  }\r\n  /* Endif (=> USART not in Disabled state => return ERROR) */\r\n\r\n  return (status);\r\n}\r\n\r\n/**\r\n  * @brief Set each @ref LL_USART_InitTypeDef field to default value.\r\n  * @param USART_InitStruct Pointer to a @ref LL_USART_InitTypeDef structure\r\n  *                         whose fields will be set to default values.\r\n  * @retval None\r\n  */\r\n\r\nvoid LL_USART_StructInit(LL_USART_InitTypeDef *USART_InitStruct)\r\n{\r\n  /* Set USART_InitStruct fields to default values */\r\n  USART_InitStruct->BaudRate            = 9600U;\r\n  USART_InitStruct->DataWidth           = LL_USART_DATAWIDTH_8B;\r\n  USART_InitStruct->StopBits            = LL_USART_STOPBITS_1;\r\n  USART_InitStruct->Parity              = LL_USART_PARITY_NONE ;\r\n  USART_InitStruct->TransferDirection   = LL_USART_DIRECTION_TX_RX;\r\n  USART_InitStruct->HardwareFlowControl = LL_USART_HWCONTROL_NONE;\r\n  USART_InitStruct->OverSampling        = LL_USART_OVERSAMPLING_16;\r\n}\r\n\r\n/**\r\n  * @brief  Initialize USART Clock related settings according to the\r\n  *         specified parameters in the USART_ClockInitStruct.\r\n  * @note   As some bits in USART configuration registers can only be written when the USART is disabled (USART_CR1_UE bit =0),\r\n  *         USART IP should be in disabled state prior calling this function. Otherwise, ERROR result will be returned.\r\n  * @param  USARTx USART Instance\r\n  * @param  USART_ClockInitStruct Pointer to a @ref LL_USART_ClockInitTypeDef structure\r\n  *         that contains the Clock configuration information for the specified USART peripheral.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: USART registers related to Clock settings are initialized according to USART_ClockInitStruct content\r\n  *          - ERROR: Problem occurred during USART Registers initialization\r\n  */\r\nErrorStatus LL_USART_ClockInit(USART_TypeDef *USARTx, LL_USART_ClockInitTypeDef *USART_ClockInitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n\r\n  /* Check USART Instance and Clock signal output parameters */\r\n  assert_param(IS_UART_INSTANCE(USARTx));\r\n  assert_param(IS_LL_USART_CLOCKOUTPUT(USART_ClockInitStruct->ClockOutput));\r\n\r\n  /* USART needs to be in disabled state, in order to be able to configure some bits in\r\n     CRx registers */\r\n  if (LL_USART_IsEnabled(USARTx) == 0U)\r\n  {\r\n    /*---------------------------- USART CR2 Configuration -----------------------*/\r\n    /* If Clock signal has to be output */\r\n    if (USART_ClockInitStruct->ClockOutput == LL_USART_CLOCK_DISABLE)\r\n    {\r\n      /* Deactivate Clock signal delivery :\r\n       * - Disable Clock Output:        USART_CR2_CLKEN cleared\r\n       */\r\n      LL_USART_DisableSCLKOutput(USARTx);\r\n    }\r\n    else\r\n    {\r\n      /* Ensure USART instance is USART capable */\r\n      assert_param(IS_USART_INSTANCE(USARTx));\r\n\r\n      /* Check clock related parameters */\r\n      assert_param(IS_LL_USART_CLOCKPOLARITY(USART_ClockInitStruct->ClockPolarity));\r\n      assert_param(IS_LL_USART_CLOCKPHASE(USART_ClockInitStruct->ClockPhase));\r\n      assert_param(IS_LL_USART_LASTBITCLKOUTPUT(USART_ClockInitStruct->LastBitClockPulse));\r\n\r\n      /*---------------------------- USART CR2 Configuration -----------------------\r\n       * Configure USARTx CR2 (Clock signal related bits) with parameters:\r\n       * - Enable Clock Output:         USART_CR2_CLKEN set\r\n       * - Clock Polarity:              USART_CR2_CPOL bit according to USART_ClockInitStruct->ClockPolarity value\r\n       * - Clock Phase:                 USART_CR2_CPHA bit according to USART_ClockInitStruct->ClockPhase value\r\n       * - Last Bit Clock Pulse Output: USART_CR2_LBCL bit according to USART_ClockInitStruct->LastBitClockPulse value.\r\n       */\r\n      MODIFY_REG(USARTx->CR2,\r\n                 USART_CR2_CLKEN | USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_LBCL,\r\n                 USART_CR2_CLKEN | USART_ClockInitStruct->ClockPolarity |\r\n                 USART_ClockInitStruct->ClockPhase | USART_ClockInitStruct->LastBitClockPulse);\r\n    }\r\n  }\r\n  /* Else (USART not in Disabled state => return ERROR */\r\n  else\r\n  {\r\n    status = ERROR;\r\n  }\r\n\r\n  return (status);\r\n}\r\n\r\n/**\r\n  * @brief Set each field of a @ref LL_USART_ClockInitTypeDef type structure to default value.\r\n  * @param USART_ClockInitStruct Pointer to a @ref LL_USART_ClockInitTypeDef structure\r\n  *                              whose fields will be set to default values.\r\n  * @retval None\r\n  */\r\nvoid LL_USART_ClockStructInit(LL_USART_ClockInitTypeDef *USART_ClockInitStruct)\r\n{\r\n  /* Set LL_USART_ClockInitStruct fields with default values */\r\n  USART_ClockInitStruct->ClockOutput       = LL_USART_CLOCK_DISABLE;\r\n  USART_ClockInitStruct->ClockPolarity     = LL_USART_POLARITY_LOW;            /* Not relevant when ClockOutput = LL_USART_CLOCK_DISABLE */\r\n  USART_ClockInitStruct->ClockPhase        = LL_USART_PHASE_1EDGE;             /* Not relevant when ClockOutput = LL_USART_CLOCK_DISABLE */\r\n  USART_ClockInitStruct->LastBitClockPulse = LL_USART_LASTCLKPULSE_NO_OUTPUT;  /* Not relevant when ClockOutput = LL_USART_CLOCK_DISABLE */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USART1 || USART2 || USART3 || USART6 || UART4 || UART5 || UART7 || UART8 || UART9 || UART10 */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n\r\n"},{"name":"stm32f4xx_ll_utils.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Drivers\\STM32F4xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32f4xx_ll_utils.c\r\n  * @author  MCD Application Team\r\n  * @brief   UTILS LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f4xx_ll_utils.h\"\r\n#include \"stm32f4xx_ll_rcc.h\"\r\n#include \"stm32f4xx_ll_system.h\"\r\n#include \"stm32f4xx_ll_pwr.h\"\r\n#ifdef  USE_FULL_ASSERT\r\n#include \"stm32_assert.h\"\r\n#else\r\n#define assert_param(expr) ((void)0U)\r\n#endif /* USE_FULL_ASSERT */\r\n\r\n/** @addtogroup STM32F4xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup UTILS_LL\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/** @addtogroup UTILS_LL_Private_Constants\r\n  * @{\r\n  */\r\n#if defined(RCC_MAX_FREQUENCY_SCALE1)\r\n#define UTILS_MAX_FREQUENCY_SCALE1  RCC_MAX_FREQUENCY           /*!< Maximum frequency for system clock at power scale1, in Hz */\r\n#endif /*RCC_MAX_FREQUENCY_SCALE1 */\r\n#define UTILS_MAX_FREQUENCY_SCALE2  RCC_MAX_FREQUENCY_SCALE2    /*!< Maximum frequency for system clock at power scale2, in Hz */\r\n#if defined(RCC_MAX_FREQUENCY_SCALE3)\r\n#define UTILS_MAX_FREQUENCY_SCALE3  RCC_MAX_FREQUENCY_SCALE3    /*!< Maximum frequency for system clock at power scale3, in Hz */\r\n#endif /* MAX_FREQUENCY_SCALE3 */\r\n\r\n/* Defines used for PLL range */\r\n#define UTILS_PLLVCO_INPUT_MIN      RCC_PLLVCO_INPUT_MIN        /*!< Frequency min for PLLVCO input, in Hz   */\r\n#define UTILS_PLLVCO_INPUT_MAX      RCC_PLLVCO_INPUT_MAX        /*!< Frequency max for PLLVCO input, in Hz   */\r\n#define UTILS_PLLVCO_OUTPUT_MIN     RCC_PLLVCO_OUTPUT_MIN       /*!< Frequency min for PLLVCO output, in Hz  */\r\n#define UTILS_PLLVCO_OUTPUT_MAX     RCC_PLLVCO_OUTPUT_MAX       /*!< Frequency max for PLLVCO output, in Hz  */\r\n\r\n/* Defines used for HSE range */\r\n#define UTILS_HSE_FREQUENCY_MIN      4000000U        /*!< Frequency min for HSE frequency, in Hz   */\r\n#define UTILS_HSE_FREQUENCY_MAX     26000000U        /*!< Frequency max for HSE frequency, in Hz   */\r\n\r\n/* Defines used for FLASH latency according to HCLK Frequency */\r\n#if defined(FLASH_SCALE1_LATENCY1_FREQ)\r\n#define UTILS_SCALE1_LATENCY1_FREQ  FLASH_SCALE1_LATENCY1_FREQ /*!< HCLK frequency to set FLASH latency 1 in power scale 1 */\r\n#endif\r\n#if defined(FLASH_SCALE1_LATENCY2_FREQ)\r\n#define UTILS_SCALE1_LATENCY2_FREQ  FLASH_SCALE1_LATENCY2_FREQ /*!< HCLK frequency to set FLASH latency 2 in power scale 1 */\r\n#endif\r\n#if defined(FLASH_SCALE1_LATENCY3_FREQ)\r\n#define UTILS_SCALE1_LATENCY3_FREQ  FLASH_SCALE1_LATENCY3_FREQ /*!< HCLK frequency to set FLASH latency 3 in power scale 1 */\r\n#endif\r\n#if defined(FLASH_SCALE1_LATENCY4_FREQ)\r\n#define UTILS_SCALE1_LATENCY4_FREQ  FLASH_SCALE1_LATENCY4_FREQ /*!< HCLK frequency to set FLASH latency 4 in power scale 1 */\r\n#endif\r\n#if defined(FLASH_SCALE1_LATENCY5_FREQ)\r\n#define UTILS_SCALE1_LATENCY5_FREQ  FLASH_SCALE1_LATENCY5_FREQ /*!< HCLK frequency to set FLASH latency 5 in power scale 1 */\r\n#endif\r\n#define UTILS_SCALE2_LATENCY1_FREQ  FLASH_SCALE2_LATENCY1_FREQ /*!< HCLK frequency to set FLASH latency 1 in power scale 2 */\r\n#define UTILS_SCALE2_LATENCY2_FREQ  FLASH_SCALE2_LATENCY2_FREQ /*!< HCLK frequency to set FLASH latency 2 in power scale 2 */\r\n#if defined(FLASH_SCALE2_LATENCY3_FREQ)\r\n#define UTILS_SCALE2_LATENCY3_FREQ  FLASH_SCALE2_LATENCY3_FREQ /*!< HCLK frequency to set FLASH latency 2 in power scale 2 */\r\n#endif\r\n#if defined(FLASH_SCALE2_LATENCY4_FREQ)\r\n#define UTILS_SCALE2_LATENCY4_FREQ  FLASH_SCALE2_LATENCY4_FREQ /*!< HCLK frequency to set FLASH latency 4 in power scale 2 */\r\n#endif\r\n#if defined(FLASH_SCALE2_LATENCY5_FREQ)\r\n#define UTILS_SCALE2_LATENCY5_FREQ  FLASH_SCALE2_LATENCY5_FREQ /*!< HCLK frequency to set FLASH latency 5 in power scale 2 */\r\n#endif\r\n#if defined(FLASH_SCALE3_LATENCY1_FREQ)\r\n#define UTILS_SCALE3_LATENCY1_FREQ  FLASH_SCALE3_LATENCY1_FREQ /*!< HCLK frequency to set FLASH latency 1 in power scale 3 */\r\n#endif\r\n#if defined(FLASH_SCALE3_LATENCY2_FREQ)\r\n#define UTILS_SCALE3_LATENCY2_FREQ  FLASH_SCALE3_LATENCY2_FREQ /*!< HCLK frequency to set FLASH latency 2 in power scale 3 */\r\n#endif\r\n#if defined(FLASH_SCALE3_LATENCY3_FREQ)\r\n#define UTILS_SCALE3_LATENCY3_FREQ  FLASH_SCALE3_LATENCY3_FREQ /*!< HCLK frequency to set FLASH latency 3 in power scale 3 */\r\n#endif\r\n#if defined(FLASH_SCALE3_LATENCY4_FREQ)\r\n#define UTILS_SCALE3_LATENCY4_FREQ  FLASH_SCALE3_LATENCY4_FREQ /*!< HCLK frequency to set FLASH latency 4 in power scale 3 */\r\n#endif\r\n#if defined(FLASH_SCALE3_LATENCY5_FREQ)\r\n#define UTILS_SCALE3_LATENCY5_FREQ  FLASH_SCALE3_LATENCY5_FREQ /*!< HCLK frequency to set FLASH latency 5 in power scale 3 */\r\n#endif\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup UTILS_LL_Private_Macros\r\n  * @{\r\n  */\r\n#define IS_LL_UTILS_SYSCLK_DIV(__VALUE__) (((__VALUE__) == LL_RCC_SYSCLK_DIV_1)   \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_2)   \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_4)   \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_8)   \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_16)  \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_64)  \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_128) \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_256) \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_512))\r\n\r\n#define IS_LL_UTILS_APB1_DIV(__VALUE__) (((__VALUE__) == LL_RCC_APB1_DIV_1) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB1_DIV_2) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB1_DIV_4) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB1_DIV_8) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB1_DIV_16))\r\n\r\n#define IS_LL_UTILS_APB2_DIV(__VALUE__) (((__VALUE__) == LL_RCC_APB2_DIV_1) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB2_DIV_2) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB2_DIV_4) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB2_DIV_8) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB2_DIV_16))\r\n\r\n#define IS_LL_UTILS_PLLM_VALUE(__VALUE__) (((__VALUE__) == LL_RCC_PLLM_DIV_2)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_3)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_4)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_5)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_6)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_7)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_8)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_9)  \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_10) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_11) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_12) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_13) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_14) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_15) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_16) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_17) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_18) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_19) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_20) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_21) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_22) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_23) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_24) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_25) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_26) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_27) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_28) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_29) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_30) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_31) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_32) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_33) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_34) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_35) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_36) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_37) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_38) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_39) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_40) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_41) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_42) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_43) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_44) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_45) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_46) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_47) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_48) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_49) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_50) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_51) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_52) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_53) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_54) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_55) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_56) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_57) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_58) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_59) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_60) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_61) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_62) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLM_DIV_63))\r\n\r\n#define IS_LL_UTILS_PLLN_VALUE(__VALUE__) ((RCC_PLLN_MIN_VALUE <= (__VALUE__)) && ((__VALUE__) <= RCC_PLLN_MAX_VALUE))\r\n\r\n#define IS_LL_UTILS_PLLP_VALUE(__VALUE__) (((__VALUE__) == LL_RCC_PLLP_DIV_2) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLP_DIV_4) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLP_DIV_6) \\\r\n                                        || ((__VALUE__) == LL_RCC_PLLP_DIV_8))\r\n\r\n#define IS_LL_UTILS_PLLVCO_INPUT(__VALUE__)  ((UTILS_PLLVCO_INPUT_MIN <= (__VALUE__)) && ((__VALUE__) <= UTILS_PLLVCO_INPUT_MAX))\r\n\r\n#define IS_LL_UTILS_PLLVCO_OUTPUT(__VALUE__) ((UTILS_PLLVCO_OUTPUT_MIN <= (__VALUE__)) && ((__VALUE__) <= UTILS_PLLVCO_OUTPUT_MAX))\r\n\r\n#if !defined(RCC_MAX_FREQUENCY_SCALE1)\r\n#define IS_LL_UTILS_PLL_FREQUENCY(__VALUE__) ((LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2) ? ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE2) : \\\r\n                                             ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE3))\r\n                                             \r\n#elif defined(RCC_MAX_FREQUENCY_SCALE3) \r\n#define IS_LL_UTILS_PLL_FREQUENCY(__VALUE__) ((LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1) ? ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE1) : \\\r\n                                              (LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2) ? ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE2) : \\\r\n                                              ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE3))\r\n\r\n#else\r\n#define IS_LL_UTILS_PLL_FREQUENCY(__VALUE__) ((LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1) ? ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE1) : \\\r\n                                             ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE2))\r\n\r\n#endif /* RCC_MAX_FREQUENCY_SCALE1*/\r\n#define IS_LL_UTILS_HSE_BYPASS(__STATE__) (((__STATE__) == LL_UTILS_HSEBYPASS_ON) \\\r\n                                        || ((__STATE__) == LL_UTILS_HSEBYPASS_OFF))\r\n\r\n#define IS_LL_UTILS_HSE_FREQUENCY(__FREQUENCY__) (((__FREQUENCY__) >= UTILS_HSE_FREQUENCY_MIN) && ((__FREQUENCY__) <= UTILS_HSE_FREQUENCY_MAX))\r\n/**\r\n  * @}\r\n  */\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @defgroup UTILS_LL_Private_Functions UTILS Private functions\r\n  * @{\r\n  */\r\nstatic uint32_t    UTILS_GetPLLOutputFrequency(uint32_t PLL_InputFrequency,\r\n                                               LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct);\r\nstatic ErrorStatus UTILS_EnablePLLAndSwitchSystem(uint32_t SYSCLK_Frequency, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct);\r\nstatic ErrorStatus UTILS_PLL_IsBusy(void);\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup UTILS_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup UTILS_LL_EF_DELAY\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  This function configures the Cortex-M SysTick source to have 1ms time base.\r\n  * @note   When a RTOS is used, it is recommended to avoid changing the Systick\r\n  *         configuration by calling this function, for a delay use rather osDelay RTOS service.\r\n  * @param  HCLKFrequency HCLK frequency in Hz\r\n  * @note   HCLK frequency can be calculated thanks to RCC helper macro or function @ref LL_RCC_GetSystemClocksFreq\r\n  * @retval None\r\n  */\r\nvoid LL_Init1msTick(uint32_t HCLKFrequency)\r\n{\r\n  /* Use frequency provided in argument */\r\n  LL_InitTick(HCLKFrequency, 1000U);\r\n}\r\n\r\n/**\r\n  * @brief  This function provides accurate delay (in milliseconds) based\r\n  *         on SysTick counter flag\r\n  * @note   When a RTOS is used, it is recommended to avoid using blocking delay\r\n  *         and use rather osDelay service.\r\n  * @note   To respect 1ms timebase, user should call @ref LL_Init1msTick function which\r\n  *         will configure Systick to 1ms\r\n  * @param  Delay specifies the delay time length, in milliseconds.\r\n  * @retval None\r\n  */\r\nvoid LL_mDelay(uint32_t Delay)\r\n{\r\n  __IO uint32_t  tmp = SysTick->CTRL;  /* Clear the COUNTFLAG first */\r\n  /* Add this code to indicate that local variable is not used */\r\n  ((void)tmp);\r\n\r\n  /* Add a period to guaranty minimum wait */\r\n  if(Delay < LL_MAX_DELAY)\r\n  {\r\n    Delay++;\r\n  }\r\n\r\n  while (Delay)\r\n  {\r\n    if((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U)\r\n    {\r\n      Delay--;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup UTILS_EF_SYSTEM\r\n  *  @brief    System Configuration functions\r\n  *\r\n  @verbatim\r\n ===============================================================================\r\n           ##### System Configuration functions #####\r\n ===============================================================================\r\n    [..]\r\n         System, AHB and APB buses clocks configuration\r\n\r\n         (+) The maximum frequency of the SYSCLK, HCLK, PCLK1 and PCLK2 is 180000000 Hz.\r\n  @endverbatim\r\n  @internal\r\n             Depending on the device voltage range, the maximum frequency should be\r\n             adapted accordingly to the Refenece manual.\r\n  @endinternal\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  This function sets directly SystemCoreClock CMSIS variable.\r\n  * @note   Variable can be calculated also through SystemCoreClockUpdate function.\r\n  * @param  HCLKFrequency HCLK frequency in Hz (can be calculated thanks to RCC helper macro)\r\n  * @retval None\r\n  */\r\nvoid LL_SetSystemCoreClock(uint32_t HCLKFrequency)\r\n{\r\n  /* HCLK clock frequency */\r\n  SystemCoreClock = HCLKFrequency;\r\n}\r\n\r\n/**\r\n  * @brief  Update number of Flash wait states in line with new frequency and current\r\n            voltage range.\r\n  * @note   This Function support ONLY devices with supply voltage (voltage range) between 2.7V and 3.6V\r\n  * @param  HCLK_Frequency  HCLK frequency\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: Latency has been modified\r\n  *          - ERROR: Latency cannot be modified\r\n  */\r\nErrorStatus LL_SetFlashLatency(uint32_t HCLK_Frequency)\r\n{\r\n  uint32_t timeout;\r\n  uint32_t getlatency;\r\n  uint32_t latency = LL_FLASH_LATENCY_0;  /* default value 0WS */\r\n  ErrorStatus status = SUCCESS;\r\n\r\n\r\n  /* Frequency cannot be equal to 0 */\r\n  if(HCLK_Frequency == 0U)\r\n  {\r\n    status = ERROR;\r\n  }\r\n  else\r\n  {\r\n    if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)\r\n    {\r\n#if defined (UTILS_SCALE1_LATENCY5_FREQ)\r\n      if((HCLK_Frequency > UTILS_SCALE1_LATENCY5_FREQ)&&(latency == LL_FLASH_LATENCY_0))\r\n      {\r\n        latency = LL_FLASH_LATENCY_5;\r\n      }\r\n#endif /*UTILS_SCALE1_LATENCY5_FREQ */\r\n#if defined (UTILS_SCALE1_LATENCY4_FREQ)\r\n      if((HCLK_Frequency > UTILS_SCALE1_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))\r\n      {\r\n        latency = LL_FLASH_LATENCY_4;\r\n      }\r\n#endif /* UTILS_SCALE1_LATENCY4_FREQ */\r\n#if defined (UTILS_SCALE1_LATENCY3_FREQ)\r\n      if((HCLK_Frequency > UTILS_SCALE1_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))\r\n      {\r\n        latency = LL_FLASH_LATENCY_3;\r\n      }\r\n#endif /* UTILS_SCALE1_LATENCY3_FREQ */\r\n#if defined (UTILS_SCALE1_LATENCY2_FREQ) \r\n      if((HCLK_Frequency > UTILS_SCALE1_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))\r\n      {\r\n        latency = LL_FLASH_LATENCY_2;\r\n      }\r\n      else\r\n      {\r\n        if((HCLK_Frequency > UTILS_SCALE1_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))\r\n        {\r\n          latency = LL_FLASH_LATENCY_1;\r\n        }\r\n      }\r\n#endif /* UTILS_SCALE1_LATENCY2_FREQ */\r\n    }\r\n    if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2)\r\n    {\r\n#if defined (UTILS_SCALE2_LATENCY5_FREQ)\r\n      if((HCLK_Frequency > UTILS_SCALE2_LATENCY5_FREQ)&&(latency == LL_FLASH_LATENCY_0))\r\n      {\r\n        latency = LL_FLASH_LATENCY_5;\r\n      }\r\n#endif /*UTILS_SCALE1_LATENCY5_FREQ */\r\n#if defined (UTILS_SCALE2_LATENCY4_FREQ)\r\n      if((HCLK_Frequency > UTILS_SCALE2_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))\r\n      {\r\n        latency = LL_FLASH_LATENCY_4;\r\n      }\r\n#endif /*UTILS_SCALE1_LATENCY4_FREQ */\r\n#if defined (UTILS_SCALE2_LATENCY3_FREQ)\r\n      if((HCLK_Frequency > UTILS_SCALE2_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))\r\n      {\r\n        latency = LL_FLASH_LATENCY_3;\r\n      }\r\n#endif /*UTILS_SCALE1_LATENCY3_FREQ */\r\n      if((HCLK_Frequency > UTILS_SCALE2_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))\r\n      {\r\n        latency = LL_FLASH_LATENCY_2;\r\n      }\r\n      else\r\n      {\r\n        if((HCLK_Frequency > UTILS_SCALE2_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))\r\n        {\r\n          latency = LL_FLASH_LATENCY_1;\r\n        }\r\n      }\r\n    }\r\n#if defined (LL_PWR_REGU_VOLTAGE_SCALE3)\r\n    if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE3)\r\n    {\r\n#if defined (UTILS_SCALE3_LATENCY3_FREQ)\r\n      if((HCLK_Frequency > UTILS_SCALE3_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))\r\n      {\r\n        latency = LL_FLASH_LATENCY_3;\r\n      }\r\n#endif /*UTILS_SCALE1_LATENCY3_FREQ */\r\n#if defined (UTILS_SCALE3_LATENCY2_FREQ)\r\n      if((HCLK_Frequency > UTILS_SCALE3_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))\r\n      {\r\n        latency = LL_FLASH_LATENCY_2;\r\n      }\r\n      else\r\n      {\r\n        if((HCLK_Frequency > UTILS_SCALE3_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))\r\n        {\r\n          latency = LL_FLASH_LATENCY_1;\r\n        }\r\n      }\r\n    }\r\n#endif /*UTILS_SCALE1_LATENCY2_FREQ */\r\n#endif /* LL_PWR_REGU_VOLTAGE_SCALE3 */\r\n\r\n    LL_FLASH_SetLatency(latency);\r\n    /* Check that the new number of wait states is taken into account to access the Flash\r\n       memory by reading the FLASH_ACR register */\r\n    timeout = 2;\r\n    do\r\n    {\r\n    /* Wait for Flash latency to be updated */\r\n    getlatency = LL_FLASH_GetLatency();\r\n    timeout--;\r\n    } while ((getlatency != latency) && (timeout > 0));\r\n\r\n    if(getlatency != latency)\r\n    {\r\n      status = ERROR;\r\n    }\r\n    else\r\n    {\r\n      status = SUCCESS;\r\n    }\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  This function configures system clock at maximum frequency with HSI as clock source of the PLL\r\n  * @note   The application need to ensure that PLL is disabled.\r\n  * @note   Function is based on the following formula:\r\n  *         - PLL output frequency = (((HSI frequency / PLLM) * PLLN) / PLLP)\r\n  *         - PLLM: ensure that the VCO input frequency ranges from @ref RCC_PLLVCO_INPUT_MIN to @ref RCC_PLLVCO_INPUT_MAX (PLLVCO_input = HSI frequency / PLLM)\r\n  *         - PLLN: ensure that the VCO output frequency is between @ref RCC_PLLVCO_OUTPUT_MIN and @ref RCC_PLLVCO_OUTPUT_MAX (PLLVCO_output = PLLVCO_input * PLLN)\r\n  *         - PLLP: ensure that max frequency at 180000000 Hz is reach (PLLVCO_output / PLLP)\r\n  * @param  UTILS_PLLInitStruct pointer to a @ref LL_UTILS_PLLInitTypeDef structure that contains\r\n  *                             the configuration information for the PLL.\r\n  * @param  UTILS_ClkInitStruct pointer to a @ref LL_UTILS_ClkInitTypeDef structure that contains\r\n  *                             the configuration information for the BUS prescalers.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: Max frequency configuration done\r\n  *          - ERROR: Max frequency configuration not done\r\n  */\r\nErrorStatus LL_PLL_ConfigSystemClock_HSI(LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct,\r\n                                         LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  uint32_t pllfreq = 0U;\r\n\r\n  /* Check if one of the PLL is enabled */\r\n  if(UTILS_PLL_IsBusy() == SUCCESS)\r\n  {\r\n    /* Calculate the new PLL output frequency */\r\n    pllfreq = UTILS_GetPLLOutputFrequency(HSI_VALUE, UTILS_PLLInitStruct);\r\n\r\n    /* Enable HSI if not enabled */\r\n    if(LL_RCC_HSI_IsReady() != 1U)\r\n    {\r\n      LL_RCC_HSI_Enable();\r\n      while (LL_RCC_HSI_IsReady() != 1U)\r\n      {\r\n        /* Wait for HSI ready */\r\n      }\r\n    }\r\n\r\n    /* Configure PLL */\r\n    LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, UTILS_PLLInitStruct->PLLM, UTILS_PLLInitStruct->PLLN,\r\n                                UTILS_PLLInitStruct->PLLP);\r\n\r\n    /* Enable PLL and switch system clock to PLL */\r\n    status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);\r\n  }\r\n  else\r\n  {\r\n    /* Current PLL configuration cannot be modified */\r\n    status = ERROR;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  This function configures system clock with HSE as clock source of the PLL\r\n  * @note   The application need to ensure that PLL is disabled.\r\n  *         - PLL output frequency = (((HSI frequency / PLLM) * PLLN) / PLLP)\r\n  *         - PLLM: ensure that the VCO input frequency ranges from @ref RCC_PLLVCO_INPUT_MIN to @ref RCC_PLLVCO_INPUT_MAX (PLLVCO_input = HSI frequency / PLLM)\r\n  *         - PLLN: ensure that the VCO output frequency is between @ref RCC_PLLVCO_OUTPUT_MIN and @ref RCC_PLLVCO_OUTPUT_MAX (PLLVCO_output = PLLVCO_input * PLLN)\r\n  *         - PLLP: ensure that max frequency at 180000000 Hz is reach (PLLVCO_output / PLLP)\r\n  * @param  HSEFrequency Value between Min_Data = 4000000 and Max_Data = 26000000\r\n  * @param  HSEBypass This parameter can be one of the following values:\r\n  *         @arg @ref LL_UTILS_HSEBYPASS_ON\r\n  *         @arg @ref LL_UTILS_HSEBYPASS_OFF\r\n  * @param  UTILS_PLLInitStruct pointer to a @ref LL_UTILS_PLLInitTypeDef structure that contains\r\n  *                             the configuration information for the PLL.\r\n  * @param  UTILS_ClkInitStruct pointer to a @ref LL_UTILS_ClkInitTypeDef structure that contains\r\n  *                             the configuration information for the BUS prescalers.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: Max frequency configuration done\r\n  *          - ERROR: Max frequency configuration not done\r\n  */\r\nErrorStatus LL_PLL_ConfigSystemClock_HSE(uint32_t HSEFrequency, uint32_t HSEBypass,\r\n                                         LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  uint32_t pllfreq = 0U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_LL_UTILS_HSE_FREQUENCY(HSEFrequency));\r\n  assert_param(IS_LL_UTILS_HSE_BYPASS(HSEBypass));\r\n\r\n  /* Check if one of the PLL is enabled */\r\n  if(UTILS_PLL_IsBusy() == SUCCESS)\r\n  {\r\n    /* Calculate the new PLL output frequency */\r\n    pllfreq = UTILS_GetPLLOutputFrequency(HSEFrequency, UTILS_PLLInitStruct);\r\n\r\n    /* Enable HSE if not enabled */\r\n    if(LL_RCC_HSE_IsReady() != 1U)\r\n    {\r\n      /* Check if need to enable HSE bypass feature or not */\r\n      if(HSEBypass == LL_UTILS_HSEBYPASS_ON)\r\n      {\r\n        LL_RCC_HSE_EnableBypass();\r\n      }\r\n      else\r\n      {\r\n        LL_RCC_HSE_DisableBypass();\r\n      }\r\n\r\n      /* Enable HSE */\r\n      LL_RCC_HSE_Enable();\r\n      while (LL_RCC_HSE_IsReady() != 1U)\r\n      {\r\n        /* Wait for HSE ready */\r\n      }\r\n    }\r\n\r\n    /* Configure PLL */\r\n    LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE, UTILS_PLLInitStruct->PLLM, UTILS_PLLInitStruct->PLLN,\r\n                                UTILS_PLLInitStruct->PLLP);\r\n\r\n    /* Enable PLL and switch system clock to PLL */\r\n    status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);\r\n  }\r\n  else\r\n  {\r\n    /* Current PLL configuration cannot be modified */\r\n    status = ERROR;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup UTILS_LL_Private_Functions\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Function to check that PLL can be modified\r\n  * @param  PLL_InputFrequency  PLL input frequency (in Hz)\r\n  * @param  UTILS_PLLInitStruct pointer to a @ref LL_UTILS_PLLInitTypeDef structure that contains\r\n  *                             the configuration information for the PLL.\r\n  * @retval PLL output frequency (in Hz)\r\n  */\r\nstatic uint32_t UTILS_GetPLLOutputFrequency(uint32_t PLL_InputFrequency, LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct)\r\n{\r\n  uint32_t pllfreq = 0U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_LL_UTILS_PLLM_VALUE(UTILS_PLLInitStruct->PLLM));\r\n  assert_param(IS_LL_UTILS_PLLN_VALUE(UTILS_PLLInitStruct->PLLN));\r\n  assert_param(IS_LL_UTILS_PLLP_VALUE(UTILS_PLLInitStruct->PLLP));\r\n  \r\n  /* Check different PLL parameters according to RM                          */\r\n  /*  - PLLM: ensure that the VCO input frequency ranges from @ref UTILS_PLLVCO_INPUT_MIN to @ref UTILS_PLLVCO_INPUT_MAX MHz.   */\r\n  pllfreq = PLL_InputFrequency / (UTILS_PLLInitStruct->PLLM & (RCC_PLLCFGR_PLLM >> RCC_PLLCFGR_PLLM_Pos));\r\n  assert_param(IS_LL_UTILS_PLLVCO_INPUT(pllfreq));\r\n\r\n  /*  - PLLN: ensure that the VCO output frequency is between @ref UTILS_PLLVCO_OUTPUT_MIN and @ref UTILS_PLLVCO_OUTPUT_MAX .*/\r\n  pllfreq = pllfreq * (UTILS_PLLInitStruct->PLLN & (RCC_PLLCFGR_PLLN >> RCC_PLLCFGR_PLLN_Pos));\r\n  assert_param(IS_LL_UTILS_PLLVCO_OUTPUT(pllfreq));\r\n  \r\n  /*  - PLLP: ensure that max frequency at @ref RCC_MAX_FREQUENCY Hz is reached     */\r\n  pllfreq = pllfreq / (((UTILS_PLLInitStruct->PLLP >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);\r\n  assert_param(IS_LL_UTILS_PLL_FREQUENCY(pllfreq));\r\n\r\n  return pllfreq;\r\n}\r\n\r\n/**\r\n  * @brief  Function to check that PLL can be modified\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: PLL modification can be done\r\n  *          - ERROR: PLL is busy\r\n  */\r\nstatic ErrorStatus UTILS_PLL_IsBusy(void)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n\r\n  /* Check if PLL is busy*/\r\n  if(LL_RCC_PLL_IsReady() != 0U)\r\n  {\r\n    /* PLL configuration cannot be modified */\r\n    status = ERROR;\r\n  }\r\n\r\n#if defined(RCC_PLLSAI_SUPPORT)\r\n  /* Check if PLLSAI is busy*/\r\n  if(LL_RCC_PLLSAI_IsReady() != 0U)\r\n  {\r\n    /* PLLSAI1 configuration cannot be modified */\r\n    status = ERROR;\r\n  }\r\n#endif /*RCC_PLLSAI_SUPPORT*/\r\n#if defined(RCC_PLLI2S_SUPPORT)\r\n  /* Check if PLLI2S is busy*/\r\n  if(LL_RCC_PLLI2S_IsReady() != 0U)\r\n  {\r\n    /* PLLI2S configuration cannot be modified */\r\n    status = ERROR;\r\n  }\r\n#endif /*RCC_PLLI2S_SUPPORT*/\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Function to enable PLL and switch system clock to PLL\r\n  * @param  SYSCLK_Frequency SYSCLK frequency\r\n  * @param  UTILS_ClkInitStruct pointer to a @ref LL_UTILS_ClkInitTypeDef structure that contains\r\n  *                             the configuration information for the BUS prescalers.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: No problem to switch system to PLL\r\n  *          - ERROR: Problem to switch system to PLL\r\n  */\r\nstatic ErrorStatus UTILS_EnablePLLAndSwitchSystem(uint32_t SYSCLK_Frequency, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  uint32_t hclk_frequency = 0U;\r\n\r\n  assert_param(IS_LL_UTILS_SYSCLK_DIV(UTILS_ClkInitStruct->AHBCLKDivider));\r\n  assert_param(IS_LL_UTILS_APB1_DIV(UTILS_ClkInitStruct->APB1CLKDivider));\r\n  assert_param(IS_LL_UTILS_APB2_DIV(UTILS_ClkInitStruct->APB2CLKDivider));\r\n\r\n  /* Calculate HCLK frequency */\r\n  hclk_frequency = __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, UTILS_ClkInitStruct->AHBCLKDivider);\r\n\r\n  /* Increasing the number of wait states because of higher CPU frequency */\r\n  if(SystemCoreClock < hclk_frequency)\r\n  {\r\n    /* Set FLASH latency to highest latency */\r\n    status = LL_SetFlashLatency(hclk_frequency);\r\n  }\r\n\r\n  /* Update system clock configuration */\r\n  if(status == SUCCESS)\r\n  {\r\n    /* Enable PLL */\r\n    LL_RCC_PLL_Enable();\r\n    while (LL_RCC_PLL_IsReady() != 1U)\r\n    {\r\n      /* Wait for PLL ready */\r\n    }\r\n\r\n    /* Sysclk activation on the main PLL */\r\n    LL_RCC_SetAHBPrescaler(UTILS_ClkInitStruct->AHBCLKDivider);\r\n    LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);\r\n    while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)\r\n    {\r\n      /* Wait for system clock switch to PLL */\r\n    }\r\n\r\n    /* Set APB1 & APB2 prescaler*/\r\n    LL_RCC_SetAPB1Prescaler(UTILS_ClkInitStruct->APB1CLKDivider);\r\n    LL_RCC_SetAPB2Prescaler(UTILS_ClkInitStruct->APB2CLKDivider);\r\n  }\r\n    \r\n  /* Decreasing the number of wait states because of lower CPU frequency */\r\n  if(SystemCoreClock > hclk_frequency)\r\n  {\r\n    /* Set FLASH latency to lowest latency */\r\n    status = LL_SetFlashLatency(hclk_frequency);\r\n  }\r\n\r\n  /* Update SystemCoreClock variable */\r\n  if(status == SUCCESS)\r\n  {\r\n    LL_SetSystemCoreClock(hclk_frequency);\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"},{"name":"stm_adc_ll.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\shared\\supportpackages\\stm32\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2021-2024 The MathWorks, Inc. */\n/******************************************************************************\n* Includes\n*******************************************************************************/\n#include \"MW_target_hardware_resources.h\"\n#include \"main.h\"\n#include \"stm_adc_ll.h\"\n#include \"string.h\"\n\n#if defined(STM32WB) && defined(ADC_SUPPORT_2_5_MSPS)\n#define MW_ADC_INJ_SUPPORTED 0\n#else\n#define MW_ADC_INJ_SUPPORTED 1\n#endif\n\n\n/**************************MW_ADC1_DMA_STREAM****************************************************\n* Global Variable Definitions\n*******************************************************************************/\n#if defined(ADC1) && defined(MW_ADC1_ENABLED)\n    ADC_Type_T mw_adc1;\n    #if defined(MW_ADC1_DMA_ENABLED)\n        #ifdef STM32H7\n            #if defined(MW_DCACHE_ENABLED)\n            uint32_T ADC1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_ADC1_DMA_BUFFER_SIZE,32)]  __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n            #else\n            uint32_T ADC1DMABuffer[MW_ADC1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\")));\n            #endif\n        #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n            uint16_T ADC1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_ADC1_DMA_BUFFER_SIZE,32)]  __attribute__((aligned (32)));\n        #elif defined(STM32H5)\n            uint16_T ADC1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_ADC1_DMA_BUFFER_SIZE,32)]  __attribute__((aligned (32)));\n        #elif defined(STM32U5)\n            uint32_T ADC1DMABuffer[MW_ADC1_DMA_BUFFER_SIZE] __attribute__((aligned (32))); \n\t    #endif\n    #endif\n#endif\n\n#if defined(ADC2) && defined(MW_ADC2_ENABLED)\n    ADC_Type_T mw_adc2;\n    #if defined(MW_ADC2_DMA_ENABLED)\n        #ifdef STM32H7\n            #if defined(MW_DCACHE_ENABLED)\n            uint32_T ADC2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_ADC2_DMA_BUFFER_SIZE,32)]  __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n            #else\n            uint32_T ADC2DMABuffer[MW_ADC2_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n            #endif\n        #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n            uint16_T ADC2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_ADC2_DMA_BUFFER_SIZE,32)]  __attribute__((aligned (32)));\n\t    #endif\n    #endif\n#endif\n\n#if defined(ADC3) && defined(MW_ADC3_ENABLED)\n    ADC_Type_T mw_adc3;\n    #if defined(MW_ADC3_DMA_ENABLED)\n        #ifdef STM32H7\n            #if defined(MW_DCACHE_ENABLED)\n            uint32_T ADC3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_ADC3_DMA_BUFFER_SIZE,32)]  __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n            #else\n            uint32_T ADC3DMABuffer[MW_ADC3_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n            #endif\n        #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n            uint16_T ADC3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_ADC3_DMA_BUFFER_SIZE,32)]  __attribute__((aligned (32)));\n\t    #endif\n    #endif\n#endif\n\n#if defined(ADC4) && defined(MW_ADC4_ENABLED)\n    ADC_Type_T mw_adc4;\n    #if defined(STM32U5) && defined(MW_ADC4_DMA_ENABLED)\n        uint16_T ADC4DMABuffer[MW_ADC4_DMA_BUFFER_SIZE]; \n    #endif\n#endif\n#if defined(ADC5) && defined(MW_ADC5_ENABLED)\n    ADC_Type_T mw_adc5;\n#endif\n\n#if (defined(GPDMA1) || defined(GPDMA2)) && !defined(GPDMA)\n    #define GPDMA 1\n#endif\n\n/******************************************************************************\n* Local Function Definitions\n*******************************************************************************/\n/*!\n* @brief Software Trigger regular channel ADC\n*\n* @param[in] ptradc  Pointer to MW ADC module - mw_adcx\n*\n* @return The status for software start of conversion\n*/\n\nstatic uint16_T regularADCTrigger(ADC_Type_T * ptradc)\n{\n    /* Set default status as error - 1 */\n    uint16_T status = 1;\n    /* Check if trigger source is software start of conversion */\n    if(LL_ADC_REG_IsTriggerSourceSWStart(ptradc->peripheralPtr))\n    {\n        if(((ADC_INT_TRIGGERED == ptradc->RegStatus) || (ADC_DMA_TRANSFER_FULL_TRIGGERED == ptradc->RegStatus) || (ADC_DATA_READ == ptradc->RegStatus)\n            #if defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n            || (1 == LL_ADC_IsActiveFlag_EOS(ptradc->peripheralPtr)))&& (0 == ADC_IsActiveFlagOVR(ptradc)))\n            #else\n            || (1 == LL_ADC_IsActiveFlag_EOCS(ptradc->peripheralPtr)))&& (0 == ADC_IsActiveFlagOVR(ptradc)))\n            #endif\n        {\n            /* Set the ADC module regular channel status as Busy */\n            if(ADC_DATA_READ == ptradc->RegStatus)\n            {\n                ptradc->RegStatus = ADC_BUSY;\n            }\n            else\n            {\n                ptradc->RegStatus = ADC_BUSY_BUT_DATA_AVAILABLE;\n\n            }\n            /* Start software start of conversion */\n            #if defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4)|| defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n            LL_ADC_REG_StartConversion(ptradc->peripheralPtr);\n            #else\n            LL_ADC_REG_StartConversionSWStart(ptradc->peripheralPtr);\n            #endif\n            status = 0;\n        }\n    }\n    return status;\n}\n#if MW_ADC_INJ_SUPPORTED == 1\n/*!\n* @brief Software Trigger Injected channel ADC\n*\n* @param[in] ptradc  Pointer to MW ADC module - mw_adcx\n*\n* @return The status for software start of conversion\n*/\nstatic uint16_T injectedADCTrigger(ADC_Type_T * ptradc)\n{\n    /* Set default status as error - 1 */\n    uint16_T status = 1;\n    /* Check if trigger source is software start of conversion */\n    if(LL_ADC_INJ_IsTriggerSourceSWStart(ptradc->peripheralPtr))\n    {\n        if((ADC_INT_TRIGGERED == ptradc->InjStatus) || (ADC_DATA_READ == ptradc->InjStatus) || (1 == LL_ADC_IsActiveFlag_JEOS(ptradc->peripheralPtr)))\n        {\n            /* Set the ADC module injected channel status as Busy */\n            if(ADC_DATA_READ == ptradc->InjStatus)\n            {\n                ptradc->InjStatus = ADC_BUSY;\n            }\n            else\n            {\n                ptradc->InjStatus = ADC_BUSY_BUT_DATA_AVAILABLE;\n            }\n            /* Start software start of conversion */\n\n            #if defined(STM32G4) || defined(STM32H7) || defined(STM32WB)  || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n            LL_ADC_INJ_StartConversion(ptradc->peripheralPtr);\n            #else\n            LL_ADC_INJ_StartConversionSWStart(ptradc->peripheralPtr);\n            #endif\n            status = 0;\n        }\n    }\n    return status;\n}\n/*!\n* @brief Read Injected channel ADC values\n*\n* @param[in] peripheralPtr   Pointer to ADC module - ADCx\n* @param[in] noOfConversion  Number of injected channel to be read\n* @param[out] data            Output ADC read data value\n*\n* @return void\n*/\nstatic inline void injectedOnlyReadADC(ADC_TypeDef * peripheralPtr, uint16_T noOfConversion, ADC_Buffer_DataType_T * data)\n{\n    uint32_t *src = (uint32_t *)&(peripheralPtr->JDR1);\n    for(int i=0;i<noOfConversion;i++)\n    {\n        data[i] = (ADC_Buffer_DataType_T)src[i];\n    }\n}\n#endif\n/*!\n* @brief Configure DMA for ADC peripheral\n*\n* @param[in] ADCx         Pointer to ADC module - ADCx\n* @param[in] DMAx         Pointer to DMA module - DMAx\n* @param[in] stream       DMA stream used\n* @param[in] dstAddress   Pointer to buffer for storing the ADC results\n* @param[in] bufferSize   DMA buffer size\n*\n* @return void\n*/\nstatic inline void configure_ADCs_DMA(ADC_TypeDef *ADCx, DMA_TypeDef* DMAx, uint32_t stream, ADC_Buffer_DataType_T * dstAddress, uint32_t bufferSize)\n{\n    #if defined(MW_ADC1_DMA_ENABLED) || defined(MW_ADC2_DMA_ENABLED) || defined(MW_ADC3_DMA_ENABLED) || defined(MW_ADC4_DMA_ENABLED) || defined(MW_ADC5_DMA_ENABLED)\n    /* Set DMA transfer addresses of source */\n    #if defined(GPDMA)\n        LL_DMA_SetSrcAddress(DMAx, stream, LL_ADC_DMA_GetRegAddr(ADCx, LL_ADC_DMA_REG_REGULAR_DATA));\n    #else\n        LL_DMA_SetPeriphAddress(DMAx, stream, LL_ADC_DMA_GetRegAddr(ADCx, LL_ADC_DMA_REG_REGULAR_DATA));\n\n    #endif\n    /* Set DMA transfer addresses of destination */\n    #if defined(STM32G4) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined (STM32U5) || defined(STM32F3) || defined(STM32H5)\n    /* Use double buffer implementation of DMA. Destination buffer format is as below */\n        #if defined (GPDMA)\n        LL_DMA_ConfigAddresses(DMAx, stream,\n                           LL_ADC_DMA_GetRegAddr(ADCx, LL_ADC_DMA_REG_REGULAR_DATA),\n                           (uint32_t)dstAddress);\n        #else\n        LL_DMA_ConfigAddresses(DMAx, stream,\n                               LL_ADC_DMA_GetRegAddr(ADCx, LL_ADC_DMA_REG_REGULAR_DATA),\n                               (uint32_t)dstAddress,\n                               LL_DMA_DIRECTION_PERIPH_TO_MEMORY);\n        #endif\n    #else\n    /* Use double buffer implementation of DMA. Destination buffer format is as below */\n    #ifdef STM32H7\n    LL_DMA_SetPeriphSize(DMAx, stream, LL_DMA_PDATAALIGN_WORD);\n    LL_DMA_SetMemorySize(DMAx, stream, LL_DMA_PDATAALIGN_WORD);\n    #endif\n    LL_DMA_SetMemoryAddress(DMAx, stream, (uint32_t)dstAddress);\n    LL_DMA_SetMemory1Address(DMAx, stream, (uint32_t)(&dstAddress[bufferSize]));\n    /* Enable double buffer implementation of DMA */\n    LL_DMA_EnableDoubleBufferMode(DMAx, stream);\n    #endif\n    #if defined(GPDMA)\n        /* Set block data length in bytes to transfer */\n        #if defined(STM32U5)\n        if (ADCx == ADC4)\n\t        LL_DMA_SetBlkDataLength(DMAx,stream,bufferSize*sizeof(ADC_Buffer_DataType_T)/2);\n        else\n            LL_DMA_SetBlkDataLength(DMAx,stream,bufferSize*sizeof(ADC_Buffer_DataType_T));\n        #else\n        LL_DMA_SetBlkDataLength(DMAx,stream,bufferSize*sizeof(ADC_Buffer_DataType_T));\n        #endif\n        \n        /* Enable DMA transfer interruption: transfer complete */\n        LL_DMA_EnableIT_TC(DMAx,stream);\n        /* Enable DMA transfer interruption: transfer error */\n        LL_DMA_EnableIT_DTE(DMAx,stream);\n\n    #else\n\t    /* Set DMA transfer size */\n\t    LL_DMA_SetDataLength(DMAx,stream,bufferSize);\n        /* Enable DMA transfer interruption: transfer complete */\n        LL_DMA_EnableIT_TC(DMAx,stream);\n        /* Enable DMA transfer interruption: transfer error */\n        LL_DMA_EnableIT_TE(DMAx,stream);\n    #endif\n    #if defined(STM32G4) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n    /* Enable the DMA transfer */\n    LL_DMA_EnableChannel(DMAx,stream);\n    #else\n    /* Enable the DMA transfer */\n    LL_DMA_EnableStream(DMAx,stream);\n    #endif\n\n    #endif\n}\n/*!\n* @brief De-configure DMA for ADC peripheral\n*\n* @param[in] ADCx         Pointer to ADC module - ADCx\n* @param[in] DMAx         Pointer to DMA module - DMAx\n* @param[in] stream       DMA stream used\n*\n* @return void\n*/\nstatic inline void deconfigure_ADCs_DMA(ADC_TypeDef *ADCx, DMA_TypeDef* DMAx, uint32_t stream)\n{\n    #if defined(MW_ADC1_DMA_ENABLED) || defined(MW_ADC2_DMA_ENABLED) || defined(MW_ADC3_DMA_ENABLED) || defined(MW_ADC4_DMA_ENABLED) || defined(MW_ADC5_DMA_ENABLED)\n\n    #if defined(STM32G4) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n    /* Disable the DMA transfer */\n    LL_DMA_DisableChannel(DMAx,stream);\n    /* Disable DMA transfer interruption: half transfer */\n    LL_DMA_DisableIT_HT(DMAx, stream);\n    #else\n    /* Disable the DMA transfer */\n    LL_DMA_DisableStream(DMAx,stream);\n    #endif\n    #if defined(GPDMA)\n        /* Disable DMA transfer interruption: transfer error */\n        LL_DMA_DisableIT_DTE(DMAx,stream);\n        /* Disable DMA transfer interruption: transfer complete */\n        LL_DMA_DisableIT_TC(DMAx,stream);\n        /* Set block data length in bytes to transfer to zero*/\n        LL_DMA_SetBlkDataLength(DMAx,stream,0);\n    #else\n        /* Disable DMA transfer interruption: transfer error */\n        LL_DMA_DisableIT_TE(DMAx,stream);\n        /* Disable DMA transfer interruption: transfer complete */\n        LL_DMA_DisableIT_TC(DMAx,stream);\n        /* Set DMA transfer size */\n        LL_DMA_SetDataLength(DMAx,stream,0);\n    #endif\n#endif\n}\n\n/*!\n* @brief Read regular channel ADC in DMA mode\n*\n* @param[in] ptradc         Pointer to MW ADC module - mw_adcx\n* @param[out] result        Output ADC read data value\n*\n* @return void\n*\n*/\n__STATIC_INLINE void copyADCChannelsFromDMABuffer(ADC_Type_T * ptradc, ADC_Buffer_DataType_T* result)\n{\n    #if defined(MW_DCACHE_ENABLED) //Invalidate cache if enabled before reading from DMA buffer\n    SCB_InvalidateDCache_by_Addr((uint32_t *)ptradc->InternalBufferPtr,  DMA_BUFFER_SIZE_BYTE_ALLIGNED(ptradc->InternalBufferSize * 2, 32) * DMA_BUFFER_WIDTH);\n    #endif\n    /*Update bytes to copy - \n    ADC1 and ADC4 DR register for STM32U5 is 32-bit and 16-bit. \n    ADC_Buffer_DataType_T is defined uint32 to match 32-bit DR register of ADC1 \n    bytesToCopy is divided by 2 to copy 16-bit data.\n    For other processor series size of ADC_Buffer_DataType_T is used\n    */\n    uint8_t bytesToCopy;\n    #if defined(STM32U5)\n        if (ptradc->peripheralPtr == ADC1)\n            bytesToCopy = sizeof(ADC_Buffer_DataType_T);\n        else if (ptradc->peripheralPtr == ADC4)\n            bytesToCopy = sizeof(ADC_Buffer_DataType_T)/2;\n    #else\n        bytesToCopy = sizeof(ADC_Buffer_DataType_T);\n    #endif\n        #if defined(STM32G4) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32F3) || defined(STM32H5)\n        if(MW_ADC_DATA_IN_DMA_SECOND_HALF_BUFFER == ptradc->DataReadyBufferID)\n        {\n            /* Data available in Second half of buffer */\n            memcpy(result,&ptradc->InternalBufferPtr[ptradc->InternalBufferSize],bytesToCopy*ptradc->InternalBufferSize);\n        }\n        else\n        {\n            /* Data available in First half of buffer */\n            memcpy(result,ptradc->InternalBufferPtr,bytesToCopy*ptradc->InternalBufferSize);\n        }\n        #elif defined(STM32U5)\n        /* Check if DMA buffer is half filled for ADC-4*/\n        uint16_T *bufferPtrUint16 = (uint16_t *)ptradc->InternalBufferPtr +ptradc->InternalBufferSize;\n\n        if ((ptradc->peripheralPtr == ADC4) && (MW_ADC_DATA_IN_DMA_SECOND_HALF_BUFFER == ptradc->DataReadyBufferID))\n        {\n                /* Data available in Second half of buffer */\n                memcpy(result,bufferPtrUint16,bytesToCopy*ptradc->InternalBufferSize);\n        }\n             \n        /* Data filled in first half of DMA buffer. DAR points to second half(DINC Enabled). */\n        else if ((ptradc->peripheralPtr == ADC1) && (MW_ADC_DATA_IN_DMA_SECOND_HALF_BUFFER == ptradc->DataReadyBufferID))\n        {\n                /* Data available in Second half of buffer */\n                memcpy(result,&ptradc->InternalBufferPtr[ptradc->InternalBufferSize],bytesToCopy*ptradc->InternalBufferSize);\n        }\n        else\n        {\n            /* Data available in First half of buffer */\n            memcpy(result,ptradc->InternalBufferPtr,bytesToCopy*ptradc->InternalBufferSize);\n        } \n        \n        #else\n        if(LL_DMA_CURRENTTARGETMEM0 == LL_DMA_GetCurrentTargetMem(ptradc->dmaPeripheralPtr, ptradc->dmastream))\n        {\n            /* Data available in M1 buffer */\n            memcpy(result,&ptradc->InternalBufferPtr[ptradc->InternalBufferSize],bytesToCopy*ptradc->InternalBufferSize);\n        }\n        else\n        {\n            memcpy(result,ptradc->InternalBufferPtr,bytesToCopy*ptradc->InternalBufferSize);\n        }\n        #endif\n}\n\n/******************************************************************************\n* Global Function Definitions\n*******************************************************************************/\n#if defined(MW_ADC1_DMA_ENABLED) || defined(MW_ADC2_DMA_ENABLED) || defined(MW_ADC3_DMA_ENABLED) || defined(MW_ADC4_DMA_ENABLED) || defined(MW_ADC5_DMA_ENABLED)\n\n/*!\n* @brief Housekeeping for ADC peripheral if DMA is enabled with transfer complete IT\n*\n* @param[in] ptradc   Pointer to MW ADC module - mw_adcx\n*\n* @return uint8_T     Is ADC DMA Transfer complete interrupt enabled\n*/\n\n#if defined(STM32G4) || defined(STM32WB) || defined(STM32L5) || defined(STM32F3)\nuint8_T ADC_IsEnabledDMAITTransferComplete(ADC_Type_T * ptradc, uint32_t (*checkActiveFlag)(DMA_TypeDef *DMAx),  void (*clearActiveFlag)(DMA_TypeDef *DMAx))\n{\n    /* Check transfer-complete interrupt */\n    uint8_T ret = (uint8_T)LL_DMA_IsEnabledIT_TC(ptradc->dmaPeripheralPtr, ptradc->dmastream);\n    if ( (1 == (uint8_T)LL_DMA_IsEnabledIT_TC(ptradc->dmaPeripheralPtr, ptradc->dmastream))  && (1 == checkActiveFlag(ptradc->dmaPeripheralPtr)) )\n    {\n        ptradc->RegStatus = ADC_DMA_TRANSFER_FULL_TRIGGERED;\n        /* Clear half transfer complete interrupt flag */\n        clearActiveFlag(ptradc->dmaPeripheralPtr);\n        /* Disable DMA stream */\n        LL_DMA_DisableChannel(ptradc->dmaPeripheralPtr, ptradc->dmastream);\n        /* Set memory address to second half, if data in first half*/\n        if(LL_DMA_GetMemoryAddress (ptradc->dmaPeripheralPtr, ptradc->dmastream) == (uint32_t)ptradc->InternalBufferPtr)\n        {\n            ptradc->DataReadyBufferID = MW_ADC_DATA_IN_DMA_FIRST_HALF_BUFFER;\n            LL_DMA_SetMemoryAddress(ptradc->dmaPeripheralPtr, ptradc->dmastream,(uint32_t)(&ptradc->InternalBufferPtr[ptradc->InternalBufferSize]));\n        }\n        else /* Set memory address to first half, if data in second half*/\n        {\n            ptradc->DataReadyBufferID = MW_ADC_DATA_IN_DMA_SECOND_HALF_BUFFER;\n            LL_DMA_SetMemoryAddress(ptradc->dmaPeripheralPtr, ptradc->dmastream,(uint32_t)ptradc->InternalBufferPtr);\n        }\n        /* Set length to receive */\n        LL_DMA_SetDataLength(ptradc->dmaPeripheralPtr, ptradc->dmastream, ptradc->InternalBufferSize);\n        /* Start DMA again */\n        LL_DMA_EnableChannel(ptradc->dmaPeripheralPtr, ptradc->dmastream);\n        ret = 1;\n    }\n    else\n    {\n        ret = 0;\n    }\n    return ret;\n}\n/* For HW using GPDMA1 such as STM32U5*/\n#elif defined(GPDMA)\nuint8_T ADC_IsEnabledDMAITTransferComplete(ADC_Type_T * ptradc, uint32_t (*checkActiveFlag)(DMA_TypeDef *DMAx, uint32_t dmastream),  void (*clearActiveFlag)(DMA_TypeDef *DMAx, uint32_t dmastream))\n{\n    /* Check transfer-complete interrupt */\n    uint8_T ret = (uint8_T)LL_DMA_IsEnabledIT_TC(ptradc->dmaPeripheralPtr, ptradc->dmastream);\n    /*Update bytes to copy - ADC4 for STM32U5 is 16-bit. \n    ADC_Buffer_DataType_T is defined uint32 to match 32-bit ADC1 \n    bytesToCopy is divided by 2 to copy 16-bit data.\n    */\n    uint8_t bytesToCopy;\n    #if defined(STM32U5)\n        if (ptradc->peripheralPtr == ADC1)\n            bytesToCopy = sizeof(ADC_Buffer_DataType_T);\n        else if (ptradc->peripheralPtr == ADC4)\n            bytesToCopy = sizeof(ADC_Buffer_DataType_T)/2;\n    #else\n        bytesToCopy = sizeof(ADC_Buffer_DataType_T);\n    #endif\n    if ( (1 == (uint8_T)LL_DMA_IsEnabledIT_TC(ptradc->dmaPeripheralPtr, ptradc->dmastream))  && (1 == checkActiveFlag(ptradc->dmaPeripheralPtr, ptradc->dmastream)) )\n    {\n        ptradc->RegStatus = ADC_DMA_TRANSFER_FULL_TRIGGERED;\n        /* Clear half transfer complete interrupt flag */\n        clearActiveFlag(ptradc->dmaPeripheralPtr, ptradc->dmastream);\n        /* Disable DMA stream */\n        LL_DMA_DisableChannel(ptradc->dmaPeripheralPtr, ptradc->dmastream);\n\n        uint32_T currentAddress = LL_DMA_GetDestAddress(ptradc->dmaPeripheralPtr, ptradc->dmastream);\n        \n        /* Check if DMA buffer is half filled for ADC-4*/\n        uint16_T *bufferPtrUint16 = (uint16_t *)ptradc->InternalBufferPtr +ptradc->InternalBufferSize;\n        #if defined(ADC4) && defined(STM32U5)\n        if ((ptradc->peripheralPtr == ADC4) && (currentAddress == (uint32_T)bufferPtrUint16))\n        {\n            ptradc->DataReadyBufferID = MW_ADC_DATA_IN_DMA_FIRST_HALF_BUFFER;\n        }\n        /* Data filled in first half of DMA buffer. DAR points to second half(DINC Enabled). */\n        else if ((ptradc->peripheralPtr == ADC1) && (currentAddress == (uint32_t)(&ptradc->InternalBufferPtr[ptradc->InternalBufferSize])))\n        #else\n        if ((ptradc->peripheralPtr == ADC1) && (currentAddress == (uint32_t)(&ptradc->InternalBufferPtr[ptradc->InternalBufferSize])))\n        #endif\n        {\n            ptradc->DataReadyBufferID = MW_ADC_DATA_IN_DMA_FIRST_HALF_BUFFER;\n        }\n        /* Data is filled in second half. Reset DAR to start of DMA buffer */\n        else \n        {\n            ptradc->DataReadyBufferID = MW_ADC_DATA_IN_DMA_SECOND_HALF_BUFFER;\n            LL_DMA_SetDestAddress(ptradc->dmaPeripheralPtr, ptradc->dmastream,(uint32_t)ptradc->InternalBufferPtr);\n        }\n\n        /* Set block data length in bytes to transfer */\n        LL_DMA_SetBlkDataLength(ptradc->dmaPeripheralPtr, ptradc->dmastream, ptradc->InternalBufferSize*bytesToCopy);\n        /* Start DMA again */\n        LL_DMA_EnableChannel(ptradc->dmaPeripheralPtr, ptradc->dmastream);\n        ret = 1;\n    }\n    else\n    {\n        ret = 0;\n    }\n    return ret;\n} \n#else\nuint8_T ADC_IsEnabledDMAITTransferComplete(ADC_Type_T * ptradc, uint32_t (*checkActiveFlag)(DMA_TypeDef *DMAx),  void (*clearActiveFlag)(DMA_TypeDef *DMAx))\n{\n    /* Check transfer-complete interrupt */\n    uint8_T ret;// = (uint8_T)LL_DMA_IsEnabledIT_TC(ptradc->dmaPeripheralPtr, ptradc->dmastream);\n    if ( (1 == (uint8_T)LL_DMA_IsEnabledIT_TC(ptradc->dmaPeripheralPtr, ptradc->dmastream)) && (1 == checkActiveFlag(ptradc->dmaPeripheralPtr)) )\n    {\n        ptradc->RegStatus = ADC_DMA_TRANSFER_FULL_TRIGGERED;\n        /* Clear transfer complete interrupt flag */\n        clearActiveFlag(ptradc->dmaPeripheralPtr); \n        /* Start DMA again when DMA mode is Normal */\n        if (LL_DMA_MODE_NORMAL == LL_DMA_GetMode(ptradc->dmaPeripheralPtr, ptradc->dmastream))\n        {\n            /* Disable DMA stream */\n            #if defined(STM32L4)\n               LL_DMA_DisableChannel(ptradc->dmaPeripheralPtr, ptradc->dmastream);\n            #else            \n                LL_DMA_DisableStream(ptradc->dmaPeripheralPtr, ptradc->dmastream);\n            #endif\n            /* Set length to receive */\n            LL_DMA_SetDataLength(ptradc->dmaPeripheralPtr, ptradc->dmastream, ptradc->InternalBufferSize);\n            /* Start DMA again */\n            #if defined(STM32L4)\n               LL_DMA_EnableChannel(ptradc->dmaPeripheralPtr, ptradc->dmastream);\n            #else  \n            LL_DMA_EnableStream(ptradc->dmaPeripheralPtr, ptradc->dmastream);\n            #endif\n        }\n        ret = 1;\n    }\n    else\n    {\n        ret = 0;\n    }\n    return ret;\n}\n#endif\n\n//#ifndef HWI_ADC_DMA_CONV_CMP_CALLBACK\n#if defined(MW_ADC1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_ADC1_DMA_ENABLED))\n/**\n* @brief This function handles DMAx y stream global interrupt for ADC1\n*/\nGETIRQ_NAME(MW_ADC1_DMA_ENABLED)\n{\n    /* DMA IRQ for ADC1 */\n    ADC_IsEnabledDMAITTransferComplete(&MW_ADC1_VAR, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_ADC1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_ADC1_DMA_STREAM));\n}\n#endif\n#if defined(MW_ADC2_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_ADC2_DMA_ENABLED))\n/**\n* @brief This function handles DMAx y stream global interrupt for ADC2\n*/\nGETIRQ_NAME(MW_ADC2_DMA_ENABLED)\n{\n    /* DMA IRQ for ADC2 */\n    ADC_IsEnabledDMAITTransferComplete(&MW_ADC2_VAR, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_ADC2_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_ADC2_DMA_STREAM));\n}\n#endif\n#if defined(MW_ADC3_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_ADC3_DMA_ENABLED))\n/**\n* @brief This function handles DMAx y stream global interrupt for ADC3\n*/\nGETIRQ_NAME(MW_ADC3_DMA_ENABLED)\n{\n    /* DMA IRQ for ADC3 */\n    ADC_IsEnabledDMAITTransferComplete(&MW_ADC3_VAR, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_ADC3_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_ADC3_DMA_STREAM));\n}\n#endif\n#if defined(MW_ADC4_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_ADC4_DMA_ENABLED))\n/**\n* @brief This function handles DMAx y stream global interrupt for ADC4\n*/\nGETIRQ_NAME(MW_ADC4_DMA_ENABLED)\n{\n    /* DMA IRQ for ADC4 */\n    ADC_IsEnabledDMAITTransferComplete(&MW_ADC4_VAR, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_ADC4_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_ADC4_DMA_STREAM));\n}\n#endif\n#if defined(MW_ADC5_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_ADC5_DMA_ENABLED))\n/**\n* @brief This function handles DMAx y stream global interrupt for ADC4\n*/\nGETIRQ_NAME(MW_ADC5_DMA_ENABLED)\n{\n    /* DMA IRQ for ADC5 */\n    ADC_IsEnabledDMAITTransferComplete(&MW_ADC5_VAR, GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_ADC5_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_ADC5_DMA_STREAM));\n}\n#endif\n#endif\n\n//#endif\n\n/*!\n* @brief Housekeeping for ADC peripheral if OVR Interrupt is enabled\n*\n* @param[in] ptradc   Pointer to MW ADC module - mw_adcx\n*\n* @return uint8_T\n*/\nuint8_T ADC_IsActiveFlagOVR(ADC_Type_T * ptradc)\n{\n    if(1 == (uint8_T)LL_ADC_IsActiveFlag_OVR(ptradc->peripheralPtr))\n    {\n        LL_ADC_ClearFlag_OVR(ptradc->peripheralPtr);\n        ptradc->RegStatus = ADC_OVR ;\n    }\n    return (ptradc->RegStatus == ADC_OVR );\n}\n#if MW_ADC_INJ_SUPPORTED == 1\n/*!\n* @brief Housekeeping for ADC peripheral if JEOS Interrupt is enabled\n*\n* @param[in] ptradc   Pointer to MW ADC module - mw_adcx\n*\n* @return uint8_T\n*/\nuint8_T ADC_IsActiveFlagJEOS(ADC_Type_T * ptradc)\n{\n    uint8_T ret = (uint8_T)LL_ADC_IsActiveFlag_JEOS(ptradc->peripheralPtr);\n    if(1 == ret)\n    {\n        /* Clear flag ADC group injected end of sequence conversions */\n        LL_ADC_ClearFlag_JEOS(ptradc->peripheralPtr);\n        /* Set the injected channel status as ADC ISR is triggered */\n        ptradc->InjStatus = ADC_INT_TRIGGERED;\n    }\n    return ret;\n}\n#endif\n/*!\n* @brief Housekeeping for ADC peripheral if EOCS Interrupt is enabled\n*\n* @param[in] ptradc   Pointer to MW ADC module - mw_adcx\n*\n* @return uint8_T\n*/\nuint8_T ADC_IsActiveFlagEOCS(ADC_Type_T * ptradc)\n{\n    uint8_T ret;\n    #if defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n    ret = (uint8_T)LL_ADC_IsActiveFlag_EOS(ptradc->peripheralPtr);\n    #else\n    ret = (uint8_T)LL_ADC_IsActiveFlag_EOCS(ptradc->peripheralPtr);\n    #endif\n\n    if(1 == ret)\n    {\n        /* Clear flag ADC group regular end of sequence conversions */\n        #if defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L5) || defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n        LL_ADC_ClearFlag_EOS(ptradc->peripheralPtr);\n        #else\n        LL_ADC_ClearFlag_EOCS(ptradc->peripheralPtr);\n        #endif\n        /* Set the regular channel status as ADC ISR is triggered */\n        ptradc->RegStatus = ADC_INT_TRIGGERED;\n    }\n    return ret;\n}\n\n\n#if defined(STM32F4) || defined(STM32F7) || defined(STM32WB) || defined(STM32U5) || defined(STM32H5)\n/**\n* @brief This function handles ADC1, ADC2 and ADC3 interrupts of STM32F4 and STM32F7 based hardware boards.\n*/\n#ifndef HWI_ADC_IRQ\n#if defined(STM32WB) || defined(STM32U5) || defined(STM32H5)\nvoid ADC1_IRQHandler(void)\n#else\nvoid ADC_IRQHandler(void)\n#endif\n{\n    #if defined(ADC1) && defined(MW_ADC1_ENABLED)\n    /* ADC IRQ for module ADC1 */\n    #if defined(MW_ADC1_INJ_IRQ_ENABLED)\n    ADC_IsActiveFlagJEOS(&mw_adc1);\n    #endif\n    #if defined(MW_ADC1_REG_IRQ_ENABLED)\n    ADC_IsActiveFlagEOCS(&mw_adc1);\n    #endif\n    #endif\n\t\n\t#if !defined(STM32WB) && !defined(STM32U5) &&  !defined(STM32H5)\n\t\t#if defined(ADC2) && defined(MW_ADC2_ENABLED)\n\t\t/* ADC IRQ for module ADC2 */\n\t\t#if defined(MW_ADC2_INJ_IRQ_ENABLED)\n\t\tADC_IsActiveFlagJEOS(&mw_adc2);\n\t\t#endif\n\t\t#if defined(MW_ADC2_REG_IRQ_ENABLED)\n\t\tADC_IsActiveFlagEOCS(&mw_adc2);\n\t\t#endif\n\t\t#endif\n\t\t#if defined(ADC3) && defined(MW_ADC3_ENABLED)\n\t\t/* ADC IRQ for module ADC3 */\n\t\t#if defined(MW_ADC3_INJ_IRQ_ENABLED)\n\t\tADC_IsActiveFlagJEOS(&mw_adc3);\n\t\t#endif\n\t\t#if defined(MW_ADC3_REG_IRQ_ENABLED)\n\t\tADC_IsActiveFlagEOCS(&mw_adc3);\n\t\t#endif\n\t\t#endif\n\t#endif\n}\n#endif\n\n#endif\n\n#if defined(STM32G4) || defined(STM32H7) || defined(STM32L5) || defined(STM32F3)\n#if ((defined(ADC1) && defined(MW_ADC1_ENABLED)) || (defined(ADC2) && defined(MW_ADC2_ENABLED)))\n#if (defined(STM32G4) || defined(STM32L5)) && !MW_GET_IRQ_HANDLER_DEFINE(ADC1_2_IRQHandler)\nvoid ADC1_2_IRQHandler(void)\n    #define MW_DEFINE_ADC1_2_IRQ_BODY 1\n    #elif defined(STM32H7) && !MW_GET_IRQ_HANDLER_DEFINE(ADC_IRQHandler)\n    void ADC_IRQHandler(void)\n    #define MW_DEFINE_ADC1_2_IRQ_BODY 1\n    #endif\n    #ifdef MW_DEFINE_ADC1_2_IRQ_BODY\n{\n    /* ADC IRQ for module ADC1 */\n    #if defined(MW_ADC1_INJ_IRQ_ENABLED)\n    ADC_IsActiveFlagJEOS(&mw_adc1);\n    #endif\n    #if defined(MW_ADC1_REG_IRQ_ENABLED)\n    ADC_IsActiveFlagEOCS(&mw_adc1);\n    #endif\n\n    /* ADC IRQ for module ADC2 */\n    #if defined(MW_ADC2_INJ_IRQ_ENABLED)\n    ADC_IsActiveFlagJEOS(&mw_adc2);\n    #endif\n    #if defined(MW_ADC2_REG_IRQ_ENABLED)\n    ADC_IsActiveFlagEOCS(&mw_adc2);\n    #endif\n}\n#endif\n#endif\n\n\n\n#if defined(ADC3) && defined(MW_ADC3_ENABLED) && !MW_GET_IRQ_HANDLER_DEFINE(ADC3_IRQHandler)\nvoid ADC3_IRQHandler(void)\n{\n    /* ADC IRQ for module ADC3 */\n    #if defined(MW_ADC3_INJ_IRQ_ENABLED)\n    ADC_IsActiveFlagJEOS(&mw_adc3);\n    #endif\n    #if defined(MW_ADC3_REG_IRQ_ENABLED)\n    ADC_IsActiveFlagEOCS(&mw_adc3);\n    #endif\n}\n#endif\n\n#if defined(ADC4) && defined(MW_ADC4_ENABLED) && !MW_GET_IRQ_HANDLER_DEFINE(ADC4_IRQHandler)\nvoid ADC4_IRQHandler(void)\n{\n    /* ADC IRQ for module ADC4 */\n    #if defined(MW_ADC4_INJ_IRQ_ENABLED)\n    ADC_IsActiveFlagJEOS(&mw_adc4);\n    #endif\n    #if defined(MW_ADC4_REG_IRQ_ENABLED)\n    ADC_IsActiveFlagEOCS(&mw_adc4);\n    #endif\n}\n#endif\n\n#if defined(ADC5) && defined(MW_ADC5_ENABLED) && !MW_GET_IRQ_HANDLER_DEFINE(ADC5_IRQHandler)\nvoid ADC5_IRQHandler(void)\n{\n    /* ADC IRQ for module ADC5 */\n    #if defined(MW_ADC5_INJ_IRQ_ENABLED)\n    ADC_IsActiveFlagJEOS(&mw_adc5);\n    #endif\n    #if defined(MW_ADC5_REG_IRQ_ENABLED)\n    ADC_IsActiveFlagEOCS(&mw_adc5);\n    #endif\n}\n#endif\n#endif\n\n#if defined(STM32H5)\n#if defined(ADC2) && defined(MW_ADC2_ENABLED) && !MW_GET_IRQ_HANDLER_DEFINE(ADC2_IRQHandler)\nvoid ADC2_IRQHandler(void)\n{\n    #if defined(ADC2) && defined(MW_ADC2_ENABLED)\n        /* ADC IRQ for module ADC1 */\n        #if defined(MW_ADC2_INJ_IRQ_ENABLED)\n            ADC_IsActiveFlagJEOS(&mw_adc2);\n        #endif\n        #if defined(MW_ADC2_REG_IRQ_ENABLED)\n            ADC_IsActiveFlagEOCS(&mw_adc2);\n        #endif\n    #endif\n}\n#endif\n#endif\n\n/* Configure PreChannel selection register for H7 */\n#ifdef STM32H7\nvoid configureADCChannelPreselectionRegister(ADC_TypeDef * ADCx, uint8_T noOfRegularConversions, uint8_T noOfInjectedConversions)\n{\n    if(noOfRegularConversions >= 1)\n    {\n        LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_1));\n        if(noOfRegularConversions >= 2)\n        {\n            LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_2));\n            if(noOfRegularConversions >= 3)\n            {\n                LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_3));\n                if(noOfRegularConversions >= 4)\n                {\n                    LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_4));\n                    if(noOfRegularConversions >= 5)\n                    {\n                        LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_5));\n                        if(noOfRegularConversions >= 6)\n                        {\n                            LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_6));\n                            if(noOfRegularConversions >= 7)\n                            {\n                                LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_7));\n                                if(noOfRegularConversions >= 8)\n                                {\n                                    LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_8));\n                                    if(noOfRegularConversions >= 9)\n                                    {\n                                        LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_9));\n                                        if(noOfRegularConversions >= 10)\n                                        {\n                                            LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_10));\n                                            if(noOfRegularConversions >= 11)\n                                            {\n                                                LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_11));\n                                                if(noOfRegularConversions >= 12)\n                                                {\n                                                    LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_12));\n                                                    if(noOfRegularConversions >= 13)\n                                                    {\n                                                        LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_13));\n                                                        if(noOfRegularConversions >= 14)\n                                                        {\n                                                            LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_14));\n                                                            if(noOfRegularConversions >= 15)\n                                                            {\n                                                                LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_15));\n                                                                if(noOfRegularConversions == 16)\n                                                                {\n                                                                    LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_REG_GetSequencerRanks(ADCx, LL_ADC_REG_RANK_16));\n                                                                }\n                                                            }\n\n                                                        }\n\n                                                    }\n\n                                                }\n\n                                            }\n\n                                        }\n\n                                    }\n\n                                }\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\t#if MW_ADC_INJ_SUPPORTED == 1\n    if(noOfInjectedConversions >= 1)\n    {\n        LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_INJ_GetSequencerRanks(ADCx, LL_ADC_INJ_RANK_1)) ;\n        if(noOfInjectedConversions >= 2)\n        {\n            LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_INJ_GetSequencerRanks(ADCx, LL_ADC_INJ_RANK_2)) ;\n            if(noOfInjectedConversions >= 3)\n            {\n                LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_INJ_GetSequencerRanks(ADCx, LL_ADC_INJ_RANK_3)) ;\n                if(noOfInjectedConversions >= 4)\n                {\n                    LL_ADC_SetChannelPreSelection(ADCx,LL_ADC_INJ_GetSequencerRanks(ADCx, LL_ADC_INJ_RANK_4)) ;\n                }\n            }\n        }\n    }\n\t#endif\n\n}\n#endif\n\n/* In case of STM32G4 and STM32H7, ADC should be started to make sure ADC is triggered from external peripherals. */\nvoid startADCConversionForExternalTrigger(ADC_Type_T* ptradc, uint8_T isRegular )\n{\n    #if defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L5) || defined(STM32L4) || defined(STM32U5) || defined(STM32F3)\n    if (1 == isRegular)\n    {\n        if (1 != LL_ADC_REG_IsTriggerSourceSWStart(ptradc->peripheralPtr))\n        {\n            LL_ADC_REG_StartConversion(ptradc->peripheralPtr);\n        }\n    }\n    else\n    {\t\n\t\t#if MW_ADC_INJ_SUPPORTED == 1\n        if (1 != LL_ADC_INJ_IsTriggerSourceSWStart(ptradc->peripheralPtr))\n        {\n            LL_ADC_INJ_StartConversion(ptradc->peripheralPtr);\n        }\n\t\t#endif\n    }\n    #endif\n}\n\nvoid MW_ADC_INJ_Init(ADC_TypeDef *ADCx, uint32_T noOfConversionEnable)\n{\n    #if defined(STM32H7) && (defined(CORE_CM4) || defined(CORE_CM7))\n\tLL_ADC_Disable(ADCx);\n\twhile(LL_ADC_IsEnabled(ADCx)){}\n\tLL_ADC_INJ_InitTypeDef ADC_INJ_InitStruct = {0};\n\n    #if defined(ADC1) && defined(MW_ADC1_EXT_TRIG_INJ_CONV_SOURCE)\n    if(ADCx == ADC1)\n\t    ADC_INJ_InitStruct.TriggerSource =  MW_ADC1_EXT_TRIG_INJ_CONV_SOURCE;\n    #endif\n\n    #if defined(ADC2) && defined(MW_ADC2_EXT_TRIG_INJ_CONV_SOURCE)\n    if(ADCx == ADC2)\n\t    ADC_INJ_InitStruct.TriggerSource =  MW_ADC2_EXT_TRIG_INJ_CONV_SOURCE;\n    #endif\n\n    #if defined(ADC3) && defined(MW_ADC3_EXT_TRIG_INJ_CONV_SOURCE)\n    if(ADCx == ADC3)\n\t    ADC_INJ_InitStruct.TriggerSource =  MW_ADC3_EXT_TRIG_INJ_CONV_SOURCE;\n    #endif\n\n    ADC_INJ_InitStruct.SequencerLength = noOfConversionEnable;\n\tADC_INJ_InitStruct.SequencerDiscont = LL_ADC_INJ_SEQ_DISCONT_DISABLE;\n\tADC_INJ_InitStruct.TrigAuto = LL_ADC_INJ_TRIG_INDEPENDENT;\n\tLL_ADC_INJ_Init(ADCx, &ADC_INJ_InitStruct);\n\tLL_ADC_INJ_SetQueueMode(ADCx, LL_ADC_INJ_QUEUE_DISABLE);\n\tLL_ADC_SetOverSamplingScope(ADCx, LL_ADC_OVS_DISABLE);\n\n    #if defined(ADC1) && defined(MW_ADC1_EXT_TRIG_INJ_CONV_EDGE)\n    if(ADCx == ADC1)\n        LL_ADC_INJ_SetTriggerEdge(ADCx, MW_ADC1_EXT_TRIG_INJ_CONV_EDGE);\n    #endif\n    \n    #if defined(ADC2) && defined(MW_ADC2_EXT_TRIG_INJ_CONV_EDGE)\n    if(ADCx == ADC2)\n        LL_ADC_INJ_SetTriggerEdge(ADCx, MW_ADC2_EXT_TRIG_INJ_CONV_EDGE);\n    #endif\n    \n    #if defined(ADC3) && defined(MW_ADC3_EXT_TRIG_INJ_CONV_EDGE)\n    if(ADCx == ADC3)\n        LL_ADC_INJ_SetTriggerEdge(ADCx, MW_ADC3_EXT_TRIG_INJ_CONV_EDGE);\n    #endif\n    \n\tLL_ADC_Enable(ADCx);\n    #endif\n}\n/*!\n* @brief Configure ADC peripheral\n*\n* @param[in] ptradc                 Pointer to ADC module used to configure ADC\n* @param[in] mode                   ADC mode operated in\n*                                       @arg @ref ADC_NORMAL_MODE\n*                                       @arg @ref ADC_INTERRUPT_MODE\n*                                       @arg @ref ADC_DMA_INTERRUPT_MODE\n* @param[in] isRegular              Regular channel configuration\n* @param[in] triggerType            ADC trigger type\n*                                       @arg @ref ADC_TRIGGER\n*                                       @arg @ref ADC_READ\n*                                       @arg @ref ADC_TRIGGER_AND_READ\n* @param[in] noOfConversionEnable   Number of Conversions configured on the block\n*\n* @return                           Pointer to MW ADC module - mw_adcx\n*/\nADC_Type_T* ADC_Handle_Init(ADC_Type_T* ptradc, uint16_T mode, uint16_T isRegualar, uint16_T triggerType, uint32_T noOfConversionEnable)\n{\n    ADC_Type_T* tempptradc = NULL;\n\n    #if defined(ADC1) && defined(MW_ADC1_ENABLED)\n    if (ADC1 == (ADC_TypeDef *)ptradc->peripheralPtr)\n    {\n        tempptradc = &mw_adc1;\n        #if defined(MW_ADC1_OVR_IRQ_ENABLED)\n        LL_ADC_EnableIT_OVR(ADC1);\n        #endif\n    }\n    else\n        #endif\n\n        #if defined(ADC2) && defined(MW_ADC2_ENABLED)\n        if (ADC2 == (ADC_TypeDef *)ptradc->peripheralPtr)\n        {\n            tempptradc = &mw_adc2;\n            #if defined(MW_ADC2_OVR_IRQ_ENABLED)\n            LL_ADC_EnableIT_OVR(ADC2);\n            #endif\n        }\n    else\n        #endif\n\n        #if defined(ADC3) && defined(MW_ADC3_ENABLED)\n        if (ADC3 == (ADC_TypeDef *)ptradc->peripheralPtr)\n        {\n            tempptradc = &mw_adc3;\n            #if defined(MW_ADC3_OVR_IRQ_ENABLED)\n            LL_ADC_EnableIT_OVR(ADC3);\n            #endif\n        }\n    else\n        #endif\n\n        #if defined(ADC4) && defined(MW_ADC4_ENABLED)\n        if (ADC4 == (ADC_TypeDef *)ptradc->peripheralPtr)\n        {\n            tempptradc = &mw_adc4;\n            #if defined(MW_ADC4_OVR_IRQ_ENABLED)\n            LL_ADC_EnableIT_OVR(ADC4);\n            #endif\n        }\n    else\n        #endif\n\n        #if defined(ADC5) && defined(MW_ADC5_ENABLED)\n        if (ADC5 == (ADC_TypeDef *)ptradc->peripheralPtr)\n        {\n            tempptradc = &mw_adc5;\n            #if defined(MW_ADC5_OVR_IRQ_ENABLED)\n            LL_ADC_EnableIT_OVR(ADC5);\n            #endif\n        }\n    else\n        #endif\n\n    {\n    }\n\n    if (NULL != tempptradc)\n    {\n        tempptradc->peripheralPtr = (ADC_TypeDef *)ptradc->peripheralPtr;\n        tempptradc->DataReadyBufferID = MW_ADC_DATA_IN_DMA_FIRST_HALF_BUFFER;\n        if(ADC_TRIGGER != triggerType)\n        {\n            if(isRegualar && (ADC_DATA_READ != tempptradc->RegStatus))\n            {\n                /* Regular channel */\n                /* Set the buffer Pointer */\n                tempptradc->InternalBufferPtr = ptradc->InternalBufferPtr;\n                /* Set the buffer size */\n                tempptradc->InternalBufferSize = ptradc->InternalBufferSize;\n                /* Set the DMA peripheral pointer used by the regular channel */\n                tempptradc->dmaPeripheralPtr = (DMA_TypeDef *)ptradc->dmaPeripheralPtr;\n                /* Set the DMA stream used by the ADC module */\n                tempptradc->dmastream = ptradc->dmastream;\n                /* Set the number of regular channel */\n                tempptradc->RegularNoOfConversion = ptradc->RegularNoOfConversion;\n                 \n                /* Set the number of regular channel depending the value set on the block */\n                /* Provide a way to use less/equal to channels than configured in ioc project */\n                LL_ADC_REG_SetSequencerLength(tempptradc->peripheralPtr,noOfConversionEnable);\n                if(ADC_NORMAL_MODE == mode)\n                {\n                    /* Normal - Software trigger Polling */\n                }\n                else if(ADC_DMA_INTERRUPT_MODE == mode)\n                {\n                    /* DMA requests are issued as long as data are converted */\n                    #if defined(STM32H7)\n                        LL_ADC_REG_SetDataTransferMode(tempptradc->peripheralPtr, LL_ADC_REG_DMA_TRANSFER_UNLIMITED);\n                    #elif !defined(STM32U5) || !defined(STM32H5)\n                        LL_ADC_REG_SetDMATransfer(tempptradc->peripheralPtr, LL_ADC_REG_DMA_TRANSFER_UNLIMITED);\n                    #endif\n                    #if defined(STM32U5) && (defined(MW_ADC1_ENABLED) || defined(MW_ADC4_ENABLED))\n                        if (tempptradc->peripheralPtr == ADC1)\n                        {\n                            LL_ADC_REG_SetDataTransferMode(tempptradc->peripheralPtr, ptradc->DataTransferMode);\n                        }\n                        else if (tempptradc->peripheralPtr == ADC4)\n                        {\n                            LL_ADC_REG_SetDMATransfer(tempptradc->peripheralPtr, ptradc->DmaTransferMode);\n                        }\n                    #endif\n                    configure_ADCs_DMA(tempptradc->peripheralPtr,tempptradc->dmaPeripheralPtr,tempptradc->dmastream,tempptradc->InternalBufferPtr,tempptradc->InternalBufferSize);\n                }\n                else if(ADC_INTERRUPT_MODE == mode)\n                {\n                    /* Enable ADC EOC for ISR to get trigger */\n                    #if defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n                    LL_ADC_EnableIT_EOS(tempptradc->peripheralPtr);\n                    #else\n                    LL_ADC_EnableIT_EOCS(tempptradc->peripheralPtr);\n                    #endif\n                }\n                /* Set regular ADC status as adc read */\n                tempptradc->RegStatus = ADC_DATA_READ;\n            }\n            else if((0 == isRegualar) && (ADC_DATA_READ != tempptradc->InjStatus))\n            {\n\t\t\t\t#if MW_ADC_INJ_SUPPORTED == 1\n                /* Injected channel */\n                /* Get the injected number of conversion */\n                tempptradc->InjectedNoOfConversion = ptradc->InjectedNoOfConversion;\n\t\t\t\t#if defined(STM32H7) && (defined(CORE_CM4) || defined(CORE_CM7))\n\t\t\t\tMW_ADC_INJ_Init(tempptradc->peripheralPtr, noOfConversionEnable);\n\t\t\t\t#endif\n                //Don't over write the injected number of channel as its sequence of conversion is opposite\n                //LL_ADC_INJ_SetSequencerLength(tempptradc->peripheralPtr,noOfConversionEnable);\n                if(ADC_INTERRUPT_MODE == mode)\n                {\n                    /* Enable ADC EOC for ISR to get trigger */\n                    LL_ADC_EnableIT_JEOS(tempptradc->peripheralPtr);\n                }\n                /* Set regular ADC status as adc read */\n                tempptradc->InjStatus = ADC_DATA_READ;\n\t\t\t\t#endif\n            }\n        }\n    }\n    return tempptradc;\n}\n\n/*!\n* @brief Enable ADC peripheral\n*\n* @param[in] ptradc                Pointer to ADC module\n\n* @return                          void\n*/\n\nvoid enableADC( ADC_Type_T * ptradc)\n{\n    /* Enable ADC */\n    if (LL_ADC_IsEnabled(ptradc->peripheralPtr) == 0)\n    {\n        /* On the ADC module */\n        LL_ADC_Enable(ptradc->peripheralPtr);\n    }\n}\n/*!\n* @brief Read regular channel ADC in normal mode\n*\n* @param[in] ptradc         Pointer to MW ADC module - mw_adcx\n* @param[in] triggerType    ADC trigger type\n*                                @arg @ref ADC_TRIGGER\n*                                @arg @ref ADC_READ\n*                                @arg @ref ADC_TRIGGER_AND_READ\n* @param[out] result        Output ADC read data value\n*\n* @return                   Status of the data field 0-Valid/1- Invalid\n*/\nuint16_T regularReadADCNormal(ADC_Type_T * ptradc, uint16_T triggerType, ADC_Buffer_DataType_T* result)\n{\n    uint16_T status = 1;\n    /* if ADC is busy and request is not to read the data return status as 1 */\n    if(NULL != ptradc->peripheralPtr)\n    {\n        if(ADC_TRIGGER == triggerType)\n        {\n            status = regularADCTrigger(ptradc);\n        }\n        else if(ADC_TRIGGER_AND_READ == triggerType)\n        {\n            if(LL_ADC_REG_IsTriggerSourceSWStart(ptradc->peripheralPtr))\n            {\n                ptradc->RegStatus = ADC_BUSY;\n                #if defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n                LL_ADC_REG_StartConversion(ptradc->peripheralPtr);\n                while (LL_ADC_IsActiveFlag_EOS(ptradc->peripheralPtr) == 0);\n                #if defined(STM32H7) || defined(STM32U5)\n                result[ptradc->RegularNoOfConversion-1] = LL_ADC_REG_ReadConversionData32(ptradc->peripheralPtr);\n                #else\n                result[ptradc->RegularNoOfConversion-1] = LL_ADC_REG_ReadConversionData12(ptradc->peripheralPtr);\n                #endif\n                LL_ADC_ClearFlag_EOS(ptradc->peripheralPtr);\n                #else\n                LL_ADC_REG_StartConversionSWStart(ptradc->peripheralPtr);\n                while (LL_ADC_IsActiveFlag_EOCS(ptradc->peripheralPtr) == 0);\n                result[ptradc->RegularNoOfConversion-1] = LL_ADC_REG_ReadConversionData12(ptradc->peripheralPtr);\n                LL_ADC_ClearFlag_EOCS(ptradc->peripheralPtr);\n                #endif\n                ptradc->RegStatus = ADC_DATA_READ;\n                status = 0;\n            }\n        }\n        else if(ADC_READ == triggerType)\n        {\n            #if defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n            if( (ADC_BUSY_BUT_DATA_AVAILABLE == ptradc->RegStatus) || (1 == LL_ADC_IsActiveFlag_EOS(ptradc->peripheralPtr)) || (ADC_OVR == ptradc->RegStatus) )\n            {\n                LL_ADC_ClearFlag_EOS(ptradc->peripheralPtr);\n\t\t\t#else\n\t\t\tif( (ADC_BUSY_BUT_DATA_AVAILABLE == ptradc->RegStatus) || (1 == LL_ADC_IsActiveFlag_EOCS(ptradc->peripheralPtr)) || (ADC_OVR == ptradc->RegStatus) )\n\t\t\t{\n\t\t\t\tLL_ADC_ClearFlag_EOCS(ptradc->peripheralPtr);\n\t\t\t#endif\n\t\t\t\tif(0 == ADC_IsActiveFlagOVR(ptradc))\n\t\t\t\t{\n\t\t\t\t\tstatus = 0;\n\t\t\t\t}\n\t\t\t\tptradc->RegStatus = ADC_DATA_READ;\n\t\t\t\t#if defined(STM32H7) || defined(STM32U5)\n\t\t\t\tresult[ptradc->RegularNoOfConversion-1] = LL_ADC_REG_ReadConversionData32(ptradc->peripheralPtr);\n\t\t\t\t#else\n\t\t\t\tresult[ptradc->RegularNoOfConversion-1] = LL_ADC_REG_ReadConversionData12(ptradc->peripheralPtr);\n\t\t\t\t#endif\n\t\t\t}\n\t\t}\n\t}\n    return status;\n}\n\n\n/*!\n* @brief Read regular channel ADC in DMA mode\n*\n* @param[in] ptradc         Pointer to MW ADC module - mw_adcx\n* @param[in] triggerType    ADC trigger type\n*                                @arg @ref ADC_TRIGGER\n*                                @arg @ref ADC_READ\n*                                @arg @ref ADC_TRIGGER_AND_READ\n* @param[out] result        Output ADC read data value\n*\n* @return                   Status of the data field 0-Valid/1- Invalid\n*/\nuint16_T regularReadADCDMA(ADC_Type_T * ptradc, uint16_T triggerType, ADC_Buffer_DataType_T* result)\n{\n    uint16_T status = 1;\n    /* if ADC is busy and request is not to read the data return status as 1 */\n    if(NULL != ptradc->peripheralPtr)\n    {\n        #if defined(MW_ADC1_DMA_ENABLED) || defined(MW_ADC2_DMA_ENABLED) || defined(MW_ADC3_DMA_ENABLED) || defined(MW_ADC4_DMA_ENABLED) || defined(MW_ADC5_DMA_ENABLED)\n        if(ADC_TRIGGER == triggerType)\n        {\n            status = regularADCTrigger(ptradc);\n        }\n        else if(ADC_TRIGGER_AND_READ == triggerType)\n        {\n            if(LL_ADC_REG_IsTriggerSourceSWStart(ptradc->peripheralPtr))\n            {\n                ptradc->RegStatus = ADC_BUSY;\n                #if defined (STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n                LL_ADC_REG_StartConversion(ptradc->peripheralPtr);\n                #else\n                LL_ADC_REG_StartConversionSWStart(ptradc->peripheralPtr);\n                #endif\n                /* Wait until requested number of channels are converted and\n                copied to memory buffer using DMA */\n                while(ADC_DMA_TRANSFER_FULL_TRIGGERED != ptradc->RegStatus);\n                /* Copy ADC data from DMA buffer */\n                copyADCChannelsFromDMABuffer(ptradc, result);\n                ptradc->RegStatus = ADC_DATA_READ;\n                status = 0;\n            }\n        }\n        else if(ADC_READ == triggerType)\n        {\n            if((ADC_BUSY_BUT_DATA_AVAILABLE == ptradc->RegStatus) || (ADC_DMA_TRANSFER_FULL_TRIGGERED == ptradc->RegStatus) || (ADC_OVR == ptradc->RegStatus))\n            {\n                ptradc->RegStatus = ADC_DATA_READ;\n                /* Copy ADC data from DMA buffer */\n                copyADCChannelsFromDMABuffer(ptradc, result);\n                status = 0;\n            }\n        }\n\n        #endif\n    }\n    return status;\n}\n\n/*!\n* @brief Read regular channel ADC in Interrupt mode\n*\n* @param[in] ptradc         Pointer to MW ADC module - mw_adcx\n* @param[in] triggerType    ADC trigger type\n*                                @arg @ref ADC_TRIGGER\n*                                @arg @ref ADC_READ\n*                                @arg @ref ADC_TRIGGER_AND_READ\n* @param[out] result        Output ADC read data value\n*\n* @return                   Status of the data field 0-Valid/1- Invalid\n*/\nuint16_T regularReadADCIntr(ADC_Type_T * ptradc, uint16_T triggerType, ADC_Buffer_DataType_T * result)\n{\n    uint16_T status = 1;\n    /* if ADC is busy and request is not to read the data return status as 1 */\n    if(NULL != ptradc->peripheralPtr)\n    {\n        if(ADC_TRIGGER == triggerType)\n        {\n            status = regularADCTrigger(ptradc);\n        }\n        else if(ADC_TRIGGER_AND_READ == triggerType)\n        {\n            if(LL_ADC_REG_IsTriggerSourceSWStart(ptradc->peripheralPtr))\n            {\n                ptradc->RegStatus = ADC_BUSY;\n                #if defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n                LL_ADC_REG_StartConversion(ptradc->peripheralPtr);\n                #else\n                LL_ADC_REG_StartConversionSWStart(ptradc->peripheralPtr);\n                #endif\n                while(ADC_INT_TRIGGERED != ptradc->RegStatus);\n                #if defined(STM32H7) || defined(STM32U5)\n                result[ptradc->RegularNoOfConversion-1] = LL_ADC_REG_ReadConversionData32(ptradc->peripheralPtr);\n                #else\n                result[ptradc->RegularNoOfConversion-1] = LL_ADC_REG_ReadConversionData12(ptradc->peripheralPtr);\n                #endif\n                ptradc->RegStatus = ADC_DATA_READ;\n                status = 0;\n            }\n        }\n        else if(ADC_READ == triggerType)\n        {\n            if((ADC_BUSY_BUT_DATA_AVAILABLE == ptradc->RegStatus) || (ADC_INT_TRIGGERED == ptradc->RegStatus) || (ADC_OVR == ptradc->RegStatus))\n            {\n                if(0 == ADC_IsActiveFlagOVR(ptradc))\n                {\n                    status = 0;\n                }\n                ptradc->RegStatus = ADC_DATA_READ;\n                #if defined(STM32H7) || defined(STM32U5)\n                result[ptradc->RegularNoOfConversion-1] = LL_ADC_REG_ReadConversionData32(ptradc->peripheralPtr);\n                #else\n                result[ptradc->RegularNoOfConversion-1] = LL_ADC_REG_ReadConversionData12(ptradc->peripheralPtr);\n                #endif\n            }\n        }\n    }\n    return status;\n}\n#if MW_ADC_INJ_SUPPORTED == 1\n/*!\n* @brief Read injected channel ADC in normal mode\n*\n* @param[in] ptradc         Pointer to MW ADC module - mw_adcx\n* @param[in] triggerType    ADC trigger type\n*                                @arg @ref ADC_TRIGGER\n*                                @arg @ref ADC_READ\n*                                @arg @ref ADC_TRIGGER_AND_READ\n* @param[out] result        Output ADC read data value\n*\n* @return                   Status of the data field 0-Valid/1- Invalid\n*/\nuint16_T injectedReadADCNormal(ADC_Type_T * ptradc, uint16_T triggerType, ADC_Buffer_DataType_T *data)\n{\n    uint16_T status = 1;\n    if(NULL != ptradc->peripheralPtr)\n    {\n        if(ADC_TRIGGER == triggerType)\n        {\n            status = injectedADCTrigger(ptradc);\n        }\n        else if(ADC_TRIGGER_AND_READ == triggerType)\n        {\n            if(LL_ADC_INJ_IsTriggerSourceSWStart(ptradc->peripheralPtr))\n            {\n                ptradc->InjStatus = ADC_BUSY;\n                #if defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n                LL_ADC_INJ_StartConversion(ptradc->peripheralPtr);\n                #else\n                LL_ADC_INJ_StartConversionSWStart(ptradc->peripheralPtr);\n                #endif\n                while (LL_ADC_IsActiveFlag_JEOS(ptradc->peripheralPtr) == 0);\n                injectedOnlyReadADC(ptradc->peripheralPtr,ptradc->InjectedNoOfConversion,data);\n                LL_ADC_ClearFlag_JEOS(ptradc->peripheralPtr);\n                ptradc->InjStatus = ADC_DATA_READ;\n                status = 0;\n            }\n        }\n        else if(ADC_READ == triggerType)\n        {\n            if((ADC_BUSY_BUT_DATA_AVAILABLE == ptradc->InjStatus) || (1 == LL_ADC_IsActiveFlag_JEOS(ptradc->peripheralPtr)))\n            {\n                LL_ADC_ClearFlag_JEOS(ptradc->peripheralPtr);\n                ptradc->InjStatus = ADC_DATA_READ;\n                injectedOnlyReadADC(ptradc->peripheralPtr,ptradc->InjectedNoOfConversion,data);\n                status = 0;\n            }\n        }\n    }\n    return status;\n}\n/*!\n* @brief Read injected channel ADC in interrupt mode\n*\n* @param[in] ptradc         Pointer to MW ADC module - mw_adcx\n* @param[in] triggerType    ADC trigger type\n*                                @arg @ref ADC_TRIGGER\n*                                @arg @ref ADC_READ\n*                                @arg @ref ADC_TRIGGER_AND_READ\n* @param[out] result        Output ADC read data value\n*\n* @return                   Status of the data field 0-Valid/1- Invalid\n*/\nuint16_T injectedReadADCIntr(ADC_Type_T * ptradc, uint16_T triggerType, ADC_Buffer_DataType_T *data)\n{\n    uint16_T status = 1;\n    if(NULL != ptradc->peripheralPtr)\n    {\n        if(ADC_TRIGGER == triggerType)\n        {\n            status = injectedADCTrigger(ptradc);\n        }\n        else if(ADC_TRIGGER_AND_READ == triggerType)\n        {\n            if(LL_ADC_INJ_IsTriggerSourceSWStart(ptradc->peripheralPtr))\n            {\n                ptradc->InjStatus = ADC_BUSY;\n                #if defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n                LL_ADC_INJ_StartConversion(ptradc->peripheralPtr);\n                #else\n                LL_ADC_INJ_StartConversionSWStart(ptradc->peripheralPtr);\n                #endif\n                while(ADC_INT_TRIGGERED != ptradc->InjStatus);\n                injectedOnlyReadADC(ptradc->peripheralPtr,ptradc->InjectedNoOfConversion,data);\n                ptradc->InjStatus = ADC_DATA_READ;\n                status = 0;\n            }\n        }\n        else if(ADC_READ == triggerType)\n        {\n            if((ADC_BUSY_BUT_DATA_AVAILABLE == ptradc->InjStatus) || ADC_INT_TRIGGERED == ptradc->InjStatus)\n            {\n                ptradc->InjStatus = ADC_DATA_READ;\n                injectedOnlyReadADC(ptradc->peripheralPtr,ptradc->InjectedNoOfConversion,data);\n                status = 0;\n            }\n        }\n    }\n    return status;\n}\n#endif\n\n/*!\n* @brief De-configure ADC peripheral\n*\n* @param[in] ptradc                Pointer to ADC module\n* @param[in] mode                  ADC mode operated in\n*                                       @arg @ref ADC_NORMAL_MODE\n*                                       @arg @ref ADC_INTERRUPT_MODE\n*                                       @arg @ref ADC_DMA_INTERRUPT_MODE\n* @param[in] isRegular             Regular channel configuration\n*\n* @return                          void\n*/\nvoid ADC_Handle_Deinit(ADC_Type_T * ptradc, uint16_T mode, uint16_T isRegualar)\n{\n    /* Disable ADC */\n    if (LL_ADC_IsEnabled(ptradc->peripheralPtr))\n    {\n        LL_ADC_Disable(ptradc->peripheralPtr);\n    }\n    if (LL_ADC_IsEnabledIT_AWD1(ptradc->peripheralPtr))\n    {\n        LL_ADC_DisableIT_AWD1(ptradc->peripheralPtr);\n    }\n    if (LL_ADC_IsEnabledIT_OVR(ptradc->peripheralPtr))\n    {\n        LL_ADC_DisableIT_OVR(ptradc->peripheralPtr);\n    }\n    if(isRegualar)\n    {\n        if(ADC_NORMAL_MODE == mode)\n        {\n            /* Normal - Software trigger Polling */\n        }\n        else if(ADC_INTERRUPT_MODE == mode)\n        {\n            /* Disable ADC EOC for ISR to get trigger */\n            #if defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32L5)|| defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n            LL_ADC_DisableIT_EOS(ptradc->peripheralPtr);\n            #else\n            LL_ADC_DisableIT_EOCS(ptradc->peripheralPtr);\n            #endif\n        }\n        else if(ADC_DMA_INTERRUPT_MODE == mode)\n        {\n            deconfigure_ADCs_DMA(ptradc->peripheralPtr,ptradc->dmaPeripheralPtr,ptradc->dmastream);\n            /* Set DMA transfer to None */\n            #ifndef STM32H7\n            LL_ADC_REG_SetDMATransfer(ptradc->peripheralPtr, LL_ADC_REG_DMA_TRANSFER_NONE);\n            #endif\n        }\n        ptradc->InternalBufferPtr = NULL;\n        ptradc->InternalBufferSize = 0;\n        ptradc->dmaPeripheralPtr = NULL;\n        ptradc->dmastream = 0;\n        ptradc->RegularNoOfConversion = 0;\n        ptradc->RegStatus = ADC_DEINIT;\n        LL_ADC_REG_SetSequencerLength(ptradc->peripheralPtr,ptradc->RegularNoOfConversion);\n    }\n    else\n    {\n        ptradc->InjectedNoOfConversion = 0;\n        ptradc->InjStatus = ADC_DEINIT;\n\t\t#if MW_ADC_INJ_SUPPORTED == 1\n        if(ADC_INTERRUPT_MODE == mode)\n        {\n            /* Disable ADC EOC for ISR to get trigger */\n            LL_ADC_DisableIT_JEOS(ptradc->peripheralPtr);\n        }\n\t\t#endif\n\t\t\n    }\n}\n\n/* ADC Calibration functions */\n\nvoid enableADCAutomaticCalibration (ADC_Type_T * ptradc, uint32_T calibrationMode, uint8_T adcConversionMode)\n{\n    #if defined(STM32H7)\n    if (LL_ADC_IsEnabled(ptradc->peripheralPtr) == 1)\n    {\n        /* Disable the ADC module */\n        LL_ADC_Disable(ptradc->peripheralPtr);\n    }\n\n    if(adcConversionMode == 0) /* Only single ended calibration */\n    {\n        LL_ADC_StartCalibration (ptradc->peripheralPtr, calibrationMode, LL_ADC_SINGLE_ENDED);\n        while(LL_ADC_IsCalibrationOnGoing(ptradc->peripheralPtr) == 1);\n    }\n    else if(adcConversionMode == 1) /*Only differential ended calibration */\n    {\n\t\t#if defined(LL_ADC_DIFFERENTIAL_ENDED)\n        LL_ADC_StartCalibration (ptradc->peripheralPtr, calibrationMode, LL_ADC_DIFFERENTIAL_ENDED);\n        while(LL_ADC_IsCalibrationOnGoing(ptradc->peripheralPtr) == 1);\n\t\t#endif\n\n    }\n    else /*Both single and differential ended calibration */\t\n\t{ \t\n\t\tLL_ADC_StartCalibration (ptradc->peripheralPtr, calibrationMode, LL_ADC_SINGLE_ENDED);\n\t\twhile(LL_ADC_IsCalibrationOnGoing(ptradc->peripheralPtr) == 1);\n\t\t\n\t\t#if defined(LL_ADC_DIFFERENTIAL_ENDED)\n\t\tLL_ADC_StartCalibration (ptradc->peripheralPtr, calibrationMode, LL_ADC_DIFFERENTIAL_ENDED);\n\t\twhile(LL_ADC_IsCalibrationOnGoing(ptradc->peripheralPtr) == 1);\n\t\t#endif\n    }\n    /*Delay between end of ADC calibration and ADC Start*/\n    volatile uint32_T count = LL_ADC_DELAY_CALIB_ENABLE_ADC_CYCLES;\n    while(count > 0)\n    {\n        count-- ;\n    }\n    #endif\n    #if defined(STM32U5)\n        LL_ADC_StartCalibration (ptradc->peripheralPtr, calibrationMode);\n\t    while(LL_ADC_IsCalibrationOnGoing(ptradc->peripheralPtr) == 1);\n        /*Delay between end of ADC calibration and ADC Start*/\n        volatile uint32_T count = LL_ADC_DELAY_CALIB_ENABLE_ADC_CYCLES;\n        while(count > 0)\n        {\n            count-- ;\n        }\n    #endif\n}\n\nvoid enableADCAutomaticCalibrationOffset (ADC_Type_T * ptradc, uint8_T adcConversionMode)\n{\n    #if defined(STM32G4) || defined(STM32WB) || defined(STM32L5) || defined(STM32L4) || defined(STM32F3) || defined(STM32H5)\n    int8_t isEnabled;\n    volatile int16_t cnt;\n    isEnabled = LL_ADC_IsEnabled(ptradc->peripheralPtr);\n    if (1 == isEnabled)\n    {\n        /* Disable the ADC module */\n        LL_ADC_Disable(ptradc->peripheralPtr);\n    }\n\n    if(adcConversionMode == 0)\n    {\n        LL_ADC_StartCalibration (ptradc->peripheralPtr, LL_ADC_SINGLE_ENDED);\n        while(LL_ADC_IsCalibrationOnGoing(ptradc->peripheralPtr) == 1);\n    }\n    else if(adcConversionMode == 1)\n    {\n        #if defined(LL_ADC_DIFFERENTIAL_ENDED)\n        LL_ADC_StartCalibration (ptradc->peripheralPtr, LL_ADC_DIFFERENTIAL_ENDED);\n        while(LL_ADC_IsCalibrationOnGoing(ptradc->peripheralPtr) == 1);\n        #endif\n    }\n    else{\n        LL_ADC_StartCalibration (ptradc->peripheralPtr, LL_ADC_SINGLE_ENDED);\n        while(LL_ADC_IsCalibrationOnGoing(ptradc->peripheralPtr) == 1);\n        //For ADC_SUPPORT_2_5_MSPS only single ADC mode is available\n        #if defined(LL_ADC_DIFFERENTIAL_ENDED)    \n        /* Delay between starting ADC Single Ended and Differential Ended Calibration */\n        for (cnt = 0; cnt < LL_ADC_DELAY_CALIB_ENABLE_ADC_CYCLES; cnt++)\n        {\n        \t__NOP();\n        }\n        LL_ADC_StartCalibration (ptradc->peripheralPtr, LL_ADC_DIFFERENTIAL_ENDED);\n        while(LL_ADC_IsCalibrationOnGoing(ptradc->peripheralPtr) == 1);\n        #endif\n\n    }\n    /*Delay between end of ADC calibration and ADC Start */\n    for (cnt = 0; cnt < LL_ADC_DELAY_CALIB_ENABLE_ADC_CYCLES; cnt++)\n    {\n      \t__NOP();\n    }\n\n    if (1 == isEnabled)\n    {\n    \tLL_ADC_Enable(ptradc->peripheralPtr);\n    }\n    #endif\n}\n\n\n/* LocalWords:  ptradc mw adcx ADCx DMAx halfword Addr PERIPH IRQ ISR OVR ioc EOC INJ tempptradc dma\n* LocalWords:  JEOS EOCS dmastream HWI CMP MSPS\n*/\n"},{"name":"stm_can_hal.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\shared\\supportpackages\\stm32\\src","tag":"","groupDisplay":"Other files","code":"/* stm_can_hal.c: Source file for STM32 HAL based bxCAN driver implementation*/\n\n/* Copyright 2022-2024 The MathWorks, Inc. */\n#include \"main.h\"\n#include \"mw_stm32_types.h\"\n#include \"stm_can_hal.h\"\n\n#define MAXCANMODULE 3\n#define MAXCANFILTERPERMODULE 14\n#if defined(CAN) && defined(MW_CAN1_ENABLED) && !defined(CAN1)\nCAN_Type_T mw_can={0,0};\nextern CAN_HandleTypeDef hcan;\n#endif\n#if defined(CAN1) && defined(MW_CAN1_ENABLED)\nCAN_Type_T mw_can1={0,0};\nextern CAN_HandleTypeDef hcan1;\n#endif\n#if defined(CAN2) && defined(MW_CAN2_ENABLED)\nCAN_Type_T mw_can2={0,0};\nextern CAN_HandleTypeDef hcan2;\n#endif\n#if defined(CAN3) && defined(MW_CAN3_ENABLED)\nCAN_Type_T mw_can3={0,0};\nextern CAN_HandleTypeDef hcan3;\n#endif\n/* Initialize CAN module */\nCAN_Type_T* MW_CAN_Initialize(uint8_T module)\n{\n    CAN_Type_T* handle = NULL;\n    #ifndef MATLAB_MEX_FILE\n    switch (module)\n    {\n    #if (defined(CAN) || defined(CAN1)) && defined(MW_CAN1_ENABLED) \n        case (0U):\n            #if defined(CAN) && !defined(CAN1)\n            handle = &mw_can;\n            #else\n            handle = &mw_can1;\n            #endif\n\n            if(0 == handle->isInit)\n            {\n                #if defined(CAN) && !defined(CAN1)\n                handle->peripheralPtr = &hcan; \n                #else\n                handle->peripheralPtr = &hcan1;\n                #endif\n\n                \n\n                #if defined(MW_CAN1_TX_ENABLED)\n                    #if defined(CAN) && !defined(CAN1)\n                    NVIC_SetPriority(CAN_TX_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                    NVIC_EnableIRQ(CAN_TX_IRQn);\n                    #else\n                \tNVIC_SetPriority(CAN1_TX_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                \tNVIC_EnableIRQ(CAN1_TX_IRQn);\n                    #endif\n                \n                #if defined(MW_CAN1_IT_TX_MAILBOX_EMPTY)\n                HAL_CAN_ActivateNotification(handle->peripheralPtr,CAN_IT_TX_MAILBOX_EMPTY);\n                #endif\n                #endif\n\n                #if defined(MW_CAN1_RX0_ENABLED)\n                    #if defined(CAN) && !defined(CAN1)\n                    NVIC_SetPriority(CAN_RX0_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                    NVIC_EnableIRQ(CAN_RX0_IRQn);\n                    #else\n                \tNVIC_SetPriority(CAN1_RX0_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                \tNVIC_EnableIRQ(CAN1_RX0_IRQn);\n                    #endif\n                \n                #if defined(MW_CAN1_IT_RX_FIFO0_MSG_PENDING)\n                HAL_CAN_ActivateNotification(handle->peripheralPtr,CAN_IT_RX_FIFO0_MSG_PENDING);\n                #endif\n                #if defined(MW_CAN1_IT_RX_FIFO0_FULL)\n                HAL_CAN_ActivateNotification(handle->peripheralPtr,CAN_IT_RX_FIFO0_FULL);\n                #endif\n                #if defined(MW_CAN1_IT_RX_FIFO0_OVERRUN)\n                HAL_CAN_ActivateNotification(handle->peripheralPtr,CAN_IT_RX_FIFO0_OVERRUN);\n                #endif\n                #endif\n\n\n                #if defined(MW_CAN1_RX1_ENABLED)\n                    #if defined(CAN) && !defined(CAN1)\n                    NVIC_SetPriority(CAN_RX1_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                    NVIC_EnableIRQ(CAN_RX1_IRQn);\n                    #else\n                \tNVIC_SetPriority(CAN1_RX1_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                \tNVIC_EnableIRQ(CAN1_RX1_IRQn);\n                    #endif\n                \n                #if defined(MW_CAN1_IT_RX_FIFO1_MSG_PENDING)\n                HAL_CAN_ActivateNotification(handle->peripheralPtr,CAN_IT_RX_FIFO1_MSG_PENDING);\n                #endif\n                #if defined(MW_CAN1_IT_RX_FIFO1_FULL)\n                HAL_CAN_ActivateNotification(handle->peripheralPtr,CAN_IT_RX_FIFO1_FULL);\n                #endif\n                #if defined(MW_CAN1_IT_RX_FIFO1_OVERRUN)\n                HAL_CAN_ActivateNotification(handle->peripheralPtr,CAN_IT_RX_FIFO1_OVERRUN);\n                #endif\n                #endif\n\n                #if defined(MW_CAN1_SCE_ENABLED)\n                    #if defined(CAN) && !defined(CAN1)\n                    NVIC_SetPriority(CAN_SCE_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                    NVIC_EnableIRQ(CAN_SCE_IRQn);\n                    #else\n                \tNVIC_SetPriority(CAN1_SCE_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                \tNVIC_EnableIRQ(CAN1_SCE_IRQn);\n                    #endif                \n                #if defined(MW_CAN1_IT_WAKEUP)\n                HAL_CAN_ActivateNotification(handle->peripheralPtr,CAN_IT_WAKEUP);\n                #endif\n                #if defined(MW_CAN1_IT_SLEEP_ACK)\n                HAL_CAN_ActivateNotification(handle->peripheralPtr,CAN_IT_SLEEP_ACK);\n                #endif\n                #if defined(MW_CAN1_IT_ERROR_WARNING)\n                HAL_CAN_ActivateNotification(handle->peripheralPtr,CAN_IT_ERROR_WARNING);\n                #endif\n                #if defined(MW_CAN1_IT_ERROR_PASSIVE)\n                HAL_CAN_ActivateNotification(handle->peripheralPtr,CAN_IT_ERROR_PASSIVE);\n                #endif\n                #if defined(MW_CAN1_IT_BUSOFF)\n                HAL_CAN_ActivateNotification(handle->peripheralPtr,CAN_IT_BUSOFF);\n                #endif\n                #if defined(MW_CAN1_IT_LAST_ERROR_CODE)\n                HAL_CAN_ActivateNotification(handle->peripheralPtr,CAN_IT_LAST_ERROR_CODE);\n                #endif\n                #if defined(MW_CAN1_IT_ERROR_WARNING) || defined(MW_CAN1_IT_ERROR_PASSIVE) || defined(MW_CAN1_IT_BUSOFF) ||defined(MW_CAN1_IT_LAST_ERROR_CODE)\n                HAL_CAN_ActivateNotification(handle->peripheralPtr,CAN_IT_ERROR);\n                #endif\n                #endif\n\n            }\n                break;\n                #endif\n   \n                #if defined(CAN2) && defined(MW_CAN2_ENABLED)\n        case (1U):\n            handle = &mw_can2;\n            if(0 == handle->isInit)\n            {\n                handle->peripheralPtr = &hcan2;\n                #if defined(MW_CAN2_TX_ENABLED)\n                NVIC_SetPriority(CAN2_TX_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                NVIC_EnableIRQ(CAN2_TX_IRQn);\n                #if defined(MW_CAN2_IT_TX_MAILBOX_EMPTY)\n                HAL_CAN_ActivateNotification(&hcan2,CAN_IT_TX_MAILBOX_EMPTY);\n                #endif\n                #endif\n                #if defined(MW_CAN2_RX0_ENABLED)\n                NVIC_SetPriority(CAN2_RX0_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                NVIC_EnableIRQ(CAN2_RX0_IRQn);\n                #if defined(MW_CAN2_IT_RX_FIFO0_MSG_PENDING)\n                HAL_CAN_ActivateNotification(&hcan2,CAN_IT_RX_FIFO0_MSG_PENDING);\n                #endif\n                #if defined(MW_CAN2_IT_RX_FIFO0_FULL)\n                HAL_CAN_ActivateNotification(&hcan2,CAN_IT_RX_FIFO0_FULL);\n                #endif\n                #if defined(MW_CAN2_IT_RX_FIFO0_OVERRUN)\n                HAL_CAN_ActivateNotification(&hcan2,CAN_IT_RX_FIFO0_OVERRUN);\n                #endif\n                #endif\n                #if defined(MW_CAN2_RX1_ENABLED)\n                NVIC_SetPriority(CAN2_RX1_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                NVIC_EnableIRQ(CAN2_RX1_IRQn);\n                #if defined(MW_CAN2_IT_RX_FIFO1_MSG_PENDING)\n                HAL_CAN_ActivateNotification(&hcan2,CAN_IT_RX_FIFO1_MSG_PENDING);\n                #endif\n                #if defined(MW_CAN2_IT_RX_FIFO1_FULL)\n                HAL_CAN_ActivateNotification(&hcan2,CAN_IT_RX_FIFO1_FULL);\n                #endif\n                #if defined(MW_CAN2_IT_RX_FIFO1_OVERRUN)\n                HAL_CAN_ActivateNotification(&hcan2,CAN_IT_RX_FIFO1_OVERRUN);\n                #endif\n                #endif\n                #if defined(MW_CAN2_SCE_ENABLED)\n                NVIC_SetPriority(CAN2_SCE_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                NVIC_EnableIRQ(CAN2_SCE_IRQn);\n                #if defined(MW_CAN2_IT_WAKEUP)\n                HAL_CAN_ActivateNotification(&hcan2,CAN_IT_WAKEUP);\n                #endif\n                #if defined(MW_CAN2_IT_SLEEP_ACK)\n                HAL_CAN_ActivateNotification(&hcan2,CAN_IT_SLEEP_ACK);\n                #endif\n                #if defined(MW_CAN2_IT_ERROR_WARNING)\n                HAL_CAN_ActivateNotification(&hcan2,CAN_IT_ERROR_WARNING);\n                #endif\n                #if defined(MW_CAN2_IT_ERROR_PASSIVE)\n                HAL_CAN_ActivateNotification(&hcan2,CAN_IT_ERROR_PASSIVE);\n                #endif\n                #if defined(MW_CAN2_IT_BUSOFF)\n                HAL_CAN_ActivateNotification(&hcan2,CAN_IT_BUSOFF);\n                #endif\n                #if defined(MW_CAN2_IT_LAST_ERROR_CODE)\n                HAL_CAN_ActivateNotification(&hcan2,CAN_IT_LAST_ERROR_CODE);\n                #endif\n                #if defined(MW_CAN2_IT_ERROR_WARNING) || defined(MW_CAN2_IT_ERROR_PASSIVE) || defined(MW_CAN2_IT_BUSOFF) ||defined(MW_CAN2_IT_LAST_ERROR_CODE)\n                HAL_CAN_ActivateNotification(&hcan2,CAN_IT_ERROR);\n                #endif\n                #endif\n            }\n                break;\n                #endif\n                #if defined(CAN3) && defined(MW_CAN3_ENABLED)\n        case (2U):\n            handle = &mw_can3;\n            if(0 == handle->isInit)\n            {\n                handle->peripheralPtr = &hcan3;\n                #if defined(MW_CAN3_TX_ENABLED)\n                NVIC_SetPriority(CAN3_TX_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                NVIC_EnableIRQ(CAN3_TX_IRQn);\n                #if defined(MW_CAN3_IT_TX_MAILBOX_EMPTY)\n                HAL_CAN_ActivateNotification(&hcan3,CAN_IT_TX_MAILBOX_EMPTY);\n                #endif\n                #endif\n                #if defined(MW_CAN3_RX0_ENABLED)\n                NVIC_SetPriority(CAN3_RX0_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                NVIC_EnableIRQ(CAN3_RX0_IRQn);\n                #if defined(MW_CAN3_IT_RX_FIFO0_MSG_PENDING)\n                HAL_CAN_ActivateNotification(&hcan3,CAN_IT_RX_FIFO0_MSG_PENDING);\n                #endif\n                #if defined(MW_CAN3_IT_RX_FIFO0_FULL)\n                HAL_CAN_ActivateNotification(&hcan3,CAN_IT_RX_FIFO0_FULL);\n                #endif\n                #if defined(MW_CAN3_IT_RX_FIFO0_OVERRUN)\n                HAL_CAN_ActivateNotification(&hcan3,CAN_IT_RX_FIFO0_OVERRUN);\n                #endif\n                #endif\n                #if defined(MW_CAN3_RX1_ENABLED)\n                NVIC_SetPriority(CAN3_RX1_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                NVIC_EnableIRQ(CAN3_RX1_IRQn);\n                #if defined(MW_CAN3_IT_RX_FIFO1_MSG_PENDING)\n                HAL_CAN_ActivateNotification(&hcan3,CAN_IT_RX_FIFO1_MSG_PENDING);\n                #endif\n                #if defined(MW_CAN3_IT_RX_FIFO1_FULL)\n                HAL_CAN_ActivateNotification(&hcan3,CAN_IT_RX_FIFO1_FULL);\n                #endif\n                #if defined(MW_CAN3_IT_RX_FIFO1_OVERRUN)\n                HAL_CAN_ActivateNotification(&hcan3,CAN_IT_RX_FIFO1_OVERRUN);\n                #endif\n                #endif\n                #if defined(MW_CAN3_SCE_ENABLED)\n                NVIC_SetPriority(CAN3_SCE_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));\n                NVIC_EnableIRQ(CAN3_SCE_IRQn);\n                #if defined(MW_CAN3_IT_WAKEUP)\n                HAL_CAN_ActivateNotification(&hcan3,CAN_IT_WAKEUP);\n                #endif\n                #if defined(MW_CAN3_IT_SLEEP_ACK)\n                HAL_CAN_ActivateNotification(&hcan3,CAN_IT_SLEEP_ACK);\n                #endif\n                #if defined(MW_CAN3_IT_ERROR_WARNING)\n                HAL_CAN_ActivateNotification(&hcan3,CAN_IT_ERROR_WARNING);\n                #endif\n                #if defined(MW_CAN3_IT_ERROR_PASSIVE)\n                HAL_CAN_ActivateNotification(&hcan3,CAN_IT_ERROR_PASSIVE);\n                #endif\n                #if defined(MW_CAN3_IT_BUSOFF)\n                HAL_CAN_ActivateNotification(&hcan3,CAN_IT_BUSOFF);\n                #endif\n                #if defined(MW_CAN3_IT_LAST_ERROR_CODE)\n                HAL_CAN_ActivateNotification(&hcan3,CAN_IT_LAST_ERROR_CODE);\n                #endif\n                #if defined(MW_CAN3_IT_ERROR_WARNING) || defined(MW_CAN3_IT_ERROR_PASSIVE) || defined(MW_CAN3_IT_BUSOFF) ||defined(MW_CAN3_IT_LAST_ERROR_CODE)\n                HAL_CAN_ActivateNotification(&hcan3,CAN_IT_ERROR);\n                #endif\n                #endif\n            }\n                break;\n                #endif\n        default:\n            handle = NULL;\n            break;\n    }\n    if ((NULL != handle) && (0 == handle->isInit))\n    {\n        handle->isInit=1;\n        HAL_CAN_Start((CAN_HandleTypeDef*)handle->peripheralPtr);\n    }\n    #endif\n    return handle;\n}\nvoid MW_configureCANFilter(CAN_Type_T * handle, uint8_T module, uint16_T idHigh, uint16_T idLow, uint16_T maskIdHigh, uint16_T maskIdLow,\n                           uint8_T FIFO, uint8_T fbNum, uint8_T mode, uint8_T scale, uint8_T enable)\n{\n    #ifndef MATLAB_MEX_FILE\n    static uint8_T filterConfigured[MAXCANMODULE][MAXCANFILTERPERMODULE] = {0};\n    CAN_FilterTypeDef nFilterConfig;\n    if ((NULL != handle) && (1 == handle->isInit))\n    {\n        if (filterConfigured[module][fbNum] == 0)\n        {\n            nFilterConfig.FilterIdHigh = idHigh;\n            nFilterConfig.FilterIdLow = idLow;\n            nFilterConfig.FilterMaskIdHigh = maskIdHigh;\n            nFilterConfig.FilterMaskIdLow = maskIdLow;\n            nFilterConfig.FilterFIFOAssignment = FIFO ? CAN_FILTER_FIFO1 : CAN_FILTER_FIFO0;\n            nFilterConfig.FilterBank = fbNum;\n            nFilterConfig.FilterMode = mode ? CAN_FILTERMODE_IDLIST : CAN_FILTERMODE_IDMASK;\n            nFilterConfig.FilterScale = scale ? CAN_FILTERSCALE_32BIT : CAN_FILTERSCALE_16BIT;\n            nFilterConfig.FilterActivation = enable ? ENABLE : DISABLE;\n            nFilterConfig.SlaveStartFilterBank = 14;\n\n            // CAN2 accept to FIFO0 needs FilterBank to be set as 14\n            if((1 == module) && (0 == idHigh) && (0 == idLow) && (0 == maskIdHigh) && (0 == maskIdLow) && (0 == fbNum) && (0 == mode) && (1 == scale))\n            {\n                nFilterConfig.FilterBank = 14;\n            }\n            HAL_CAN_ConfigFilter((CAN_HandleTypeDef*)handle->peripheralPtr, &nFilterConfig);\n            filterConfigured[module][fbNum]++;\n        }\n    }\n    #endif\n}\nuint8_T MW_CAN_GetLastErrorCode(CAN_Type_T * handle)\n{\n    #ifndef MATLAB_MEX_FILE\n    if ((NULL != handle) && (1 == handle->isInit))\n    {\n        return (uint8_T)(((uint32_T)READ_REG(((CAN_HandleTypeDef*)handle->peripheralPtr)->Instance->ESR) & (uint32_T)CAN_ESR_LEC)>>CAN_ESR_LEC_Pos);\n    }\n    #endif\n    return 0;\n}\nuint8_T MW_CAN_TransmitMessage(CAN_Type_T* handle, uint8_T* txData, uint32_T id, uint8_T idType, uint8_T remote, uint8_T length, uint32_T timeout, uint32_T * FifoLevel)\n{\n    #ifndef MATLAB_MEX_FILE\n    CAN_TxHeaderTypeDef txHeader;\n    uint32_t TxMailbox = 0;\n    CAN_HandleTypeDef* canHandle;\n    uint32_T initialTime = 0;\n    if ((NULL != handle) && (1 == handle->isInit))\n    {\n        canHandle = (CAN_HandleTypeDef*)handle->peripheralPtr;\n\n        if(idType == 0)\n        {\n            txHeader.StdId = id;\n            txHeader.IDE = CAN_ID_STD;\n        }\n        else\n        {\n            txHeader.ExtId = id;\n            txHeader.IDE = CAN_ID_EXT;\n        }\n        txHeader.RTR = (remote == 0) ? CAN_RTR_DATA : CAN_RTR_REMOTE;\n        txHeader.DLC = length;\n        txHeader.TransmitGlobalTime = DISABLE;\n\n        initialTime = GET_CURRENT_TIME();\n        /* Check transmit mailbox value */\n        while (((((canHandle->Instance->TSR) & CAN_TSR_CODE) >> CAN_TSR_CODE_Pos) > 2U) && (returnTimeElapsed(initialTime, 1) <= (timeout)));\n\n        /* Request transmission */\n        if(HAL_CAN_AddTxMessage(canHandle, &txHeader, txData, &TxMailbox) != HAL_OK)\n        {\n            /* Transmission request Error */\n            *FifoLevel = HAL_CAN_GetTxMailboxesFreeLevel(canHandle);\n            return 1;\n        }\n\n        /* Wait till transmission complete. Enable for blocking mode */\n        // while(HAL_CAN_GetTxMailboxesFreeLevel(canHandle) != 3) {}\n        *FifoLevel = HAL_CAN_GetTxMailboxesFreeLevel(canHandle);\n        return 0;\n    }\n    #endif\n    return 0;\n}\n\nuint8_T MW_CAN_ReceiveMessage(CAN_Type_T* handle, uint8_T ReadSrc, uint8_T* rxData, uint32_T *id, uint8_T *idType, uint8_T *remote, uint8_T *length, uint32_T timeout, uint32_T * FifoLevel)\n{\n    #ifndef MATLAB_MEX_FILE\n    CAN_RxHeaderTypeDef rxHeader;\n    CAN_HandleTypeDef* canHandle;\n    uint32_T initialTime = 0;\n    if ((NULL != handle) && (1 == handle->isInit))\n    {\n        canHandle = (CAN_HandleTypeDef*)handle->peripheralPtr;\n\n        initialTime = GET_CURRENT_TIME();\n        *FifoLevel = 0;\n        while ((0 == HAL_CAN_GetRxFifoFillLevel(canHandle, ReadSrc)) && (returnTimeElapsed(initialTime, 1) <= (timeout)));\n        if( HAL_CAN_GetRxFifoFillLevel(canHandle, ReadSrc) == 0)\n        {\n            /* Reception Missing */\n            return 1;\n        }\n\n        if(HAL_CAN_GetRxMessage(canHandle, ReadSrc, &rxHeader, rxData) != HAL_OK)\n        {\n            /* Reception Error */\n            return 1;\n        }\n        *FifoLevel = HAL_CAN_GetRxFifoFillLevel(canHandle, ReadSrc);\n        *id = rxHeader.IDE ? rxHeader.ExtId:rxHeader.StdId;\n        *idType = rxHeader.IDE ? 1:0;\n        *remote = rxHeader.RTR;\n        *length = rxHeader.DLC;\n        return 0;\n    }\n    #endif\n    return 0;\n}\n\nvoid MW_CAN_Close(CAN_Type_T* handle)\n{\n    #ifndef MATLAB_MEX_FILE\n    \n    CAN_HandleTypeDef* canHandle;\n    if ((NULL != handle) && (1 == handle->isInit))\n    {\n        canHandle = (CAN_HandleTypeDef*)handle->peripheralPtr;\n        \n        // Disable CAN peripheral when CAN module is used in model but not used in external mode\n        #if (defined(CAN) || defined(CAN1)) && defined(MW_CAN1_ENABLED) && (MW_EXTMODE_CANMODULE!=0)\n\n        #if defined(CAN) && !defined(CAN1)\n        if(canHandle == &hcan)\n        #else\n        if(canHandle == &hcan1)\n        #endif\n        {\n            #if defined(MW_CAN1_TX_ENABLED)\n            #if defined(MW_CAN1_IT_TX_MAILBOX_EMPTY)\n            HAL_CAN_DeactivateNotification(canHandle,CAN_IT_TX_MAILBOX_EMPTY);\n            #endif\n            #endif\n            #if defined(MW_CAN1_RX0_ENABLED)\n            #if defined(MW_CAN1_IT_RX_FIFO0_MSG_PENDING)\n            HAL_CAN_DeactivateNotification(canHandle,CAN_IT_RX_FIFO0_MSG_PENDING);\n            #endif\n            #if defined(MW_CAN1_IT_RX_FIFO0_FULL)\n            HAL_CAN_DeactivateNotification(canHandle,CAN_IT_RX_FIFO0_FULL);\n            #endif\n            #if defined(MW_CAN1_IT_RX_FIFO0_OVERRUN)\n            HAL_CAN_DeactivateNotification(canHandle,CAN_IT_RX_FIFO0_OVERRUN);\n            #endif\n            #endif\n            #if defined(MW_CAN1_RX1_ENABLED)\n            #if defined(MW_CAN1_IT_RX_FIFO1_MSG_PENDING)\n            HAL_CAN_DeactivateNotification(canHandle,CAN_IT_RX_FIFO1_MSG_PENDING);\n            #endif\n            #if defined(MW_CAN1_IT_RX_FIFO1_FULL)\n            HAL_CAN_DeactivateNotification(canHandle,CAN_IT_RX_FIFO1_FULL);\n            #endif\n            #if defined(MW_CAN1_IT_RX_FIFO1_OVERRUN)\n            HAL_CAN_DeactivateNotification(canHandle,CAN_IT_RX_FIFO1_OVERRUN);\n            #endif\n            #endif\n            #if defined(MW_CAN1_SCE_ENABLED)\n            #if defined(MW_CAN1_IT_WAKEUP)\n            HAL_CAN_DeactivateNotification(canHandle,CAN_IT_WAKEUP);\n            #endif\n            #if defined(MW_CAN1_IT_SLEEP_ACK)\n            HAL_CAN_DeactivateNotification(canHandle,CAN_IT_SLEEP_ACK);\n            #endif\n            #if defined(MW_CAN1_IT_ERROR_WARNING)\n            HAL_CAN_DeactivateNotification(canHandle,CAN_IT_ERROR_WARNING);\n            #endif\n            #if defined(MW_CAN1_IT_ERROR_PASSIVE)\n            HAL_CAN_DeactivateNotification(canHandle,CAN_IT_ERROR_PASSIVE);\n            #endif\n            #if defined(MW_CAN1_IT_BUSOFF)\n            HAL_CAN_DeactivateNotification(canHandle,CAN_IT_BUSOFF);\n            #endif\n            #if defined(MW_CAN1_IT_LAST_ERROR_CODE)\n            HAL_CAN_DeactivateNotification(canHandle,CAN_IT_LAST_ERROR_CODE);\n            #endif\n            #if defined(MW_CAN1_IT_ERROR_WARNING) || defined(MW_CAN1_IT_ERROR_PASSIVE) || defined(MW_CAN1_IT_BUSOFF) ||defined(MW_CAN1_IT_LAST_ERROR_CODE)\n            HAL_CAN_DeactivateNotification(canHandle,CAN_IT_ERROR);\n            #endif\n            #endif\n            HAL_CAN_DeInit(canHandle);\n            handle->isInit=0;\n        }\n        #endif\n        // Disable CAN peripheral when CAN module is used in model but not used in external mode\n        #if defined(CAN2) && defined(MW_CAN2_ENABLED) && (MW_EXTMODE_CANMODULE != 1)\n        if(canHandle == &hcan2)\n        {\n            #if defined(MW_CAN2_TX_ENABLED)\n            #if defined(MW_CAN2_IT_TX_MAILBOX_EMPTY)\n            HAL_CAN_DeactivateNotification(&hcan2,CAN_IT_TX_MAILBOX_EMPTY);\n            #endif\n            #endif\n            #if defined(MW_CAN2_RX0_ENABLED)\n            #if defined(MW_CAN2_IT_RX_FIFO0_MSG_PENDING)\n            HAL_CAN_DeactivateNotification(&hcan2,CAN_IT_RX_FIFO0_MSG_PENDING);\n            #endif\n            #if defined(MW_CAN2_IT_RX_FIFO0_FULL)\n            HAL_CAN_DeactivateNotification(&hcan2,CAN_IT_RX_FIFO0_FULL);\n            #endif\n            #if defined(MW_CAN2_IT_RX_FIFO0_OVERRUN)\n            HAL_CAN_DeactivateNotification(&hcan2,CAN_IT_RX_FIFO0_OVERRUN);\n            #endif\n            #endif\n            #if defined(MW_CAN2_RX1_ENABLED)\n            #if defined(MW_CAN2_IT_RX_FIFO1_MSG_PENDING)\n            HAL_CAN_DeactivateNotification(&hcan2,CAN_IT_RX_FIFO1_MSG_PENDING);\n            #endif\n            #if defined(MW_CAN2_IT_RX_FIFO1_FULL)\n            HAL_CAN_DeactivateNotification(&hcan2,CAN_IT_RX_FIFO1_FULL);\n            #endif\n            #if defined(MW_CAN2_IT_RX_FIFO1_OVERRUN)\n            HAL_CAN_DeactivateNotification(&hcan2,CAN_IT_RX_FIFO1_OVERRUN);\n            #endif\n            #endif\n            #if defined(MW_CAN2_SCE_ENABLED)\n            #if defined(MW_CAN2_IT_WAKEUP)\n            HAL_CAN_DeactivateNotification(&hcan2,CAN_IT_WAKEUP);\n            #endif\n            #if defined(MW_CAN2_IT_SLEEP_ACK)\n            HAL_CAN_DeactivateNotification(&hcan2,CAN_IT_SLEEP_ACK);\n            #endif\n            #if defined(MW_CAN2_IT_ERROR_WARNING)\n            HAL_CAN_DeactivateNotification(&hcan2,CAN_IT_ERROR_WARNING);\n            #endif\n            #if defined(MW_CAN2_IT_ERROR_PASSIVE)\n            HAL_CAN_DeactivateNotification(&hcan2,CAN_IT_ERROR_PASSIVE);\n            #endif\n            #if defined(MW_CAN2_IT_BUSOFF)\n            HAL_CAN_DeactivateNotification(&hcan2,CAN_IT_BUSOFF);\n            #endif\n            #if defined(MW_CAN2_IT_LAST_ERROR_CODE)\n            HAL_CAN_DeactivateNotification(&hcan2,CAN_IT_LAST_ERROR_CODE);\n            #endif\n            #if defined(MW_CAN2_IT_ERROR_WARNING) || defined(MW_CAN2_IT_ERROR_PASSIVE) || defined(MW_CAN2_IT_BUSOFF) ||defined(MW_CAN2_IT_LAST_ERROR_CODE)\n            HAL_CAN_DeactivateNotification(&hcan2,CAN_IT_ERROR);\n            #endif\n            #endif\n            HAL_CAN_DeInit(canHandle);\n            handle->isInit=0;\n        }\n        #endif\n        // Disable CAN peripheral when CAN module is used in model but not used in external mode\n        #if defined(CAN3) && defined(MW_CAN3_ENABLED) && (MW_EXTMODE_CANMODULE != 2)\n        if(canHandle == &hcan3)\n        {\n            #if defined(MW_CAN3_TX_ENABLED)\n            #if defined(MW_CAN3_IT_TX_MAILBOX_EMPTY)\n            HAL_CAN_DeactivateNotification(&hcan3,CAN_IT_TX_MAILBOX_EMPTY);\n            #endif\n            #endif\n            #if defined(MW_CAN3_RX0_ENABLED)\n            #if defined(MW_CAN3_IT_RX_FIFO0_MSG_PENDING)\n            HAL_CAN_DeactivateNotification(&hcan3,CAN_IT_RX_FIFO0_MSG_PENDING);\n            #endif\n            #if defined(MW_CAN3_IT_RX_FIFO0_FULL)\n            HAL_CAN_DeactivateNotification(&hcan3,CAN_IT_RX_FIFO0_FULL);\n            #endif\n            #if defined(MW_CAN3_IT_RX_FIFO0_OVERRUN)\n            HAL_CAN_DeactivateNotification(&hcan3,CAN_IT_RX_FIFO0_OVERRUN);\n            #endif\n            #endif\n            #if defined(MW_CAN3_RX1_ENABLED)\n            #if defined(MW_CAN3_IT_RX_FIFO1_MSG_PENDING)\n            HAL_CAN_DeactivateNotification(&hcan3,CAN_IT_RX_FIFO1_MSG_PENDING);\n            #endif\n            #if defined(MW_CAN3_IT_RX_FIFO1_FULL)\n            HAL_CAN_DeactivateNotification(&hcan3,CAN_IT_RX_FIFO1_FULL);\n            #endif\n            #if defined(MW_CAN3_IT_RX_FIFO1_OVERRUN)\n            HAL_CAN_DeactivateNotification(&hcan3,CAN_IT_RX_FIFO1_OVERRUN);\n            #endif\n            #endif\n            #if defined(MW_CAN3_SCE_ENABLED)\n            #if defined(MW_CAN3_IT_WAKEUP)\n            HAL_CAN_DeactivateNotification(&hcan3,CAN_IT_WAKEUP);\n            #endif\n            #if defined(MW_CAN3_IT_SLEEP_ACK)\n            HAL_CAN_DeactivateNotification(&hcan3,CAN_IT_SLEEP_ACK);\n            #endif\n            #if defined(MW_CAN3_IT_ERROR_WARNING)\n            HAL_CAN_DeactivateNotification(&hcan3,CAN_IT_ERROR_WARNING);\n            #endif\n            #if defined(MW_CAN3_IT_ERROR_PASSIVE)\n            HAL_CAN_DeactivateNotification(&hcan3,CAN_IT_ERROR_PASSIVE);\n            #endif\n            #if defined(MW_CAN3_IT_BUSOFF)\n            HAL_CAN_DeactivateNotification(&hcan3,CAN_IT_BUSOFF);\n            #endif\n            #if defined(MW_CAN3_IT_LAST_ERROR_CODE)\n            HAL_CAN_DeactivateNotification(&hcan3,CAN_IT_LAST_ERROR_CODE);\n            #endif\n            #if defined(MW_CAN3_IT_ERROR_WARNING) || defined(MW_CAN3_IT_ERROR_PASSIVE) || defined(MW_CAN3_IT_BUSOFF) ||defined(MW_CAN3_IT_LAST_ERROR_CODE)\n            HAL_CAN_DeactivateNotification(&hcan3,CAN_IT_ERROR);\n            #endif\n            #endif\n            HAL_CAN_DeInit(canHandle);\n            handle->isInit=0;\n        }\n        #endif\n    }\n    #endif\n}\n\n"},{"name":"stm_timer_ll.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\mcb_open_loop_control_nucleo_f401re_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\shared\\supportpackages\\stm32\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2021-2024 The MathWorks, Inc. */\n/******************************************************************************\n* Includes\n*******************************************************************************/\n#include \"stm_timer_ll.h\"\n#include <string.h>\n/******************************************************************************\n* Preprocessor Macros\n*******************************************************************************/\n/******************************************************************************\n* Global Variable Definitions\n*******************************************************************************/\n#if (defined(GPDMA1) || defined(GPDMA2)) && !defined(GPDMA)\n    #define GPDMA 1\n#endif\n\n#if defined(TIM1) && defined(MW_TIM1_ENABLED)\nTIM_Type_T mw_tim1;\n\n#ifdef MW_TIM1_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM1CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM1_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM1CH1DMABuffer[MW_TIM1_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM1CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM1_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM1_CH2_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM1CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM1_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM1CH2DMABuffer[MW_TIM1_CH2_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM1CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM1_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM1_CH3_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM1CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM1_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM1CH3DMABuffer[MW_TIM1_CH3_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM1CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM1_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM1_CH4_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM1CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM1_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM1CH4DMABuffer[MW_TIM1_CH4_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM1CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM1_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM2) && defined(MW_TIM2_ENABLED)\nTIM_Type_T mw_tim2;\n#ifdef MW_TIM2_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM2CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM2_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM2CH1DMABuffer[MW_TIM2_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM2CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM2_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM2_CH2_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM2CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM2_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM2CH2DMABuffer[MW_TIM2_CH2_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM2CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM2_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM2_CH3_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM2CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM2_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM2CH3DMABuffer[MW_TIM2_CH3_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM2CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM2_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM2_CH4_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM2CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM2_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM2CH4DMABuffer[MW_TIM2_CH4_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM2CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM2_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM3) && defined(MW_TIM3_ENABLED)\nTIM_Type_T mw_tim3;\n#ifdef MW_TIM3_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM3CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM3_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM3CH1DMABuffer[MW_TIM3_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM3CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM3_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM3_CH2_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM3CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM3_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM3CH2DMABuffer[MW_TIM3_CH2_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM3CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM3_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM3_CH3_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM3CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM3_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM3CH3DMABuffer[MW_TIM3_CH3_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM3CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM3_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM3_CH4_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM3CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM3_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM3CH4DMABuffer[MW_TIM3_CH4_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM3CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM3_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM4) && defined(MW_TIM4_ENABLED)\nTIM_Type_T mw_tim4;\n#ifdef MW_TIM4_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM4CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM4_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM4CH1DMABuffer[MW_TIM4_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM4CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM4_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM4_CH2_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM4CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM4_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM4CH2DMABuffer[MW_TIM4_CH2_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM4CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM4_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM4_CH3_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM4CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM4_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM4CH3DMABuffer[MW_TIM4_CH3_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM4CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM4_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM4_CH4_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM4CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM4_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM4CH4DMABuffer[MW_TIM4_CH4_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM4CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM4_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM5) && defined(MW_TIM5_ENABLED)\nTIM_Type_T mw_tim5;\n#ifdef MW_TIM5_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM5CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM5_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM5CH1DMABuffer[MW_TIM5_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM5CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM5_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM5_CH2_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM5CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM5_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM5CH2DMABuffer[MW_TIM5_CH2_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM5CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM5_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM5_CH3_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM5CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM5_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM5CH3DMABuffer[MW_TIM5_CH3_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM5CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM5_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM5_CH4_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM5CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM5_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM5CH4DMABuffer[MW_TIM5_CH4_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM5CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM5_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM6) && defined(MW_TIM6_ENABLED)\nTIM_Type_T mw_tim6;\n#endif\n\n#if defined(TIM7) && defined(MW_TIM7_ENABLED)\nTIM_Type_T mw_tim7;\n#endif\n\n#if defined(TIM8) && defined(MW_TIM8_ENABLED)\nTIM_Type_T mw_tim8;\n#ifdef MW_TIM8_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM8CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM8_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM8CH1DMABuffer[MW_TIM8_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM8CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM8_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM8_CH2_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM8CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM8_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM8CH2DMABuffer[MW_TIM8_CH2_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM8CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM8_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM8_CH3_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM8CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM8_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM8CH3DMABuffer[MW_TIM8_CH3_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM8CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM8_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM8_CH4_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM8CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM8_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM8CH4DMABuffer[MW_TIM8_CH4_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM8CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM8_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM9) && defined(MW_TIM9_ENABLED)\nTIM_Type_T mw_tim9;\n#ifdef MW_TIM9_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM9CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM9_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM9CH1DMABuffer[MW_TIM9_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM9CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM9_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM9_CH2_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM9CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM9_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM9CH2DMABuffer[MW_TIM9_CH2_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM9CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM9_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM10) && defined(MW_TIM10_ENABLED)\nTIM_Type_T mw_tim10;\n#ifdef MW_TIM10_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM10CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM10_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM10CH1DMABuffer[MW_TIM10_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM10CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM10_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM11) && defined(MW_TIM11_ENABLED)\nTIM_Type_T mw_tim11;\n#ifdef MW_TIM11_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM11CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM11_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM11CH1DMABuffer[MW_TIM11_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM11CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM11_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM12) && defined(MW_TIM12_ENABLED)\nTIM_Type_T mw_tim12;\n#ifdef MW_TIM12_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM12CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM12_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM12CH1DMABuffer[MW_TIM12_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM12CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM12_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM12_CH2_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM12CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM12_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM12CH2DMABuffer[MW_TIM12_CH2_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM12CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM12_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM13) && defined(MW_TIM13_ENABLED)\nTIM_Type_T mw_tim13;\n#ifdef MW_TIM13_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM13CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM13_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM13CH1DMABuffer[MW_TIM13_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM13CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM13_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM14) && defined(MW_TIM14_ENABLED)\nTIM_Type_T mw_tim14;\n#ifdef MW_TIM14_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM14CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM14_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM14CH1DMABuffer[MW_TIM14_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM14CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM14_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM15) && defined(MW_TIM15_ENABLED)\nTIM_Type_T mw_tim15;\n#ifdef MW_TIM15_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM15CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM15_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM15CH1DMABuffer[MW_TIM15_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM15CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM15_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM15_CH2_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM15CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM15_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM15CH2DMABuffer[MW_TIM15_CH2_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM15CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM15_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM16) && defined(MW_TIM16_ENABLED)\nTIM_Type_T mw_tim16;\n#ifdef MW_TIM16_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM16CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM16_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM16CH1DMABuffer[MW_TIM16_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM16CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM16_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM17) && defined(MW_TIM17_ENABLED)\nTIM_Type_T mw_tim17;\n#ifdef MW_TIM17_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint16_T TIM17CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM17_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint16_T TIM17CH1DMABuffer[MW_TIM17_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint16_T TIM17CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM17_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM20) && defined(MW_TIM20_ENABLED)\nTIM_Type_T mw_tim20;\n#endif\n\n#if defined(TIM23) && defined(MW_TIM23_ENABLED)\nTIM_Type_T mw_tim23;\n#ifdef MW_TIM23_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM23CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM23_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM23CH1DMABuffer[MW_TIM23_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM23CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM23_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM23_CH2_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM23CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM23_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM23CH2DMABuffer[MW_TIM23_CH2_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM23CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM23_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM23_CH3_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM23CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM23_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM23CH3DMABuffer[MW_TIM23_CH3_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM23CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM23_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM23_CH4_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM23CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM23_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM23CH4DMABuffer[MW_TIM23_CH4_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM23CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM23_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n#if defined(TIM24) && defined(MW_TIM24_ENABLED)\nTIM_Type_T mw_tim24;\n#ifdef MW_TIM24_CH1_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM24CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM24_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM24CH1DMABuffer[MW_TIM24_CH1_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM24CH1DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM24_CH1_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM24_CH2_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM24CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM24_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM24CH2DMABuffer[MW_TIM24_CH2_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM24CH2DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM24_CH2_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM24_CH3_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM24CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM24_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM24CH3DMABuffer[MW_TIM24_CH3_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM24CH3DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM24_CH3_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n\n#ifdef MW_TIM24_CH4_DMA_ENABLED\n    #ifdef STM32H7\n        #if defined(MW_DCACHE_ENABLED)\n        uint32_T TIM24CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM24_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32))) __attribute__((section(\".dma_buffer\"))) ;\n        #else\n        uint32_T TIM24CH4DMABuffer[MW_TIM24_CH4_DMA_BUFFER_SIZE] __attribute__((section(\".dma_buffer\"))) ;\n        #endif\n    #elif defined(STM32F7) && defined(MW_DCACHE_ENABLED)\n        uint32_T TIM24CH4DMABuffer[DMA_BUFFER_SIZE_BYTE_ALLIGNED(MW_TIM24_CH4_DMA_BUFFER_SIZE,32)] __attribute__((aligned (32)));\n    #endif\n#endif\n#endif\n\n\n\n/*DMA transfer complete callback */\nuint8_T TIM_IsEnabledDMAITTransferComplete(Channel_DMA_T * ptrTimChannel, uint32_t (*checkActiveFlag)(DMA_TypeDef *DMAx),  void (*clearActiveFlag)(DMA_TypeDef *DMAx))\n{\n    /* Check transfer-complete interrupt */\n    if (LL_DMA_IsEnabledIT_TC(ptrTimChannel->dmaPeripheralPtr, ptrTimChannel->dmastream) && (1 == checkActiveFlag(ptrTimChannel->dmaPeripheralPtr)))\n    {\n        clearActiveFlag(ptrTimChannel->dmaPeripheralPtr);         /* Clear transfer complete interrupt flag */\n        if(ptrTimChannel->buffer.writeRollOver == 1)\n        {\n            ptrTimChannel->errorStatus =  ptrTimChannel->errorStatus |  MW_TIM_OVERRUN_ERROR;\n            ptrTimChannel->buffer.readPos = 0;\n        }\n        ptrTimChannel->buffer.writeRollOver = 1;\n        #ifndef GPDMA\n        /* Start DMA again when DMA mode is Normal - GetMode not preset for GPDMA*/\n        if (LL_DMA_MODE_NORMAL == LL_DMA_GetMode(ptrTimChannel->dmaPeripheralPtr, ptrTimChannel->dmastream))\n        #endif\n        {\n            /* Disable DMA stream */\n            #if defined(STM32G4)  || defined(STM32WB) || defined(STM32L5) || defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n            LL_DMA_DisableChannel(ptrTimChannel->dmaPeripheralPtr, (uint32_t)ptrTimChannel->dmastream);\n            #else\n            LL_DMA_DisableStream(ptrTimChannel->dmaPeripheralPtr, (uint32_t)ptrTimChannel->dmastream);\n            #endif\n            /* Set length to receive */\n            #if defined (GPDMA)\n            if(NULL != ptrTimChannel->buffer.bufferPtr32Bit)\n            {\n                LL_DMA_SetDestAddress(ptrTimChannel->dmaPeripheralPtr, (uint32_t)ptrTimChannel->dmastream, (uint32_t)ptrTimChannel->buffer.bufferPtr32Bit);\n            }\n            else\n            {\n                LL_DMA_SetDestAddress(ptrTimChannel->dmaPeripheralPtr, (uint32_t)ptrTimChannel->dmastream, (uint32_t)ptrTimChannel->buffer.bufferPtr16Bit);\n            }\n            LL_DMA_SetBlkDataLength(ptrTimChannel->dmaPeripheralPtr, ptrTimChannel->dmastream, ptrTimChannel->buffer.bufferSize);\n            #else\n            LL_DMA_SetDataLength(ptrTimChannel->dmaPeripheralPtr, ptrTimChannel->dmastream, ptrTimChannel->buffer.bufferSize);\n            #endif\n            /* Start DMA again */\n            #if defined(STM32G4)  || defined(STM32WB) || defined(STM32L5) || defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n            LL_DMA_EnableChannel(ptrTimChannel->dmaPeripheralPtr, (uint32_t)ptrTimChannel->dmastream);\n            #else\n            LL_DMA_EnableStream(ptrTimChannel->dmaPeripheralPtr, (uint32_t)ptrTimChannel->dmastream);\n            #endif\n        }\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n/******************************************************************************\n* DMA IRQ for Timer channels\n*******************************************************************************/\n#if defined(MW_TIM1_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM1_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM1_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim1.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM1_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM1_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM1_CH2_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM1_CH2_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM1_CH2_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim1.channel2), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM1_CH2_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM1_CH2_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM1_CH3_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM1_CH3_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM1_CH3_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim1.channel3), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM1_CH3_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM1_CH3_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM1_CH4_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM1_CH4_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM1_CH4_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim1.channel4), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM1_CH4_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM1_CH4_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM2_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM2_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM2_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim2.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM2_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM2_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM2_CH2_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM2_CH2_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM2_CH2_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim2.channel2), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM2_CH2_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM2_CH2_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM2_CH3_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM2_CH3_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM2_CH3_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim2.channel3), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM2_CH3_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM2_CH3_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM2_CH4_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM2_CH4_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM2_CH4_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim2.channel4), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM2_CH4_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM2_CH4_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM3_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM3_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM3_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim3.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM3_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM3_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM3_CH2_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM3_CH2_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM3_CH2_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim3.channel2), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM3_CH2_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM3_CH2_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM3_CH3_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM3_CH3_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM3_CH3_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim3.channel3), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM3_CH3_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM3_CH3_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM3_CH4_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM3_CH4_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM3_CH4_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim3.channel4), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM3_CH4_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM3_CH4_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM4_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM4_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM4_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim4.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM4_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM4_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM4_CH2_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM4_CH2_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM4_CH2_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim4.channel2), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM4_CH2_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM4_CH2_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM4_CH3_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM4_CH3_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM4_CH3_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim4.channel3), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM4_CH3_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM4_CH3_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM4_CH4_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM4_CH4_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM4_CH4_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim4.channel4), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM4_CH4_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM4_CH4_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM5_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM5_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM5_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim5.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM5_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM5_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM5_CH2_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM5_CH2_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM5_CH2_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim5.channel2), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM5_CH2_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM5_CH2_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM5_CH3_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM5_CH3_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM5_CH3_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim5.channel3), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM5_CH3_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM5_CH3_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM5_CH4_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM5_CH4_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM5_CH4_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim5.channel4), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM5_CH4_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM5_CH4_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM8_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM8_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM8_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim8.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM8_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM8_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM8_CH2_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM8_CH2_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM8_CH2_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim8.channel2), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM8_CH2_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM8_CH2_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM8_CH3_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM8_CH3_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM8_CH3_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim8.channel3), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM8_CH3_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM8_CH3_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM8_CH4_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM8_CH4_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM8_CH4_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim8.channel4), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM8_CH4_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM8_CH4_DMA_STREAM));\n}\n#endif\n\n#if defined(MW_TIM9_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM9_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM9_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim9.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM9_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM9_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM9_CH2_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM9_CH2_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM9_CH2_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim9.channel2), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM9_CH2_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM9_CH2_DMA_STREAM));\n}\n#endif\n\n#if defined(MW_TIM12_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM12_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM12_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim12.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM12_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM12_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM12_CH2_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM12_CH2_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM12_CH2_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim12.channel2), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM12_CH2_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM12_CH2_DMA_STREAM));\n}\n#endif\n\n#if defined(MW_TIM10_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM10_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM10_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim10.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM10_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM10_CH1_DMA_STREAM));\n}\n#endif\n\n#if defined(MW_TIM11_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM11_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM1_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim11.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM11_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM11_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM13_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM13_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM13_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim13.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM13_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM13_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM14_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM14_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM14_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim14.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM14_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM14_CH1_DMA_STREAM));\n}\n#endif\n\n#if defined(MW_TIM15_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM15_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM15_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim15.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM15_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM15_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM15_CH2_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM15_CH2_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM15_CH2_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim15.channel2), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM15_CH2_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM15_CH2_DMA_STREAM));\n}\n#endif\n\n#if defined(MW_TIM16_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM16_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM16_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim16.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM16_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM16_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM17_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM17_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM17_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim17.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM17_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM17_CH1_DMA_STREAM));\n}\n#endif\n\n#if defined(MW_TIM23_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM23_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM23_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim23.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM23_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM23_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM23_CH2_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM23_CH2_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM23_CH2_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim23.channel2), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM23_CH2_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM23_CH2_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM23_CH3_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM23_CH3_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM23_CH3_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim23.channel3), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM23_CH3_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM23_CH3_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM23_CH4_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM23_CH4_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM23_CH4_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim23.channel4), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM23_CH4_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM23_CH4_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM24_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM24_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM24_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim24.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM24_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM24_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM24_CH2_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM24_CH2_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM24_CH2_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim24.channel2), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM24_CH2_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM24_CH2_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM24_CH3_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM24_CH3_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM24_CH3_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim24.channel3), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM24_CH3_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM24_CH3_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM24_CH4_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM24_CH4_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM24_CH4_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim24.channel4), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM24_CH4_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM24_CH4_DMA_STREAM));\n}\n#endif\n\n#if defined(MW_TIM20_CH1_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM20_CH1_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM20_CH1_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim20.channel1), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM20_CH1_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM20_CH1_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM20_CH2_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM20_CH2_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM20_CH2_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim20.channel2), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM20_CH2_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM20_CH2_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM20_CH3_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM20_CH3_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM20_CH3_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim20.channel3), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM20_CH3_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM20_CH3_DMA_STREAM));\n}\n#endif\n#if defined(MW_TIM20_CH4_DMA_ENABLED) && (!MW_GET_IRQ_HANDLER_DEFINE(MW_TIM20_CH4_DMA_ENABLED))\nGETIRQ_NAME(MW_TIM20_CH4_DMA_ENABLED)\n{\n    TIM_IsEnabledDMAITTransferComplete(&(mw_tim20.channel4), GETFCN_LL_GET_STREAM_ACTIVEFLAG(MW_TIM20_CH4_DMA_STREAM), GETFCN_LL_CLEAR_STREAM_ACTIVEFLAG(MW_TIM20_CH4_DMA_STREAM));\n}\n#endif\n\n\n/******************************************************************************\n* Function Definitions\n*******************************************************************************/\n\n/******************************************************************************\n* Check Flags\n*******************************************************************************/\n#ifdef STM32G4\n\n/*Check if TERR flag is active */\nuint8_T TIM_IsActiveFlagTERR(TIM_Type_T * ptrTimer)\n{\n    if ( 1 == LL_TIM_IsActiveFlag_TERR(ptrTimer->PeripheralPtr) )\n    {\n        ptrTimer->errorStatus = ptrTimer->errorStatus | ENCODER_TRANSITION_ERROR ;\n    }\n    return (ptrTimer->errorStatus & ENCODER_TRANSITION_ERROR );\n}\n\n/*Check if IERR flag is active */\nuint8_T TIM_IsActiveFlagIERR(TIM_Type_T * ptrTimer)\n{\n    if ( 1 == LL_TIM_IsActiveFlag_IERR(ptrTimer->PeripheralPtr) )\n    {\n        ptrTimer->errorStatus = ptrTimer->errorStatus | ENCODER_INDEX_ERROR ;\n    }\n    return (ptrTimer->errorStatus & ENCODER_INDEX_ERROR );\n}\n\n/*Check if IDX flag is active */\nboolean_T TIM_IsActiveFlagIDX(TIM_Type_T * ptrTimer)\n{\n    if(1 == LL_TIM_IsActiveFlag_IDX(ptrTimer->PeripheralPtr))\n    {\n        ptrTimer->firstIndexReceivedStatus = 1 ;\n    }\n    return (ptrTimer->firstIndexReceivedStatus == 1 );\n}\n#endif\n\n/*Check if CC1 flag is active */\nboolean_T TIM_IsActiveFlag_CC1(TIM_Type_T * ptrTimer)\n{\n    if ( 1 == LL_TIM_IsActiveFlag_CC1(ptrTimer->PeripheralPtr) )\n    {\n        ptrTimer->cc1Flag = 1 ;\n    }\n    return (ptrTimer->cc1Flag == 1 ) ;\n}\n\n/*Check if CC2 flag is active */\nboolean_T TIM_IsActiveFlag_CC2(TIM_Type_T * ptrTimer)\n{\n    if ( 1 == LL_TIM_IsActiveFlag_CC2(ptrTimer->PeripheralPtr) )\n    {\n        ptrTimer->cc2Flag = 1 ;\n    }\n    return (ptrTimer->cc2Flag == 1 );\n}\n\n/*Check if CC3 flag is active */\nboolean_T TIM_IsActiveFlag_CC3(TIM_Type_T * ptrTimer)\n{\n    if ( 1 == LL_TIM_IsActiveFlag_CC3(ptrTimer->PeripheralPtr) )\n    {\n        ptrTimer->cc3Flag = 1 ;\n    }\n    return (ptrTimer->cc3Flag == 1 );\n}\n\n/*Check if CC4 flag is active */\nboolean_T TIM_IsActiveFlag_CC4(TIM_Type_T * ptrTimer)\n{\n    if ( 1 == LL_TIM_IsActiveFlag_CC4(ptrTimer->PeripheralPtr) )\n    {\n        ptrTimer->cc4Flag = 1 ;\n    }\n    return (ptrTimer->cc4Flag == 1 );\n}\n\n/******************************************************************************\n* Enable and Disable timer Interrupts\n*******************************************************************************/\n\n/*Enable Timer Interrupts */\nvoid enableTimerInterrupts(TIM_Type_T * ptrTimer, uint16_T interruptsToEnable)\n{\n    if( (interruptsToEnable & 1) &&  (1 != LL_TIM_IsEnabledIT_TRIG(ptrTimer->PeripheralPtr)))\n    {\n        //Enable Trigger Interrupt\n        LL_TIM_EnableIT_TRIG(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToEnable & 2) &&  (1 != LL_TIM_IsEnabledIT_CC1(ptrTimer->PeripheralPtr)))\n    {\n        //Enable Capture Compare 1 Interrupt\n        LL_TIM_EnableIT_CC1(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToEnable & 4) && (1 != LL_TIM_IsEnabledIT_CC2(ptrTimer->PeripheralPtr)))\n    {\n        //Enable Capture Compare 2 Interrupt\n        LL_TIM_EnableIT_CC2(ptrTimer->PeripheralPtr);\n    }\n    if((interruptsToEnable & 8) && (1 != LL_TIM_IsEnabledIT_CC3(ptrTimer->PeripheralPtr)) )\n    {\n        //Enable Capture Compare 3 Interrupt\n        LL_TIM_EnableIT_CC3(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToEnable & 16) &&  (1 != LL_TIM_IsEnabledIT_CC4(ptrTimer->PeripheralPtr)))\n    {\n        //Enable Capture Compare 4 Interrupt\n        LL_TIM_EnableIT_CC4(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToEnable & 32) &&  (1 != LL_TIM_IsEnabledIT_UPDATE(ptrTimer->PeripheralPtr)))\n    {\n        //Enable Update Interrupt\n        LL_TIM_EnableIT_UPDATE(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToEnable & 64) &&  (1 != LL_TIM_IsEnabledIT_BRK(ptrTimer->PeripheralPtr)) )\n    {\n        //Enable Break Interrupt\n        LL_TIM_EnableIT_BRK(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToEnable & 128) &&  (1 != LL_TIM_IsEnabledIT_COM(ptrTimer->PeripheralPtr)) )\n    {\n        //Enable Break Interrupt\n        LL_TIM_EnableIT_COM(ptrTimer->PeripheralPtr);\n    }\n    #ifdef STM32G4\n    if( (interruptsToEnable & 256) &&  (1 != LL_TIM_IsEnabledIT_IDX(ptrTimer->PeripheralPtr)) )\n    {\n        //Enable Index Interrupt\n        LL_TIM_EnableIT_IDX(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToEnable & 512) &&  (1 != LL_TIM_IsEnabledIT_DIR(ptrTimer->PeripheralPtr)) )\n    {\n        //Enable Direction Interrupt\n        LL_TIM_EnableIT_DIR(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToEnable & 1024) &&  (1 != LL_TIM_IsEnabledIT_TERR(ptrTimer->PeripheralPtr)) )\n    {\n        //Enable Transition error Interrupt\n        LL_TIM_EnableIT_TERR(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToEnable & 2048) &&  (1 != LL_TIM_IsEnabledIT_IERR(ptrTimer->PeripheralPtr)) )\n    {\n        //Enable Index error Interrupt\n        LL_TIM_EnableIT_IERR(ptrTimer->PeripheralPtr);\n    }\n    #endif\n}\n\n/*Disable Timer Interrupts */\nvoid disableTimerInterrupts(TIM_Type_T * ptrTimer, uint16_T interruptsToDisable)\n{\n    if( (interruptsToDisable & 1) &&  (1 == LL_TIM_IsEnabledIT_TRIG(ptrTimer->PeripheralPtr)))\n    {\n        //Disable Trigger Interrupt\n        LL_TIM_DisableIT_TRIG(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToDisable & 2) &&  (1 == LL_TIM_IsEnabledIT_CC1(ptrTimer->PeripheralPtr)))\n    {\n        //Disable Capture Compare 1 Interrupt\n        LL_TIM_DisableIT_CC1(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToDisable & 4) && (1 == LL_TIM_IsEnabledIT_CC2(ptrTimer->PeripheralPtr)))\n    {\n        //Disable Capture Compare 2 Interrupt\n        LL_TIM_DisableIT_CC2(ptrTimer->PeripheralPtr);\n    }\n    if((interruptsToDisable & 8) && (1 == LL_TIM_IsEnabledIT_CC3(ptrTimer->PeripheralPtr)) )\n    {\n        //Disable Capture Compare 3 Interrupt\n        LL_TIM_DisableIT_CC3(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToDisable & 16) &&  (1 == LL_TIM_IsEnabledIT_CC4(ptrTimer->PeripheralPtr)))\n    {\n        //Disable Capture Compare 4 Interrupt\n        LL_TIM_DisableIT_CC4(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToDisable & 32) &&  (1 != LL_TIM_IsEnabledIT_UPDATE(ptrTimer->PeripheralPtr)))\n    {\n        //Disable Update Interrupt\n        LL_TIM_DisableIT_UPDATE(ptrTimer->PeripheralPtr);\n    }\n    if((interruptsToDisable & 64) &&  (1 == LL_TIM_IsEnabledIT_BRK(ptrTimer->PeripheralPtr)))\n    {\n        //Disable Break Interrupt\n        LL_TIM_DisableIT_BRK(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToDisable & 128) &&  (1 == LL_TIM_IsEnabledIT_COM(ptrTimer->PeripheralPtr)) )\n    {\n        //Disable Break Interrupt\n        LL_TIM_DisableIT_COM(ptrTimer->PeripheralPtr);\n    }\n    #ifdef STM32G4\n    if( (interruptsToDisable & 256) &&  (1 == LL_TIM_IsEnabledIT_IDX(ptrTimer->PeripheralPtr)) )\n    {\n        //Disable Index Interrupt\n        LL_TIM_DisableIT_IDX(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToDisable & 512) &&  (1 == LL_TIM_IsEnabledIT_DIR(ptrTimer->PeripheralPtr)) )\n    {\n        //Disable Direction Interrupt\n        LL_TIM_DisableIT_DIR(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToDisable & 1024) &&  (1 == LL_TIM_IsEnabledIT_TERR(ptrTimer->PeripheralPtr)) )\n    {\n        //Disable Transition error Interrupt\n        LL_TIM_DisableIT_TERR(ptrTimer->PeripheralPtr);\n    }\n    if( (interruptsToDisable & 2048) &&  (1 == LL_TIM_IsEnabledIT_IERR(ptrTimer->PeripheralPtr)) )\n    {\n        //Disable Index error Interrupt\n        LL_TIM_DisableIT_IERR(ptrTimer->PeripheralPtr);\n    }\n    #endif\n\n}\n\n/******************************************************************************\n* Enable and Disable Timer channels\n*******************************************************************************/\n\n/* Enable the Timer Capture compare channel 1 */\nvoid enableTimerChannel1(TIM_Type_T * ptrTimer,  uint8_T PWMChannelInfo)\n{\n    if(PWMChannelInfo == ENABLE_CH)\n    {\n        LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH1);\n    }\n    else if  (IS_TIM_BREAK_INSTANCE(ptrTimer->PeripheralPtr))\n    {\n        if(PWMChannelInfo == ENABLE_CHN)\n        {\n            LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH1N);\n        }\n        else if(PWMChannelInfo == ENABLE_CH_CHN)\n        {\n            LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH1);\n            LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH1N);\n        }\n    }\n}\n\n/* Disable Timer Capture Compare Channel 1 */\nvoid disableTimerChannel1(TIM_Type_T * ptrTimer,  uint8_T PWMChannelInfo)\n{\n    if(PWMChannelInfo == ENABLE_CH)\n    {\n        LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH1);\n    }\n    else if  (IS_TIM_BREAK_INSTANCE(ptrTimer->PeripheralPtr))\n    {\n        if(PWMChannelInfo == ENABLE_CHN)\n        {\n            LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH1N);\n        }\n        else if(PWMChannelInfo == ENABLE_CH_CHN)\n        {\n            LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH1);\n            LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH1N);\n        }\n    }\n}\n\n/* Enable the Timer Capture compare channel 2 */\nvoid enableTimerChannel2(TIM_Type_T * ptrTimer,  uint8_T PWMChannelInfo)\n{\n    if(PWMChannelInfo == ENABLE_CH)\n    {\n        LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH2);\n    }\n    else if  (IS_TIM_BREAK_INSTANCE(ptrTimer->PeripheralPtr))\n    {\n        if(PWMChannelInfo == ENABLE_CHN)\n        {\n            LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH2N);\n        }\n        else if(PWMChannelInfo == ENABLE_CH_CHN)\n        {\n            LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH2);\n            LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH2N);\n        }\n    }\n}\n\n/* Disable the Timer Capture compare channel 2 */\nvoid disableTimerChannel2(TIM_Type_T * ptrTimer,  uint8_T PWMChannelInfo)\n{\n    if(PWMChannelInfo == ENABLE_CH)\n    {\n        LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH2);\n    }\n\n    else if  (IS_TIM_BREAK_INSTANCE(ptrTimer->PeripheralPtr))\n    {\n        if(PWMChannelInfo == ENABLE_CHN)\n        {\n            LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH2N);\n        }\n        else if(PWMChannelInfo == ENABLE_CH_CHN)\n        {\n            LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH2);\n            LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH2N);\n        }\n    }\n}\n\n/* Enable the Timer Capture compare channel 3 */\nvoid enableTimerChannel3(TIM_Type_T * ptrTimer,  uint8_T PWMChannelInfo)\n{\n    if(PWMChannelInfo == ENABLE_CH)\n    {\n        LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH3);\n    }\n    else if  (IS_TIM_BREAK_INSTANCE(ptrTimer->PeripheralPtr))\n    {\n        if(PWMChannelInfo == ENABLE_CHN)\n        {\n            LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH3N);\n        }\n        else if(PWMChannelInfo == ENABLE_CH_CHN)\n        {\n            LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH3);\n            LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH3N);\n        }\n    }\n}\n\n/* Disable the Timer Capture compare channel 3 */\nvoid disableTimerChannel3(TIM_Type_T * ptrTimer,  uint8_T PWMChannelInfo)\n{\n    if(PWMChannelInfo == ENABLE_CH)\n    {\n        LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH3);\n    }\n    else if  (IS_TIM_BREAK_INSTANCE(ptrTimer->PeripheralPtr))\n    {\n        if(PWMChannelInfo == ENABLE_CHN)\n        {\n            LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH3N);\n        }\n        else if(PWMChannelInfo == ENABLE_CH_CHN)\n        {\n            LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH3);\n            LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH3N);\n        }\n    }\n}\n\n/* Enable the Timer Capture compare channel 4 */\nvoid enableTimerChannel4(TIM_Type_T * ptrTimer,  uint8_T PWMChannelInfo)\n{\n    if(PWMChannelInfo == ENABLE_CH)\n    {\n        LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH4);\n    }\n    #if defined(STM32G4)  || defined(STM32H5)\n    else if  (IS_TIM_BREAK_INSTANCE(ptrTimer->PeripheralPtr))\n    {\n        if(PWMChannelInfo == ENABLE_CHN)\n        {\n            LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH4N);\n        }\n        else if(PWMChannelInfo == ENABLE_CH_CHN)\n        {\n            LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH4);\n            LL_TIM_CC_EnableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH4N);\n        }        \n    }\n    #endif\n}\n\n/* Disable the Timer Capture compare channel 4 */\nvoid disableTimerChannel4(TIM_Type_T * ptrTimer,  uint8_T PWMChannelInfo)\n{\n    if(PWMChannelInfo == ENABLE_CH)\n    {\n        LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH4);\n    }\n    #if defined(STM32G4)  || defined(STM32H5)\n    else if  (IS_TIM_BREAK_INSTANCE(ptrTimer->PeripheralPtr))\n    {\n        if(PWMChannelInfo == ENABLE_CHN)\n        {\n            LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH4N);\n        }\n        else if(PWMChannelInfo == ENABLE_CH_CHN)\n        {\n            LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH4);\n            LL_TIM_CC_DisableChannel(ptrTimer->PeripheralPtr, LL_TIM_CHANNEL_CH4N);\n        }\n    }\n    #endif\n}\n\n/******************************************************************************\n* Initialize Timer Handle\n*******************************************************************************/\n\n/*Initialize the timer */\nTIM_Type_T * Timer_Handle_Init(TIM_Type_T * ptrTimer)\n{\n    TIM_Type_T* tempTimerPtr = NULL;\n\n    //Initialize the peripheral ptr\n    #if defined(TIM1) && defined(MW_TIM1_ENABLED)\n\n    if ( (TIM_TypeDef *)TIM1 == (TIM_TypeDef  *)ptrTimer->PeripheralPtr)\n    {\n        tempTimerPtr = &mw_tim1;\n    }\n    else\n        #endif\n\n        #if defined(TIM2) && defined(MW_TIM2_ENABLED)\n        if ((TIM_TypeDef *)TIM2 == (TIM_TypeDef  *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim2;\n        }\n    else\n        #endif\n        #if defined(TIM3) && defined(MW_TIM3_ENABLED)\n        if ((TIM_TypeDef *)TIM3 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim3;\n        }\n    else\n        #endif\n\n        #if defined(TIM4) && defined(MW_TIM4_ENABLED)\n        if ((TIM_TypeDef *)TIM4 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim4;\n        }\n    else\n        #endif\n        #if defined(TIM5) && defined(MW_TIM5_ENABLED)\n        if ( (TIM_TypeDef *)TIM5 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim5;\n        }\n    else\n        #endif\n\n        #if defined(TIM6) && defined(MW_TIM6_ENABLED)\n        if ((TIM_TypeDef *)TIM6 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim6;\n        }\n    else\n        #endif\n        #if defined(TIM7) && defined(MW_TIM7_ENABLED)\n        if ((TIM_TypeDef *)TIM7 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim7;\n        }\n    else\n        #endif\n        #if defined(TIM8) && defined(MW_TIM8_ENABLED)\n        if ((TIM_TypeDef *)TIM8 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim8;\n        }\n    else\n        #endif\n        #if defined(TIM9) && defined(MW_TIM9_ENABLED)\n        if ((TIM_TypeDef *)TIM9 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim9;\n        }\n    else\n        #endif\n        #if defined(TIM10) && defined(MW_TIM10_ENABLED)\n        if ( (TIM_TypeDef *)TIM10 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim10;\n        }\n    else\n        #endif\n        #if defined(TIM11) && defined(MW_TIM11_ENABLED)\n        if ((TIM_TypeDef *)TIM11 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim11;\n        }\n    else\n        #endif\n        #if defined(TIM12) && defined(MW_TIM12_ENABLED)\n        if ((TIM_TypeDef *)TIM12 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim12;\n        }\n    else\n        #endif\n        #if defined(TIM13) && defined(MW_TIM13_ENABLED)\n        if ((TIM_TypeDef *)TIM13 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim13;\n        }\n    else\n        #endif\n        #if defined(TIM14) && defined(MW_TIM14_ENABLED)\n        if ((TIM_TypeDef *)TIM14 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim14;\n        }\n    else\n        #endif\n        #if defined(TIM15) && defined(MW_TIM15_ENABLED)\n        if ((TIM_TypeDef *)TIM15 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim15;\n        }\n    else\n        #endif\n        #if defined(TIM16) && defined(MW_TIM16_ENABLED)\n        if ((TIM_TypeDef *)TIM16 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim16;\n        }\n    else\n        #endif\n        #if defined(TIM17) && defined(MW_TIM17_ENABLED)\n        if ((TIM_TypeDef *)TIM17 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim17;\n        }\n    else\n        #endif\n        #if defined(TIM18) && defined(MW_TIM18_ENABLED)\n        if ((TIM_TypeDef *)TIM18 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim18;\n        }\n    else\n        #endif\n        #if defined(TIM19) && defined(MW_TIM19_ENABLED)\n        if ((TIM_TypeDef *)TIM19 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim19;\n        }\n    else\n        #endif\n        #if defined(TIM20) && defined(MW_TIM20_ENABLED)\n        if ((TIM_TypeDef *)TIM20 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim20;\n        }\n    else\n        #endif\n        #if defined(TIM23) && defined(MW_TIM23_ENABLED)\n        if ((TIM_TypeDef *)TIM23 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim23;\n        }\n    else\n        #endif\n        #if defined(TIM24) && defined(MW_TIM24_ENABLED)\n        if ((TIM_TypeDef *)TIM24 == (TIM_TypeDef *)ptrTimer->PeripheralPtr)\n        {\n            tempTimerPtr = &mw_tim24;\n        }\n    else\n        #endif\n    {\n    }\n    tempTimerPtr->PeripheralPtr = (TIM_TypeDef *)ptrTimer->PeripheralPtr;\n    uint32_t mode =  LL_TIM_GetCounterMode (tempTimerPtr->PeripheralPtr);\n    if( (mode != LL_TIM_COUNTERMODE_UP) && (mode != LL_TIM_COUNTERMODE_DOWN))\n    {\n        tempTimerPtr->isCenterAlignedMode = 1;\n    }\n    else\n    {\n        tempTimerPtr->isCenterAlignedMode = 0;\n    }\n\n    // Enable the MOE bit if AOE bit is disabled in STM32CubemMX for Advanced TIMERS\n    if( IS_TIM_BREAK_INSTANCE(tempTimerPtr->PeripheralPtr))\n    {\n        LL_TIM_EnableAllOutputs(tempTimerPtr->PeripheralPtr);\n    }\n    //Get the current repetition counter value\n    if( IS_TIM_REPETITION_COUNTER_INSTANCE(tempTimerPtr->PeripheralPtr))\n    {\n        tempTimerPtr->repetitionCounter = (uint8_T)LL_TIM_GetRepetitionCounter(ptrTimer->PeripheralPtr) ;\n    }\n    #ifdef STM32G4\n    tempTimerPtr->errorStatus = ENCODER_NO_ERROR;\n    tempTimerPtr->firstIndexReceivedStatus = 0;\n    #endif\n\n    return tempTimerPtr;\n}\n\n/*Configure DMA for Timer capture if capture length > 1*/\nvoid configureDMAForChannel(TIM_Type_T * ptrTimer, Channel_DMA_T ptrTimChannel, uint8_T channel)\n{\n    register uint32_t data_reg_addr = 0;\n    switch (channel)\n    {\n        case 1:\n            data_reg_addr = (uint32_t)&(((TIM_TypeDef *)ptrTimer->PeripheralPtr)->CCR1);\n            ptrTimer->channel1 = ptrTimChannel;\n            ptrTimer->cc1Flag = 0;\n            break;\n        case 2:\n            data_reg_addr = (uint32_t)&(((TIM_TypeDef *)ptrTimer->PeripheralPtr)->CCR2);\n            ptrTimer->channel2 = ptrTimChannel;\n            ptrTimer->cc2Flag = 0;\n            break;\n        case 3:\n            data_reg_addr = (uint32_t)&(((TIM_TypeDef *)ptrTimer->PeripheralPtr)->CCR3);\n            ptrTimer->channel3 = ptrTimChannel;\n            ptrTimer->cc3Flag = 0;\n            break;\n        case 4:\n            data_reg_addr = (uint32_t)&(((TIM_TypeDef *)ptrTimer->PeripheralPtr)->CCR4);\n            ptrTimer->channel4 = ptrTimChannel;\n            ptrTimer->cc4Flag = 0;\n            break;\n    }\n\n    /* Enable TC interrupts */\n    if(IS_TIM_32B_COUNTER_INSTANCE(ptrTimer->PeripheralPtr))\n    {\n        #if defined(GPDMA)\n        LL_DMA_ConfigAddresses(ptrTimChannel.dmaPeripheralPtr, (uint32_t)ptrTimChannel.dmastream,data_reg_addr ,\n                               (uint32_t)&ptrTimChannel.buffer.bufferPtr32Bit[0]);\n        #else\n            LL_DMA_ConfigAddresses(ptrTimChannel.dmaPeripheralPtr, (uint32_t)ptrTimChannel.dmastream,data_reg_addr ,\n                               (uint32_t)&ptrTimChannel.buffer.bufferPtr32Bit[0],\n                               LL_DMA_DIRECTION_PERIPH_TO_MEMORY);\n        #endif\n    }\n    else\n    {\n        #if defined(GPDMA)\n        LL_DMA_ConfigAddresses(ptrTimChannel.dmaPeripheralPtr, (uint32_t)ptrTimChannel.dmastream,data_reg_addr ,\n                                   (uint32_t)&ptrTimChannel.buffer.bufferPtr16Bit[0]);\n        #else\n            LL_DMA_ConfigAddresses(ptrTimChannel.dmaPeripheralPtr, (uint32_t)ptrTimChannel.dmastream,data_reg_addr,\n                               (uint32_t)&ptrTimChannel.buffer.bufferPtr16Bit[0],\n                               LL_DMA_DIRECTION_PERIPH_TO_MEMORY);\n        #endif\n    }\n\n    #if defined(GPDMA)\n        LL_DMA_SetBlkDataLength(ptrTimChannel.dmaPeripheralPtr, (uint32_t)ptrTimChannel.dmastream, ptrTimChannel.buffer.bufferSize);\n    #else\n    LL_DMA_SetDataLength(ptrTimChannel.dmaPeripheralPtr, (uint32_t)ptrTimChannel.dmastream, ptrTimChannel.buffer.bufferSize);\n    #endif\n\n    LL_DMA_EnableIT_TC(ptrTimChannel.dmaPeripheralPtr, (uint32_t)ptrTimChannel.dmastream);\n\n    LL_TIM_CC_SetDMAReqTrigger(ptrTimer->PeripheralPtr,LL_TIM_CCDMAREQUEST_CC);\n\n    switch (channel)\n    {\n        case 1:\n            LL_TIM_EnableDMAReq_CC1(ptrTimer->PeripheralPtr);\n            break;\n        case 2:\n            LL_TIM_EnableDMAReq_CC2(ptrTimer->PeripheralPtr);\n            break;\n        case 3:\n            LL_TIM_EnableDMAReq_CC3(ptrTimer->PeripheralPtr);\n            break;\n        case 4:\n            LL_TIM_EnableDMAReq_CC4(ptrTimer->PeripheralPtr);\n            break;\n    }\n    /* Enable USART and DMA Stream */\n    #if defined(STM32G4)  || defined(STM32WB) || defined(STM32L5) || defined(STM32L4) || defined(STM32U5) || defined(STM32F3) || defined(STM32H5)\n    LL_DMA_EnableChannel(ptrTimChannel.dmaPeripheralPtr, (uint32_t)ptrTimChannel.dmastream);\n    #else\n    LL_DMA_EnableStream(ptrTimChannel.dmaPeripheralPtr, (uint32_t)ptrTimChannel.dmastream);\n    #endif\n}\n\n\n/*Check that frequeny/duty cycle is not greater than 65535 for 16 bit timers */\nuint32_T checkFrequencyAndDutyCycleLimits(TIM_Type_T * ptrTimer, uint32_T input)\n{\n    uint32_t ret = input;\n    if ((input > 65535) && (!IS_TIM_32B_COUNTER_INSTANCE(ptrTimer->PeripheralPtr)))\n    {\n        ret = 65535;\n    }\n    return ret;\n}\n\n/******************************************************************************\n* Internal functions to get data from buffer\n*******************************************************************************/\n\n/* Get data available in internal recieve buffer */\nuint32_T getAvailableDataInTimerBuffer(Channel_DMA_T * ptrTimChannel)\n{\n\tboolean_T rollOverFlag = ptrTimChannel->buffer.writeRollOver;\n    #if defined(GPDMA)\n        uint32_T dmaDataToBeTransferred = LL_DMA_GetBlkDataLength(ptrTimChannel->dmaPeripheralPtr, (uint32_t)ptrTimChannel->dmastream);\n    #else\n\tuint32_T dmaDataToBeTransferred = LL_DMA_GetDataLength(ptrTimChannel->dmaPeripheralPtr, (uint32_t)ptrTimChannel->dmastream);\n    #endif\n    uint32_T nbDataPos = (ptrTimChannel->buffer.bufferSize - dmaDataToBeTransferred);\n    if(nbDataPos == ptrTimChannel->buffer.bufferSize)\n    {\n        nbDataPos = 0;\n    }\n\n    /* Update read position to nbDataPos if buffer is overwritten in DMA mode i.e. read data which is not overwritten */\n    if(1 == rollOverFlag)\n    {\n        if(nbDataPos > ptrTimChannel->buffer.readPos)\n        {\n            ptrTimChannel->errorStatus =  ptrTimChannel->errorStatus |  MW_TIM_OVERRUN_ERROR;\n            ptrTimChannel->buffer.readPos = nbDataPos;\n        }\n    }\n\n    if (nbDataPos > ptrTimChannel->buffer.readPos)\n    {\n        /* No rollover condition */\n        return  (nbDataPos - ptrTimChannel->buffer.readPos);\n    }\n    else if  (nbDataPos < ptrTimChannel->buffer.readPos)\n    {\n        /* Rollover condition */\n        return  ((ptrTimChannel->buffer.bufferSize - (ptrTimChannel->buffer.readPos)) + nbDataPos);\n    }\n    else\n    {\n        if(1 == rollOverFlag)\n        {\n            return (ptrTimChannel->buffer.bufferSize);\n        }\n        else\n        {\n            return 0;\n        }\n    }\n}\n\n/*Read data from 16 bit buffer */\nvoid getDataFrom16BitTimerBuffer(Channel_DMA_T * ptrTimChannel, uint16_T *dataPtr, uint32_T dataToRead)\n {\n    #if defined(MW_DCACHE_ENABLED) //Invalidate cache if enabled before reading from DMA buffer\n    SCB_InvalidateDCache_by_Addr((uint32_t *)&ptrTimChannel->buffer.bufferPtr16Bit[0],  DMA_BUFFER_SIZE_BYTE_ALLIGNED(ptrTimChannel->buffer.bufferSize, 32) * 2);\n    #endif\n    if (((ptrTimChannel->buffer.readPos ) + dataToRead) > ptrTimChannel->buffer.bufferSize)\n    {\n        int lengthToReadFromBottom = (ptrTimChannel->buffer.bufferSize - ptrTimChannel->buffer.readPos);\n        memcpy(dataPtr,&ptrTimChannel->buffer.bufferPtr16Bit[ptrTimChannel->buffer.readPos],(lengthToReadFromBottom * 2));\n\n        ptrTimChannel->buffer.readPos = (ptrTimChannel->buffer.readPos + dataToRead) - ptrTimChannel->buffer.bufferSize;\n        memcpy((dataPtr + lengthToReadFromBottom),&ptrTimChannel->buffer.bufferPtr16Bit[0],(ptrTimChannel->buffer.readPos * 2));\n        ptrTimChannel->buffer.writeRollOver = 0;\n    }\n    else\n    {\n        memcpy(dataPtr,&ptrTimChannel->buffer.bufferPtr16Bit[ptrTimChannel->buffer.readPos],(dataToRead * 2));\n        ptrTimChannel->buffer.readPos+=dataToRead;\n    }\n}\n\n/*Read data from 32 bit buffer */\nvoid getDataFrom32BitTimerBuffer(Channel_DMA_T * ptrTimChannel, uint32_T *dataPtr, uint32_T dataToRead)\n{\n    #if defined(MW_DCACHE_ENABLED) //Invalidate cache if enabled before reading from DMA buffer\n    SCB_InvalidateDCache_by_Addr((uint32_t *)&ptrTimChannel->buffer.bufferPtr32Bit[0],  DMA_BUFFER_SIZE_BYTE_ALLIGNED(ptrTimChannel->buffer.bufferSize, 32) * 4);\n    #endif\n    if (((ptrTimChannel->buffer.readPos ) + dataToRead) > ptrTimChannel->buffer.bufferSize)\n    {\n        int lengthToReadFromBottom = (ptrTimChannel->buffer.bufferSize - ptrTimChannel->buffer.readPos);\n        memcpy(dataPtr,&ptrTimChannel->buffer.bufferPtr32Bit[ptrTimChannel->buffer.readPos],(lengthToReadFromBottom * 4));\n\n        ptrTimChannel->buffer.readPos = (ptrTimChannel->buffer.readPos + dataToRead) - ptrTimChannel->buffer.bufferSize;\n        memcpy((dataPtr + lengthToReadFromBottom),&ptrTimChannel->buffer.bufferPtr32Bit[0],(ptrTimChannel->buffer.readPos * 4));\n        ptrTimChannel->buffer.writeRollOver = 0;\n    }\n    else\n    {\n        memcpy(dataPtr,&ptrTimChannel->buffer.bufferPtr32Bit[ptrTimChannel->buffer.readPos],(dataToRead * 4));\n        ptrTimChannel->buffer.readPos+=dataToRead;\n    }\n}\n\n/*Read data from timer internal receive buffer */\nuint8_T readDataFromTimerBuffer(TIM_Type_T * TimerPtr, Channel_DMA_T * ptrTimChannel, void *dataPtr, uint32_T dataToRead, uint32_T *receivedLength)\n{\n    *receivedLength = 0;\n    uint8_T status = MW_TIM_SUCCESS;\n\n    uint32_T availableData = getAvailableDataInTimerBuffer(ptrTimChannel);\n    if (availableData < dataToRead)\n    {\n        dataToRead = availableData;\n    }\n    if(availableData > 0)\n    {\n        if(IS_TIM_32B_COUNTER_INSTANCE(TimerPtr->PeripheralPtr))\n        {\n            getDataFrom32BitTimerBuffer(ptrTimChannel, (uint32_T *)dataPtr, dataToRead);\n        }\n        else\n        {\n            getDataFrom16BitTimerBuffer(ptrTimChannel, (uint16_T *)dataPtr, dataToRead);\n        }\n\n        if(ptrTimChannel->buffer.readPos == ptrTimChannel->buffer.bufferSize )\n        {\n            ptrTimChannel->buffer.readPos = 0;\n            ptrTimChannel->buffer.writeRollOver = 0;\n        }\n        status = ptrTimChannel->errorStatus;\n        ptrTimChannel->errorStatus = MW_TIM_SUCCESS;\n    }\n    *receivedLength = dataToRead;\n    return status;\n}\n\n/******************************************************************************\n* Internal functions to get capture data\n*******************************************************************************/\n\n/* Read capture comapre register 1  in DMA mode */\nuint8_T getCCR1RegisterValueDMAMode(TIM_Type_T * TimerPtr, void *data, uint32_T dataLength, uint32_T *receivedLength)\n{\n\n    return readDataFromTimerBuffer(TimerPtr,&TimerPtr->channel1, data, dataLength, receivedLength);\n}\n/* Read capture comapre register 2  in DMA mode */\nuint8_T getCCR2RegisterValueDMAMode(TIM_Type_T * TimerPtr, void *data, uint32_T dataLength, uint32_T *receivedLength)\n{\n    return readDataFromTimerBuffer(TimerPtr,&TimerPtr->channel2, data, dataLength, receivedLength);\n}\n/* Read capture comapre register 3  in DMA mode */\nuint8_T getCCR3RegisterValueDMAMode(TIM_Type_T * TimerPtr, void *data, uint32_T dataLength, uint32_T *receivedLength)\n{\n    return readDataFromTimerBuffer(TimerPtr,&TimerPtr->channel3, data, dataLength, receivedLength);\n}\n/* Read capture comapre register 4  in DMA mode */\nuint8_T getCCR4RegisterValueDMAMode(TIM_Type_T * TimerPtr, void *data, uint32_T dataLength, uint32_T *receivedLength)\n{\n    return readDataFromTimerBuffer(TimerPtr,&TimerPtr->channel4, data, dataLength, receivedLength);\n}\n/* Read capture comapre register 1  in polling mode */\nuint8_T getCCR1RegisterValuePollingMode(TIM_Type_T * TimerPtr, void *data, uint32_T *receivedLen)\n{\n    uint8_T status = MW_TIM_SUCCESS;\n    if(0 ==  TIM_IsActiveFlag_CC1(TimerPtr))\n    {\n        *receivedLen = 0;\n    }\n    else\n    {\n        if(IS_TIM_32B_COUNTER_INSTANCE(TimerPtr->PeripheralPtr))\n        {\n            *(uint32_T *)data = LL_TIM_IC_GetCaptureCH1(TimerPtr->PeripheralPtr);\n        }\n        else\n        {\n            *(uint16_T *)data = LL_TIM_IC_GetCaptureCH1(TimerPtr->PeripheralPtr);\n        }\n        LL_TIM_ClearFlag_CC1(TimerPtr->PeripheralPtr);\n        TimerPtr->cc1Flag = 0;\n        *receivedLen = 1;\n        if( 1 ==  LL_TIM_IsActiveFlag_CC1OVR(TimerPtr->PeripheralPtr))\n        {\n            LL_TIM_ClearFlag_CC1OVR(TimerPtr->PeripheralPtr);\n            status = MW_TIM_OVERRUN_ERROR;\n        }\n    }\n    return status;\n}\n/* Read capture comapre register 2  in polling mode */\nuint8_T getCCR2RegisterValuePollingMode(TIM_Type_T * TimerPtr, void *data, uint32_T *receivedLen)\n{\n    uint8_T status = MW_TIM_SUCCESS;\n    if(0 ==  TIM_IsActiveFlag_CC2(TimerPtr))\n    {\n        *receivedLen = 0;\n    }\n    else\n    {\n        if(IS_TIM_32B_COUNTER_INSTANCE(TimerPtr->PeripheralPtr))\n        {\n            *(uint32_T *)data = LL_TIM_IC_GetCaptureCH2(TimerPtr->PeripheralPtr);\n        }\n        else\n        {\n            *(uint16_T *)data = LL_TIM_IC_GetCaptureCH2(TimerPtr->PeripheralPtr);\n        }\n        LL_TIM_ClearFlag_CC2(TimerPtr->PeripheralPtr);\n        TimerPtr->cc2Flag = 0;\n        *receivedLen = 1;\n        if( 1 ==  LL_TIM_IsActiveFlag_CC2OVR(TimerPtr->PeripheralPtr))\n        {\n            LL_TIM_ClearFlag_CC2OVR(TimerPtr->PeripheralPtr);\n            status = MW_TIM_OVERRUN_ERROR;\n        }\n    }\n    return status;\n}\n/* Read capture comapre register 3  in polling mode */\nuint8_T getCCR3RegisterValuePollingMode(TIM_Type_T * TimerPtr, void *data, uint32_T *receivedLen)\n{\n    uint8_T status = MW_TIM_SUCCESS;\n    if(0 ==  TIM_IsActiveFlag_CC3(TimerPtr))\n    {\n        *receivedLen = 0;\n    }\n    else\n    {\n        if(IS_TIM_32B_COUNTER_INSTANCE(TimerPtr->PeripheralPtr))\n        {\n            *(uint32_T *)data = LL_TIM_IC_GetCaptureCH3(TimerPtr->PeripheralPtr);\n        }\n        else\n        {\n            *(uint16_T *)data = LL_TIM_IC_GetCaptureCH3(TimerPtr->PeripheralPtr);\n        }\n        LL_TIM_ClearFlag_CC3(TimerPtr->PeripheralPtr);\n        TimerPtr->cc3Flag = 0;\n        *receivedLen = 1;\n        if( 1 ==  LL_TIM_IsActiveFlag_CC3OVR(TimerPtr->PeripheralPtr))\n        {\n            LL_TIM_ClearFlag_CC3OVR(TimerPtr->PeripheralPtr);\n            status = MW_TIM_OVERRUN_ERROR;\n        }\n    }\n    return status;\n}\n/* Read capture comapre register 4  in polling mode */\nuint8_T getCCR4RegisterValuePollingMode(TIM_Type_T * TimerPtr, void *data, uint32_T *receivedLen)\n{\n    uint8_T status = MW_TIM_SUCCESS;\n    if(0 ==  TIM_IsActiveFlag_CC4(TimerPtr))\n    {\n        *receivedLen = 0;\n    }\n    else\n    {\n        if(IS_TIM_32B_COUNTER_INSTANCE(TimerPtr->PeripheralPtr))\n        {\n            *(uint32_T *)data = LL_TIM_IC_GetCaptureCH4(TimerPtr->PeripheralPtr);\n        }\n        else\n        {\n            *(uint16_T *)data = LL_TIM_IC_GetCaptureCH4(TimerPtr->PeripheralPtr);\n        }\n        LL_TIM_ClearFlag_CC4(TimerPtr->PeripheralPtr);\n        TimerPtr->cc4Flag = 0;\n        *receivedLen = 1;\n        if( 1 ==  LL_TIM_IsActiveFlag_CC4OVR(TimerPtr->PeripheralPtr))\n        {\n            LL_TIM_ClearFlag_CC4OVR(TimerPtr->PeripheralPtr);\n            status = MW_TIM_OVERRUN_ERROR;\n        }\n    }\n    return status;\n}\n\n/******************************************************************************\n*  Internal functions to get counter value\n*******************************************************************************/\n\n/*Get Timer counter value */\nuint32_T getTimerCounterValue(TIM_Type_T * TimerPtr)\n{\n    return LL_TIM_GetCounter(TimerPtr->PeripheralPtr);\n}\n\n#if  defined(STM32G4)\n/* Get counter value for G4 */\nuint32_T getTimerCounterValueForG4(TIM_Type_T * TimerPtr, boolean_T enableCountAfterFirstIndex, boolean_T * validIndex)\n{\n    if ((enableCountAfterFirstIndex == 1) || (validIndex != NULL))\n    {\n        static boolean_T firstIndexReceived = 0;\n        if(firstIndexReceived == 0)\n        {\n            if (0 == TIM_IsActiveFlagIDX(TimerPtr) )\n            {\n                if(enableCountAfterFirstIndex == 1)\n                {\n                    return 0;\n                }\n            }\n            else\n            {\n                if(validIndex != NULL)\n                {\n                    *validIndex = 1;\n                }\n                firstIndexReceived = 1;\n            }\n        }\n    }\n    return LL_TIM_GetCounter(TimerPtr->PeripheralPtr);\n}\n\n\n/******************************************************************************\n* Internal functions to get encoder read status for G4\n*******************************************************************************/\n/*Get encoder read status for G4 */\nuint8_T ouputEncoderReadStatus(TIM_Type_T * TimerPtr)\n{\n    uint8_T status = ENCODER_NO_ERROR;\n    if ( ENCODER_TRANSITION_ERROR == TIM_IsActiveFlagTERR(TimerPtr) )\n    {\n        status = status | ENCODER_TRANSITION_ERROR;\n        LL_TIM_ClearFlag_TERR(TimerPtr->PeripheralPtr);\n    }\n    if ( ENCODER_INDEX_ERROR == TIM_IsActiveFlagIERR(TimerPtr))\n    {\n        status = status | ENCODER_INDEX_ERROR;\n        LL_TIM_ClearFlag_IERR(TimerPtr->PeripheralPtr);\n    }\n    TimerPtr->errorStatus = ENCODER_NO_ERROR ;\n    return status;\n}\n\n#endif\n"},{"name":"syscalls.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\STM32CubeIDE\\Application\\User\\Core","tag":"","groupDisplay":"Other files","code":"/**\n ******************************************************************************\n * @file      syscalls.c\n * @author    Auto-generated by STM32CubeIDE\n * @brief     STM32CubeIDE Minimal System calls file\n *\n *            For more information about which c-functions\n *            need which of these lowlevel functions\n *            please consult the Newlib libc-manual\n ******************************************************************************\n * @attention\n *\n * Copyright (c) 2021 STMicroelectronics.\n * All rights reserved.\n *\n * This software is licensed under terms that can be found in the LICENSE file\n * in the root directory of this software component.\n * If no LICENSE file comes with this software, it is provided AS-IS.\n *\n ******************************************************************************\n */\n\n/* Includes */\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdio.h>\n#include <signal.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sys/times.h>\n\n\n/* Variables */\nextern int __io_putchar(int ch) __attribute__((weak));\nextern int __io_getchar(void) __attribute__((weak));\n\n\nchar *__env[1] = { 0 };\nchar **environ = __env;\n\n\n/* Functions */\nvoid initialise_monitor_handles()\n{\n}\n\nint _getpid(void)\n{\n\treturn 1;\n}\n\nint _kill(int pid, int sig)\n{\n\terrno = EINVAL;\n\treturn -1;\n}\n\nvoid _exit (int status)\n{\n\t_kill(status, -1);\n\twhile (1) {}\t\t/* Make sure we hang here */\n}\n\n__attribute__((weak)) int _read(int file, char *ptr, int len)\n{\n\tint DataIdx;\n\n\tfor (DataIdx = 0; DataIdx < len; DataIdx++)\n\t{\n\t\t*ptr++ = __io_getchar();\n\t}\n\nreturn len;\n}\n\n__attribute__((weak)) int _write(int file, char *ptr, int len)\n{\n\tint DataIdx;\n\n\tfor (DataIdx = 0; DataIdx < len; DataIdx++)\n\t{\n\t\t__io_putchar(*ptr++);\n\t}\n\treturn len;\n}\n\nint _close(int file)\n{\n\treturn -1;\n}\n\n\nint _fstat(int file, struct stat *st)\n{\n\tst->st_mode = S_IFCHR;\n\treturn 0;\n}\n\nint _isatty(int file)\n{\n\treturn 1;\n}\n\nint _lseek(int file, int ptr, int dir)\n{\n\treturn 0;\n}\n\nint _open(char *path, int flags, ...)\n{\n\t/* Pretend like we always fail */\n\treturn -1;\n}\n\nint _wait(int *status)\n{\n\terrno = ECHILD;\n\treturn -1;\n}\n\nint _unlink(char *name)\n{\n\terrno = ENOENT;\n\treturn -1;\n}\n\nint _times(struct tms *buf)\n{\n\treturn -1;\n}\n\nint _stat(char *file, struct stat *st)\n{\n\tst->st_mode = S_IFCHR;\n\treturn 0;\n}\n\nint _link(char *old, char *new)\n{\n\terrno = EMLINK;\n\treturn -1;\n}\n\nint _fork(void)\n{\n\terrno = EAGAIN;\n\treturn -1;\n}\n\nint _execve(char *name, char **argv, char **env)\n{\n\terrno = ENOMEM;\n\treturn -1;\n}\n"},{"name":"sysmem.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\STM32CubeIDE\\Application\\User\\Core","tag":"","groupDisplay":"Other files","code":"/**\n ******************************************************************************\n * @file      sysmem.c\n * @author    Generated by STM32CubeIDE\n * @brief     STM32CubeIDE System Memory calls file\n *\n *            For more information about which C functions\n *            need which of these lowlevel functions\n *            please consult the newlib libc manual\n ******************************************************************************\n * @attention\n *\n * Copyright (c) 2021 STMicroelectronics.\n * All rights reserved.\n *\n * This software is licensed under terms that can be found in the LICENSE file\n * in the root directory of this software component.\n * If no LICENSE file comes with this software, it is provided AS-IS.\n *\n ******************************************************************************\n */\n\n/* Includes */\n#include <errno.h>\n#include <stdint.h>\n\n/**\n * Pointer to the current high watermark of the heap usage\n */\nstatic uint8_t *__sbrk_heap_end = NULL;\n\n/**\n * @brief _sbrk() allocates memory to the newlib heap and is used by malloc\n *        and others from the C library\n *\n * @verbatim\n * ############################################################################\n * #  .data  #  .bss  #       newlib heap       #          MSP stack          #\n * #         #        #                         # Reserved by _Min_Stack_Size #\n * ############################################################################\n * ^-- RAM start      ^-- _end                             _estack, RAM end --^\n * @endverbatim\n *\n * This implementation starts allocating at the '_end' linker symbol\n * The '_Min_Stack_Size' linker symbol reserves a memory for the MSP stack\n * The implementation considers '_estack' linker symbol to be RAM end\n * NOTE: If the MSP stack, at any point during execution, grows larger than the\n * reserved size, please increase the '_Min_Stack_Size'.\n *\n * @param incr Memory size\n * @return Pointer to allocated memory\n */\nvoid *_sbrk(ptrdiff_t incr)\n{\n  extern uint8_t _end; /* Symbol defined in the linker script */\n  extern uint8_t _estack; /* Symbol defined in the linker script */\n  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */\n  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;\n  const uint8_t *max_heap = (uint8_t *)stack_limit;\n  uint8_t *prev_heap_end;\n\n  /* Initialize heap end at first call */\n  if (NULL == __sbrk_heap_end)\n  {\n    __sbrk_heap_end = &_end;\n  }\n\n  /* Protect heap from growing into the reserved MSP stack */\n  if (__sbrk_heap_end + incr > max_heap)\n  {\n    errno = ENOMEM;\n    return (void *)-1;\n  }\n\n  prev_heap_end = __sbrk_heap_end;\n  __sbrk_heap_end += incr;\n\n  return (void *)prev_heap_end;\n}\n"},{"name":"system_stm32f4xx.c","type":"source","group":"legacy","path":"C:\\Users\\aferreira\\Documents\\MATLAB\\Examples\\R2024b\\stm32f4discovery\\OpenLoopControlUsingSTM32F4xxBasedExample\\stm32g446re_pmsm_example\\Core\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    system_stm32f4xx.c\r\n  * @author  MCD Application Team\r\n  * @brief   CMSIS Cortex-M4 Device Peripheral Access Layer System Source File.\r\n  *\r\n  *   This file provides two functions and one global variable to be called from \r\n  *   user application:\r\n  *      - SystemInit(): This function is called at startup just after reset and \r\n  *                      before branch to main program. This call is made inside\r\n  *                      the \"startup_stm32f4xx.s\" file.\r\n  *\r\n  *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used\r\n  *                                  by the user application to setup the SysTick \r\n  *                                  timer or configure other parameters.\r\n  *                                     \r\n  *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must\r\n  *                                 be called whenever the core clock is changed\r\n  *                                 during program execution.\r\n  *\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.</center></h2>\r\n  *\r\n  * This software component is licensed by ST under BSD 3-Clause license,\r\n  * the \"License\"; You may not use this file except in compliance with the\r\n  * License. You may obtain a copy of the License at:\r\n  *                        opensource.org/licenses/BSD-3-Clause\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/** @addtogroup CMSIS\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup stm32f4xx_system\r\n  * @{\r\n  */  \r\n  \r\n/** @addtogroup STM32F4xx_System_Private_Includes\r\n  * @{\r\n  */\r\n\r\n\r\n#include \"stm32f4xx.h\"\r\n\r\n#if !defined  (HSE_VALUE) \r\n  #define HSE_VALUE    ((uint32_t)25000000) /*!< Default value of the External oscillator in Hz */\r\n#endif /* HSE_VALUE */\r\n\r\n#if !defined  (HSI_VALUE)\r\n  #define HSI_VALUE    ((uint32_t)16000000) /*!< Value of the Internal oscillator in Hz*/\r\n#endif /* HSI_VALUE */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32F4xx_System_Private_TypesDefinitions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32F4xx_System_Private_Defines\r\n  * @{\r\n  */\r\n\r\n/************************* Miscellaneous Configuration ************************/\r\n/*!< Uncomment the following line if you need to use external SRAM or SDRAM as data memory  */\r\n#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)\\\r\n || defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\\\r\n || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx)\r\n/* #define DATA_IN_ExtSRAM */\r\n#endif /* STM32F40xxx || STM32F41xxx || STM32F42xxx || STM32F43xxx || STM32F469xx || STM32F479xx ||\\\r\n          STM32F412Zx || STM32F412Vx */\r\n \r\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\\\r\n || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)\r\n/* #define DATA_IN_ExtSDRAM */\r\n#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx ||\\\r\n          STM32F479xx */\r\n\r\n/* Note: Following vector table addresses must be defined in line with linker\r\n         configuration. */\r\n/*!< Uncomment the following line if you need to relocate the vector table\r\n     anywhere in Flash or Sram, else the vector table is kept at the automatic\r\n     remap of boot address selected */\r\n/* #define USER_VECT_TAB_ADDRESS */\r\n\r\n#if defined(USER_VECT_TAB_ADDRESS)\r\n/*!< Uncomment the following line if you need to relocate your vector Table\r\n     in Sram else user remap will be done in Flash. */\r\n/* #define VECT_TAB_SRAM */\r\n#if defined(VECT_TAB_SRAM)\r\n#define VECT_TAB_BASE_ADDRESS   SRAM_BASE       /*!< Vector Table base address field.\r\n                                                     This value must be a multiple of 0x200. */\r\n#define VECT_TAB_OFFSET         0x00000000U     /*!< Vector Table base offset field.\r\n                                                     This value must be a multiple of 0x200. */\r\n#else\r\n#define VECT_TAB_BASE_ADDRESS   FLASH_BASE      /*!< Vector Table base address field.\r\n                                                     This value must be a multiple of 0x200. */\r\n#define VECT_TAB_OFFSET         0x00000000U     /*!< Vector Table base offset field.\r\n                                                     This value must be a multiple of 0x200. */\r\n#endif /* VECT_TAB_SRAM */\r\n#endif /* USER_VECT_TAB_ADDRESS */\r\n/******************************************************************************/\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32F4xx_System_Private_Macros\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32F4xx_System_Private_Variables\r\n  * @{\r\n  */\r\n  /* This variable is updated in three ways:\r\n      1) by calling CMSIS function SystemCoreClockUpdate()\r\n      2) by calling HAL API function HAL_RCC_GetHCLKFreq()\r\n      3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency \r\n         Note: If you use this function to configure the system clock; then there\r\n               is no need to call the 2 first functions listed above, since SystemCoreClock\r\n               variable is updated automatically.\r\n  */\r\nuint32_t SystemCoreClock = 16000000;\r\nconst uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};\r\nconst uint8_t APBPrescTable[8]  = {0, 0, 0, 0, 1, 2, 3, 4};\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32F4xx_System_Private_FunctionPrototypes\r\n  * @{\r\n  */\r\n\r\n#if defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)\r\n  static void SystemInit_ExtMemCtl(void); \r\n#endif /* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32F4xx_System_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Setup the microcontroller system\r\n  *         Initialize the FPU setting, vector table location and External memory \r\n  *         configuration.\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid SystemInit(void)\r\n{\r\n  /* FPU settings ------------------------------------------------------------*/\r\n  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)\r\n    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */\r\n  #endif\r\n\r\n#if defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)\r\n  SystemInit_ExtMemCtl(); \r\n#endif /* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */\r\n\r\n  /* Configure the Vector Table location -------------------------------------*/\r\n#if defined(USER_VECT_TAB_ADDRESS)\r\n  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */\r\n#endif /* USER_VECT_TAB_ADDRESS */\r\n}\r\n\r\n/**\r\n   * @brief  Update SystemCoreClock variable according to Clock Register Values.\r\n  *         The SystemCoreClock variable contains the core clock (HCLK), it can\r\n  *         be used by the user application to setup the SysTick timer or configure\r\n  *         other parameters.\r\n  *           \r\n  * @note   Each time the core clock (HCLK) changes, this function must be called\r\n  *         to update SystemCoreClock variable value. Otherwise, any configuration\r\n  *         based on this variable will be incorrect.         \r\n  *     \r\n  * @note   - The system frequency computed by this function is not the real \r\n  *           frequency in the chip. It is calculated based on the predefined \r\n  *           constant and the selected clock source:\r\n  *             \r\n  *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)\r\n  *                                              \r\n  *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)\r\n  *                          \r\n  *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**) \r\n  *             or HSI_VALUE(*) multiplied/divided by the PLL factors.\r\n  *         \r\n  *         (*) HSI_VALUE is a constant defined in stm32f4xx_hal_conf.h file (default value\r\n  *             16 MHz) but the real value may vary depending on the variations\r\n  *             in voltage and temperature.   \r\n  *    \r\n  *         (**) HSE_VALUE is a constant defined in stm32f4xx_hal_conf.h file (its value\r\n  *              depends on the application requirements), user has to ensure that HSE_VALUE\r\n  *              is same as the real frequency of the crystal used. Otherwise, this function\r\n  *              may have wrong result.\r\n  *                \r\n  *         - The result of this function could be not correct when using fractional\r\n  *           value for HSE crystal.\r\n  *     \r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid SystemCoreClockUpdate(void)\r\n{\r\n  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;\r\n  \r\n  /* Get SYSCLK source -------------------------------------------------------*/\r\n  tmp = RCC->CFGR & RCC_CFGR_SWS;\r\n\r\n  switch (tmp)\r\n  {\r\n    case 0x00:  /* HSI used as system clock source */\r\n      SystemCoreClock = HSI_VALUE;\r\n      break;\r\n    case 0x04:  /* HSE used as system clock source */\r\n      SystemCoreClock = HSE_VALUE;\r\n      break;\r\n    case 0x08:  /* PLL used as system clock source */\r\n\r\n      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N\r\n         SYSCLK = PLL_VCO / PLL_P\r\n         */    \r\n      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;\r\n      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;\r\n      \r\n      if (pllsource != 0)\r\n      {\r\n        /* HSE used as PLL clock source */\r\n        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);\r\n      }\r\n      else\r\n      {\r\n        /* HSI used as PLL clock source */\r\n        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);\r\n      }\r\n\r\n      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;\r\n      SystemCoreClock = pllvco/pllp;\r\n      break;\r\n    default:\r\n      SystemCoreClock = HSI_VALUE;\r\n      break;\r\n  }\r\n  /* Compute HCLK frequency --------------------------------------------------*/\r\n  /* Get HCLK prescaler */\r\n  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];\r\n  /* HCLK frequency */\r\n  SystemCoreClock >>= tmp;\r\n}\r\n\r\n#if defined (DATA_IN_ExtSRAM) && defined (DATA_IN_ExtSDRAM)\r\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\\\r\n || defined(STM32F469xx) || defined(STM32F479xx)\r\n/**\r\n  * @brief  Setup the external memory controller.\r\n  *         Called in startup_stm32f4xx.s before jump to main.\r\n  *         This function configures the external memories (SRAM/SDRAM)\r\n  *         This SRAM/SDRAM will be used as program data memory (including heap and stack).\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid SystemInit_ExtMemCtl(void)\r\n{\r\n  __IO uint32_t tmp = 0x00;\r\n\r\n  register uint32_t tmpreg = 0, timeout = 0xFFFF;\r\n  register __IO uint32_t index;\r\n\r\n  /* Enable GPIOC, GPIOD, GPIOE, GPIOF, GPIOG, GPIOH and GPIOI interface clock */\r\n  RCC->AHB1ENR |= 0x000001F8;\r\n\r\n  /* Delay after an RCC peripheral clock enabling */\r\n  tmp = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);\r\n  \r\n  /* Connect PDx pins to FMC Alternate function */\r\n  GPIOD->AFR[0]  = 0x00CCC0CC;\r\n  GPIOD->AFR[1]  = 0xCCCCCCCC;\r\n  /* Configure PDx pins in Alternate function mode */  \r\n  GPIOD->MODER   = 0xAAAA0A8A;\r\n  /* Configure PDx pins speed to 100 MHz */  \r\n  GPIOD->OSPEEDR = 0xFFFF0FCF;\r\n  /* Configure PDx pins Output type to push-pull */  \r\n  GPIOD->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PDx pins */ \r\n  GPIOD->PUPDR   = 0x00000000;\r\n\r\n  /* Connect PEx pins to FMC Alternate function */\r\n  GPIOE->AFR[0]  = 0xC00CC0CC;\r\n  GPIOE->AFR[1]  = 0xCCCCCCCC;\r\n  /* Configure PEx pins in Alternate function mode */ \r\n  GPIOE->MODER   = 0xAAAA828A;\r\n  /* Configure PEx pins speed to 100 MHz */ \r\n  GPIOE->OSPEEDR = 0xFFFFC3CF;\r\n  /* Configure PEx pins Output type to push-pull */  \r\n  GPIOE->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PEx pins */ \r\n  GPIOE->PUPDR   = 0x00000000;\r\n  \r\n  /* Connect PFx pins to FMC Alternate function */\r\n  GPIOF->AFR[0]  = 0xCCCCCCCC;\r\n  GPIOF->AFR[1]  = 0xCCCCCCCC;\r\n  /* Configure PFx pins in Alternate function mode */   \r\n  GPIOF->MODER   = 0xAA800AAA;\r\n  /* Configure PFx pins speed to 50 MHz */ \r\n  GPIOF->OSPEEDR = 0xAA800AAA;\r\n  /* Configure PFx pins Output type to push-pull */  \r\n  GPIOF->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PFx pins */ \r\n  GPIOF->PUPDR   = 0x00000000;\r\n\r\n  /* Connect PGx pins to FMC Alternate function */\r\n  GPIOG->AFR[0]  = 0xCCCCCCCC;\r\n  GPIOG->AFR[1]  = 0xCCCCCCCC;\r\n  /* Configure PGx pins in Alternate function mode */ \r\n  GPIOG->MODER   = 0xAAAAAAAA;\r\n  /* Configure PGx pins speed to 50 MHz */ \r\n  GPIOG->OSPEEDR = 0xAAAAAAAA;\r\n  /* Configure PGx pins Output type to push-pull */  \r\n  GPIOG->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PGx pins */ \r\n  GPIOG->PUPDR   = 0x00000000;\r\n  \r\n  /* Connect PHx pins to FMC Alternate function */\r\n  GPIOH->AFR[0]  = 0x00C0CC00;\r\n  GPIOH->AFR[1]  = 0xCCCCCCCC;\r\n  /* Configure PHx pins in Alternate function mode */ \r\n  GPIOH->MODER   = 0xAAAA08A0;\r\n  /* Configure PHx pins speed to 50 MHz */ \r\n  GPIOH->OSPEEDR = 0xAAAA08A0;\r\n  /* Configure PHx pins Output type to push-pull */  \r\n  GPIOH->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PHx pins */ \r\n  GPIOH->PUPDR   = 0x00000000;\r\n  \r\n  /* Connect PIx pins to FMC Alternate function */\r\n  GPIOI->AFR[0]  = 0xCCCCCCCC;\r\n  GPIOI->AFR[1]  = 0x00000CC0;\r\n  /* Configure PIx pins in Alternate function mode */ \r\n  GPIOI->MODER   = 0x0028AAAA;\r\n  /* Configure PIx pins speed to 50 MHz */ \r\n  GPIOI->OSPEEDR = 0x0028AAAA;\r\n  /* Configure PIx pins Output type to push-pull */  \r\n  GPIOI->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PIx pins */ \r\n  GPIOI->PUPDR   = 0x00000000;\r\n  \r\n/*-- FMC Configuration -------------------------------------------------------*/\r\n  /* Enable the FMC interface clock */\r\n  RCC->AHB3ENR |= 0x00000001;\r\n  /* Delay after an RCC peripheral clock enabling */\r\n  tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);\r\n\r\n  FMC_Bank5_6->SDCR[0] = 0x000019E4;\r\n  FMC_Bank5_6->SDTR[0] = 0x01115351;      \r\n  \r\n  /* SDRAM initialization sequence */\r\n  /* Clock enable command */\r\n  FMC_Bank5_6->SDCMR = 0x00000011; \r\n  tmpreg = FMC_Bank5_6->SDSR & 0x00000020; \r\n  while((tmpreg != 0) && (timeout-- > 0))\r\n  {\r\n    tmpreg = FMC_Bank5_6->SDSR & 0x00000020; \r\n  }\r\n\r\n  /* Delay */\r\n  for (index = 0; index<1000; index++);\r\n  \r\n  /* PALL command */\r\n  FMC_Bank5_6->SDCMR = 0x00000012;           \r\n  tmpreg = FMC_Bank5_6->SDSR & 0x00000020;\r\n  timeout = 0xFFFF;\r\n  while((tmpreg != 0) && (timeout-- > 0))\r\n  {\r\n    tmpreg = FMC_Bank5_6->SDSR & 0x00000020; \r\n  }\r\n  \r\n  /* Auto refresh command */\r\n  FMC_Bank5_6->SDCMR = 0x00000073;\r\n  tmpreg = FMC_Bank5_6->SDSR & 0x00000020;\r\n  timeout = 0xFFFF;\r\n  while((tmpreg != 0) && (timeout-- > 0))\r\n  {\r\n    tmpreg = FMC_Bank5_6->SDSR & 0x00000020; \r\n  }\r\n \r\n  /* MRD register program */\r\n  FMC_Bank5_6->SDCMR = 0x00046014;\r\n  tmpreg = FMC_Bank5_6->SDSR & 0x00000020;\r\n  timeout = 0xFFFF;\r\n  while((tmpreg != 0) && (timeout-- > 0))\r\n  {\r\n    tmpreg = FMC_Bank5_6->SDSR & 0x00000020; \r\n  } \r\n  \r\n  /* Set refresh count */\r\n  tmpreg = FMC_Bank5_6->SDRTR;\r\n  FMC_Bank5_6->SDRTR = (tmpreg | (0x0000027C<<1));\r\n  \r\n  /* Disable write protection */\r\n  tmpreg = FMC_Bank5_6->SDCR[0]; \r\n  FMC_Bank5_6->SDCR[0] = (tmpreg & 0xFFFFFDFF);\r\n\r\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\r\n  /* Configure and enable Bank1_SRAM2 */\r\n  FMC_Bank1->BTCR[2]  = 0x00001011;\r\n  FMC_Bank1->BTCR[3]  = 0x00000201;\r\n  FMC_Bank1E->BWTR[2] = 0x0fffffff;\r\n#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */ \r\n#if defined(STM32F469xx) || defined(STM32F479xx)\r\n  /* Configure and enable Bank1_SRAM2 */\r\n  FMC_Bank1->BTCR[2]  = 0x00001091;\r\n  FMC_Bank1->BTCR[3]  = 0x00110212;\r\n  FMC_Bank1E->BWTR[2] = 0x0fffffff;\r\n#endif /* STM32F469xx || STM32F479xx */\r\n\r\n  (void)(tmp); \r\n}\r\n#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */\r\n#elif defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)\r\n/**\r\n  * @brief  Setup the external memory controller.\r\n  *         Called in startup_stm32f4xx.s before jump to main.\r\n  *         This function configures the external memories (SRAM/SDRAM)\r\n  *         This SRAM/SDRAM will be used as program data memory (including heap and stack).\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid SystemInit_ExtMemCtl(void)\r\n{\r\n  __IO uint32_t tmp = 0x00;\r\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\\\r\n || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)\r\n#if defined (DATA_IN_ExtSDRAM)\r\n  register uint32_t tmpreg = 0, timeout = 0xFFFF;\r\n  register __IO uint32_t index;\r\n\r\n#if defined(STM32F446xx)\r\n  /* Enable GPIOA, GPIOC, GPIOD, GPIOE, GPIOF, GPIOG interface\r\n      clock */\r\n  RCC->AHB1ENR |= 0x0000007D;\r\n#else\r\n  /* Enable GPIOC, GPIOD, GPIOE, GPIOF, GPIOG, GPIOH and GPIOI interface \r\n      clock */\r\n  RCC->AHB1ENR |= 0x000001F8;\r\n#endif /* STM32F446xx */  \r\n  /* Delay after an RCC peripheral clock enabling */\r\n  tmp = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);\r\n  \r\n#if defined(STM32F446xx)\r\n  /* Connect PAx pins to FMC Alternate function */\r\n  GPIOA->AFR[0]  |= 0xC0000000;\r\n  GPIOA->AFR[1]  |= 0x00000000;\r\n  /* Configure PDx pins in Alternate function mode */\r\n  GPIOA->MODER   |= 0x00008000;\r\n  /* Configure PDx pins speed to 50 MHz */\r\n  GPIOA->OSPEEDR |= 0x00008000;\r\n  /* Configure PDx pins Output type to push-pull */\r\n  GPIOA->OTYPER  |= 0x00000000;\r\n  /* No pull-up, pull-down for PDx pins */\r\n  GPIOA->PUPDR   |= 0x00000000;\r\n\r\n  /* Connect PCx pins to FMC Alternate function */\r\n  GPIOC->AFR[0]  |= 0x00CC0000;\r\n  GPIOC->AFR[1]  |= 0x00000000;\r\n  /* Configure PDx pins in Alternate function mode */\r\n  GPIOC->MODER   |= 0x00000A00;\r\n  /* Configure PDx pins speed to 50 MHz */\r\n  GPIOC->OSPEEDR |= 0x00000A00;\r\n  /* Configure PDx pins Output type to push-pull */\r\n  GPIOC->OTYPER  |= 0x00000000;\r\n  /* No pull-up, pull-down for PDx pins */\r\n  GPIOC->PUPDR   |= 0x00000000;\r\n#endif /* STM32F446xx */\r\n\r\n  /* Connect PDx pins to FMC Alternate function */\r\n  GPIOD->AFR[0]  = 0x000000CC;\r\n  GPIOD->AFR[1]  = 0xCC000CCC;\r\n  /* Configure PDx pins in Alternate function mode */  \r\n  GPIOD->MODER   = 0xA02A000A;\r\n  /* Configure PDx pins speed to 50 MHz */  \r\n  GPIOD->OSPEEDR = 0xA02A000A;\r\n  /* Configure PDx pins Output type to push-pull */  \r\n  GPIOD->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PDx pins */ \r\n  GPIOD->PUPDR   = 0x00000000;\r\n\r\n  /* Connect PEx pins to FMC Alternate function */\r\n  GPIOE->AFR[0]  = 0xC00000CC;\r\n  GPIOE->AFR[1]  = 0xCCCCCCCC;\r\n  /* Configure PEx pins in Alternate function mode */ \r\n  GPIOE->MODER   = 0xAAAA800A;\r\n  /* Configure PEx pins speed to 50 MHz */ \r\n  GPIOE->OSPEEDR = 0xAAAA800A;\r\n  /* Configure PEx pins Output type to push-pull */  \r\n  GPIOE->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PEx pins */ \r\n  GPIOE->PUPDR   = 0x00000000;\r\n\r\n  /* Connect PFx pins to FMC Alternate function */\r\n  GPIOF->AFR[0]  = 0xCCCCCCCC;\r\n  GPIOF->AFR[1]  = 0xCCCCCCCC;\r\n  /* Configure PFx pins in Alternate function mode */   \r\n  GPIOF->MODER   = 0xAA800AAA;\r\n  /* Configure PFx pins speed to 50 MHz */ \r\n  GPIOF->OSPEEDR = 0xAA800AAA;\r\n  /* Configure PFx pins Output type to push-pull */  \r\n  GPIOF->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PFx pins */ \r\n  GPIOF->PUPDR   = 0x00000000;\r\n\r\n  /* Connect PGx pins to FMC Alternate function */\r\n  GPIOG->AFR[0]  = 0xCCCCCCCC;\r\n  GPIOG->AFR[1]  = 0xCCCCCCCC;\r\n  /* Configure PGx pins in Alternate function mode */ \r\n  GPIOG->MODER   = 0xAAAAAAAA;\r\n  /* Configure PGx pins speed to 50 MHz */ \r\n  GPIOG->OSPEEDR = 0xAAAAAAAA;\r\n  /* Configure PGx pins Output type to push-pull */  \r\n  GPIOG->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PGx pins */ \r\n  GPIOG->PUPDR   = 0x00000000;\r\n\r\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\\\r\n || defined(STM32F469xx) || defined(STM32F479xx)  \r\n  /* Connect PHx pins to FMC Alternate function */\r\n  GPIOH->AFR[0]  = 0x00C0CC00;\r\n  GPIOH->AFR[1]  = 0xCCCCCCCC;\r\n  /* Configure PHx pins in Alternate function mode */ \r\n  GPIOH->MODER   = 0xAAAA08A0;\r\n  /* Configure PHx pins speed to 50 MHz */ \r\n  GPIOH->OSPEEDR = 0xAAAA08A0;\r\n  /* Configure PHx pins Output type to push-pull */  \r\n  GPIOH->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PHx pins */ \r\n  GPIOH->PUPDR   = 0x00000000;\r\n  \r\n  /* Connect PIx pins to FMC Alternate function */\r\n  GPIOI->AFR[0]  = 0xCCCCCCCC;\r\n  GPIOI->AFR[1]  = 0x00000CC0;\r\n  /* Configure PIx pins in Alternate function mode */ \r\n  GPIOI->MODER   = 0x0028AAAA;\r\n  /* Configure PIx pins speed to 50 MHz */ \r\n  GPIOI->OSPEEDR = 0x0028AAAA;\r\n  /* Configure PIx pins Output type to push-pull */  \r\n  GPIOI->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PIx pins */ \r\n  GPIOI->PUPDR   = 0x00000000;\r\n#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */\r\n  \r\n/*-- FMC Configuration -------------------------------------------------------*/\r\n  /* Enable the FMC interface clock */\r\n  RCC->AHB3ENR |= 0x00000001;\r\n  /* Delay after an RCC peripheral clock enabling */\r\n  tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);\r\n\r\n  /* Configure and enable SDRAM bank1 */\r\n#if defined(STM32F446xx)\r\n  FMC_Bank5_6->SDCR[0] = 0x00001954;\r\n#else  \r\n  FMC_Bank5_6->SDCR[0] = 0x000019E4;\r\n#endif /* STM32F446xx */\r\n  FMC_Bank5_6->SDTR[0] = 0x01115351;      \r\n  \r\n  /* SDRAM initialization sequence */\r\n  /* Clock enable command */\r\n  FMC_Bank5_6->SDCMR = 0x00000011; \r\n  tmpreg = FMC_Bank5_6->SDSR & 0x00000020; \r\n  while((tmpreg != 0) && (timeout-- > 0))\r\n  {\r\n    tmpreg = FMC_Bank5_6->SDSR & 0x00000020; \r\n  }\r\n\r\n  /* Delay */\r\n  for (index = 0; index<1000; index++);\r\n  \r\n  /* PALL command */\r\n  FMC_Bank5_6->SDCMR = 0x00000012;           \r\n  tmpreg = FMC_Bank5_6->SDSR & 0x00000020;\r\n  timeout = 0xFFFF;\r\n  while((tmpreg != 0) && (timeout-- > 0))\r\n  {\r\n    tmpreg = FMC_Bank5_6->SDSR & 0x00000020; \r\n  }\r\n  \r\n  /* Auto refresh command */\r\n#if defined(STM32F446xx)\r\n  FMC_Bank5_6->SDCMR = 0x000000F3;\r\n#else  \r\n  FMC_Bank5_6->SDCMR = 0x00000073;\r\n#endif /* STM32F446xx */\r\n  tmpreg = FMC_Bank5_6->SDSR & 0x00000020;\r\n  timeout = 0xFFFF;\r\n  while((tmpreg != 0) && (timeout-- > 0))\r\n  {\r\n    tmpreg = FMC_Bank5_6->SDSR & 0x00000020; \r\n  }\r\n \r\n  /* MRD register program */\r\n#if defined(STM32F446xx)\r\n  FMC_Bank5_6->SDCMR = 0x00044014;\r\n#else  \r\n  FMC_Bank5_6->SDCMR = 0x00046014;\r\n#endif /* STM32F446xx */\r\n  tmpreg = FMC_Bank5_6->SDSR & 0x00000020;\r\n  timeout = 0xFFFF;\r\n  while((tmpreg != 0) && (timeout-- > 0))\r\n  {\r\n    tmpreg = FMC_Bank5_6->SDSR & 0x00000020; \r\n  } \r\n  \r\n  /* Set refresh count */\r\n  tmpreg = FMC_Bank5_6->SDRTR;\r\n#if defined(STM32F446xx)\r\n  FMC_Bank5_6->SDRTR = (tmpreg | (0x0000050C<<1));\r\n#else    \r\n  FMC_Bank5_6->SDRTR = (tmpreg | (0x0000027C<<1));\r\n#endif /* STM32F446xx */\r\n  \r\n  /* Disable write protection */\r\n  tmpreg = FMC_Bank5_6->SDCR[0]; \r\n  FMC_Bank5_6->SDCR[0] = (tmpreg & 0xFFFFFDFF);\r\n#endif /* DATA_IN_ExtSDRAM */\r\n#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */\r\n\r\n#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)\\\r\n || defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\\\r\n || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx)\r\n\r\n#if defined(DATA_IN_ExtSRAM)\r\n/*-- GPIOs Configuration -----------------------------------------------------*/\r\n   /* Enable GPIOD, GPIOE, GPIOF and GPIOG interface clock */\r\n  RCC->AHB1ENR   |= 0x00000078;\r\n  /* Delay after an RCC peripheral clock enabling */\r\n  tmp = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\r\n  \r\n  /* Connect PDx pins to FMC Alternate function */\r\n  GPIOD->AFR[0]  = 0x00CCC0CC;\r\n  GPIOD->AFR[1]  = 0xCCCCCCCC;\r\n  /* Configure PDx pins in Alternate function mode */  \r\n  GPIOD->MODER   = 0xAAAA0A8A;\r\n  /* Configure PDx pins speed to 100 MHz */  \r\n  GPIOD->OSPEEDR = 0xFFFF0FCF;\r\n  /* Configure PDx pins Output type to push-pull */  \r\n  GPIOD->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PDx pins */ \r\n  GPIOD->PUPDR   = 0x00000000;\r\n\r\n  /* Connect PEx pins to FMC Alternate function */\r\n  GPIOE->AFR[0]  = 0xC00CC0CC;\r\n  GPIOE->AFR[1]  = 0xCCCCCCCC;\r\n  /* Configure PEx pins in Alternate function mode */ \r\n  GPIOE->MODER   = 0xAAAA828A;\r\n  /* Configure PEx pins speed to 100 MHz */ \r\n  GPIOE->OSPEEDR = 0xFFFFC3CF;\r\n  /* Configure PEx pins Output type to push-pull */  \r\n  GPIOE->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PEx pins */ \r\n  GPIOE->PUPDR   = 0x00000000;\r\n\r\n  /* Connect PFx pins to FMC Alternate function */\r\n  GPIOF->AFR[0]  = 0x00CCCCCC;\r\n  GPIOF->AFR[1]  = 0xCCCC0000;\r\n  /* Configure PFx pins in Alternate function mode */   \r\n  GPIOF->MODER   = 0xAA000AAA;\r\n  /* Configure PFx pins speed to 100 MHz */ \r\n  GPIOF->OSPEEDR = 0xFF000FFF;\r\n  /* Configure PFx pins Output type to push-pull */  \r\n  GPIOF->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PFx pins */ \r\n  GPIOF->PUPDR   = 0x00000000;\r\n\r\n  /* Connect PGx pins to FMC Alternate function */\r\n  GPIOG->AFR[0]  = 0x00CCCCCC;\r\n  GPIOG->AFR[1]  = 0x000000C0;\r\n  /* Configure PGx pins in Alternate function mode */ \r\n  GPIOG->MODER   = 0x00085AAA;\r\n  /* Configure PGx pins speed to 100 MHz */ \r\n  GPIOG->OSPEEDR = 0x000CAFFF;\r\n  /* Configure PGx pins Output type to push-pull */  \r\n  GPIOG->OTYPER  = 0x00000000;\r\n  /* No pull-up, pull-down for PGx pins */ \r\n  GPIOG->PUPDR   = 0x00000000;\r\n  \r\n/*-- FMC/FSMC Configuration --------------------------------------------------*/\r\n  /* Enable the FMC/FSMC interface clock */\r\n  RCC->AHB3ENR         |= 0x00000001;\r\n\r\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\r\n  /* Delay after an RCC peripheral clock enabling */\r\n  tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);\r\n  /* Configure and enable Bank1_SRAM2 */\r\n  FMC_Bank1->BTCR[2]  = 0x00001011;\r\n  FMC_Bank1->BTCR[3]  = 0x00000201;\r\n  FMC_Bank1E->BWTR[2] = 0x0fffffff;\r\n#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */ \r\n#if defined(STM32F469xx) || defined(STM32F479xx)\r\n  /* Delay after an RCC peripheral clock enabling */\r\n  tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);\r\n  /* Configure and enable Bank1_SRAM2 */\r\n  FMC_Bank1->BTCR[2]  = 0x00001091;\r\n  FMC_Bank1->BTCR[3]  = 0x00110212;\r\n  FMC_Bank1E->BWTR[2] = 0x0fffffff;\r\n#endif /* STM32F469xx || STM32F479xx */\r\n#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx)\\\r\n   || defined(STM32F412Zx) || defined(STM32F412Vx)\r\n  /* Delay after an RCC peripheral clock enabling */\r\n  tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);\r\n  /* Configure and enable Bank1_SRAM2 */\r\n  FSMC_Bank1->BTCR[2]  = 0x00001011;\r\n  FSMC_Bank1->BTCR[3]  = 0x00000201;\r\n  FSMC_Bank1E->BWTR[2] = 0x0FFFFFFF;\r\n#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F412Zx || STM32F412Vx */\r\n\r\n#endif /* DATA_IN_ExtSRAM */\r\n#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx ||\\\r\n          STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx  */ \r\n  (void)(tmp); \r\n}\r\n#endif /* DATA_IN_ExtSRAM && DATA_IN_ExtSDRAM */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n"}],"trace":"{\"model\":\"mcb_open_loop_control_nucleo_f401re\",\"sources\":[\"mcb_open_loop_control_nucleo_f401re.c\",\"mcb_open_loop_control_nucleo_f401re.h\"],\"categoricalProps\":[\"ModelElemCategory\",\"StorageClass\"],\"categoricalValues\":[\"InternalData\",\"Default\",\"GlobalParameters\",\"LocalParameters\"],\"sidPrefixes\":[\"mcb_open_loop_control_nucleo_f401re\"],\"fileRecords\":{\"1\":{\"records\":[{\"tk\":[54,3,54,9],\"els\":[\"0:3916\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[54,10,54,17],\"els\":[\"0:3916\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[54,17,54,18],\"els\":[\"0:3916\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[55,3,55,11],\"els\":[\"0:3294:0\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[55,12,55,17],\"els\":[\"0:3294:0\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[55,17,55,18],\"els\":[\"0:3294:0\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[56,3,56,10],\"els\":[\"0:3926\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[56,11,56,41],\"els\":[\"0:3926\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[56,41,56,42],\"els\":[\"0:3926\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[57,3,57,10],\"els\":[\"0:3917\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[57,11,57,20],\"els\":[\"0:3917\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[57,20,57,21],\"els\":[\"0:3917\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[57,21,57,22],\"els\":[\"0:3917\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[57,22,57,23],\"els\":[\"0:3917\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[57,23,57,24],\"els\":[\"0:3917\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[58,3,58,12],\"els\":[\"0:3918\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[58,13,58,44],\"els\":[\"0:3918\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[58,44,58,45],\"els\":[\"0:3918\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[63,3,63,34],\"els\":[\"0:3916\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[63,35,63,38],\"els\":[\"0:3916\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[63,38,63,39],\"els\":[\"0:3916\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[64,3,64,34],\"els\":[\"0:3906\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[64,35,64,40],\"els\":[\"0:3906\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[64,40,64,41],\"els\":[\"0:3906\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[65,3,65,34],\"els\":[\"0:3774:462\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[65,35,65,40],\"els\":[\"0:3774:462\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[65,40,65,41],\"els\":[\"0:3774:462\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[66,3,66,34],\"els\":[\"0:3778:2103\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[66,35,66,40],\"els\":[\"0:3778:2103\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[66,40,66,41],\"els\":[\"0:3778:2103\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[67,3,67,9],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[67,10,67,11],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[67,11,67,12],\"els\":[\"0:4003\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[68,3,68,11],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[68,12,68,32],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[68,32,68,33],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[69,3,69,11],\"els\":[\"0:3294:1187\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[69,12,69,28],\"els\":[\"0:3294:1187\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[69,28,69,29],\"els\":[\"0:3294:1187\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[70,3,70,11],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[70,12,70,18],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[70,18,70,19],\"els\":[\"0:4003\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[71,3,71,11],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[71,12,71,17],\"els\":[\"0:4003\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[71,17,71,18],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[71,18,71,21],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[71,21,71,22],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[71,22,71,23],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[72,3,72,11],\"els\":[\"0:4003\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[72,12,72,19],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[72,19,72,20],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[72,20,72,21],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[72,21,72,22],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[72,22,72,23],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[73,3,73,11],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[73,12,73,19],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[73,19,73,20],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[74,3,74,8],\"els\":[\"0:3917\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[74,9,74,31],\"els\":[\"0:3917\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[74,31,74,32],\"els\":[\"0:3917\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[75,3,75,8],\"els\":[\"0:3917\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[75,9,75,31],\"els\":[\"0:3917\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[75,31,75,32],\"els\":[\"0:3917\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[76,3,76,11],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[76,12,76,19],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[76,20,76,51],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[76,51,76,52],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[77,3,77,12],\"els\":[\"0:3294:1210\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[77,13,77,25],\"els\":[\"0:3294:1210\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[77,25,77,26],\"els\":[\"0:3294:1210\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[78,3,78,11],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[78,12,78,21],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[78,22,78,53],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[78,53,78,54],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[79,3,79,12],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[79,13,79,24],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[79,24,79,25],\"els\":[\"0:4003\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[84,3,84,11],\"els\":[\"0:3303\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[84,12,84,14],\"els\":[\"0:3303\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[84,14,84,15],\"els\":[\"0:3303\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[87,3,87,11],\"els\":[\"0:3996\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[87,12,87,29],\"els\":[\"0:3996\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[87,29,87,30],\"els\":[\"0:3996\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[90,3,90,11],\"els\":[\"0:3668\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[90,12,90,27],\"els\":[\"0:3668\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[90,27,90,28],\"els\":[\"0:3668\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[93,3,93,11],\"els\":[\"0:3373\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[93,12,93,26],\"els\":[\"0:3373\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[93,26,93,27],\"els\":[\"0:3373\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[96,3,96,11],\"els\":[\"0:3502:1177:492\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[96,12,96,29],\"els\":[\"0:3502:1177:492\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[96,29,96,30],\"els\":[\"0:3502:1177:492\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[99,3,99,11],\"els\":[\"0:3502:1177:493\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[99,12,99,27],\"els\":[\"0:3502:1177:493\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[99,27,99,28],\"els\":[\"0:3502:1177:493\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[102,3,102,11],\"els\":[\"0:3502:1177:567\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[102,12,102,19],\"els\":[\"0:3502:1177:567\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[102,19,102,20],\"els\":[\"0:3502:1177:567\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[105,3,105,11],\"els\":[\"0:3502:1177:566\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[105,12,105,19],\"els\":[\"0:3502:1177:566\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[105,19,105,20],\"els\":[\"0:3502:1177:566\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[108,3,108,11],\"els\":[\"0:3502:1177:565\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[108,12,108,19],\"els\":[\"0:3502:1177:565\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[108,19,108,20],\"els\":[\"0:3502:1177:565\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[111,3,111,11],\"els\":[\"0:3375\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[111,12,111,21],\"els\":[\"0:3375\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[111,21,111,22],\"els\":[\"0:3375\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[114,3,114,11],\"els\":[\"0:3389\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[114,12,114,22],\"els\":[\"0:3389\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[114,22,114,23],\"els\":[\"0:3389\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[117,3,117,11],\"els\":[\"0:3294:1206\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[117,12,117,19],\"els\":[\"0:3294:1206\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[117,19,117,20],\"els\":[\"0:3294:1206\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[120,3,120,11],\"els\":[\"0:3294:1188\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[120,12,120,22],\"els\":[\"0:3294:1188\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[120,22,120,23],\"els\":[\"0:3294:1188\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[123,3,123,11],\"els\":[\"0:3396\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[123,12,123,22],\"els\":[\"0:3396\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[123,22,123,23],\"els\":[\"0:3396\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[126,3,126,11],\"els\":[\"0:3502:1180:76:692:3\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[126,12,126,28],\"els\":[\"0:3502:1180:76:692:3\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[126,28,126,29],\"els\":[\"0:3502:1180:76:692:3\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[129,3,129,11],\"els\":[\"0:3502:1164\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[129,12,129,28],\"els\":[\"0:3502:1164\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[129,28,129,29],\"els\":[\"0:3502:1164\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[132,3,132,11],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[132,12,132,33],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[132,33,132,34],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[135,3,135,11],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[135,12,135,28],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[135,28,135,29],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[138,3,138,11],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[138,12,138,34],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[138,34,138,35],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[141,3,141,11],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[141,12,141,34],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[141,34,141,35],\"els\":[\"0:3302\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[144,3,144,11],\"els\":[\"0:3309\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[144,12,144,21],\"els\":[\"0:3309\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[144,21,144,22],\"els\":[\"0:3309\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[147,3,147,11],\"els\":[\"0:3287\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[147,12,147,42],\"els\":[\"0:3287\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[147,42,147,43],\"els\":[\"0:3287\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[151,3,151,11],\"els\":[\"0:3607\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[151,12,151,30],\"els\":[\"0:3607\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[151,30,151,31],\"els\":[\"0:3607\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[154,3,154,11],\"els\":[\"0:3603\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[154,12,154,31],\"els\":[\"0:3603\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[154,31,154,32],\"els\":[\"0:3603\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[157,3,157,11],\"els\":[\"0:3603\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[157,12,157,31],\"els\":[\"0:3603\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[157,31,157,32],\"els\":[\"0:3603\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[160,3,160,11],\"els\":[\"0:3502:1180:76:549\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[160,12,160,35],\"els\":[\"0:3502:1180:76:549\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[160,35,160,36],\"els\":[\"0:3502:1180:76:549\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[160,36,160,40],\"els\":[\"0:3502:1180:76:549\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[160,40,160,41],\"els\":[\"0:3502:1180:76:549\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[160,41,160,42],\"els\":[\"0:3502:1180:76:549\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[164,3,164,11],\"els\":[\"0:3312\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[164,12,164,35],\"els\":[\"0:3312\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[164,35,164,36],\"els\":[\"0:3312\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[168,3,168,11],\"els\":[\"0:3294:1202\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[168,12,168,24],\"els\":[\"0:3294:1202\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[168,24,168,25],\"els\":[\"0:3294:1202\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[171,3,171,11],\"els\":[\"0:3294:1187\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[171,12,171,38],\"els\":[\"0:3294:1187\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[171,38,171,39],\"els\":[\"0:3294:1187\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[175,3,175,11],\"els\":[\"0:3294:1189\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[175,12,175,25],\"els\":[\"0:3294:1189\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[175,25,175,26],\"els\":[\"0:3294:1189\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[178,3,178,11],\"els\":[\"0:3502:1180:76:652\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[178,12,178,27],\"els\":[\"0:3502:1180:76:652\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[178,27,178,28],\"els\":[\"0:3502:1180:76:652\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[181,3,181,11],\"els\":[\"0:3502:1180:76:605\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[181,12,181,25],\"els\":[\"0:3502:1180:76:605\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[181,25,181,26],\"els\":[\"0:3502:1180:76:605\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[184,3,184,11],\"els\":[\"0:3301\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[184,12,184,21],\"els\":[\"0:3301\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[184,21,184,22],\"els\":[\"0:3301\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[187,3,187,11],\"els\":[\"0:3305\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[187,12,187,30],\"els\":[\"0:3305\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[187,30,187,31],\"els\":[\"0:3305\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[190,3,190,10],\"els\":[\"0:3929\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[190,11,190,22],\"els\":[\"0:3929\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[190,22,190,23],\"els\":[\"0:3929\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[193,3,193,10],\"els\":[\"0:3502:1180:76:657\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[193,11,193,23],\"els\":[\"0:3502:1180:76:657\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[193,23,193,24],\"els\":[\"0:3502:1180:76:657\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[193,24,193,25],\"els\":[\"0:3502:1180:76:657\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[193,25,193,26],\"els\":[\"0:3502:1180:76:657\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[193,26,193,27],\"els\":[\"0:3502:1180:76:657\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[196,3,196,10],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[196,11,196,42],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[196,42,196,43],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[200,3,200,10],\"els\":[\"0:3314\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[200,11,200,24],\"els\":[\"0:3314\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[200,24,200,25],\"els\":[\"0:3314\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[203,3,203,11],\"els\":[\"0:3502:1176:753\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[203,12,203,24],\"els\":[\"0:3502:1176:753\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[203,24,203,25],\"els\":[\"0:3502:1176:753\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[206,3,206,11],\"els\":[\"0:3502:1176:755\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[206,12,206,28],\"els\":[\"0:3502:1176:755\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[206,28,206,29],\"els\":[\"0:3502:1176:755\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[209,3,209,11],\"els\":[\"0:3583\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[209,12,209,29],\"els\":[\"0:3583\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[209,29,209,30],\"els\":[\"0:3583\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[212,3,212,11],\"els\":[\"0:3585\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[212,12,212,30],\"els\":[\"0:3585\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[212,30,212,31],\"els\":[\"0:3585\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[215,3,215,11],\"els\":[\"0:3968\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[215,12,215,30],\"els\":[\"0:3968\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[215,30,215,31],\"els\":[\"0:3968\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[218,3,218,12],\"els\":[\"0:3294:1210\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[218,13,218,35],\"els\":[\"0:3294:1210\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[218,35,218,36],\"els\":[\"0:3294:1210\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[221,3,221,12],\"els\":[\"0:3294:1209\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[221,13,221,29],\"els\":[\"0:3294:1209\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[221,29,221,30],\"els\":[\"0:3294:1209\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[224,3,224,12],\"els\":[\"0:3294:1216\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[224,13,224,33],\"els\":[\"0:3294:1216\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[224,33,224,34],\"els\":[\"0:3294:1216\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[227,3,227,12],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[227,13,227,44],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[227,44,227,45],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[231,3,231,10],\"els\":[\"0:3967\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[231,11,231,36],\"els\":[\"0:3967\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[231,36,231,37],\"els\":[\"0:3967\"],\"ct\":{\"1\":1,\"0\":3}}]},\"0\":{\"records\":[{\"tk\":[58,21,58,25],\"els\":[\"0:3778:2103\"]},{\"tk\":[62,25,62,27],\"els\":[\"0:3778:2103\"]},{\"tk\":[63,41,63,42],\"els\":[\"0:3778:2103\"]},{\"tk\":[65,41,65,50],\"els\":[\"0:3778:2103\"]},{\"tk\":[66,41,66,50],\"els\":[\"0:3778:2103\"]},{\"tk\":[67,41,67,50],\"els\":[\"0:3778:2103\"]},{\"tk\":[81,24,81,25],\"els\":[\"0:3774:462\"]},{\"tk\":[85,40,85,42],\"els\":[\"0:3774:462\"]},{\"tk\":[86,32,86,36],\"els\":[\"0:3774:462\"]},{\"tk\":[87,35,87,39],\"els\":[\"0:3774:462\"]},{\"tk\":[88,28,88,29],\"els\":[\"0:3774:462\"]},{\"tk\":[89,35,89,50],\"els\":[\"0:3774:462\"]},{\"tk\":[90,34,90,58],\"els\":[\"0:3774:462\"]},{\"tk\":[91,37,91,39],\"els\":[\"0:3774:462\"]},{\"tk\":[92,41,92,43],\"els\":[\"0:3774:462\"]},{\"tk\":[93,51,93,69],\"els\":[\"0:3774:462\"]},{\"tk\":[93,71,93,72],\"els\":[\"0:3774:462\"]},{\"tk\":[94,5,94,13],\"els\":[\"0:3774:462\"]},{\"tk\":[94,15,94,48],\"els\":[\"0:3774:462\"]},{\"tk\":[96,56,96,57],\"els\":[\"0:3774:462\"]},{\"tk\":[420,3,420,24],\"els\":[\"0:3916\"]},{\"tk\":[420,25,420,56],\"els\":[\"0:3916\"]},{\"tk\":[420,57,420,60],\"els\":[\"0:3916\"]},{\"tk\":[420,76,420,77],\"els\":[\"0:3916\"]},{\"tk\":[421,26,421,57],\"els\":[\"0:3916#out:1\"]},{\"tk\":[421,58,421,65],\"els\":[\"0:3916#out:1\"]},{\"tk\":[421,66,421,70],\"els\":[\"0:3916#out:1\",\"0:3916\"]},{\"tk\":[421,70,421,71],\"els\":[\"0:3916\"]},{\"tk\":[421,71,421,72],\"els\":[\"0:3916\"]},{\"tk\":[422,26,422,57],\"els\":[\"0:3916#out:1\"]},{\"tk\":[422,58,422,65],\"els\":[\"0:3916#out:1\"]},{\"tk\":[422,66,422,68],\"els\":[\"0:3916#out:1\",\"0:3916\"]},{\"tk\":[423,26,423,57],\"els\":[\"0:3916#out:1\"]},{\"tk\":[423,58,423,65],\"els\":[\"0:3916#out:1\"]},{\"tk\":[423,66,423,74],\"els\":[\"0:3916#out:1\",\"0:3916\"]},{\"tk\":[424,26,424,57],\"els\":[\"0:3916#out:1\"]},{\"tk\":[424,58,424,65],\"els\":[\"0:3916#out:1\"]},{\"tk\":[424,66,424,72],\"els\":[\"0:3916#out:1\",\"0:3916\"]},{\"tk\":[425,26,425,57],\"els\":[\"0:3916#out:1\"]},{\"tk\":[425,58,425,65],\"els\":[\"0:3916#out:1\"]},{\"tk\":[425,66,425,72],\"els\":[\"0:3916#out:1\",\"0:3916\"]},{\"tk\":[425,74,425,76],\"els\":[\"0:3916\"]},{\"tk\":[426,3,426,34],\"els\":[\"0:3916#out:1\"]},{\"tk\":[426,35,426,42],\"els\":[\"0:3916#out:1\"]},{\"tk\":[426,43,426,48],\"els\":[\"0:3916#out:1\",\"0:3916\"]},{\"tk\":[426,49,426,50],\"els\":[\"0:3916\"]},{\"tk\":[426,51,426,53],\"els\":[\"0:3916\"]},{\"tk\":[427,3,427,34],\"els\":[\"0:3916#out:1\"]},{\"tk\":[427,35,427,42],\"els\":[\"0:3916#out:1\"]},{\"tk\":[427,43,427,52],\"els\":[\"0:3916#out:1\",\"0:3916\"]},{\"tk\":[427,53,427,54],\"els\":[\"0:3916\"]},{\"tk\":[427,55,427,58],\"els\":[\"0:3916\"]},{\"tk\":[430,3,430,4],\"els\":[\"0:3917\"]},{\"tk\":[432,5,432,7],\"els\":[\"0:3917\"]},{\"tk\":[432,8,432,9],\"els\":[\"0:3917\"]},{\"tk\":[432,9,432,10],\"els\":[\"0:3917\"]},{\"tk\":[432,10,432,11],\"els\":[\"0:3917\"]},{\"tk\":[432,12,432,14],\"els\":[\"0:3917\"]},{\"tk\":[432,15,432,46],\"els\":[\"0:3917\"]},{\"tk\":[432,46,432,47],\"els\":[\"0:3917\"]},{\"tk\":[432,47,432,54],\"els\":[\"0:3917\"]},{\"tk\":[432,54,432,55],\"els\":[\"0:3917\"]},{\"tk\":[432,55,432,61],\"els\":[\"0:3917\"]},{\"tk\":[432,61,432,62],\"els\":[\"0:3917\"]},{\"tk\":[432,63,432,65],\"els\":[\"0:3917\"]},{\"tk\":[433,9,433,10],\"els\":[\"0:3917\"]},{\"tk\":[433,10,433,41],\"els\":[\"0:3917\"]},{\"tk\":[433,41,433,42],\"els\":[\"0:3917\"]},{\"tk\":[433,42,433,49],\"els\":[\"0:3917\"]},{\"tk\":[433,49,433,50],\"els\":[\"0:3917\"]},{\"tk\":[433,50,433,52],\"els\":[\"0:3917\"]},{\"tk\":[433,53,433,55],\"els\":[\"0:3917\"]},{\"tk\":[433,56,433,70],\"els\":[\"0:3917\"]},{\"tk\":[433,70,433,71],\"els\":[\"0:3917\"]},{\"tk\":[433,72,433,73],\"els\":[\"0:3917\"]},{\"tk\":[433,74,433,75],\"els\":[\"0:3917\"]},{\"tk\":[434,7,434,9],\"els\":[\"0:3917\"]},{\"tk\":[434,10,434,11],\"els\":[\"0:3917\"]},{\"tk\":[434,11,434,12],\"els\":[\"0:3917\"]},{\"tk\":[434,12,434,15],\"els\":[\"0:3917\"]},{\"tk\":[434,16,434,18],\"els\":[\"0:3917\"]},{\"tk\":[434,19,434,50],\"els\":[\"0:3917\"]},{\"tk\":[434,50,434,51],\"els\":[\"0:3917\"]},{\"tk\":[434,51,434,58],\"els\":[\"0:3917\"]},{\"tk\":[434,58,434,59],\"els\":[\"0:3917\"]},{\"tk\":[434,59,434,61],\"els\":[\"0:3917\"]},{\"tk\":[434,61,434,62],\"els\":[\"0:3917\"]},{\"tk\":[434,63,434,65],\"els\":[\"0:3917\"]},{\"tk\":[434,66,434,67],\"els\":[\"0:3917\"]},{\"tk\":[434,67,434,69],\"els\":[\"0:3917\"]},{\"tk\":[434,70,434,72],\"els\":[\"0:3917\"]},{\"tk\":[435,12,435,43],\"els\":[\"0:3917\"]},{\"tk\":[435,43,435,44],\"els\":[\"0:3917\"]},{\"tk\":[435,44,435,51],\"els\":[\"0:3917\"]},{\"tk\":[435,51,435,52],\"els\":[\"0:3917\"]},{\"tk\":[435,52,435,60],\"els\":[\"0:3917\"]},{\"tk\":[435,60,435,61],\"els\":[\"0:3917\"]},{\"tk\":[435,62,435,63],\"els\":[\"0:3917\"]},{\"tk\":[435,64,435,65],\"els\":[\"0:3917\"]},{\"tk\":[436,9,436,10],\"els\":[\"0:3917\"]},{\"tk\":[436,10,436,14],\"els\":[\"0:3917\"]},{\"tk\":[436,14,436,15],\"els\":[\"0:3917\"]},{\"tk\":[436,16,436,22],\"els\":[\"0:3917\"]},{\"tk\":[436,22,436,23],\"els\":[\"0:3917\"]},{\"tk\":[436,23,436,24],\"els\":[\"0:3917\"]},{\"tk\":[436,24,436,55],\"els\":[\"0:3917\"]},{\"tk\":[436,55,436,56],\"els\":[\"0:3917\"]},{\"tk\":[436,56,436,65],\"els\":[\"0:3917\"]},{\"tk\":[436,65,436,66],\"els\":[\"0:3917\"]},{\"tk\":[436,66,436,67],\"els\":[\"0:3917\"]},{\"tk\":[436,67,436,68],\"els\":[\"0:3917\"]},{\"tk\":[436,68,436,69],\"els\":[\"0:3917\"]},{\"tk\":[437,23,437,54],\"els\":[\"0:3917\"]},{\"tk\":[437,54,437,55],\"els\":[\"0:3917\"]},{\"tk\":[437,55,437,62],\"els\":[\"0:3917\"]},{\"tk\":[437,62,437,63],\"els\":[\"0:3917\"]},{\"tk\":[437,63,437,67],\"els\":[\"0:3917\"]},{\"tk\":[437,67,437,68],\"els\":[\"0:3917\"]},{\"tk\":[438,23,438,24],\"els\":[\"0:3917\"]},{\"tk\":[438,25,438,26],\"els\":[\"0:3917\"]},{\"tk\":[438,27,438,33],\"els\":[\"0:3917\"]},{\"tk\":[438,33,438,34],\"els\":[\"0:3917\"]},{\"tk\":[438,34,438,41],\"els\":[\"0:3917\"]},{\"tk\":[438,41,438,42],\"els\":[\"0:3917\"]},{\"tk\":[438,42,438,43],\"els\":[\"0:3917\"]},{\"tk\":[438,43,438,44],\"els\":[\"0:3917\"]},{\"tk\":[439,7,439,8],\"els\":[\"0:3917\"]},{\"tk\":[440,5,440,6],\"els\":[\"0:3917\"]},{\"tk\":[441,3,441,4],\"els\":[\"0:3917\"]},{\"tk\":[448,3,448,34],\"els\":[\"0:3906\"]},{\"tk\":[448,34,448,35],\"els\":[\"0:3906\"]},{\"tk\":[448,35,448,36],\"els\":[\"0:3906\"]},{\"tk\":[448,38,448,39],\"els\":[\"0:3906\",\"0:3998\"]},{\"tk\":[448,40,448,41],\"els\":[\"0:3906\",\"0:3998\"]},{\"tk\":[449,6,449,37],\"els\":[\"0:3968\"]},{\"tk\":[449,38,449,56],\"els\":[\"0:3968\"]},{\"tk\":[449,57,449,59],\"els\":[\"0:4007\"]},{\"tk\":[449,60,449,61],\"els\":[\"0:4007\"]},{\"tk\":[459,25,459,56],\"els\":[\"0:3913\"]},{\"tk\":[459,57,459,66],\"els\":[\"0:3913\"]},{\"tk\":[478,25,478,56],\"els\":[\"0:3915\"]},{\"tk\":[478,57,478,66],\"els\":[\"0:3915\"]},{\"tk\":[497,25,497,56],\"els\":[\"0:3912\"]},{\"tk\":[497,57,497,66],\"els\":[\"0:3912\"]},{\"tk\":[516,25,516,56],\"els\":[\"0:3914\"]},{\"tk\":[516,57,516,66],\"els\":[\"0:3914\"]},{\"tk\":[528,3,528,5],\"els\":[\"0:4003:53-115\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[528,7,528,8],\"els\":[\"0:4003:56-66\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[528,8,528,39],\"els\":[\"0:4003:56-66\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[528,40,528,51],\"els\":[\"0:4003:56-66\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[529,7,529,8],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[529,9,529,40],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[529,40,529,41],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[529,41,529,42],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[529,43,529,44],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[529,45,529,52],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[530,7,530,8],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[530,9,530,40],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[530,40,530,41],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[530,41,530,46],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[530,46,530,47],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[530,47,530,48],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[530,48,530,49],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[530,49,530,50],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[531,11,531,12],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[531,13,531,17],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[531,18,531,22],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[534,15,534,16],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[534,17,534,21],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[534,22,534,26],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[535,7,535,9],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[535,11,535,12],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[535,28,535,30],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[535,31,535,32],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[535,46,535,47],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[535,48,535,49],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[536,13,536,14],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[536,15,536,46],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[536,46,536,47],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[536,47,536,48],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[536,49,536,50],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[536,51,536,58],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[537,13,537,14],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[537,15,537,20],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[538,9,538,11],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[538,15,538,17],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[538,18,538,49],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[538,49,538,50],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[538,50,538,53],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[538,53,538,54],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[546,7,546,8],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[546,9,546,22],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[546,22,546,23],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[546,23,546,24],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[546,24,546,25],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[547,5,547,7],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[547,11,547,12],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[547,13,547,27],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[548,7,548,9],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[548,13,548,15],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[548,16,548,19],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[549,11,549,12],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[549,13,549,14],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[551,11,551,12],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[551,13,551,15],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[554,9,554,10],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[554,11,554,23],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[557,5,557,11],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[557,13,557,44],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[557,45,557,51],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[558,11,558,13],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[559,7,559,38],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[559,39,559,44],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[559,44,559,45],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[559,45,559,46],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[559,48,559,49],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[560,7,560,10],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[560,18,560,19],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[560,27,560,30],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[560,35,560,37],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[561,11,561,12],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[561,17,561,19],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[561,20,561,23],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[561,24,561,25],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[561,29,561,30],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[561,31,561,42],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[561,43,561,44],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[561,45,561,46],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[561,60,561,61],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[561,62,561,64],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[562,9,562,40],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[562,41,562,46],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[562,46,562,47],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[562,51,562,52],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[562,53,562,54],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[562,56,562,57],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[565,7,565,38],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[565,39,565,44],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[565,44,565,45],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[565,45,565,48],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[565,50,565,51],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[565,52,565,56],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[568,11,568,13],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[569,7,569,38],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[569,39,569,46],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[569,46,569,47],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[569,47,569,48],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[569,50,569,51],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[569,52,569,62],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[570,7,570,38],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[570,39,570,46],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[570,46,570,47],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[570,47,570,48],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[570,50,570,51],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[571,7,571,9],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[571,11,571,42],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[571,43,571,50],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[571,50,571,51],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[571,51,571,52],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[571,54,571,56],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[571,57,571,59],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[572,9,572,40],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[572,41,572,48],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[572,48,572,49],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[572,49,572,50],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[572,52,572,53],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[572,54,572,64],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[576,11,576,13],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[577,11,577,12],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[577,13,577,14],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[577,25,577,27],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[577,28,577,31],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[578,9,578,10],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[578,11,578,12],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[578,23,578,24],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[578,25,578,31],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[579,7,579,38],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[579,39,579,46],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[579,47,579,48],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[579,49,579,50],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[579,63,579,65],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[579,66,579,69],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[580,7,580,38],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[580,39,580,46],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[580,47,580,48],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[580,51,580,52],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[581,9,581,40],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[581,41,581,48],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[582,7,582,38],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[582,39,582,46],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[582,47,582,49],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[582,50,582,51],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[583,7,583,38],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[583,39,583,46],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[583,47,583,50],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[583,51,583,54],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[584,7,584,38],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[584,39,584,46],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[584,47,584,49],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[584,50,584,51],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[585,7,585,38],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[585,39,585,46],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[585,47,585,49],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[585,50,585,51],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[586,7,586,9],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[586,11,586,42],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[586,43,586,50],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[586,51,586,52],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[586,53,586,55],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[587,9,587,40],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[587,41,587,48],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[587,49,587,50],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[587,51,587,62],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[588,14,588,16],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[588,18,588,49],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[588,50,588,57],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[588,58,588,59],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[588,60,588,71],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[589,9,589,40],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[589,41,589,48],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[589,49,589,50],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[589,51,589,62],\"els\":[\"0:4003:71-85\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[594,7,594,8],\"els\":[\"0:4003:95-110\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[594,9,594,40],\"els\":[\"0:4003:95-110\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[594,40,594,41],\"els\":[\"0:4003:95-110\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[594,41,594,42],\"els\":[\"0:4003:95-110\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[595,5,595,36],\"els\":[\"0:4003:91-110\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[595,37,595,38],\"els\":[\"0:4003:91-110\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[595,39,595,40],\"els\":[\"0:4003:91-110\",\"0:4003:95-110\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[595,41,595,46],\"els\":[\"0:4003:95-110\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[595,49,595,50],\"els\":[\"0:4003:95-110\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[595,51,595,56],\"els\":[\"0:4003:95-110\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[596,5,596,36],\"els\":[\"0:4003:123-126\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[596,37,596,48],\"els\":[\"0:4003:123-126\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[596,49,596,50],\"els\":[\"0:4003:123-126\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[596,51,596,55],\"els\":[\"0:4003:123-126\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[608,3,608,34],\"els\":[\"0:3906\"]},{\"tk\":[608,34,608,35],\"els\":[\"0:3906\"]},{\"tk\":[608,35,608,36],\"els\":[\"0:3906\"]},{\"tk\":[608,38,608,39],\"els\":[\"0:3906\"]},{\"tk\":[608,40,608,41],\"els\":[\"0:3997\"]},{\"tk\":[608,50,608,51],\"els\":[\"0:3996\"]},{\"tk\":[609,5,609,36],\"els\":[\"0:3968\"]},{\"tk\":[609,37,609,55],\"els\":[\"0:3968\"]},{\"tk\":[609,56,609,57],\"els\":[\"0:3996\"]},{\"tk\":[610,5,610,36],\"els\":[\"0:3996\"]},{\"tk\":[610,37,610,54],\"els\":[\"0:3996\"]},{\"tk\":[611,3,611,34],\"els\":[\"0:3906\"]},{\"tk\":[611,34,611,35],\"els\":[\"0:3906\"]},{\"tk\":[611,35,611,36],\"els\":[\"0:3906\"]},{\"tk\":[611,38,611,39],\"els\":[\"0:3906\"]},{\"tk\":[611,40,611,41],\"els\":[\"0:4001\"]},{\"tk\":[612,5,612,36],\"els\":[\"0:4003:120-121\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[612,37,612,38],\"els\":[\"0:4003:120-121\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[613,3,613,34],\"els\":[\"0:3906\"]},{\"tk\":[613,34,613,35],\"els\":[\"0:3906\"]},{\"tk\":[613,35,613,36],\"els\":[\"0:3906\"]},{\"tk\":[613,38,613,39],\"els\":[\"0:3906\"]},{\"tk\":[613,40,613,41],\"els\":[\"0:4004\"]},{\"tk\":[613,50,613,51],\"els\":[\"0:4001\"]},{\"tk\":[614,5,614,36],\"els\":[\"0:4003:120-121\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[614,37,614,38],\"els\":[\"0:4003:120-121\",\"0:4003\",\"0:4003::25\"]},{\"tk\":[614,39,614,40],\"els\":[\"0:4004\"]},{\"tk\":[615,5,615,36],\"els\":[\"0:3967\"]},{\"tk\":[615,37,615,62],\"els\":[\"0:3967\"]},{\"tk\":[618,3,618,25],\"els\":[\"0:3906\"]},{\"tk\":[618,26,618,57],\"els\":[\"0:3906\"]},{\"tk\":[618,58,618,63],\"els\":[\"0:3906\"]},{\"tk\":[619,6,619,37],\"els\":[\"0:3906\"]},{\"tk\":[619,37,619,38],\"els\":[\"0:3906\"]},{\"tk\":[619,38,619,39],\"els\":[\"0:3906\"]},{\"tk\":[619,42,619,46],\"els\":[\"0:3906\"]},{\"tk\":[619,48,619,49],\"els\":[\"0:3906\"]},{\"tk\":[619,51,619,52],\"els\":[\"0:3906\"]},{\"tk\":[619,54,619,55],\"els\":[\"0:3906\"]},{\"tk\":[619,57,619,61],\"els\":[\"0:3906\"]},{\"tk\":[624,3,624,28],\"els\":[\"0:3918#out:1\"]},{\"tk\":[624,29,624,30],\"els\":[\"0:3918\"]},{\"tk\":[624,33,624,47],\"els\":[\"0:3912#out:1\"]},{\"tk\":[624,48,624,49],\"els\":[\"0:3921:4\"]},{\"tk\":[624,50,624,52],\"els\":[\"0:3921:4\"]},{\"tk\":[624,54,624,56],\"els\":[\"0:3918\"]},{\"tk\":[624,57,624,59],\"els\":[\"0:3918\"]},{\"tk\":[627,67,627,68],\"els\":[\"0:3918\"]},{\"tk\":[628,5,628,30],\"els\":[\"0:3918#out:1\"]},{\"tk\":[636,3,636,5],\"els\":[\"0:3930\"]},{\"tk\":[636,8,636,23],\"els\":[\"0:3914#out:1\"]},{\"tk\":[636,24,636,25],\"els\":[\"0:3922:4\"]},{\"tk\":[636,26,636,28],\"els\":[\"0:3922:4\"]},{\"tk\":[636,30,636,32],\"els\":[\"0:3919\"]},{\"tk\":[636,33,636,35],\"els\":[\"0:3919\"]},{\"tk\":[637,5,637,17],\"els\":[\"0:3930#out:1\"]},{\"tk\":[637,18,637,19],\"els\":[\"0:3930\"]},{\"tk\":[637,20,637,21],\"els\":[\"0:3930\"]},{\"tk\":[637,30,637,45],\"els\":[\"0:3913#out:1\"]},{\"tk\":[637,46,637,48],\"els\":[\"0:3911:1\"]},{\"tk\":[637,49,637,50],\"els\":[\"0:3911:1\"]},{\"tk\":[637,51,637,52],\"els\":[\"0:3911:1\"]},{\"tk\":[637,53,637,68],\"els\":[\"0:3915#out:1\"]},{\"tk\":[639,5,639,17],\"els\":[\"0:3930#out:1\"]},{\"tk\":[639,18,639,19],\"els\":[\"0:3930\"]},{\"tk\":[639,20,639,21],\"els\":[\"0:3929\",\"0:3930\"]},{\"tk\":[639,30,639,31],\"els\":[\"0:3911:1\"]},{\"tk\":[639,41,639,56],\"els\":[\"0:3913#out:1\"]},{\"tk\":[639,57,639,59],\"els\":[\"0:3911:1\"]},{\"tk\":[639,60,639,61],\"els\":[\"0:3911:1\"]},{\"tk\":[639,62,639,63],\"els\":[\"0:3911:1\"]},{\"tk\":[639,64,639,79],\"els\":[\"0:3915#out:1\"]},{\"tk\":[639,81,639,82],\"els\":[\"0:3929\",\"0:3930\"]},{\"tk\":[640,7,640,38],\"els\":[\"0:3929\"]},{\"tk\":[640,39,640,50],\"els\":[\"0:3929\"]},{\"tk\":[646,67,646,68],\"els\":[\"0:3279\"]},{\"tk\":[646,69,646,81],\"els\":[\"0:3930#out:1\"]},{\"tk\":[786,69,786,70],\"els\":[\"0:3918\"]},{\"tk\":[787,7,787,38],\"els\":[\"0:3918\"]},{\"tk\":[787,39,787,70],\"els\":[\"0:3918\"]},{\"tk\":[790,69,790,70],\"els\":[\"0:3279\"]},{\"tk\":[791,7,791,38],\"els\":[\"0:3279\"]},{\"tk\":[791,39,791,70],\"els\":[\"0:3279\"]},{\"tk\":[800,5,800,36],\"els\":[\"0:3302\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[800,36,800,37],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[800,37,800,57],\"els\":[\"0:3302\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[800,58,800,59],\"els\":[\"0:3302\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[801,7,801,38],\"els\":[\"0:3302\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[801,38,801,39],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[801,39,801,55],\"els\":[\"0:3302\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[801,55,801,56],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[805,5,805,36],\"els\":[\"0:3294:1210\",\"0:3294:1180\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[805,36,805,37],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[805,37,805,49],\"els\":[\"0:3294:1210\",\"0:3294:1180\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[805,50,805,51],\"els\":[\"0:3294:1210\",\"0:3294:1180\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[806,7,806,38],\"els\":[\"0:3294:1210\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[806,38,806,39],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[806,39,806,61],\"els\":[\"0:3294:1210\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[806,61,806,62],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[812,5,812,36],\"els\":[\"0:3294:1211\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[812,36,812,37],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[812,37,812,42],\"els\":[\"0:3294:1211\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[812,43,812,44],\"els\":[\"0:3294:1211\",\"0:3294:1206\",\"0:3294:1204\",\"0:3294:1180\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[813,7,813,38],\"els\":[\"0:3294:1206\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[813,38,813,39],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[813,39,813,46],\"els\":[\"0:3294:1206\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[813,46,813,47],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[821,5,821,36],\"els\":[\"0:3294:1188\",\"0:3294:1180\",\"0:3294:1184#out:1\",\"0:3294:1187\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[821,36,821,37],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[821,37,821,53],\"els\":[\"0:3294:1188\",\"0:3294:1180\",\"0:3294:1184#out:1\",\"0:3294:1187\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[821,54,821,55],\"els\":[\"0:3294:1188\",\"0:3294:1180\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[822,7,822,38],\"els\":[\"0:3294:1188\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[822,38,822,39],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[822,39,822,49],\"els\":[\"0:3294:1188\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[822,49,822,50],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[827,5,827,36],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[827,36,827,37],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[827,37,827,42],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[827,42,827,43],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[827,43,827,65],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[827,66,827,67],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[827,68,827,73],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[827,73,827,74],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[828,5,828,36],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[828,36,828,37],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[828,37,828,42],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[828,42,828,43],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[828,43,828,58],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[828,59,828,60],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[828,61,828,66],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[828,66,828,67],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[829,5,829,36],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[829,36,829,37],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[829,37,829,42],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[829,42,829,43],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[829,43,829,56],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[829,57,829,58],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[829,59,829,60],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[829,60,829,61],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[830,5,830,36],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[830,36,830,37],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[830,37,830,38],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[830,38,830,69],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[830,69,830,70],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[830,70,830,75],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[830,75,830,76],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[830,76,830,77],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[831,5,831,36],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[831,36,831,37],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[831,37,831,42],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[831,42,831,43],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[831,43,831,58],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[831,59,831,60],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[831,61,831,65],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[831,65,831,66],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[834,5,834,36],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[834,36,834,37],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[834,37,834,42],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[834,42,834,43],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[834,43,834,56],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[834,57,834,58],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[834,59,834,60],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[834,60,834,61],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[835,5,835,36],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[835,36,835,37],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[835,37,835,42],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[835,42,835,43],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[835,43,835,65],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[835,66,835,67],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[835,68,835,73],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[835,73,835,74],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[836,5,836,36],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[836,36,836,37],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[836,37,836,38],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[836,38,836,69],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[836,69,836,70],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[836,70,836,75],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[836,75,836,76],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[836,76,836,77],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[841,5,841,11],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[841,13,841,44],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[841,45,841,50],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[841,50,841,51],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[841,51,841,52],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[841,56,841,59],\"els\":[\"0:4003\"]},{\"tk\":[841,59,841,60],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[841,60,841,61],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[841,64,841,68],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[841,69,841,70],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[841,71,841,77],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[843,5,843,36],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[843,37,843,48],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[843,49,843,50],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[843,51,843,56],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[844,5,844,36],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[844,37,844,43],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[844,44,844,45],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[844,46,844,48],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[845,5,845,36],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[845,37,845,44],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[845,44,845,45],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[845,45,845,46],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[845,48,845,49],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[845,50,845,60],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[846,5,846,36],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[846,37,846,44],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[846,44,846,45],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[846,45,846,46],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[846,48,846,49],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[846,50,846,60],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[847,5,847,36],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[847,37,847,44],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[847,45,847,46],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[847,47,847,58],\"els\":[\"0:4003\",\"0:4003::25\"]},{\"tk\":[850,5,850,36],\"els\":[\"0:3916\"]},{\"tk\":[850,37,850,40],\"els\":[\"0:3916\"]},{\"tk\":[850,41,850,63],\"els\":[\"0:3916\"]},{\"tk\":[850,64,850,65],\"els\":[\"0:3916\"]},{\"tk\":[850,66,850,71],\"els\":[\"0:3916\"]},{\"tk\":[851,5,851,36],\"els\":[\"0:3916\"]},{\"tk\":[851,37,851,40],\"els\":[\"0:3916\"]},{\"tk\":[851,41,851,54],\"els\":[\"0:3916\"]},{\"tk\":[851,55,851,56],\"els\":[\"0:3916\"]},{\"tk\":[851,57,851,58],\"els\":[\"0:3916\"]},{\"tk\":[852,5,852,36],\"els\":[\"0:3916\"]},{\"tk\":[852,37,852,40],\"els\":[\"0:3916\"]},{\"tk\":[852,41,852,54],\"els\":[\"0:3916\"]},{\"tk\":[852,55,852,56],\"els\":[\"0:3916\"]},{\"tk\":[852,57,852,74],\"els\":[\"0:3916\"]},{\"tk\":[852,75,852,76],\"els\":[\"0:3916\"]},{\"tk\":[853,5,853,26],\"els\":[\"0:3916\"]},{\"tk\":[853,27,853,58],\"els\":[\"0:3916\"]},{\"tk\":[853,59,853,62],\"els\":[\"0:3916\"]},{\"tk\":[853,78,853,79],\"els\":[\"0:3916\"]},{\"tk\":[854,27,854,28],\"els\":[\"0:3916\"]},{\"tk\":[854,30,854,31],\"els\":[\"0:3916\"]},{\"tk\":[854,33,854,34],\"els\":[\"0:3916\"]},{\"tk\":[854,36,854,37],\"els\":[\"0:3916\"]},{\"tk\":[854,39,854,40],\"els\":[\"0:3916\"]},{\"tk\":[854,42,854,43],\"els\":[\"0:3916\"]},{\"tk\":[854,45,854,46],\"els\":[\"0:3916\"]},{\"tk\":[854,48,854,49],\"els\":[\"0:3916\"]},{\"tk\":[854,51,854,52],\"els\":[\"0:3916\"]},{\"tk\":[855,5,855,36],\"els\":[\"0:3916\"]},{\"tk\":[855,37,855,40],\"els\":[\"0:3916\"]},{\"tk\":[855,41,855,56],\"els\":[\"0:3916\"]},{\"tk\":[855,57,855,58],\"els\":[\"0:3916\"]},{\"tk\":[855,59,855,63],\"els\":[\"0:3916\"]},{\"tk\":[858,5,858,36],\"els\":[\"0:3906\"]},{\"tk\":[858,37,858,42],\"els\":[\"0:3906\"]},{\"tk\":[858,43,858,65],\"els\":[\"0:3906\"]},{\"tk\":[858,66,858,67],\"els\":[\"0:3906\"]},{\"tk\":[858,68,858,73],\"els\":[\"0:3906\"]},{\"tk\":[859,5,859,36],\"els\":[\"0:3906\"]},{\"tk\":[859,37,859,42],\"els\":[\"0:3906\"]},{\"tk\":[859,43,859,56],\"els\":[\"0:3906\"]},{\"tk\":[859,57,859,58],\"els\":[\"0:3906\"]},{\"tk\":[859,59,859,60],\"els\":[\"0:3906\"]},{\"tk\":[860,5,860,36],\"els\":[\"0:3906\"]},{\"tk\":[860,37,860,42],\"els\":[\"0:3906\"]},{\"tk\":[860,43,860,56],\"els\":[\"0:3906\"]},{\"tk\":[860,57,860,58],\"els\":[\"0:3906\"]},{\"tk\":[860,59,860,76],\"els\":[\"0:3906\"]},{\"tk\":[860,77,860,78],\"els\":[\"0:3906\"]},{\"tk\":[861,5,861,26],\"els\":[\"0:3906\"]},{\"tk\":[861,27,861,58],\"els\":[\"0:3906\"]},{\"tk\":[861,59,861,64],\"els\":[\"0:3906\"]},{\"tk\":[861,80,861,81],\"els\":[\"0:3906\"]},{\"tk\":[862,27,862,28],\"els\":[\"0:3906\"]},{\"tk\":[862,30,862,31],\"els\":[\"0:3906\"]},{\"tk\":[862,33,862,34],\"els\":[\"0:3906\"]},{\"tk\":[862,36,862,37],\"els\":[\"0:3906\"]},{\"tk\":[862,39,862,40],\"els\":[\"0:3906\"]},{\"tk\":[862,42,862,43],\"els\":[\"0:3906\"]},{\"tk\":[862,45,862,46],\"els\":[\"0:3906\"]},{\"tk\":[862,48,862,49],\"els\":[\"0:3906\"]},{\"tk\":[862,51,862,52],\"els\":[\"0:3906\"]},{\"tk\":[863,5,863,36],\"els\":[\"0:3906\"]},{\"tk\":[863,37,863,42],\"els\":[\"0:3906\"]},{\"tk\":[863,43,863,58],\"els\":[\"0:3906\"]},{\"tk\":[863,59,863,60],\"els\":[\"0:3906\"]},{\"tk\":[863,61,863,65],\"els\":[\"0:3906\"]},{\"tk\":[871,3,871,5],\"els\":[\"0:3916\"]},{\"tk\":[871,7,871,8],\"els\":[\"0:3916\"]},{\"tk\":[871,8,871,39],\"els\":[\"0:3916\"]},{\"tk\":[871,40,871,43],\"els\":[\"0:3916\"]},{\"tk\":[872,5,872,36],\"els\":[\"0:3916\"]},{\"tk\":[872,37,872,40],\"els\":[\"0:3916\"]},{\"tk\":[872,41,872,63],\"els\":[\"0:3916\"]},{\"tk\":[872,64,872,65],\"els\":[\"0:3916\"]},{\"tk\":[872,66,872,70],\"els\":[\"0:3916\"]},{\"tk\":[873,5,873,7],\"els\":[\"0:3916\"]},{\"tk\":[873,10,873,41],\"els\":[\"0:3916\"]},{\"tk\":[873,42,873,45],\"els\":[\"0:3916\"]},{\"tk\":[873,60,873,62],\"els\":[\"0:3916\"]},{\"tk\":[873,63,873,64],\"els\":[\"0:3916\"]},{\"tk\":[873,66,873,68],\"els\":[\"0:3916\"]},{\"tk\":[874,9,874,40],\"els\":[\"0:3916\"]},{\"tk\":[874,41,874,44],\"els\":[\"0:3916\"]},{\"tk\":[875,7,875,19],\"els\":[\"0:3916\"]},{\"tk\":[875,20,875,51],\"els\":[\"0:3916\"]},{\"tk\":[875,52,875,55],\"els\":[\"0:3916\"]},{\"tk\":[888,3,888,5],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[888,6,888,7],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[888,7,888,8],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[888,8,888,39],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[888,39,888,40],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[888,40,888,45],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[888,45,888,46],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[888,46,888,68],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[888,68,888,69],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[888,70,888,71],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[889,5,889,36],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[889,36,889,37],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[889,37,889,42],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[889,42,889,43],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[889,43,889,65],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[889,66,889,67],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[889,68,889,72],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[889,72,889,73],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[890,5,890,7],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[890,8,890,9],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[890,9,890,10],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[890,10,890,41],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[890,41,890,42],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[890,42,890,47],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[890,47,890,48],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[890,48,890,61],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[890,62,890,64],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[890,65,890,66],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[890,66,890,67],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[890,68,890,70],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[891,9,891,40],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[891,40,891,41],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[891,41,891,46],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[891,46,891,47],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[891,47,891,62],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[891,62,891,63],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[891,64,891,65],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[892,7,892,21],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[892,21,892,22],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[892,22,892,53],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[892,53,892,54],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[892,54,892,59],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[892,59,892,60],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[892,60,892,71],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[892,71,892,72],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[892,72,892,73],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[893,7,893,29],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[893,29,893,30],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[893,30,893,61],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[893,61,893,62],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[893,62,893,67],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[893,67,893,68],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[893,68,893,79],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[893,79,893,80],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[894,9,894,10],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[894,10,894,11],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[894,11,894,12],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[895,7,895,27],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[895,27,895,28],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[895,28,895,59],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[895,59,895,60],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[895,60,895,65],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[895,65,895,66],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[895,66,895,77],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[895,77,895,78],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[896,28,896,37],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[896,37,896,38],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[896,38,896,39],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[897,7,897,27],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[897,27,897,28],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[897,28,897,59],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[897,59,897,60],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[897,60,897,65],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[897,65,897,66],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[897,66,897,77],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[897,77,897,78],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[898,28,898,37],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[898,37,898,38],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[898,38,898,39],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[899,7,899,27],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[899,27,899,28],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[899,28,899,59],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[899,59,899,60],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[899,60,899,65],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[899,65,899,66],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[899,66,899,77],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[899,77,899,78],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[900,28,900,37],\"els\":[\"0:3778:2103\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[900,37,900,38],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[900,38,900,39],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[901,5,901,6],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[902,3,902,4],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[907,3,907,5],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[907,6,907,7],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[907,7,907,8],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[907,8,907,39],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[907,39,907,40],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[907,40,907,45],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[907,45,907,46],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[907,46,907,68],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[907,68,907,69],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[907,70,907,71],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[908,5,908,36],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[908,36,908,37],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[908,37,908,42],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[908,42,908,43],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[908,43,908,65],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[908,66,908,67],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[908,68,908,72],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[908,72,908,73],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[909,5,909,7],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[909,8,909,9],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[909,9,909,10],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[909,10,909,41],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[909,41,909,42],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[909,42,909,47],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[909,47,909,48],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[909,48,909,61],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[909,62,909,64],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[909,65,909,66],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[909,66,909,67],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[909,68,909,70],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[910,9,910,40],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[910,40,910,41],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[910,41,910,46],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[910,46,910,47],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[910,47,910,62],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[910,62,910,63],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[910,64,910,65],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[911,7,911,24],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[911,24,911,25],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[911,25,911,56],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[911,56,911,57],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[911,57,911,62],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[911,62,911,63],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[911,63,911,72],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[911,72,911,73],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[912,25,912,43],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[912,43,912,44],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[912,45,912,46],\"els\":[\"0:3774:462\",\"0:3279\",\"0:3773:517\"]},{\"tk\":[912,46,912,47],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[912,47,912,48],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[913,5,913,6],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[914,3,914,4],\"els\":[\"0:3279\",\"0:3773:517\"]},{\"tk\":[921,3,921,5],\"els\":[\"0:3906\"]},{\"tk\":[921,7,921,8],\"els\":[\"0:3906\"]},{\"tk\":[921,8,921,39],\"els\":[\"0:3906\"]},{\"tk\":[921,40,921,45],\"els\":[\"0:3906\"]},{\"tk\":[922,5,922,36],\"els\":[\"0:3906\"]},{\"tk\":[922,37,922,42],\"els\":[\"0:3906\"]},{\"tk\":[922,43,922,65],\"els\":[\"0:3906\"]},{\"tk\":[922,66,922,67],\"els\":[\"0:3906\"]},{\"tk\":[922,68,922,72],\"els\":[\"0:3906\"]},{\"tk\":[923,5,923,7],\"els\":[\"0:3906\"]},{\"tk\":[923,10,923,41],\"els\":[\"0:3906\"]},{\"tk\":[923,42,923,47],\"els\":[\"0:3906\"]},{\"tk\":[923,62,923,64],\"els\":[\"0:3906\"]},{\"tk\":[923,65,923,66],\"els\":[\"0:3906\"]},{\"tk\":[923,68,923,70],\"els\":[\"0:3906\"]},{\"tk\":[924,9,924,40],\"els\":[\"0:3906\"]},{\"tk\":[924,41,924,46],\"els\":[\"0:3906\"]},{\"tk\":[925,7,925,19],\"els\":[\"0:3906\"]},{\"tk\":[925,20,925,51],\"els\":[\"0:3906\"]},{\"tk\":[925,52,925,57],\"els\":[\"0:3906\"]},{\"tk\":[958,9,958,40],\"els\":[\"0:3918\"]},{\"tk\":[958,41,958,72],\"els\":[\"0:3918\"]},{\"tk\":[958,73,958,74],\"els\":[\"0:3918\"]},{\"tk\":[962,9,962,40],\"els\":[\"0:3279\"]},{\"tk\":[962,41,962,71],\"els\":[\"0:3279\"]},{\"tk\":[962,72,962,73],\"els\":[\"0:3279\"]},{\"tk\":[968,9,968,10],\"els\":[\"0:3773:517\"]},{\"tk\":[969,11,969,23],\"els\":[\"0:3773:517\"]},{\"tk\":[969,24,969,25],\"els\":[\"0:3773:517\"]},{\"tk\":[969,26,969,37],\"els\":[\"0:3773:517\"]},{\"tk\":[969,37,969,38],\"els\":[\"0:3773:517\"]},{\"tk\":[970,11,970,18],\"els\":[\"0:3773:517\"]},{\"tk\":[970,19,970,30],\"els\":[\"0:3773:517\"]},{\"tk\":[970,30,970,31],\"els\":[\"0:3773:517\"]},{\"tk\":[971,11,971,18],\"els\":[\"0:3773:517\"]},{\"tk\":[971,19,971,24],\"els\":[\"0:3773:517\"]},{\"tk\":[971,24,971,25],\"els\":[\"0:3773:517\"]},{\"tk\":[972,11,972,18],\"els\":[\"0:3773:517\"]},{\"tk\":[972,19,972,24],\"els\":[\"0:3773:517\"]},{\"tk\":[972,24,972,25],\"els\":[\"0:3773:517\"]},{\"tk\":[973,11,973,19],\"els\":[\"0:3773:517\"]},{\"tk\":[973,20,973,32],\"els\":[\"0:3773:517\"]},{\"tk\":[973,32,973,33],\"els\":[\"0:3773:517\"]},{\"tk\":[974,11,974,19],\"els\":[\"0:3773:517\"]},{\"tk\":[974,20,974,34],\"els\":[\"0:3773:517\"]},{\"tk\":[974,34,974,35],\"els\":[\"0:3773:517\"]},{\"tk\":[975,11,975,19],\"els\":[\"0:3773:517\"]},{\"tk\":[975,20,975,33],\"els\":[\"0:3773:517\"]},{\"tk\":[975,33,975,34],\"els\":[\"0:3773:517\"]},{\"tk\":[976,11,976,19],\"els\":[\"0:3773:517\"]},{\"tk\":[976,20,976,37],\"els\":[\"0:3773:517\"]},{\"tk\":[976,37,976,38],\"els\":[\"0:3773:517\"]},{\"tk\":[977,11,977,19],\"els\":[\"0:3773:517\"]},{\"tk\":[977,20,977,32],\"els\":[\"0:3773:517\"]},{\"tk\":[977,32,977,33],\"els\":[\"0:3773:517\"]},{\"tk\":[978,11,978,19],\"els\":[\"0:3773:517\"]},{\"tk\":[978,20,978,32],\"els\":[\"0:3773:517\"]},{\"tk\":[978,32,978,33],\"els\":[\"0:3773:517\"]},{\"tk\":[979,11,979,19],\"els\":[\"0:3773:517\"]},{\"tk\":[979,20,979,25],\"els\":[\"0:3773:517\"]},{\"tk\":[979,25,979,26],\"els\":[\"0:3773:517\"]},{\"tk\":[980,11,980,19],\"els\":[\"0:3773:517\"]},{\"tk\":[980,20,980,23],\"els\":[\"0:3773:517\"]},{\"tk\":[980,23,980,24],\"els\":[\"0:3773:517\"]},{\"tk\":[980,24,980,25],\"els\":[\"0:3773:517\"]},{\"tk\":[980,25,980,26],\"els\":[\"0:3773:517\"]},{\"tk\":[980,26,980,27],\"els\":[\"0:3773:517\"]},{\"tk\":[981,11,981,20],\"els\":[\"0:3773:517\"]},{\"tk\":[981,21,981,26],\"els\":[\"0:3773:517\"]},{\"tk\":[981,26,981,27],\"els\":[\"0:3773:517\"]},{\"tk\":[984,11,984,22],\"els\":[\"0:3773:517\"]},{\"tk\":[984,23,984,24],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[984,25,984,30],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[984,30,984,31],\"els\":[\"0:3773:517\"]},{\"tk\":[990,11,990,13],\"els\":[\"0:3585\",\"0:3773:517\"]},{\"tk\":[990,14,990,15],\"els\":[\"0:3773:517\"]},{\"tk\":[990,15,990,46],\"els\":[\"0:3583\",\"0:3773:517\"]},{\"tk\":[990,46,990,47],\"els\":[\"0:3773:517\"]},{\"tk\":[990,47,990,64],\"els\":[\"0:3583\",\"0:3773:517\"]},{\"tk\":[990,65,990,66],\"els\":[\"0:3585\",\"0:3773:517\"]},{\"tk\":[991,15,991,46],\"els\":[\"0:3585\",\"0:3773:517\"]},{\"tk\":[991,46,991,47],\"els\":[\"0:3773:517\"]},{\"tk\":[991,47,991,65],\"els\":[\"0:3585\",\"0:3773:517\"]},{\"tk\":[991,65,991,66],\"els\":[\"0:3773:517\"]},{\"tk\":[991,67,991,68],\"els\":[\"0:3773:517\"]},{\"tk\":[992,13,992,18],\"els\":[\"0:3585\",\"0:3773:517\"]},{\"tk\":[992,19,992,20],\"els\":[\"0:3585\",\"0:3773:517\"]},{\"tk\":[993,15,993,46],\"els\":[\"0:3585\",\"0:3773:517\"]},{\"tk\":[993,46,993,47],\"els\":[\"0:3773:517\"]},{\"tk\":[993,47,993,78],\"els\":[\"0:3585\",\"0:3773:517\"]},{\"tk\":[993,78,993,79],\"els\":[\"0:3773:517\"]},{\"tk\":[994,11,994,12],\"els\":[\"0:3773:517\"]},{\"tk\":[994,13,994,17],\"els\":[\"0:3773:517\"]},{\"tk\":[994,18,994,19],\"els\":[\"0:3773:517\"]},{\"tk\":[995,13,995,18],\"els\":[\"0:3585\",\"0:3773:517\"]},{\"tk\":[995,19,995,20],\"els\":[\"0:3585\",\"0:3773:517\"]},{\"tk\":[996,15,996,16],\"els\":[\"0:3584\",\"0:3585\",\"0:3773:517\"]},{\"tk\":[996,16,996,47],\"els\":[\"0:3584\",\"0:3585\",\"0:3773:517\"]},{\"tk\":[996,47,996,48],\"els\":[\"0:3773:517\"]},{\"tk\":[996,48,996,79],\"els\":[\"0:3584\",\"0:3585\",\"0:3773:517\"]},{\"tk\":[996,79,996,80],\"els\":[\"0:3773:517\"]},{\"tk\":[997,11,997,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1002,11,1002,13],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1002,14,1002,15],\"els\":[\"0:3773:517\"]},{\"tk\":[1002,15,1002,20],\"els\":[\"0:3585\",\"0:3773:517\"]},{\"tk\":[1002,20,1002,21],\"els\":[\"0:3773:517\"]},{\"tk\":[1002,22,1002,23],\"els\":[\"0:3773:517\"]},{\"tk\":[1003,13,1003,24],\"els\":[\"0:3773:517\"]},{\"tk\":[1003,25,1003,26],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1003,27,1003,31],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1003,31,1003,32],\"els\":[\"0:3773:517\"]},{\"tk\":[1004,13,1004,18],\"els\":[\"0:3773:517\"]},{\"tk\":[1004,19,1004,20],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1004,21,1004,25],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1004,25,1004,26],\"els\":[\"0:3773:517\"]},{\"tk\":[1005,13,1005,18],\"els\":[\"0:3773:517\"]},{\"tk\":[1005,19,1005,20],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1005,21,1005,25],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1005,25,1005,26],\"els\":[\"0:3773:517\"]},{\"tk\":[1006,11,1006,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1006,13,1006,17],\"els\":[\"0:3773:517\"]},{\"tk\":[1006,18,1006,19],\"els\":[\"0:3773:517\"]},{\"tk\":[1007,13,1007,24],\"els\":[\"0:3773:517\"]},{\"tk\":[1007,25,1007,26],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1007,27,1007,28],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1007,28,1007,29],\"els\":[\"0:3773:517\"]},{\"tk\":[1008,13,1008,18],\"els\":[\"0:3773:517\"]},{\"tk\":[1008,19,1008,20],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1008,21,1008,22],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1008,22,1008,23],\"els\":[\"0:3773:517\"]},{\"tk\":[1009,13,1009,18],\"els\":[\"0:3773:517\"]},{\"tk\":[1009,19,1009,20],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1009,21,1009,22],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1009,22,1009,23],\"els\":[\"0:3773:517\"]},{\"tk\":[1010,11,1010,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1012,11,1012,22],\"els\":[\"0:3773:517\"]},{\"tk\":[1012,23,1012,24],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1012,25,1012,26],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1012,26,1012,33],\"els\":[\"0:3773:517\"]},{\"tk\":[1012,33,1012,34],\"els\":[\"0:3773:517\"]},{\"tk\":[1012,34,1012,35],\"els\":[\"0:3773:517\"]},{\"tk\":[1012,35,1012,36],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1012,36,1012,44],\"els\":[\"0:3773:517\"]},{\"tk\":[1012,44,1012,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1012,45,1012,56],\"els\":[\"0:3773:517\"]},{\"tk\":[1012,57,1012,58],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1012,59,1012,60],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1012,60,1012,68],\"els\":[\"0:3773:517\"]},{\"tk\":[1012,68,1012,69],\"els\":[\"0:3773:517\"]},{\"tk\":[1012,69,1012,74],\"els\":[\"0:3773:517\"]},{\"tk\":[1012,75,1012,76],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1013,13,1013,14],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1013,14,1013,22],\"els\":[\"0:3773:517\"]},{\"tk\":[1013,22,1013,23],\"els\":[\"0:3773:517\"]},{\"tk\":[1013,23,1013,28],\"els\":[\"0:3773:517\"]},{\"tk\":[1013,28,1013,29],\"els\":[\"0:3773:517\"]},{\"tk\":[1013,29,1013,30],\"els\":[\"0:3773:517\"]},{\"tk\":[1014,11,1014,31],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1014,31,1014,32],\"els\":[\"0:3773:517\"]},{\"tk\":[1014,32,1014,43],\"els\":[\"0:3773:517\"]},{\"tk\":[1014,43,1014,44],\"els\":[\"0:3773:517\"]},{\"tk\":[1014,45,1014,46],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1014,46,1014,54],\"els\":[\"0:3773:517\"]},{\"tk\":[1014,54,1014,55],\"els\":[\"0:3773:517\"]},{\"tk\":[1014,55,1014,66],\"els\":[\"0:3773:517\"]},{\"tk\":[1014,66,1014,67],\"els\":[\"0:3773:517\"]},{\"tk\":[1014,67,1014,68],\"els\":[\"0:3773:517\"]},{\"tk\":[1015,11,1015,33],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1015,33,1015,34],\"els\":[\"0:3773:517\"]},{\"tk\":[1015,34,1015,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1015,45,1015,46],\"els\":[\"0:3773:517\"]},{\"tk\":[1015,47,1015,48],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1015,48,1015,49],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1015,49,1015,57],\"els\":[\"0:3773:517\"]},{\"tk\":[1015,57,1015,58],\"els\":[\"0:3773:517\"]},{\"tk\":[1015,58,1015,69],\"els\":[\"0:3773:517\"]},{\"tk\":[1015,70,1015,71],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1015,72,1015,77],\"els\":[\"0:3779:355\",\"0:3773:517\"]},{\"tk\":[1015,77,1015,78],\"els\":[\"0:3773:517\"]},{\"tk\":[1015,78,1015,79],\"els\":[\"0:3773:517\"]},{\"tk\":[1020,11,1020,13],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1020,14,1020,15],\"els\":[\"0:3773:517\"]},{\"tk\":[1020,15,1020,16],\"els\":[\"0:3300\",\"0:3773:517\"]},{\"tk\":[1020,16,1020,47],\"els\":[\"0:3300\",\"0:3773:517\"]},{\"tk\":[1020,47,1020,48],\"els\":[\"0:3773:517\"]},{\"tk\":[1020,48,1020,79],\"els\":[\"0:3300\",\"0:3773:517\"]},{\"tk\":[1020,79,1020,80],\"els\":[\"0:3773:517\"]},{\"tk\":[1021,11,1021,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1022,13,1022,44],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1022,44,1022,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1022,45,1022,65],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1022,66,1022,67],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1023,15,1023,46],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1023,46,1023,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1023,47,1023,63],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1023,63,1023,64],\"els\":[\"0:3773:517\"]},{\"tk\":[1024,11,1024,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1030,11,1030,24],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1030,25,1030,26],\"els\":[\"0:3295\",\"0:3773:517\"]},{\"tk\":[1030,27,1030,28],\"els\":[\"0:3314\",\"0:3773:517\"]},{\"tk\":[1030,28,1030,36],\"els\":[\"0:3773:517\"]},{\"tk\":[1030,36,1030,37],\"els\":[\"0:3773:517\"]},{\"tk\":[1031,13,1031,44],\"els\":[\"0:3314\",\"0:3773:517\"]},{\"tk\":[1031,44,1031,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1031,45,1031,58],\"els\":[\"0:3314\",\"0:3773:517\"]},{\"tk\":[1031,59,1031,60],\"els\":[\"0:3314\",\"0:3773:517\"]},{\"tk\":[1031,61,1031,75],\"els\":[\"0:3314\",\"0:3773:517\"]},{\"tk\":[1031,76,1031,77],\"els\":[\"0:3314\",\"0:3773:517\"]},{\"tk\":[1032,13,1032,14],\"els\":[\"0:3314\",\"0:3773:517\"]},{\"tk\":[1032,14,1032,22],\"els\":[\"0:3773:517\"]},{\"tk\":[1032,22,1032,23],\"els\":[\"0:3773:517\"]},{\"tk\":[1033,13,1033,44],\"els\":[\"0:3314\",\"0:3773:517\"]},{\"tk\":[1033,44,1033,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1033,45,1033,75],\"els\":[\"0:3314\",\"0:3773:517\"]},{\"tk\":[1033,76,1033,77],\"els\":[\"0:3295\",\"0:3773:517\"]},{\"tk\":[1034,13,1034,44],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1034,44,1034,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1034,45,1034,65],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1034,65,1034,66],\"els\":[\"0:3773:517\"]},{\"tk\":[1040,11,1040,23],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1040,24,1040,25],\"els\":[\"0:3287\",\"0:3773:517\"]},{\"tk\":[1040,26,1040,57],\"els\":[\"0:3309\",\"0:3773:517\"]},{\"tk\":[1040,57,1040,58],\"els\":[\"0:3773:517\"]},{\"tk\":[1040,58,1040,67],\"els\":[\"0:3309\",\"0:3773:517\"]},{\"tk\":[1040,68,1040,69],\"els\":[\"0:3309\",\"0:3773:517\"]},{\"tk\":[1040,70,1040,75],\"els\":[\"0:3620\",\"0:3773:517\"]},{\"tk\":[1041,13,1041,14],\"els\":[\"0:3773:517\"]},{\"tk\":[1041,14,1041,27],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1041,27,1041,28],\"els\":[\"0:3773:517\"]},{\"tk\":[1041,29,1041,30],\"els\":[\"0:3287\",\"0:3773:517\"]},{\"tk\":[1042,13,1042,44],\"els\":[\"0:3287\",\"0:3773:517\"]},{\"tk\":[1042,44,1042,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1042,45,1042,75],\"els\":[\"0:3287\",\"0:3773:517\"]},{\"tk\":[1042,75,1042,76],\"els\":[\"0:3773:517\"]},{\"tk\":[1048,11,1048,13],\"els\":[\"0:3611\",\"0:3773:517\"]},{\"tk\":[1048,14,1048,15],\"els\":[\"0:3773:517\"]},{\"tk\":[1048,15,1048,27],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1048,28,1048,29],\"els\":[\"0:3610\",\"0:3773:517\"]},{\"tk\":[1048,30,1048,61],\"els\":[\"0:3607\",\"0:3773:517\"]},{\"tk\":[1048,61,1048,62],\"els\":[\"0:3773:517\"]},{\"tk\":[1048,62,1048,80],\"els\":[\"0:3607\",\"0:3773:517\"]},{\"tk\":[1048,80,1048,81],\"els\":[\"0:3773:517\"]},{\"tk\":[1049,11,1049,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1050,13,1050,27],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1050,28,1050,29],\"els\":[\"0:3611\",\"0:3773:517\"]},{\"tk\":[1050,30,1050,42],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1050,42,1050,43],\"els\":[\"0:3773:517\"]},{\"tk\":[1051,11,1051,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1051,13,1051,17],\"els\":[\"0:3773:517\"]},{\"tk\":[1051,18,1051,19],\"els\":[\"0:3773:517\"]},{\"tk\":[1052,13,1052,27],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1052,28,1052,29],\"els\":[\"0:3611\",\"0:3773:517\"]},{\"tk\":[1052,30,1052,61],\"els\":[\"0:3607\",\"0:3773:517\"]},{\"tk\":[1052,61,1052,62],\"els\":[\"0:3773:517\"]},{\"tk\":[1052,62,1052,80],\"els\":[\"0:3607\",\"0:3773:517\"]},{\"tk\":[1052,80,1052,81],\"els\":[\"0:3773:517\"]},{\"tk\":[1053,11,1053,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1064,11,1064,13],\"els\":[\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1064,14,1064,15],\"els\":[\"0:3773:517\"]},{\"tk\":[1064,15,1064,16],\"els\":[\"0:3294:1179\",\"0:3773:517\"]},{\"tk\":[1064,16,1064,47],\"els\":[\"0:3294:1216\",\"0:3773:517\"]},{\"tk\":[1064,47,1064,48],\"els\":[\"0:3773:517\"]},{\"tk\":[1064,48,1064,68],\"els\":[\"0:3294:1216\",\"0:3773:517\"]},{\"tk\":[1064,68,1064,69],\"els\":[\"0:3773:517\"]},{\"tk\":[1064,70,1064,71],\"els\":[\"0:3773:517\"]},{\"tk\":[1068,13,1068,15],\"els\":[\"0:3294:1207\",\"0:3294:1204\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1068,16,1068,17],\"els\":[\"0:3773:517\"]},{\"tk\":[1068,17,1068,48],\"els\":[\"0:3294:1210\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1068,48,1068,49],\"els\":[\"0:3773:517\"]},{\"tk\":[1068,49,1068,61],\"els\":[\"0:3294:1210\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1068,61,1068,62],\"els\":[\"0:3773:517\"]},{\"tk\":[1068,63,1068,64],\"els\":[\"0:3773:517\"]},{\"tk\":[1073,15,1073,46],\"els\":[\"0:3294:1211\",\"0:3773:517\"]},{\"tk\":[1073,46,1073,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1073,47,1073,52],\"els\":[\"0:3294:1211\",\"0:3773:517\"]},{\"tk\":[1073,53,1073,54],\"els\":[\"0:3294:1211\",\"0:3294:1207\",\"0:3294:1204\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1074,17,1074,48],\"els\":[\"0:3312\",\"0:3773:517\"]},{\"tk\":[1074,48,1074,49],\"els\":[\"0:3773:517\"]},{\"tk\":[1074,49,1074,72],\"els\":[\"0:3312\",\"0:3773:517\"]},{\"tk\":[1074,73,1074,74],\"els\":[\"0:3312\",\"0:3773:517\"]},{\"tk\":[1075,17,1075,30],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1075,31,1075,32],\"els\":[\"0:3294:1202\",\"0:3773:517\"]},{\"tk\":[1075,33,1075,64],\"els\":[\"0:3294:1202\",\"0:3773:517\"]},{\"tk\":[1075,64,1075,65],\"els\":[\"0:3773:517\"]},{\"tk\":[1075,65,1075,77],\"els\":[\"0:3294:1202\",\"0:3773:517\"]},{\"tk\":[1075,77,1075,78],\"els\":[\"0:3773:517\"]},{\"tk\":[1076,13,1076,14],\"els\":[\"0:3773:517\"]},{\"tk\":[1084,13,1084,26],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1084,27,1084,28],\"els\":[\"0:3294:1183\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1084,29,1084,60],\"els\":[\"0:3294:1183\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1084,60,1084,61],\"els\":[\"0:3773:517\"]},{\"tk\":[1084,61,1084,66],\"els\":[\"0:3294:1183\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1084,67,1084,68],\"els\":[\"0:3294:1183\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1085,15,1085,46],\"els\":[\"0:3294:1187\",\"0:3773:517\"]},{\"tk\":[1085,46,1085,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1085,47,1085,63],\"els\":[\"0:3294:1187\",\"0:3773:517\"]},{\"tk\":[1085,63,1085,64],\"els\":[\"0:3773:517\"]},{\"tk\":[1092,13,1092,44],\"els\":[\"0:3294:1184\",\"0:3294:1182\",\"0:3294:1180\",\"0:3294:1187\",\"0:3773:517\"]},{\"tk\":[1092,44,1092,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1092,45,1092,61],\"els\":[\"0:3294:1184\",\"0:3294:1182\",\"0:3294:1180\",\"0:3294:1187\",\"0:3773:517\"]},{\"tk\":[1092,62,1092,63],\"els\":[\"0:3294:1184\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1092,64,1092,77],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1092,78,1092,79],\"els\":[\"0:3294:1184\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1093,15,1093,16],\"els\":[\"0:3294:1215\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1093,16,1093,24],\"els\":[\"0:3773:517\"]},{\"tk\":[1093,24,1093,25],\"els\":[\"0:3773:517\"]},{\"tk\":[1093,25,1093,26],\"els\":[\"0:3294:1195\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1093,26,1093,33],\"els\":[\"0:3773:517\"]},{\"tk\":[1093,33,1093,34],\"els\":[\"0:3773:517\"]},{\"tk\":[1093,34,1093,40],\"els\":[\"0:3294:1195\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1093,40,1093,41],\"els\":[\"0:3773:517\"]},{\"tk\":[1093,41,1093,54],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1093,54,1093,55],\"els\":[\"0:3773:517\"]},{\"tk\":[1093,55,1093,56],\"els\":[\"0:3773:517\"]},{\"tk\":[1098,13,1098,44],\"els\":[\"0:3294:1210\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1098,44,1098,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1098,45,1098,57],\"els\":[\"0:3294:1210\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1098,58,1098,59],\"els\":[\"0:3294:1210\",\"0:3294:1182\",\"0:3294:1180\",\"0:3773:517\"]},{\"tk\":[1099,15,1099,46],\"els\":[\"0:3294:1209\",\"0:3773:517\"]},{\"tk\":[1099,46,1099,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1099,47,1099,63],\"els\":[\"0:3294:1209\",\"0:3773:517\"]},{\"tk\":[1099,63,1099,64],\"els\":[\"0:3773:517\"]},{\"tk\":[1100,11,1100,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1109,11,1109,24],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1109,25,1109,26],\"els\":[\"0:3502:1180:76:652\",\"0:3773:517\"]},{\"tk\":[1109,27,1109,58],\"els\":[\"0:3294:1189\",\"0:3773:517\"]},{\"tk\":[1109,58,1109,59],\"els\":[\"0:3773:517\"]},{\"tk\":[1109,59,1109,72],\"els\":[\"0:3294:1189\",\"0:3773:517\"]},{\"tk\":[1109,73,1109,74],\"els\":[\"0:3294:1189\",\"0:3773:517\"]},{\"tk\":[1110,13,1110,44],\"els\":[\"0:3294:1189\",\"0:3294:1187\",\"0:3773:517\"]},{\"tk\":[1110,44,1110,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1110,45,1110,61],\"els\":[\"0:3294:1189\",\"0:3294:1187\",\"0:3773:517\"]},{\"tk\":[1110,62,1110,63],\"els\":[\"0:3502:1180:76:652\",\"0:3773:517\"]},{\"tk\":[1111,13,1111,44],\"els\":[\"0:3502:1180:76:652\",\"0:3773:517\"]},{\"tk\":[1111,44,1111,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1111,45,1111,60],\"els\":[\"0:3502:1180:76:652\",\"0:3773:517\"]},{\"tk\":[1111,60,1111,61],\"els\":[\"0:3773:517\"]},{\"tk\":[1124,11,1124,13],\"els\":[\"0:3502:1180:76:683\",\"0:3773:517\"]},{\"tk\":[1124,14,1124,15],\"els\":[\"0:3773:517\"]},{\"tk\":[1124,15,1124,28],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1124,29,1124,30],\"els\":[\"0:3502:1180:76:692:2\",\"0:3773:517\"]},{\"tk\":[1124,31,1124,62],\"els\":[\"0:3502:1180:76:692:3\",\"0:3773:517\"]},{\"tk\":[1124,62,1124,63],\"els\":[\"0:3773:517\"]},{\"tk\":[1124,63,1124,79],\"els\":[\"0:3502:1180:76:692:3\",\"0:3773:517\"]},{\"tk\":[1124,79,1124,80],\"els\":[\"0:3773:517\"]},{\"tk\":[1125,11,1125,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1129,13,1129,30],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1129,31,1129,32],\"els\":[\"0:3502:1180:76:683\",\"0:3773:517\"]},{\"tk\":[1129,33,1129,46],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1129,47,1129,48],\"els\":[\"0:3502:1180:76:693\",\"0:3502:1180:76:684\",\"0:3502:1180:76:683\",\"0:3502:1180:76:686\",\"0:3773:517\"]},{\"tk\":[1129,49,1129,50],\"els\":[\"0:3502:1180:76:695\",\"0:3502:1180:76:684\",\"0:3502:1180:76:683\",\"0:3502:1180:76:686\",\"0:3773:517\"]},{\"tk\":[1129,50,1129,58],\"els\":[\"0:3773:517\"]},{\"tk\":[1129,58,1129,59],\"els\":[\"0:3773:517\"]},{\"tk\":[1129,59,1129,60],\"els\":[\"0:3502:1180:76:694\",\"0:3502:1180:76:684\",\"0:3502:1180:76:683\",\"0:3502:1180:76:686\",\"0:3773:517\"]},{\"tk\":[1129,60,1129,67],\"els\":[\"0:3773:517\"]},{\"tk\":[1129,67,1129,68],\"els\":[\"0:3773:517\"]},{\"tk\":[1129,68,1129,74],\"els\":[\"0:3502:1180:76:694\",\"0:3502:1180:76:684\",\"0:3502:1180:76:683\",\"0:3502:1180:76:686\",\"0:3773:517\"]},{\"tk\":[1130,15,1130,16],\"els\":[\"0:3773:517\"]},{\"tk\":[1130,16,1130,29],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1130,29,1130,30],\"els\":[\"0:3773:517\"]},{\"tk\":[1130,30,1130,31],\"els\":[\"0:3773:517\"]},{\"tk\":[1133,11,1133,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1133,13,1133,17],\"els\":[\"0:3773:517\"]},{\"tk\":[1133,18,1133,19],\"els\":[\"0:3773:517\"]},{\"tk\":[1137,13,1137,30],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1137,31,1137,32],\"els\":[\"0:3502:1180:76:683\",\"0:3773:517\"]},{\"tk\":[1137,33,1137,46],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1137,47,1137,48],\"els\":[\"0:3502:1180:76:700\",\"0:3502:1180:76:688\",\"0:3502:1180:76:683\",\"0:3502:1180:76:690\",\"0:3773:517\"]},{\"tk\":[1137,49,1137,50],\"els\":[\"0:3502:1180:76:698\",\"0:3502:1180:76:688\",\"0:3502:1180:76:683\",\"0:3502:1180:76:690\",\"0:3773:517\"]},{\"tk\":[1137,50,1137,58],\"els\":[\"0:3773:517\"]},{\"tk\":[1137,58,1137,59],\"els\":[\"0:3773:517\"]},{\"tk\":[1137,59,1137,60],\"els\":[\"0:3502:1180:76:697\",\"0:3502:1180:76:688\",\"0:3502:1180:76:683\",\"0:3502:1180:76:690\",\"0:3773:517\"]},{\"tk\":[1137,60,1137,67],\"els\":[\"0:3773:517\"]},{\"tk\":[1137,67,1137,68],\"els\":[\"0:3773:517\"]},{\"tk\":[1137,68,1137,81],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1137,81,1137,82],\"els\":[\"0:3773:517\"]},{\"tk\":[1140,11,1140,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1142,11,1142,23],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1142,24,1142,25],\"els\":[\"0:3502:1180:76:605\",\"0:3773:517\"]},{\"tk\":[1142,26,1142,57],\"els\":[\"0:3502:1180:76:605\",\"0:3773:517\"]},{\"tk\":[1142,57,1142,58],\"els\":[\"0:3773:517\"]},{\"tk\":[1142,58,1142,71],\"els\":[\"0:3502:1180:76:605\",\"0:3773:517\"]},{\"tk\":[1142,72,1142,73],\"els\":[\"0:3502:1180:76:605\",\"0:3773:517\"]},{\"tk\":[1143,13,1143,30],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1143,30,1143,31],\"els\":[\"0:3773:517\"]},{\"tk\":[1151,11,1151,23],\"els\":[\"0:3502:1176:436#out:1\",\"0:3773:517\"]},{\"tk\":[1151,24,1151,25],\"els\":[\"0:3502:1180:76:612\",\"0:3773:517\"]},{\"tk\":[1151,26,1151,38],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1151,39,1151,40],\"els\":[\"0:3502:1180:76:612\",\"0:3773:517\"]},{\"tk\":[1151,41,1151,42],\"els\":[\"0:3502:1180:76:653\",\"0:3773:517\"]},{\"tk\":[1151,42,1151,50],\"els\":[\"0:3773:517\"]},{\"tk\":[1151,50,1151,51],\"els\":[\"0:3773:517\"]},{\"tk\":[1151,51,1151,52],\"els\":[\"0:3502:1180:76:608\",\"0:3773:517\"]},{\"tk\":[1151,52,1151,60],\"els\":[\"0:3773:517\"]},{\"tk\":[1151,60,1151,61],\"els\":[\"0:3773:517\"]},{\"tk\":[1151,61,1151,73],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1151,73,1151,74],\"els\":[\"0:3773:517\"]},{\"tk\":[1154,11,1154,13],\"els\":[\"0:3603\",\"0:3773:517\"]},{\"tk\":[1154,14,1154,15],\"els\":[\"0:3773:517\"]},{\"tk\":[1154,15,1154,29],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1154,30,1154,31],\"els\":[\"0:3603\",\"0:3773:517\"]},{\"tk\":[1155,15,1155,46],\"els\":[\"0:3603\",\"0:3773:517\"]},{\"tk\":[1155,46,1155,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1155,47,1155,66],\"els\":[\"0:3603\",\"0:3773:517\"]},{\"tk\":[1155,66,1155,67],\"els\":[\"0:3773:517\"]},{\"tk\":[1155,68,1155,69],\"els\":[\"0:3773:517\"]},{\"tk\":[1156,13,1156,27],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1156,28,1156,29],\"els\":[\"0:3603\",\"0:3773:517\"]},{\"tk\":[1156,30,1156,61],\"els\":[\"0:3603\",\"0:3773:517\"]},{\"tk\":[1156,61,1156,62],\"els\":[\"0:3773:517\"]},{\"tk\":[1156,62,1156,81],\"els\":[\"0:3603\",\"0:3773:517\"]},{\"tk\":[1156,81,1156,82],\"els\":[\"0:3773:517\"]},{\"tk\":[1157,11,1157,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1157,13,1157,17],\"els\":[\"0:3773:517\"]},{\"tk\":[1157,18,1157,20],\"els\":[\"0:3603\",\"0:3773:517\"]},{\"tk\":[1157,21,1157,22],\"els\":[\"0:3773:517\"]},{\"tk\":[1157,22,1157,36],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1157,37,1157,38],\"els\":[\"0:3603\",\"0:3773:517\"]},{\"tk\":[1158,22,1158,53],\"els\":[\"0:3603\",\"0:3773:517\"]},{\"tk\":[1158,53,1158,54],\"els\":[\"0:3773:517\"]},{\"tk\":[1158,54,1158,73],\"els\":[\"0:3603\",\"0:3773:517\"]},{\"tk\":[1158,73,1158,74],\"els\":[\"0:3773:517\"]},{\"tk\":[1158,75,1158,76],\"els\":[\"0:3773:517\"]},{\"tk\":[1159,13,1159,27],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1159,28,1159,29],\"els\":[\"0:3603\",\"0:3773:517\"]},{\"tk\":[1159,30,1159,61],\"els\":[\"0:3603\",\"0:3773:517\"]},{\"tk\":[1159,61,1159,62],\"els\":[\"0:3773:517\"]},{\"tk\":[1159,62,1159,81],\"els\":[\"0:3603\",\"0:3773:517\"]},{\"tk\":[1159,81,1159,82],\"els\":[\"0:3773:517\"]},{\"tk\":[1160,11,1160,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1170,11,1170,28],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1170,29,1170,30],\"els\":[\"0:3502:1180:76:557\",\"0:3502:1180:76:549\",\"0:3773:517\"]},{\"tk\":[1171,13,1171,44],\"els\":[\"0:3502:1180:76:549\",\"0:3773:517\"]},{\"tk\":[1171,44,1171,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1171,45,1171,68],\"els\":[\"0:3502:1180:76:549\",\"0:3773:517\"]},{\"tk\":[1171,68,1171,69],\"els\":[\"0:3502:1180:76:557\",\"0:3502:1180:76:549\",\"0:3773:517\"]},{\"tk\":[1171,69,1171,70],\"els\":[\"0:3502:1180:76:614\",\"0:3773:517\"]},{\"tk\":[1171,70,1171,77],\"els\":[\"0:3773:517\"]},{\"tk\":[1171,77,1171,78],\"els\":[\"0:3773:517\"]},{\"tk\":[1172,13,1172,14],\"els\":[\"0:3773:517\"]},{\"tk\":[1172,14,1172,15],\"els\":[\"0:3502:1180:76:614\",\"0:3502:1180:76:610\",\"0:3773:517\"]},{\"tk\":[1172,15,1172,23],\"els\":[\"0:3773:517\"]},{\"tk\":[1172,23,1172,24],\"els\":[\"0:3773:517\"]},{\"tk\":[1172,24,1172,55],\"els\":[\"0:3502:1180:76:657\",\"0:3773:517\"]},{\"tk\":[1172,55,1172,56],\"els\":[\"0:3773:517\"]},{\"tk\":[1172,56,1172,68],\"els\":[\"0:3502:1180:76:657\",\"0:3773:517\"]},{\"tk\":[1172,68,1172,69],\"els\":[\"0:3502:1180:76:610\",\"0:3502:1180:76:657\",\"0:3502:1180:76:557\",\"0:3773:517\"]},{\"tk\":[1172,69,1172,70],\"els\":[\"0:3502:1180:76:610\",\"0:3502:1180:76:657\",\"0:3773:517\"]},{\"tk\":[1172,70,1172,71],\"els\":[\"0:3773:517\"]},{\"tk\":[1172,72,1172,73],\"els\":[\"0:3502:1180:76:614\",\"0:3502:1180:76:610\",\"0:3773:517\"]},{\"tk\":[1173,14,1173,15],\"els\":[\"0:3502:1180:76:608\",\"0:3773:517\"]},{\"tk\":[1173,15,1173,23],\"els\":[\"0:3773:517\"]},{\"tk\":[1173,23,1173,24],\"els\":[\"0:3773:517\"]},{\"tk\":[1173,24,1173,36],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1173,36,1173,37],\"els\":[\"0:3773:517\"]},{\"tk\":[1173,37,1173,38],\"els\":[\"0:3773:517\"]},{\"tk\":[1173,38,1173,39],\"els\":[\"0:3773:517\"]},{\"tk\":[1174,11,1174,16],\"els\":[\"0:3502:1180:76:557\",\"0:3773:517\"]},{\"tk\":[1174,17,1174,18],\"els\":[\"0:3502:1180:76:557\",\"0:3502:1180:76:549\",\"0:3773:517\"]},{\"tk\":[1174,19,1174,50],\"els\":[\"0:3502:1180:76:549\",\"0:3773:517\"]},{\"tk\":[1174,50,1174,51],\"els\":[\"0:3773:517\"]},{\"tk\":[1174,51,1174,74],\"els\":[\"0:3502:1180:76:549\",\"0:3773:517\"]},{\"tk\":[1175,13,1175,14],\"els\":[\"0:3502:1180:76:557\",\"0:3502:1180:76:549\",\"0:3773:517\"]},{\"tk\":[1175,14,1175,15],\"els\":[\"0:3502:1180:76:622\",\"0:3773:517\"]},{\"tk\":[1175,15,1175,22],\"els\":[\"0:3773:517\"]},{\"tk\":[1175,22,1175,23],\"els\":[\"0:3773:517\"]},{\"tk\":[1175,23,1175,24],\"els\":[\"0:3773:517\"]},{\"tk\":[1175,24,1175,25],\"els\":[\"0:3502:1180:76:622\",\"0:3502:1180:76:610\",\"0:3773:517\"]},{\"tk\":[1175,25,1175,33],\"els\":[\"0:3773:517\"]},{\"tk\":[1175,33,1175,34],\"els\":[\"0:3773:517\"]},{\"tk\":[1175,34,1175,65],\"els\":[\"0:3502:1180:76:657\",\"0:3773:517\"]},{\"tk\":[1175,65,1175,66],\"els\":[\"0:3773:517\"]},{\"tk\":[1175,66,1175,78],\"els\":[\"0:3502:1180:76:657\",\"0:3773:517\"]},{\"tk\":[1175,78,1175,79],\"els\":[\"0:3502:1180:76:610\",\"0:3502:1180:76:657\",\"0:3502:1180:76:557\",\"0:3773:517\"]},{\"tk\":[1175,79,1175,80],\"els\":[\"0:3502:1180:76:610\",\"0:3502:1180:76:657\",\"0:3773:517\"]},{\"tk\":[1175,80,1175,81],\"els\":[\"0:3773:517\"]},{\"tk\":[1176,24,1176,25],\"els\":[\"0:3502:1180:76:622\",\"0:3502:1180:76:610\",\"0:3773:517\"]},{\"tk\":[1176,26,1176,27],\"els\":[\"0:3502:1180:76:608\",\"0:3773:517\"]},{\"tk\":[1176,27,1176,35],\"els\":[\"0:3773:517\"]},{\"tk\":[1176,35,1176,36],\"els\":[\"0:3773:517\"]},{\"tk\":[1176,36,1176,48],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1176,48,1176,49],\"els\":[\"0:3773:517\"]},{\"tk\":[1176,49,1176,50],\"els\":[\"0:3773:517\"]},{\"tk\":[1176,50,1176,51],\"els\":[\"0:3773:517\"]},{\"tk\":[1195,11,1195,27],\"els\":[\"0:3502:1176:761\",\"0:3502:1176:778\",\"0:3773:517\"]},{\"tk\":[1195,27,1195,28],\"els\":[\"0:3773:517\"]},{\"tk\":[1195,28,1195,59],\"els\":[\"0:3502:1164\",\"0:3773:517\"]},{\"tk\":[1195,59,1195,60],\"els\":[\"0:3773:517\"]},{\"tk\":[1195,60,1195,76],\"els\":[\"0:3502:1164\",\"0:3773:517\"]},{\"tk\":[1195,76,1195,77],\"els\":[\"0:3773:517\"]},{\"tk\":[1196,28,1196,29],\"els\":[\"0:3502:1174\",\"0:3773:517\"]},{\"tk\":[1196,29,1196,43],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1196,43,1196,44],\"els\":[\"0:3773:517\"]},{\"tk\":[1196,45,1196,46],\"els\":[\"0:3773:517\"]},{\"tk\":[1196,46,1196,59],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1196,59,1196,60],\"els\":[\"0:3773:517\"]},{\"tk\":[1196,61,1196,62],\"els\":[\"0:3773:517\"]},{\"tk\":[1196,62,1196,74],\"els\":[\"0:3502:1176:761\",\"0:3773:517\"]},{\"tk\":[1196,74,1196,75],\"els\":[\"0:3773:517\"]},{\"tk\":[1197,28,1197,29],\"els\":[\"0:3773:517\"]},{\"tk\":[1197,29,1197,60],\"els\":[\"0:3502:1180:76:549\",\"0:3773:517\"]},{\"tk\":[1197,60,1197,61],\"els\":[\"0:3773:517\"]},{\"tk\":[1197,61,1197,84],\"els\":[\"0:3502:1180:76:549\",\"0:3773:517\"]},{\"tk\":[1198,29,1198,30],\"els\":[\"0:3502:1180:76:557\",\"0:3502:1180:76:549\",\"0:3773:517\"]},{\"tk\":[1198,30,1198,31],\"els\":[\"0:3502:1180:76:614\",\"0:3773:517\"]},{\"tk\":[1198,31,1198,38],\"els\":[\"0:3773:517\"]},{\"tk\":[1198,38,1198,39],\"els\":[\"0:3773:517\"]},{\"tk\":[1198,39,1198,40],\"els\":[\"0:3773:517\"]},{\"tk\":[1198,40,1198,41],\"els\":[\"0:3502:1180:76:614\",\"0:3502:1180:76:610\",\"0:3773:517\"]},{\"tk\":[1198,41,1198,49],\"els\":[\"0:3773:517\"]},{\"tk\":[1198,49,1198,50],\"els\":[\"0:3773:517\"]},{\"tk\":[1199,13,1199,44],\"els\":[\"0:3502:1180:76:657\",\"0:3773:517\"]},{\"tk\":[1199,44,1199,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1199,45,1199,57],\"els\":[\"0:3502:1180:76:657\",\"0:3773:517\"]},{\"tk\":[1199,57,1199,58],\"els\":[\"0:3502:1180:76:610\",\"0:3502:1180:76:657\",\"0:3502:1180:76:557\",\"0:3773:517\"]},{\"tk\":[1199,58,1199,59],\"els\":[\"0:3502:1180:76:610\",\"0:3502:1180:76:657\",\"0:3773:517\"]},{\"tk\":[1199,59,1199,60],\"els\":[\"0:3773:517\"]},{\"tk\":[1199,61,1199,62],\"els\":[\"0:3502:1180:76:614\",\"0:3502:1180:76:610\",\"0:3773:517\"]},{\"tk\":[1199,63,1199,64],\"els\":[\"0:3502:1180:76:608\",\"0:3773:517\"]},{\"tk\":[1199,64,1199,72],\"els\":[\"0:3773:517\"]},{\"tk\":[1199,72,1199,73],\"els\":[\"0:3773:517\"]},{\"tk\":[1200,13,1200,25],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1200,25,1200,26],\"els\":[\"0:3773:517\"]},{\"tk\":[1200,26,1200,27],\"els\":[\"0:3773:517\"]},{\"tk\":[1200,28,1200,29],\"els\":[\"0:3502:1180:76:614\",\"0:3773:517\"]},{\"tk\":[1200,30,1200,47],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1200,47,1200,48],\"els\":[\"0:3773:517\"]},{\"tk\":[1200,49,1200,50],\"els\":[\"0:3502:1180:76:616\",\"0:3773:517\"]},{\"tk\":[1200,51,1200,63],\"els\":[\"0:3502:1176:436#out:1\",\"0:3773:517\"]},{\"tk\":[1200,64,1200,65],\"els\":[\"0:3502:1180:76:615\",\"0:3773:517\"]},{\"tk\":[1201,28,1201,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1201,45,1201,46],\"els\":[\"0:3773:517\"]},{\"tk\":[1202,28,1202,29],\"els\":[\"0:3773:517\"]},{\"tk\":[1202,29,1202,60],\"els\":[\"0:3502:1180:76:549\",\"0:3773:517\"]},{\"tk\":[1202,60,1202,61],\"els\":[\"0:3773:517\"]},{\"tk\":[1202,61,1202,84],\"els\":[\"0:3502:1180:76:549\",\"0:3773:517\"]},{\"tk\":[1203,29,1203,30],\"els\":[\"0:3502:1180:76:557\",\"0:3502:1180:76:549\",\"0:3773:517\"]},{\"tk\":[1203,30,1203,31],\"els\":[\"0:3502:1180:76:622\",\"0:3773:517\"]},{\"tk\":[1203,31,1203,38],\"els\":[\"0:3773:517\"]},{\"tk\":[1203,38,1203,39],\"els\":[\"0:3773:517\"]},{\"tk\":[1203,39,1203,40],\"els\":[\"0:3773:517\"]},{\"tk\":[1203,40,1203,41],\"els\":[\"0:3502:1180:76:622\",\"0:3502:1180:76:610\",\"0:3773:517\"]},{\"tk\":[1203,41,1203,49],\"els\":[\"0:3773:517\"]},{\"tk\":[1203,49,1203,50],\"els\":[\"0:3773:517\"]},{\"tk\":[1204,13,1204,44],\"els\":[\"0:3502:1180:76:657\",\"0:3773:517\"]},{\"tk\":[1204,44,1204,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1204,45,1204,57],\"els\":[\"0:3502:1180:76:657\",\"0:3773:517\"]},{\"tk\":[1204,57,1204,58],\"els\":[\"0:3502:1180:76:610\",\"0:3502:1180:76:657\",\"0:3502:1180:76:557\",\"0:3773:517\"]},{\"tk\":[1204,58,1204,59],\"els\":[\"0:3502:1180:76:610\",\"0:3502:1180:76:657\",\"0:3773:517\"]},{\"tk\":[1204,59,1204,60],\"els\":[\"0:3773:517\"]},{\"tk\":[1204,61,1204,62],\"els\":[\"0:3502:1180:76:622\",\"0:3502:1180:76:610\",\"0:3773:517\"]},{\"tk\":[1204,63,1204,64],\"els\":[\"0:3502:1180:76:608\",\"0:3773:517\"]},{\"tk\":[1204,64,1204,72],\"els\":[\"0:3773:517\"]},{\"tk\":[1204,72,1204,73],\"els\":[\"0:3773:517\"]},{\"tk\":[1205,13,1205,25],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1205,25,1205,26],\"els\":[\"0:3773:517\"]},{\"tk\":[1205,26,1205,27],\"els\":[\"0:3773:517\"]},{\"tk\":[1205,28,1205,29],\"els\":[\"0:3502:1180:76:622\",\"0:3773:517\"]},{\"tk\":[1205,30,1205,35],\"els\":[\"0:3502:1180:76:557\",\"0:3773:517\"]},{\"tk\":[1205,35,1205,36],\"els\":[\"0:3773:517\"]},{\"tk\":[1205,37,1205,38],\"els\":[\"0:3502:1180:76:621\",\"0:3773:517\"]},{\"tk\":[1205,39,1205,51],\"els\":[\"0:3502:1176:436#out:1\",\"0:3773:517\"]},{\"tk\":[1205,52,1205,53],\"els\":[\"0:3502:1180:76:623\",\"0:3773:517\"]},{\"tk\":[1205,54,1205,59],\"els\":[\"0:3773:517\"]},{\"tk\":[1205,59,1205,60],\"els\":[\"0:3773:517\"]},{\"tk\":[1205,60,1205,61],\"els\":[\"0:3773:517\"]},{\"tk\":[1222,11,1222,13],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1222,14,1222,15],\"els\":[\"0:3773:517\"]},{\"tk\":[1222,15,1222,46],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1222,46,1222,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1222,47,1222,78],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1222,78,1222,79],\"els\":[\"0:3773:517\"]},{\"tk\":[1222,80,1222,81],\"els\":[\"0:3773:517\"]},{\"tk\":[1224,13,1224,30],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1224,31,1224,32],\"els\":[\"0:3502:1177:492\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1225,15,1225,46],\"els\":[\"0:3502:1177:492\",\"0:3773:517\"]},{\"tk\":[1225,46,1225,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1225,47,1225,64],\"els\":[\"0:3502:1177:492\",\"0:3773:517\"]},{\"tk\":[1225,65,1225,66],\"els\":[\"0:3502:1177:492\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1225,67,1225,79],\"els\":[\"0:3502:1176:761\",\"0:3773:517\"]},{\"tk\":[1225,79,1225,80],\"els\":[\"0:3773:517\"]},{\"tk\":[1228,13,1228,25],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1228,26,1228,27],\"els\":[\"0:3502:1177:493\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1228,28,1228,59],\"els\":[\"0:3502:1177:493\",\"0:3773:517\"]},{\"tk\":[1228,59,1228,60],\"els\":[\"0:3773:517\"]},{\"tk\":[1228,60,1228,75],\"els\":[\"0:3502:1177:493\",\"0:3773:517\"]},{\"tk\":[1228,76,1228,77],\"els\":[\"0:3502:1177:493\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1229,15,1229,28],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1229,28,1229,29],\"els\":[\"0:3773:517\"]},{\"tk\":[1230,13,1230,27],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1230,28,1230,29],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1230,30,1230,31],\"els\":[\"0:3773:517\"]},{\"tk\":[1230,31,1230,62],\"els\":[\"0:3502:1177:565\",\"0:3773:517\"]},{\"tk\":[1230,62,1230,63],\"els\":[\"0:3773:517\"]},{\"tk\":[1230,63,1230,70],\"els\":[\"0:3502:1177:565\",\"0:3773:517\"]},{\"tk\":[1230,71,1230,72],\"els\":[\"0:3502:1177:565\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1231,31,1231,44],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1231,45,1231,46],\"els\":[\"0:3378\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1232,31,1232,62],\"els\":[\"0:3373\",\"0:3773:517\"]},{\"tk\":[1232,62,1232,63],\"els\":[\"0:3773:517\"]},{\"tk\":[1232,63,1232,77],\"els\":[\"0:3373\",\"0:3773:517\"]},{\"tk\":[1232,77,1232,78],\"els\":[\"0:3773:517\"]},{\"tk\":[1232,79,1232,80],\"els\":[\"0:3375\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1233,15,1233,46],\"els\":[\"0:3375\",\"0:3773:517\"]},{\"tk\":[1233,46,1233,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1233,47,1233,56],\"els\":[\"0:3375\",\"0:3773:517\"]},{\"tk\":[1233,57,1233,58],\"els\":[\"0:3377\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1234,15,1234,46],\"els\":[\"0:3668\",\"0:3773:517\"]},{\"tk\":[1234,46,1234,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1234,47,1234,62],\"els\":[\"0:3668\",\"0:3773:517\"]},{\"tk\":[1234,62,1234,63],\"els\":[\"0:3773:517\"]},{\"tk\":[1235,13,1235,26],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1235,27,1235,28],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1235,29,1235,30],\"els\":[\"0:3773:517\"]},{\"tk\":[1235,30,1235,31],\"els\":[\"0:3773:517\"]},{\"tk\":[1235,31,1235,48],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1235,49,1235,50],\"els\":[\"0:3502:1177:490\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1235,51,1235,63],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1235,63,1235,64],\"els\":[\"0:3773:517\"]},{\"tk\":[1235,65,1235,66],\"els\":[\"0:3502:1177:566\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1236,30,1236,61],\"els\":[\"0:3502:1177:566\",\"0:3773:517\"]},{\"tk\":[1236,61,1236,62],\"els\":[\"0:3773:517\"]},{\"tk\":[1236,62,1236,69],\"els\":[\"0:3502:1177:566\",\"0:3773:517\"]},{\"tk\":[1236,70,1236,71],\"els\":[\"0:3378\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1237,30,1237,61],\"els\":[\"0:3373\",\"0:3773:517\"]},{\"tk\":[1237,61,1237,62],\"els\":[\"0:3773:517\"]},{\"tk\":[1237,62,1237,76],\"els\":[\"0:3373\",\"0:3773:517\"]},{\"tk\":[1237,76,1237,77],\"els\":[\"0:3773:517\"]},{\"tk\":[1237,78,1237,79],\"els\":[\"0:3375\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1238,15,1238,46],\"els\":[\"0:3375\",\"0:3773:517\"]},{\"tk\":[1238,46,1238,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1238,47,1238,56],\"els\":[\"0:3375\",\"0:3773:517\"]},{\"tk\":[1238,57,1238,58],\"els\":[\"0:3377\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1239,15,1239,46],\"els\":[\"0:3668\",\"0:3773:517\"]},{\"tk\":[1239,46,1239,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1239,47,1239,62],\"els\":[\"0:3668\",\"0:3773:517\"]},{\"tk\":[1239,62,1239,63],\"els\":[\"0:3773:517\"]},{\"tk\":[1240,13,1240,30],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1240,31,1240,32],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1240,33,1240,34],\"els\":[\"0:3773:517\"]},{\"tk\":[1240,34,1240,35],\"els\":[\"0:3773:517\"]},{\"tk\":[1240,35,1240,36],\"els\":[\"0:3773:517\"]},{\"tk\":[1240,36,1240,40],\"els\":[\"0:3502:1177:499\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1240,41,1240,42],\"els\":[\"0:3502:1177:499\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1240,43,1240,55],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1240,55,1240,56],\"els\":[\"0:3773:517\"]},{\"tk\":[1240,57,1240,58],\"els\":[\"0:3502:1177:499\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1240,59,1240,76],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1240,76,1240,77],\"els\":[\"0:3773:517\"]},{\"tk\":[1240,78,1240,79],\"els\":[\"0:3502:1177:567\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1241,34,1241,65],\"els\":[\"0:3502:1177:567\",\"0:3773:517\"]},{\"tk\":[1241,65,1241,66],\"els\":[\"0:3773:517\"]},{\"tk\":[1241,66,1241,73],\"els\":[\"0:3502:1177:567\",\"0:3773:517\"]},{\"tk\":[1241,74,1241,75],\"els\":[\"0:3378\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1242,34,1242,65],\"els\":[\"0:3373\",\"0:3773:517\"]},{\"tk\":[1242,65,1242,66],\"els\":[\"0:3773:517\"]},{\"tk\":[1242,66,1242,80],\"els\":[\"0:3373\",\"0:3773:517\"]},{\"tk\":[1242,80,1242,81],\"els\":[\"0:3773:517\"]},{\"tk\":[1243,15,1243,16],\"els\":[\"0:3375\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1243,17,1243,48],\"els\":[\"0:3375\",\"0:3773:517\"]},{\"tk\":[1243,48,1243,49],\"els\":[\"0:3773:517\"]},{\"tk\":[1243,49,1243,58],\"els\":[\"0:3375\",\"0:3773:517\"]},{\"tk\":[1243,59,1243,60],\"els\":[\"0:3377\",\"0:3385\",\"0:3773:517\"]},{\"tk\":[1244,15,1244,46],\"els\":[\"0:3668\",\"0:3773:517\"]},{\"tk\":[1244,46,1244,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1244,47,1244,62],\"els\":[\"0:3668\",\"0:3773:517\"]},{\"tk\":[1244,62,1244,63],\"els\":[\"0:3773:517\"]},{\"tk\":[1245,11,1245,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1245,13,1245,17],\"els\":[\"0:3773:517\"]},{\"tk\":[1245,18,1245,19],\"els\":[\"0:3773:517\"]},{\"tk\":[1246,13,1246,27],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1246,28,1246,29],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1246,30,1246,61],\"els\":[\"0:3389\",\"0:3773:517\"]},{\"tk\":[1246,61,1246,62],\"els\":[\"0:3773:517\"]},{\"tk\":[1246,62,1246,72],\"els\":[\"0:3389\",\"0:3773:517\"]},{\"tk\":[1246,72,1246,73],\"els\":[\"0:3773:517\"]},{\"tk\":[1247,13,1247,26],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1247,27,1247,28],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1247,29,1247,60],\"els\":[\"0:3389\",\"0:3773:517\"]},{\"tk\":[1247,60,1247,61],\"els\":[\"0:3773:517\"]},{\"tk\":[1247,61,1247,71],\"els\":[\"0:3389\",\"0:3773:517\"]},{\"tk\":[1247,71,1247,72],\"els\":[\"0:3773:517\"]},{\"tk\":[1248,13,1248,30],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1248,31,1248,32],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1248,33,1248,64],\"els\":[\"0:3389\",\"0:3773:517\"]},{\"tk\":[1248,64,1248,65],\"els\":[\"0:3773:517\"]},{\"tk\":[1248,65,1248,75],\"els\":[\"0:3389\",\"0:3773:517\"]},{\"tk\":[1248,75,1248,76],\"els\":[\"0:3773:517\"]},{\"tk\":[1249,11,1249,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1254,11,1254,43],\"els\":[\"0:3778:2103\",\"0:3773:517\"]},{\"tk\":[1255,13,1255,14],\"els\":[\"0:3773:517\"]},{\"tk\":[1255,14,1255,45],\"els\":[\"0:3778:2103\",\"0:3773:517\"]},{\"tk\":[1255,45,1255,46],\"els\":[\"0:3773:517\"]},{\"tk\":[1255,46,1255,51],\"els\":[\"0:3778:2103\",\"0:3773:517\"]},{\"tk\":[1255,51,1255,52],\"els\":[\"0:3773:517\"]},{\"tk\":[1255,52,1255,63],\"els\":[\"0:3773:517\"]},{\"tk\":[1255,63,1255,64],\"els\":[\"0:3773:517\"]},{\"tk\":[1255,65,1255,79],\"els\":[\"0:3502:1180:76:621#out:1\",\"0:3773:517\"]},{\"tk\":[1255,79,1255,80],\"els\":[\"0:3773:517\"]},{\"tk\":[1255,80,1255,81],\"els\":[\"0:3773:517\"]},{\"tk\":[1256,11,1256,43],\"els\":[\"0:3778:2103\",\"0:3773:517\"]},{\"tk\":[1257,13,1257,14],\"els\":[\"0:3773:517\"]},{\"tk\":[1257,14,1257,45],\"els\":[\"0:3778:2103\",\"0:3773:517\"]},{\"tk\":[1257,45,1257,46],\"els\":[\"0:3773:517\"]},{\"tk\":[1257,46,1257,51],\"els\":[\"0:3778:2103\",\"0:3773:517\"]},{\"tk\":[1257,51,1257,52],\"els\":[\"0:3773:517\"]},{\"tk\":[1257,52,1257,63],\"els\":[\"0:3773:517\"]},{\"tk\":[1257,63,1257,64],\"els\":[\"0:3773:517\"]},{\"tk\":[1257,65,1257,78],\"els\":[\"0:3502:1180:76:616#out:1\",\"0:3773:517\"]},{\"tk\":[1257,78,1257,79],\"els\":[\"0:3773:517\"]},{\"tk\":[1257,79,1257,80],\"els\":[\"0:3773:517\"]},{\"tk\":[1258,11,1258,43],\"els\":[\"0:3778:2103\",\"0:3773:517\"]},{\"tk\":[1259,13,1259,14],\"els\":[\"0:3773:517\"]},{\"tk\":[1259,14,1259,45],\"els\":[\"0:3778:2103\",\"0:3773:517\"]},{\"tk\":[1259,45,1259,46],\"els\":[\"0:3773:517\"]},{\"tk\":[1259,46,1259,51],\"els\":[\"0:3778:2103\",\"0:3773:517\"]},{\"tk\":[1259,51,1259,52],\"els\":[\"0:3773:517\"]},{\"tk\":[1259,52,1259,63],\"els\":[\"0:3773:517\"]},{\"tk\":[1259,63,1259,64],\"els\":[\"0:3773:517\"]},{\"tk\":[1260,14,1260,31],\"els\":[\"0:3385\",\"0:3773:517\"]},{\"tk\":[1260,31,1260,32],\"els\":[\"0:3773:517\"]},{\"tk\":[1260,32,1260,33],\"els\":[\"0:3773:517\"]},{\"tk\":[1263,11,1263,30],\"els\":[\"0:3774:462\",\"0:3773:517\"]},{\"tk\":[1263,30,1263,31],\"els\":[\"0:3773:517\"]},{\"tk\":[1263,31,1263,62],\"els\":[\"0:3774:462\",\"0:3773:517\"]},{\"tk\":[1263,62,1263,63],\"els\":[\"0:3773:517\"]},{\"tk\":[1263,63,1263,68],\"els\":[\"0:3774:462\",\"0:3773:517\"]},{\"tk\":[1263,68,1263,69],\"els\":[\"0:3773:517\"]},{\"tk\":[1263,69,1263,78],\"els\":[\"0:3773:517\"]},{\"tk\":[1263,78,1263,79],\"els\":[\"0:3773:517\"]},{\"tk\":[1264,31,1264,39],\"els\":[\"0:3774:462\",\"0:3773:517\"]},{\"tk\":[1264,39,1264,40],\"els\":[\"0:3773:517\"]},{\"tk\":[1264,41,1264,42],\"els\":[\"0:3773:517\"]},{\"tk\":[1264,42,1264,45],\"els\":[\"0:3774:462\",\"0:3773:517\"]},{\"tk\":[1264,45,1264,46],\"els\":[\"0:3774:462\",\"0:3773:517\"]},{\"tk\":[1264,46,1264,47],\"els\":[\"0:3774:462\",\"0:3773:517\"]},{\"tk\":[1264,47,1264,48],\"els\":[\"0:3773:517\"]},{\"tk\":[1264,48,1264,49],\"els\":[\"0:3773:517\"]},{\"tk\":[1264,49,1264,50],\"els\":[\"0:3773:517\"]},{\"tk\":[1272,11,1272,42],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1272,42,1272,43],\"els\":[\"0:3773:517\"]},{\"tk\":[1272,43,1272,63],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1272,64,1272,66],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1273,13,1273,44],\"els\":[\"0:3301\",\"0:3773:517\"]},{\"tk\":[1273,44,1273,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1273,45,1273,54],\"els\":[\"0:3301\",\"0:3773:517\"]},{\"tk\":[1273,55,1273,56],\"els\":[\"0:3299\",\"0:3773:517\"]},{\"tk\":[1274,13,1274,44],\"els\":[\"0:3305\",\"0:3773:517\"]},{\"tk\":[1274,44,1274,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1274,45,1274,63],\"els\":[\"0:3305\",\"0:3773:517\"]},{\"tk\":[1274,64,1274,65],\"els\":[\"0:3303\",\"0:3773:517\"]},{\"tk\":[1275,13,1275,44],\"els\":[\"0:3303\",\"0:3773:517\"]},{\"tk\":[1275,44,1275,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1275,45,1275,47],\"els\":[\"0:3303\",\"0:3773:517\"]},{\"tk\":[1275,48,1275,49],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1276,13,1276,44],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1276,44,1276,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1276,45,1276,66],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1276,66,1276,67],\"els\":[\"0:3773:517\"]},{\"tk\":[1277,11,1277,13],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1277,14,1277,15],\"els\":[\"0:3773:517\"]},{\"tk\":[1277,15,1277,46],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1277,46,1277,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1277,47,1277,67],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1277,68,1277,69],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1278,15,1278,46],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1278,46,1278,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1278,47,1278,69],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1278,69,1278,70],\"els\":[\"0:3773:517\"]},{\"tk\":[1278,71,1278,72],\"els\":[\"0:3773:517\"]},{\"tk\":[1279,13,1279,44],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1279,44,1279,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1279,45,1279,65],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1279,66,1279,67],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1280,15,1280,46],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1280,46,1280,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1280,47,1280,69],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1280,69,1280,70],\"els\":[\"0:3773:517\"]},{\"tk\":[1281,11,1281,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1281,13,1281,17],\"els\":[\"0:3773:517\"]},{\"tk\":[1281,18,1281,20],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1281,21,1281,22],\"els\":[\"0:3773:517\"]},{\"tk\":[1281,22,1281,53],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1281,53,1281,54],\"els\":[\"0:3773:517\"]},{\"tk\":[1281,54,1281,74],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1281,75,1281,76],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1282,22,1282,53],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1282,53,1282,54],\"els\":[\"0:3773:517\"]},{\"tk\":[1282,54,1282,76],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1282,76,1282,77],\"els\":[\"0:3773:517\"]},{\"tk\":[1282,78,1282,79],\"els\":[\"0:3773:517\"]},{\"tk\":[1283,13,1283,44],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1283,44,1283,45],\"els\":[\"0:3773:517\"]},{\"tk\":[1283,45,1283,65],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1283,66,1283,67],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1284,15,1284,46],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1284,46,1284,47],\"els\":[\"0:3773:517\"]},{\"tk\":[1284,47,1284,69],\"els\":[\"0:3302\",\"0:3773:517\"]},{\"tk\":[1284,69,1284,70],\"els\":[\"0:3773:517\"]},{\"tk\":[1285,11,1285,12],\"els\":[\"0:3773:517\"]},{\"tk\":[1288,9,1288,10],\"els\":[\"0:3773:517\"]}]}}}","blocks":[{"RTWName":"<S7>/u1","SIDString":"mcb_open_loop_control_nucleo_f401re:3911:6"},{"RTWName":"<S7>/u2","SIDString":"mcb_open_loop_control_nucleo_f401re:3911:7"},{"RTWName":"<S7>/BitConcat2","SIDString":"mcb_open_loop_control_nucleo_f401re:3911:1"},{"RTWName":"<S7>/y","SIDString":"mcb_open_loop_control_nucleo_f401re:3911:8"},{"RTWName":"<S1>/Byte Unpack","SIDString":"mcb_open_loop_control_nucleo_f401re:3912"},{"RTWName":"<S1>/Byte Unpack1","SIDString":"mcb_open_loop_control_nucleo_f401re:3913"},{"RTWName":"<S1>/Byte Unpack2","SIDString":"mcb_open_loop_control_nucleo_f401re:3914"},{"RTWName":"<S1>/Byte Unpack3","SIDString":"mcb_open_loop_control_nucleo_f401re:3915"},{"RTWName":"<S1>/CAN Read","SIDString":"mcb_open_loop_control_nucleo_f401re:3916"},{"RTWName":"<S1>/CAN Unpack","SIDString":"mcb_open_loop_control_nucleo_f401re:3917"},{"RTWName":"<S1>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3918"},{"RTWName":"<S1>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3919"},{"RTWName":"<S1>/Demux","SIDString":"mcb_open_loop_control_nucleo_f401re:3920"},{"RTWName":"<S8>/u","SIDString":"mcb_open_loop_control_nucleo_f401re:3921:1"},{"RTWName":"<S8>/DTProp1","SIDString":"mcb_open_loop_control_nucleo_f401re:3921:2"},{"RTWName":"<S8>/DTProp2","SIDString":"mcb_open_loop_control_nucleo_f401re:3921:3"},{"RTWName":"<S8>/Extract Desired Bits","SIDString":"mcb_open_loop_control_nucleo_f401re:3921:4"},{"RTWName":"<S8>/Modify Scaling Only","SIDString":"mcb_open_loop_control_nucleo_f401re:3921:5"},{"RTWName":"<S8>/y","SIDString":"mcb_open_loop_control_nucleo_f401re:3921:6"},{"RTWName":"<S9>/u","SIDString":"mcb_open_loop_control_nucleo_f401re:3922:1"},{"RTWName":"<S9>/DTProp1","SIDString":"mcb_open_loop_control_nucleo_f401re:3922:2"},{"RTWName":"<S9>/DTProp2","SIDString":"mcb_open_loop_control_nucleo_f401re:3922:3"},{"RTWName":"<S9>/Extract Desired Bits","SIDString":"mcb_open_loop_control_nucleo_f401re:3922:4"},{"RTWName":"<S9>/Modify Scaling Only","SIDString":"mcb_open_loop_control_nucleo_f401re:3922:5"},{"RTWName":"<S9>/y","SIDString":"mcb_open_loop_control_nucleo_f401re:3922:6"},{"RTWName":"<S1>/START STOP","SIDString":"mcb_open_loop_control_nucleo_f401re:3923"},{"RTWName":"<S1>/DEFINE RPM","SIDString":"mcb_open_loop_control_nucleo_f401re:3924"},{"RTWName":"<S1>/DIRECTION ROTATION","SIDString":"mcb_open_loop_control_nucleo_f401re:3925"},{"RTWName":"<S2>/Input","SIDString":"mcb_open_loop_control_nucleo_f401re:3961"},{"RTWName":"<S2>/Input1","SIDString":"mcb_open_loop_control_nucleo_f401re:3962"},{"RTWName":"<S2>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3966"},{"RTWName":"<S2>/In2","SIDString":"mcb_open_loop_control_nucleo_f401re:3993"},{"RTWName":"<S2>/CAN Write","SIDString":"mcb_open_loop_control_nucleo_f401re:3906"},{"RTWName":"<S2>/Mux","SIDString":"mcb_open_loop_control_nucleo_f401re:3952"},{"RTWName":"<S3>/IN RPM","SIDString":"mcb_open_loop_control_nucleo_f401re:3927"},{"RTWName":"<S3>/DIRECTION","SIDString":"mcb_open_loop_control_nucleo_f401re:3928"},{"RTWName":"<S3>/Gain","SIDString":"mcb_open_loop_control_nucleo_f401re:3929"},{"RTWName":"<S3>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3930"},{"RTWName":"<S3>/Rpm Out","SIDString":"mcb_open_loop_control_nucleo_f401re:3931"},{"RTWName":"<S4>/Demux","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:21"},{"RTWName":"<S10>/data","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:514"},{"RTWName":"<S11>/data","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:516"},{"RTWName":"<S11>/Hardware Interrupt","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:517"},{"RTWName":"<S11>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:518"},{"RTWName":"<S11>/msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:519"},{"RTWName":"<S4294967295>/data","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:521"},{"RTWName":"<S4294967295>/msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:522"},{"RTWName":"<S10>/msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:523"},{"RTWName":"<S4>/EXTI0 Event Task","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:598"},{"RTWName":"<S4>/Mux","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:177"},{"RTWName":"<S4>/ADC1 Inj EoCS","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:101"},{"RTWName":"<Root>/Number Control Safety","SIDString":"mcb_open_loop_control_nucleo_f401re:3967"},{"RTWName":"<Root>/Number ID ECU1","SIDString":"mcb_open_loop_control_nucleo_f401re:3968"},{"RTWName":"<S5>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3648"},{"RTWName":"<S5>/Speed_ref_RPM","SIDString":"mcb_open_loop_control_nucleo_f401re:3280"},{"RTWName":"<S5>/ADC Interrupt","SIDString":"mcb_open_loop_control_nucleo_f401re:3281"},{"RTWName":"<S18>/Analog to Digital Converter","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:462"},{"RTWName":"<S18>/Cnts","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1082"},{"RTWName":"<S4294967295>/msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1064"},{"RTWName":"<S22>/msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1066"},{"RTWName":"<S22>/Trigger","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1067"},{"RTWName":"<S22>/Ground","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1068"},{"RTWName":"<S23>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:228"},{"RTWName":"<S23>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:269"},{"RTWName":"<S23>/Data Unpack","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:271"},{"RTWName":"<S24>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:254"},{"RTWName":"<S25>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:251"},{"RTWName":"<S25>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:266"},{"RTWName":"<S25>/MessageSend","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:244"},{"RTWName":"<S25>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:252"},{"RTWName":"<S24>/ Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:255"},{"RTWName":"<S23>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:237"},{"RTWName":"<S23>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:270"},{"RTWName":"<S23>/Width","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:267"},{"RTWName":"<S23>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:241"},{"RTWName":"<S23>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:242"},{"RTWName":"<S23>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:243"},{"RTWName":"<S23>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:245"},{"RTWName":"<S22>/TerminateDone","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1070"},{"RTWName":"<S22>/TerminateLength","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1071"},{"RTWName":"<S22>/TerminateValid","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1072"},{"RTWName":"<S22>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1073"},{"RTWName":"<S22>/Cnts","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1074"},{"RTWName":"<S22>/Status","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1075"},{"RTWName":"<S4294967295>/Status","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1085"},{"RTWName":"<S4294967295>/Trigger","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1076"},{"RTWName":"<S4294967295>/Cnts","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1077"},{"RTWName":"<S17>/Cnts","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1083"},{"RTWName":"<S12>/Cnts","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1084"},{"RTWName":"<S5>/Boost Voltage","SIDString":"mcb_open_loop_control_nucleo_f401re:3607"},{"RTWName":"<S13>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3647"},{"RTWName":"<S13>/PWM Duty Cycle","SIDString":"mcb_open_loop_control_nucleo_f401re:3427"},{"RTWName":"<S19>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3649"},{"RTWName":"<S19>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3583"},{"RTWName":"<S21>/Pin 10","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:341"},{"RTWName":"<S21>/Pin 11","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:550"},{"RTWName":"<S21>/Pin 12","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:551"},{"RTWName":"<S22>/Pin 10","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:346"},{"RTWName":"<S22>/Pin 11","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:548"},{"RTWName":"<S22>/Pin 12","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:549"},{"RTWName":"<S23>/Pin 10","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:351"},{"RTWName":"<S23>/Pin 11","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:546"},{"RTWName":"<S23>/Pin 12","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:547"},{"RTWName":"<S23>/Digital Port Write","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:355"},{"RTWName":"<S4294967295>/Pin 1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:357"},{"RTWName":"<S4294967295>/Pin 2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:358"},{"RTWName":"<S4294967295>/Pin 3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:359"},{"RTWName":"<S4294967295>/Pin 0","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:360"},{"RTWName":"<S4294967295>/Pin(s)","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:545"},{"RTWName":"<S4294967295>/Pin 10","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:361"},{"RTWName":"<S4294967295>/Pin 11","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:362"},{"RTWName":"<S4294967295>/Pin 12","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:363"},{"RTWName":"<S4294967295>/Pin 13","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:364"},{"RTWName":"<S4294967295>/Pin 14","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:365"},{"RTWName":"<S4294967295>/Pin 15","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:366"},{"RTWName":"<S4294967295>/Pin 4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:367"},{"RTWName":"<S4294967295>/Pin 5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:368"},{"RTWName":"<S4294967295>/Pin 6","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:369"},{"RTWName":"<S4294967295>/Pin 7","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:370"},{"RTWName":"<S4294967295>/Pin 8","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:371"},{"RTWName":"<S4294967295>/Pin 9","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:372"},{"RTWName":"<S32>/Pin(s)","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:375"},{"RTWName":"<S32>/Pin 0","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:376"},{"RTWName":"<S32>/Pin 1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:377"},{"RTWName":"<S32>/Pin 2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:378"},{"RTWName":"<S32>/Pin 3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:379"},{"RTWName":"<S32>/Pin 4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:380"},{"RTWName":"<S32>/Pin 5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:381"},{"RTWName":"<S32>/Pin 6","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:382"},{"RTWName":"<S32>/Pin 7","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:383"},{"RTWName":"<S32>/Pin 8","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:384"},{"RTWName":"<S32>/Pin 9","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:385"},{"RTWName":"<S32>/Pin 10","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:386"},{"RTWName":"<S32>/Pin 11","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:387"},{"RTWName":"<S32>/Pin 12","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:388"},{"RTWName":"<S32>/Pin 13","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:389"},{"RTWName":"<S32>/Pin 14","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:390"},{"RTWName":"<S32>/Pin 15","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:391"},{"RTWName":"<S32>/ConstValid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:392"},{"RTWName":"<S32>/ConstValid1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:393"},{"RTWName":"<S32>/ConstValid10","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:394"},{"RTWName":"<S32>/ConstValid11","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:395"},{"RTWName":"<S32>/ConstValid12","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:396"},{"RTWName":"<S32>/ConstValid13","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:397"},{"RTWName":"<S32>/ConstValid14","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:398"},{"RTWName":"<S32>/ConstValid15","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:399"},{"RTWName":"<S32>/ConstValid16","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:400"},{"RTWName":"<S32>/ConstValid2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:401"},{"RTWName":"<S32>/ConstValid3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:402"},{"RTWName":"<S32>/ConstValid4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:403"},{"RTWName":"<S32>/ConstValid5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:404"},{"RTWName":"<S32>/ConstValid6","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:405"},{"RTWName":"<S32>/ConstValid7","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:406"},{"RTWName":"<S32>/ConstValid8","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:407"},{"RTWName":"<S32>/ConstValid9","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:408"},{"RTWName":"<S32>/Data Type Conversion","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:409"},{"RTWName":"<S32>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:410"},{"RTWName":"<S32>/Data Type Conversion10","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:411"},{"RTWName":"<S32>/Data Type Conversion11","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:412"},{"RTWName":"<S32>/Data Type Conversion12","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:413"},{"RTWName":"<S32>/Data Type Conversion13","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:414"},{"RTWName":"<S32>/Data Type Conversion14","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:415"},{"RTWName":"<S32>/Data Type Conversion15","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:416"},{"RTWName":"<S32>/Data Type Conversion16","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:417"},{"RTWName":"<S32>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:418"},{"RTWName":"<S32>/Data Type Conversion3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:419"},{"RTWName":"<S32>/Data Type Conversion4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:420"},{"RTWName":"<S32>/Data Type Conversion5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:421"},{"RTWName":"<S32>/Data Type Conversion6","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:422"},{"RTWName":"<S32>/Data Type Conversion7","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:423"},{"RTWName":"<S32>/Data Type Conversion8","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:424"},{"RTWName":"<S32>/Data Type Conversion9","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:425"},{"RTWName":"<S32>/GroundDone","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:426"},{"RTWName":"<S32>/GroundDone1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:427"},{"RTWName":"<S32>/GroundDone10","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:428"},{"RTWName":"<S32>/GroundDone11","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:429"},{"RTWName":"<S32>/GroundDone12","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:430"},{"RTWName":"<S32>/GroundDone13","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:431"},{"RTWName":"<S32>/GroundDone14","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:432"},{"RTWName":"<S32>/GroundDone15","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:433"},{"RTWName":"<S32>/GroundDone16","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:434"},{"RTWName":"<S32>/GroundDone2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:435"},{"RTWName":"<S32>/GroundDone3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:436"},{"RTWName":"<S32>/GroundDone4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:437"},{"RTWName":"<S32>/GroundDone5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:438"},{"RTWName":"<S32>/GroundDone6","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:439"},{"RTWName":"<S32>/GroundDone7","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:440"},{"RTWName":"<S32>/GroundDone8","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:441"},{"RTWName":"<S32>/GroundDone9","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:442"},{"RTWName":"<S33>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:244"},{"RTWName":"<S33>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:246"},{"RTWName":"<S33>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:245"},{"RTWName":"<S33>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:271"},{"RTWName":"<S33>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:358"},{"RTWName":"<S33>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:339"},{"RTWName":"<S33>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:340"},{"RTWName":"<S50>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:279"},{"RTWName":"<S50>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:280"},{"RTWName":"<S52>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:275"},{"RTWName":"<S52>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:360"},{"RTWName":"<S52>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:363"},{"RTWName":"<S52>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:355"},{"RTWName":"<S53>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:283"},{"RTWName":"<S53>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:284"},{"RTWName":"<S53>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:342"},{"RTWName":"<S53>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:343"},{"RTWName":"<S53>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:344"},{"RTWName":"<S53>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:345"},{"RTWName":"<S53>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:346"},{"RTWName":"<S53>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:365"},{"RTWName":"<S53>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:347"},{"RTWName":"<S53>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:364"},{"RTWName":"<S53>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:348"},{"RTWName":"<S53>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:349"},{"RTWName":"<S53>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:350"},{"RTWName":"<S53>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:351"},{"RTWName":"<S53>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:352"},{"RTWName":"<S53>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:285"},{"RTWName":"<S53>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:361"},{"RTWName":"<S50>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:281"},{"RTWName":"<S50>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:362"},{"RTWName":"<S51>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:249"},{"RTWName":"<S54>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:251"},{"RTWName":"<S54>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:253"},{"RTWName":"<S55>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:256"},{"RTWName":"<S55>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:257"},{"RTWName":"<S55>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:258"},{"RTWName":"<S55>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:259"},{"RTWName":"<S55>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:260"},{"RTWName":"<S51>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:261"},{"RTWName":"<S51>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:262"},{"RTWName":"<S33>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:264"},{"RTWName":"<S33>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:338"},{"RTWName":"<S33>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:270"},{"RTWName":"<S33>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:267"},{"RTWName":"<S33>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:272"},{"RTWName":"<S34>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:244"},{"RTWName":"<S34>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:246"},{"RTWName":"<S34>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:245"},{"RTWName":"<S34>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:271"},{"RTWName":"<S34>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:358"},{"RTWName":"<S34>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:339"},{"RTWName":"<S34>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:340"},{"RTWName":"<S56>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:279"},{"RTWName":"<S56>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:280"},{"RTWName":"<S58>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:275"},{"RTWName":"<S58>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:360"},{"RTWName":"<S58>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:363"},{"RTWName":"<S58>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:355"},{"RTWName":"<S59>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:283"},{"RTWName":"<S59>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:284"},{"RTWName":"<S59>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:342"},{"RTWName":"<S59>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:343"},{"RTWName":"<S59>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:344"},{"RTWName":"<S59>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:345"},{"RTWName":"<S59>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:346"},{"RTWName":"<S59>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:365"},{"RTWName":"<S59>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:347"},{"RTWName":"<S59>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:364"},{"RTWName":"<S59>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:348"},{"RTWName":"<S59>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:349"},{"RTWName":"<S59>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:350"},{"RTWName":"<S59>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:351"},{"RTWName":"<S59>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:352"},{"RTWName":"<S59>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:285"},{"RTWName":"<S59>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:361"},{"RTWName":"<S56>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:281"},{"RTWName":"<S56>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:362"},{"RTWName":"<S57>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:249"},{"RTWName":"<S60>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:251"},{"RTWName":"<S60>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:253"},{"RTWName":"<S61>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:256"},{"RTWName":"<S61>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:257"},{"RTWName":"<S61>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:258"},{"RTWName":"<S61>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:259"},{"RTWName":"<S61>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:260"},{"RTWName":"<S57>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:261"},{"RTWName":"<S57>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:262"},{"RTWName":"<S34>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:264"},{"RTWName":"<S34>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:338"},{"RTWName":"<S34>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:270"},{"RTWName":"<S34>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:267"},{"RTWName":"<S34>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:272"},{"RTWName":"<S35>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:244"},{"RTWName":"<S35>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:246"},{"RTWName":"<S35>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:245"},{"RTWName":"<S35>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:271"},{"RTWName":"<S35>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:358"},{"RTWName":"<S35>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:339"},{"RTWName":"<S35>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:340"},{"RTWName":"<S62>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:279"},{"RTWName":"<S62>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:280"},{"RTWName":"<S64>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:275"},{"RTWName":"<S64>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:360"},{"RTWName":"<S64>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:363"},{"RTWName":"<S64>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:355"},{"RTWName":"<S65>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:283"},{"RTWName":"<S65>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:284"},{"RTWName":"<S65>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:342"},{"RTWName":"<S65>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:343"},{"RTWName":"<S65>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:344"},{"RTWName":"<S65>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:345"},{"RTWName":"<S65>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:346"},{"RTWName":"<S65>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:365"},{"RTWName":"<S65>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:347"},{"RTWName":"<S65>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:364"},{"RTWName":"<S65>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:348"},{"RTWName":"<S65>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:349"},{"RTWName":"<S65>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:350"},{"RTWName":"<S65>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:351"},{"RTWName":"<S65>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:352"},{"RTWName":"<S65>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:285"},{"RTWName":"<S65>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:361"},{"RTWName":"<S62>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:281"},{"RTWName":"<S62>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:362"},{"RTWName":"<S63>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:249"},{"RTWName":"<S66>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:251"},{"RTWName":"<S66>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:253"},{"RTWName":"<S67>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:256"},{"RTWName":"<S67>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:257"},{"RTWName":"<S67>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:258"},{"RTWName":"<S67>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:259"},{"RTWName":"<S67>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:260"},{"RTWName":"<S63>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:261"},{"RTWName":"<S63>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:262"},{"RTWName":"<S35>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:264"},{"RTWName":"<S35>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:338"},{"RTWName":"<S35>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:270"},{"RTWName":"<S35>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:267"},{"RTWName":"<S35>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:272"},{"RTWName":"<S36>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:244"},{"RTWName":"<S36>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:246"},{"RTWName":"<S36>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:245"},{"RTWName":"<S36>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:271"},{"RTWName":"<S36>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:358"},{"RTWName":"<S36>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:339"},{"RTWName":"<S36>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:340"},{"RTWName":"<S68>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:279"},{"RTWName":"<S68>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:280"},{"RTWName":"<S70>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:275"},{"RTWName":"<S70>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:360"},{"RTWName":"<S70>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:363"},{"RTWName":"<S70>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:355"},{"RTWName":"<S71>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:283"},{"RTWName":"<S71>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:284"},{"RTWName":"<S71>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:342"},{"RTWName":"<S71>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:343"},{"RTWName":"<S71>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:344"},{"RTWName":"<S71>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:345"},{"RTWName":"<S71>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:346"},{"RTWName":"<S71>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:365"},{"RTWName":"<S71>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:347"},{"RTWName":"<S71>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:364"},{"RTWName":"<S71>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:348"},{"RTWName":"<S71>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:349"},{"RTWName":"<S71>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:350"},{"RTWName":"<S71>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:351"},{"RTWName":"<S71>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:352"},{"RTWName":"<S71>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:285"},{"RTWName":"<S71>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:361"},{"RTWName":"<S68>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:281"},{"RTWName":"<S68>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:362"},{"RTWName":"<S69>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:249"},{"RTWName":"<S72>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:251"},{"RTWName":"<S72>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:253"},{"RTWName":"<S73>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:256"},{"RTWName":"<S73>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:257"},{"RTWName":"<S73>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:258"},{"RTWName":"<S73>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:259"},{"RTWName":"<S73>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:260"},{"RTWName":"<S69>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:261"},{"RTWName":"<S69>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:262"},{"RTWName":"<S36>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:264"},{"RTWName":"<S36>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:338"},{"RTWName":"<S36>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:270"},{"RTWName":"<S36>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:267"},{"RTWName":"<S36>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:272"},{"RTWName":"<S37>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:244"},{"RTWName":"<S37>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:246"},{"RTWName":"<S37>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:245"},{"RTWName":"<S37>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:271"},{"RTWName":"<S37>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:358"},{"RTWName":"<S37>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:339"},{"RTWName":"<S37>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:340"},{"RTWName":"<S74>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:279"},{"RTWName":"<S74>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:280"},{"RTWName":"<S76>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:275"},{"RTWName":"<S76>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:360"},{"RTWName":"<S76>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:363"},{"RTWName":"<S76>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:355"},{"RTWName":"<S77>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:283"},{"RTWName":"<S77>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:284"},{"RTWName":"<S77>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:342"},{"RTWName":"<S77>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:343"},{"RTWName":"<S77>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:344"},{"RTWName":"<S77>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:345"},{"RTWName":"<S77>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:346"},{"RTWName":"<S77>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:365"},{"RTWName":"<S77>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:347"},{"RTWName":"<S77>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:364"},{"RTWName":"<S77>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:348"},{"RTWName":"<S77>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:349"},{"RTWName":"<S77>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:350"},{"RTWName":"<S77>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:351"},{"RTWName":"<S77>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:352"},{"RTWName":"<S77>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:285"},{"RTWName":"<S77>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:361"},{"RTWName":"<S74>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:281"},{"RTWName":"<S74>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:362"},{"RTWName":"<S75>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:249"},{"RTWName":"<S78>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:251"},{"RTWName":"<S78>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:253"},{"RTWName":"<S79>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:256"},{"RTWName":"<S79>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:257"},{"RTWName":"<S79>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:258"},{"RTWName":"<S79>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:259"},{"RTWName":"<S79>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:260"},{"RTWName":"<S75>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:261"},{"RTWName":"<S75>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:262"},{"RTWName":"<S37>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:264"},{"RTWName":"<S37>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:338"},{"RTWName":"<S37>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:270"},{"RTWName":"<S37>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:267"},{"RTWName":"<S37>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:272"},{"RTWName":"<S38>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:244"},{"RTWName":"<S38>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:246"},{"RTWName":"<S38>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:245"},{"RTWName":"<S38>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:271"},{"RTWName":"<S38>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:358"},{"RTWName":"<S38>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:339"},{"RTWName":"<S38>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:340"},{"RTWName":"<S80>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:279"},{"RTWName":"<S80>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:280"},{"RTWName":"<S82>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:275"},{"RTWName":"<S82>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:360"},{"RTWName":"<S82>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:363"},{"RTWName":"<S82>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:355"},{"RTWName":"<S83>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:283"},{"RTWName":"<S83>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:284"},{"RTWName":"<S83>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:342"},{"RTWName":"<S83>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:343"},{"RTWName":"<S83>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:344"},{"RTWName":"<S83>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:345"},{"RTWName":"<S83>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:346"},{"RTWName":"<S83>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:365"},{"RTWName":"<S83>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:347"},{"RTWName":"<S83>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:364"},{"RTWName":"<S83>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:348"},{"RTWName":"<S83>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:349"},{"RTWName":"<S83>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:350"},{"RTWName":"<S83>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:351"},{"RTWName":"<S83>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:352"},{"RTWName":"<S83>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:285"},{"RTWName":"<S83>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:361"},{"RTWName":"<S80>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:281"},{"RTWName":"<S80>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:362"},{"RTWName":"<S81>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:249"},{"RTWName":"<S84>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:251"},{"RTWName":"<S84>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:253"},{"RTWName":"<S85>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:256"},{"RTWName":"<S85>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:257"},{"RTWName":"<S85>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:258"},{"RTWName":"<S85>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:259"},{"RTWName":"<S85>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:260"},{"RTWName":"<S81>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:261"},{"RTWName":"<S81>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:262"},{"RTWName":"<S38>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:264"},{"RTWName":"<S38>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:338"},{"RTWName":"<S38>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:270"},{"RTWName":"<S38>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:267"},{"RTWName":"<S38>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:272"},{"RTWName":"<S39>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:244"},{"RTWName":"<S39>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:246"},{"RTWName":"<S39>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:245"},{"RTWName":"<S39>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:271"},{"RTWName":"<S39>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:358"},{"RTWName":"<S39>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:339"},{"RTWName":"<S39>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:340"},{"RTWName":"<S86>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:279"},{"RTWName":"<S86>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:280"},{"RTWName":"<S88>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:275"},{"RTWName":"<S88>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:360"},{"RTWName":"<S88>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:363"},{"RTWName":"<S88>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:355"},{"RTWName":"<S89>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:283"},{"RTWName":"<S89>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:284"},{"RTWName":"<S89>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:342"},{"RTWName":"<S89>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:343"},{"RTWName":"<S89>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:344"},{"RTWName":"<S89>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:345"},{"RTWName":"<S89>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:346"},{"RTWName":"<S89>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:365"},{"RTWName":"<S89>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:347"},{"RTWName":"<S89>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:364"},{"RTWName":"<S89>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:348"},{"RTWName":"<S89>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:349"},{"RTWName":"<S89>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:350"},{"RTWName":"<S89>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:351"},{"RTWName":"<S89>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:352"},{"RTWName":"<S89>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:285"},{"RTWName":"<S89>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:361"},{"RTWName":"<S86>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:281"},{"RTWName":"<S86>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:362"},{"RTWName":"<S87>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:249"},{"RTWName":"<S90>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:251"},{"RTWName":"<S90>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:253"},{"RTWName":"<S91>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:256"},{"RTWName":"<S91>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:257"},{"RTWName":"<S91>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:258"},{"RTWName":"<S91>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:259"},{"RTWName":"<S91>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:260"},{"RTWName":"<S87>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:261"},{"RTWName":"<S87>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:262"},{"RTWName":"<S39>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:264"},{"RTWName":"<S39>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:338"},{"RTWName":"<S39>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:270"},{"RTWName":"<S39>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:267"},{"RTWName":"<S39>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:272"},{"RTWName":"<S40>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:244"},{"RTWName":"<S40>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:246"},{"RTWName":"<S40>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:245"},{"RTWName":"<S40>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:271"},{"RTWName":"<S40>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:358"},{"RTWName":"<S40>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:339"},{"RTWName":"<S40>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:340"},{"RTWName":"<S92>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:279"},{"RTWName":"<S92>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:280"},{"RTWName":"<S94>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:275"},{"RTWName":"<S94>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:360"},{"RTWName":"<S94>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:363"},{"RTWName":"<S94>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:355"},{"RTWName":"<S95>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:283"},{"RTWName":"<S95>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:284"},{"RTWName":"<S95>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:342"},{"RTWName":"<S95>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:343"},{"RTWName":"<S95>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:344"},{"RTWName":"<S95>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:345"},{"RTWName":"<S95>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:346"},{"RTWName":"<S95>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:365"},{"RTWName":"<S95>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:347"},{"RTWName":"<S95>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:364"},{"RTWName":"<S95>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:348"},{"RTWName":"<S95>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:349"},{"RTWName":"<S95>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:350"},{"RTWName":"<S95>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:351"},{"RTWName":"<S95>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:352"},{"RTWName":"<S95>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:285"},{"RTWName":"<S95>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:361"},{"RTWName":"<S92>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:281"},{"RTWName":"<S92>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:362"},{"RTWName":"<S93>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:249"},{"RTWName":"<S96>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:251"},{"RTWName":"<S96>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:253"},{"RTWName":"<S97>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:256"},{"RTWName":"<S97>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:257"},{"RTWName":"<S97>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:258"},{"RTWName":"<S97>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:259"},{"RTWName":"<S97>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:260"},{"RTWName":"<S93>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:261"},{"RTWName":"<S93>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:262"},{"RTWName":"<S40>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:264"},{"RTWName":"<S40>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:338"},{"RTWName":"<S40>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:270"},{"RTWName":"<S40>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:267"},{"RTWName":"<S40>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:272"},{"RTWName":"<S41>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:244"},{"RTWName":"<S41>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:246"},{"RTWName":"<S41>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:245"},{"RTWName":"<S41>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:271"},{"RTWName":"<S41>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:358"},{"RTWName":"<S41>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:339"},{"RTWName":"<S41>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:340"},{"RTWName":"<S98>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:279"},{"RTWName":"<S98>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:280"},{"RTWName":"<S100>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:275"},{"RTWName":"<S100>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:360"},{"RTWName":"<S100>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:363"},{"RTWName":"<S100>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:355"},{"RTWName":"<S101>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:283"},{"RTWName":"<S101>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:284"},{"RTWName":"<S101>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:342"},{"RTWName":"<S101>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:343"},{"RTWName":"<S101>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:344"},{"RTWName":"<S101>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:345"},{"RTWName":"<S101>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:346"},{"RTWName":"<S101>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:365"},{"RTWName":"<S101>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:347"},{"RTWName":"<S101>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:364"},{"RTWName":"<S101>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:348"},{"RTWName":"<S101>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:349"},{"RTWName":"<S101>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:350"},{"RTWName":"<S101>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:351"},{"RTWName":"<S101>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:352"},{"RTWName":"<S101>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:285"},{"RTWName":"<S101>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:361"},{"RTWName":"<S98>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:281"},{"RTWName":"<S98>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:362"},{"RTWName":"<S99>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:249"},{"RTWName":"<S102>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:251"},{"RTWName":"<S102>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:253"},{"RTWName":"<S103>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:256"},{"RTWName":"<S103>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:257"},{"RTWName":"<S103>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:258"},{"RTWName":"<S103>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:259"},{"RTWName":"<S103>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:260"},{"RTWName":"<S99>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:261"},{"RTWName":"<S99>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:262"},{"RTWName":"<S41>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:264"},{"RTWName":"<S41>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:338"},{"RTWName":"<S41>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:270"},{"RTWName":"<S41>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:267"},{"RTWName":"<S41>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:272"},{"RTWName":"<S42>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:244"},{"RTWName":"<S42>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:246"},{"RTWName":"<S42>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:245"},{"RTWName":"<S42>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:271"},{"RTWName":"<S42>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:358"},{"RTWName":"<S42>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:339"},{"RTWName":"<S42>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:340"},{"RTWName":"<S104>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:279"},{"RTWName":"<S104>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:280"},{"RTWName":"<S106>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:275"},{"RTWName":"<S106>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:360"},{"RTWName":"<S106>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:363"},{"RTWName":"<S106>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:355"},{"RTWName":"<S107>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:283"},{"RTWName":"<S107>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:284"},{"RTWName":"<S107>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:342"},{"RTWName":"<S107>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:343"},{"RTWName":"<S107>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:344"},{"RTWName":"<S107>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:345"},{"RTWName":"<S107>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:346"},{"RTWName":"<S107>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:365"},{"RTWName":"<S107>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:347"},{"RTWName":"<S107>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:364"},{"RTWName":"<S107>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:348"},{"RTWName":"<S107>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:349"},{"RTWName":"<S107>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:350"},{"RTWName":"<S107>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:351"},{"RTWName":"<S107>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:352"},{"RTWName":"<S107>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:285"},{"RTWName":"<S107>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:361"},{"RTWName":"<S104>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:281"},{"RTWName":"<S104>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:362"},{"RTWName":"<S105>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:249"},{"RTWName":"<S108>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:251"},{"RTWName":"<S108>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:253"},{"RTWName":"<S109>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:256"},{"RTWName":"<S109>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:257"},{"RTWName":"<S109>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:258"},{"RTWName":"<S109>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:259"},{"RTWName":"<S109>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:260"},{"RTWName":"<S105>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:261"},{"RTWName":"<S105>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:262"},{"RTWName":"<S42>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:264"},{"RTWName":"<S42>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:338"},{"RTWName":"<S42>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:270"},{"RTWName":"<S42>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:267"},{"RTWName":"<S42>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:272"},{"RTWName":"<S43>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:244"},{"RTWName":"<S43>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:246"},{"RTWName":"<S43>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:245"},{"RTWName":"<S43>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:271"},{"RTWName":"<S43>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:358"},{"RTWName":"<S43>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:339"},{"RTWName":"<S43>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:340"},{"RTWName":"<S110>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:279"},{"RTWName":"<S110>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:280"},{"RTWName":"<S112>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:275"},{"RTWName":"<S112>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:360"},{"RTWName":"<S112>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:363"},{"RTWName":"<S112>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:355"},{"RTWName":"<S113>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:283"},{"RTWName":"<S113>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:284"},{"RTWName":"<S113>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:342"},{"RTWName":"<S113>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:343"},{"RTWName":"<S113>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:344"},{"RTWName":"<S113>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:345"},{"RTWName":"<S113>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:346"},{"RTWName":"<S113>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:365"},{"RTWName":"<S113>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:347"},{"RTWName":"<S113>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:364"},{"RTWName":"<S113>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:348"},{"RTWName":"<S113>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:349"},{"RTWName":"<S113>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:350"},{"RTWName":"<S113>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:351"},{"RTWName":"<S113>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:352"},{"RTWName":"<S113>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:285"},{"RTWName":"<S113>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:361"},{"RTWName":"<S110>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:281"},{"RTWName":"<S110>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:362"},{"RTWName":"<S111>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:249"},{"RTWName":"<S114>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:251"},{"RTWName":"<S114>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:253"},{"RTWName":"<S115>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:256"},{"RTWName":"<S115>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:257"},{"RTWName":"<S115>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:258"},{"RTWName":"<S115>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:259"},{"RTWName":"<S115>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:260"},{"RTWName":"<S111>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:261"},{"RTWName":"<S111>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:262"},{"RTWName":"<S43>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:264"},{"RTWName":"<S43>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:338"},{"RTWName":"<S43>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:270"},{"RTWName":"<S43>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:267"},{"RTWName":"<S43>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:272"},{"RTWName":"<S44>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:244"},{"RTWName":"<S44>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:246"},{"RTWName":"<S44>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:245"},{"RTWName":"<S44>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:271"},{"RTWName":"<S44>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:358"},{"RTWName":"<S44>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:339"},{"RTWName":"<S44>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:340"},{"RTWName":"<S116>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:279"},{"RTWName":"<S116>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:280"},{"RTWName":"<S118>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:275"},{"RTWName":"<S118>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:360"},{"RTWName":"<S118>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:363"},{"RTWName":"<S118>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:355"},{"RTWName":"<S119>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:283"},{"RTWName":"<S119>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:284"},{"RTWName":"<S119>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:342"},{"RTWName":"<S119>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:343"},{"RTWName":"<S119>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:344"},{"RTWName":"<S119>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:345"},{"RTWName":"<S119>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:346"},{"RTWName":"<S119>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:365"},{"RTWName":"<S119>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:347"},{"RTWName":"<S119>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:364"},{"RTWName":"<S119>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:348"},{"RTWName":"<S119>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:349"},{"RTWName":"<S119>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:350"},{"RTWName":"<S119>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:351"},{"RTWName":"<S119>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:352"},{"RTWName":"<S119>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:285"},{"RTWName":"<S119>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:361"},{"RTWName":"<S116>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:281"},{"RTWName":"<S116>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:362"},{"RTWName":"<S117>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:249"},{"RTWName":"<S120>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:251"},{"RTWName":"<S120>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:253"},{"RTWName":"<S121>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:256"},{"RTWName":"<S121>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:257"},{"RTWName":"<S121>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:258"},{"RTWName":"<S121>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:259"},{"RTWName":"<S121>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:260"},{"RTWName":"<S117>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:261"},{"RTWName":"<S117>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:262"},{"RTWName":"<S44>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:264"},{"RTWName":"<S44>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:338"},{"RTWName":"<S44>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:270"},{"RTWName":"<S44>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:267"},{"RTWName":"<S44>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:272"},{"RTWName":"<S45>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:244"},{"RTWName":"<S45>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:246"},{"RTWName":"<S45>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:245"},{"RTWName":"<S45>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:271"},{"RTWName":"<S45>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:358"},{"RTWName":"<S45>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:339"},{"RTWName":"<S45>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:340"},{"RTWName":"<S122>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:279"},{"RTWName":"<S122>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:280"},{"RTWName":"<S124>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:275"},{"RTWName":"<S124>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:360"},{"RTWName":"<S124>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:363"},{"RTWName":"<S124>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:355"},{"RTWName":"<S125>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:283"},{"RTWName":"<S125>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:284"},{"RTWName":"<S125>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:342"},{"RTWName":"<S125>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:343"},{"RTWName":"<S125>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:344"},{"RTWName":"<S125>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:345"},{"RTWName":"<S125>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:346"},{"RTWName":"<S125>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:365"},{"RTWName":"<S125>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:347"},{"RTWName":"<S125>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:364"},{"RTWName":"<S125>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:348"},{"RTWName":"<S125>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:349"},{"RTWName":"<S125>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:350"},{"RTWName":"<S125>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:351"},{"RTWName":"<S125>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:352"},{"RTWName":"<S125>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:285"},{"RTWName":"<S125>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:361"},{"RTWName":"<S122>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:281"},{"RTWName":"<S122>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:362"},{"RTWName":"<S123>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:249"},{"RTWName":"<S126>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:251"},{"RTWName":"<S126>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:253"},{"RTWName":"<S127>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:256"},{"RTWName":"<S127>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:257"},{"RTWName":"<S127>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:258"},{"RTWName":"<S127>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:259"},{"RTWName":"<S127>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:260"},{"RTWName":"<S123>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:261"},{"RTWName":"<S123>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:262"},{"RTWName":"<S45>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:264"},{"RTWName":"<S45>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:338"},{"RTWName":"<S45>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:270"},{"RTWName":"<S45>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:267"},{"RTWName":"<S45>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:272"},{"RTWName":"<S46>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:244"},{"RTWName":"<S46>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:246"},{"RTWName":"<S46>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:245"},{"RTWName":"<S46>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:271"},{"RTWName":"<S46>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:358"},{"RTWName":"<S46>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:339"},{"RTWName":"<S46>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:340"},{"RTWName":"<S128>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:279"},{"RTWName":"<S128>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:280"},{"RTWName":"<S130>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:275"},{"RTWName":"<S130>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:360"},{"RTWName":"<S130>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:363"},{"RTWName":"<S130>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:355"},{"RTWName":"<S131>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:283"},{"RTWName":"<S131>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:284"},{"RTWName":"<S131>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:342"},{"RTWName":"<S131>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:343"},{"RTWName":"<S131>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:344"},{"RTWName":"<S131>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:345"},{"RTWName":"<S131>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:346"},{"RTWName":"<S131>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:365"},{"RTWName":"<S131>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:347"},{"RTWName":"<S131>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:364"},{"RTWName":"<S131>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:348"},{"RTWName":"<S131>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:349"},{"RTWName":"<S131>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:350"},{"RTWName":"<S131>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:351"},{"RTWName":"<S131>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:352"},{"RTWName":"<S131>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:285"},{"RTWName":"<S131>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:361"},{"RTWName":"<S128>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:281"},{"RTWName":"<S128>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:362"},{"RTWName":"<S129>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:249"},{"RTWName":"<S132>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:251"},{"RTWName":"<S132>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:253"},{"RTWName":"<S133>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:256"},{"RTWName":"<S133>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:257"},{"RTWName":"<S133>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:258"},{"RTWName":"<S133>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:259"},{"RTWName":"<S133>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:260"},{"RTWName":"<S129>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:261"},{"RTWName":"<S129>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:262"},{"RTWName":"<S46>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:264"},{"RTWName":"<S46>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:338"},{"RTWName":"<S46>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:270"},{"RTWName":"<S46>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:267"},{"RTWName":"<S46>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:272"},{"RTWName":"<S47>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:244"},{"RTWName":"<S47>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:246"},{"RTWName":"<S47>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:245"},{"RTWName":"<S47>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:271"},{"RTWName":"<S47>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:358"},{"RTWName":"<S47>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:339"},{"RTWName":"<S47>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:340"},{"RTWName":"<S134>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:279"},{"RTWName":"<S134>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:280"},{"RTWName":"<S136>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:275"},{"RTWName":"<S136>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:360"},{"RTWName":"<S136>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:363"},{"RTWName":"<S136>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:355"},{"RTWName":"<S137>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:283"},{"RTWName":"<S137>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:284"},{"RTWName":"<S137>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:342"},{"RTWName":"<S137>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:343"},{"RTWName":"<S137>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:344"},{"RTWName":"<S137>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:345"},{"RTWName":"<S137>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:346"},{"RTWName":"<S137>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:365"},{"RTWName":"<S137>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:347"},{"RTWName":"<S137>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:364"},{"RTWName":"<S137>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:348"},{"RTWName":"<S137>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:349"},{"RTWName":"<S137>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:350"},{"RTWName":"<S137>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:351"},{"RTWName":"<S137>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:352"},{"RTWName":"<S137>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:285"},{"RTWName":"<S137>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:361"},{"RTWName":"<S134>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:281"},{"RTWName":"<S134>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:362"},{"RTWName":"<S135>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:249"},{"RTWName":"<S138>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:251"},{"RTWName":"<S138>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:253"},{"RTWName":"<S139>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:256"},{"RTWName":"<S139>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:257"},{"RTWName":"<S139>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:258"},{"RTWName":"<S139>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:259"},{"RTWName":"<S139>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:260"},{"RTWName":"<S135>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:261"},{"RTWName":"<S135>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:262"},{"RTWName":"<S47>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:264"},{"RTWName":"<S47>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:338"},{"RTWName":"<S47>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:270"},{"RTWName":"<S47>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:267"},{"RTWName":"<S47>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:272"},{"RTWName":"<S48>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:244"},{"RTWName":"<S48>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:246"},{"RTWName":"<S48>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:245"},{"RTWName":"<S48>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:271"},{"RTWName":"<S48>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:358"},{"RTWName":"<S48>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:339"},{"RTWName":"<S48>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:340"},{"RTWName":"<S140>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:279"},{"RTWName":"<S140>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:280"},{"RTWName":"<S142>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:275"},{"RTWName":"<S142>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:360"},{"RTWName":"<S142>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:363"},{"RTWName":"<S142>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:355"},{"RTWName":"<S143>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:283"},{"RTWName":"<S143>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:284"},{"RTWName":"<S143>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:342"},{"RTWName":"<S143>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:343"},{"RTWName":"<S143>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:344"},{"RTWName":"<S143>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:345"},{"RTWName":"<S143>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:346"},{"RTWName":"<S143>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:365"},{"RTWName":"<S143>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:347"},{"RTWName":"<S143>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:364"},{"RTWName":"<S143>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:348"},{"RTWName":"<S143>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:349"},{"RTWName":"<S143>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:350"},{"RTWName":"<S143>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:351"},{"RTWName":"<S143>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:352"},{"RTWName":"<S143>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:285"},{"RTWName":"<S143>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:361"},{"RTWName":"<S140>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:281"},{"RTWName":"<S140>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:362"},{"RTWName":"<S141>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:249"},{"RTWName":"<S144>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:251"},{"RTWName":"<S144>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:253"},{"RTWName":"<S145>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:256"},{"RTWName":"<S145>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:257"},{"RTWName":"<S145>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:258"},{"RTWName":"<S145>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:259"},{"RTWName":"<S145>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:260"},{"RTWName":"<S141>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:261"},{"RTWName":"<S141>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:262"},{"RTWName":"<S48>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:264"},{"RTWName":"<S48>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:338"},{"RTWName":"<S48>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:270"},{"RTWName":"<S48>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:267"},{"RTWName":"<S48>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:272"},{"RTWName":"<S49>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:244"},{"RTWName":"<S49>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:246"},{"RTWName":"<S49>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:245"},{"RTWName":"<S49>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:271"},{"RTWName":"<S49>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:358"},{"RTWName":"<S49>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:339"},{"RTWName":"<S49>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:340"},{"RTWName":"<S146>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:279"},{"RTWName":"<S146>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:280"},{"RTWName":"<S148>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:275"},{"RTWName":"<S148>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:360"},{"RTWName":"<S148>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:363"},{"RTWName":"<S148>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:355"},{"RTWName":"<S149>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:283"},{"RTWName":"<S149>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:284"},{"RTWName":"<S149>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:342"},{"RTWName":"<S149>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:343"},{"RTWName":"<S149>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:344"},{"RTWName":"<S149>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:345"},{"RTWName":"<S149>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:346"},{"RTWName":"<S149>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:365"},{"RTWName":"<S149>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:347"},{"RTWName":"<S149>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:364"},{"RTWName":"<S149>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:348"},{"RTWName":"<S149>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:349"},{"RTWName":"<S149>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:350"},{"RTWName":"<S149>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:351"},{"RTWName":"<S149>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:352"},{"RTWName":"<S149>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:285"},{"RTWName":"<S149>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:361"},{"RTWName":"<S146>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:281"},{"RTWName":"<S146>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:362"},{"RTWName":"<S147>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:249"},{"RTWName":"<S150>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:251"},{"RTWName":"<S150>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:253"},{"RTWName":"<S151>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:256"},{"RTWName":"<S151>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:257"},{"RTWName":"<S151>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:258"},{"RTWName":"<S151>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:259"},{"RTWName":"<S151>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:260"},{"RTWName":"<S147>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:261"},{"RTWName":"<S147>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:262"},{"RTWName":"<S49>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:264"},{"RTWName":"<S49>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:338"},{"RTWName":"<S49>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:270"},{"RTWName":"<S49>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:267"},{"RTWName":"<S49>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:272"},{"RTWName":"<S32>/TerminateEvent","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:460"},{"RTWName":"<S32>/TerminateEvent1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:461"},{"RTWName":"<S32>/TerminateEvent10","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:462"},{"RTWName":"<S32>/TerminateEvent11","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:463"},{"RTWName":"<S32>/TerminateEvent12","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:464"},{"RTWName":"<S32>/TerminateEvent13","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:465"},{"RTWName":"<S32>/TerminateEvent14","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:466"},{"RTWName":"<S32>/TerminateEvent15","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:467"},{"RTWName":"<S32>/TerminateEvent16","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:468"},{"RTWName":"<S32>/TerminateEvent2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:469"},{"RTWName":"<S32>/TerminateEvent3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:470"},{"RTWName":"<S32>/TerminateEvent4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:471"},{"RTWName":"<S32>/TerminateEvent5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:472"},{"RTWName":"<S32>/TerminateEvent6","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:473"},{"RTWName":"<S32>/TerminateEvent7","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:474"},{"RTWName":"<S32>/TerminateEvent8","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:475"},{"RTWName":"<S32>/TerminateEvent9","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:476"},{"RTWName":"<S32>/TerminateReady","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:477"},{"RTWName":"<S32>/TerminateReady1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:478"},{"RTWName":"<S32>/TerminateReady10","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:479"},{"RTWName":"<S32>/TerminateReady11","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:480"},{"RTWName":"<S32>/TerminateReady12","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:481"},{"RTWName":"<S32>/TerminateReady13","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:482"},{"RTWName":"<S32>/TerminateReady14","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:483"},{"RTWName":"<S32>/TerminateReady15","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:484"},{"RTWName":"<S32>/TerminateReady16","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:485"},{"RTWName":"<S32>/TerminateReady2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:486"},{"RTWName":"<S32>/TerminateReady3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:487"},{"RTWName":"<S32>/TerminateReady4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:488"},{"RTWName":"<S32>/TerminateReady5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:489"},{"RTWName":"<S32>/TerminateReady6","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:490"},{"RTWName":"<S32>/TerminateReady7","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:491"},{"RTWName":"<S32>/TerminateReady8","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:492"},{"RTWName":"<S32>/TerminateReady9","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:493"},{"RTWName":"<S32>/Width","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:494"},{"RTWName":"<S32>/Width1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:495"},{"RTWName":"<S32>/Width10","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:496"},{"RTWName":"<S32>/Width11","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:497"},{"RTWName":"<S32>/Width12","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:498"},{"RTWName":"<S32>/Width13","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:499"},{"RTWName":"<S32>/Width14","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:500"},{"RTWName":"<S32>/Width15","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:501"},{"RTWName":"<S32>/Width16","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:502"},{"RTWName":"<S32>/Width2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:503"},{"RTWName":"<S32>/Width3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:504"},{"RTWName":"<S32>/Width4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:505"},{"RTWName":"<S32>/Width5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:506"},{"RTWName":"<S32>/Width6","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:507"},{"RTWName":"<S32>/Width7","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:508"},{"RTWName":"<S32>/Width8","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:509"},{"RTWName":"<S32>/Width9","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:510"},{"RTWName":"<S32>/msg Pin(s)","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:511"},{"RTWName":"<S32>/msg Pin 0","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:512"},{"RTWName":"<S32>/msg Pin 1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:513"},{"RTWName":"<S32>/msg Pin 2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:514"},{"RTWName":"<S32>/msg Pin 3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:515"},{"RTWName":"<S32>/msg Pin 4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:516"},{"RTWName":"<S32>/msg Pin 5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:517"},{"RTWName":"<S32>/msg Pin 6","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:518"},{"RTWName":"<S32>/msg Pin 7","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:519"},{"RTWName":"<S32>/msg Pin 8","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:520"},{"RTWName":"<S32>/msg Pin 9","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:521"},{"RTWName":"<S32>/msg Pin 10","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:522"},{"RTWName":"<S32>/msg Pin 11","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:523"},{"RTWName":"<S32>/msg Pin 12","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:524"},{"RTWName":"<S32>/msg Pin 13","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:525"},{"RTWName":"<S32>/msg Pin 14","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:526"},{"RTWName":"<S32>/msg Pin 15","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:527"},{"RTWName":"<S4294967295>/msg Pin 0","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:528"},{"RTWName":"<S4294967295>/msg Pin 1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:529"},{"RTWName":"<S4294967295>/msg Pin 10","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:530"},{"RTWName":"<S4294967295>/msg Pin 11","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:531"},{"RTWName":"<S4294967295>/msg Pin 12","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:532"},{"RTWName":"<S4294967295>/msg Pin 13","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:533"},{"RTWName":"<S4294967295>/msg Pin 14","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:534"},{"RTWName":"<S4294967295>/msg Pin 15","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:535"},{"RTWName":"<S4294967295>/msg Pin 2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:536"},{"RTWName":"<S4294967295>/msg Pin 3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:537"},{"RTWName":"<S4294967295>/msg Pin 4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:538"},{"RTWName":"<S4294967295>/msg Pin 5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:539"},{"RTWName":"<S4294967295>/msg Pin 6","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:540"},{"RTWName":"<S4294967295>/msg Pin 7","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:541"},{"RTWName":"<S4294967295>/msg Pin 8","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:542"},{"RTWName":"<S4294967295>/msg Pin 9","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:543"},{"RTWName":"<S4294967295>/msg Pin(s)","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:544"},{"RTWName":"<S19>/NOT","SIDString":"mcb_open_loop_control_nucleo_f401re:3584"},{"RTWName":"<S19>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3585"},{"RTWName":"<S20>/PWM Duty Cycle","SIDString":"mcb_open_loop_control_nucleo_f401re:3381"},{"RTWName":"<S20>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3646"},{"RTWName":"<S20>/Demux","SIDString":"mcb_open_loop_control_nucleo_f401re:3383"},{"RTWName":"<S20>/Mux2","SIDString":"mcb_open_loop_control_nucleo_f401re:3384"},{"RTWName":"<S24>/CH1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2098"},{"RTWName":"<S24>/CH2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2207"},{"RTWName":"<S24>/CH3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2208"},{"RTWName":"<S25>/CH1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2100"},{"RTWName":"<S25>/CH2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2205"},{"RTWName":"<S25>/CH3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2206"},{"RTWName":"<S26>/CH1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2102"},{"RTWName":"<S26>/CH2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2203"},{"RTWName":"<S26>/CH3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2204"},{"RTWName":"<S26>/PWM Output","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2103"},{"RTWName":"<S4294967295>/CH1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2105"},{"RTWName":"<S4294967295>/CH2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2106"},{"RTWName":"<S4294967295>/CH3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2107"},{"RTWName":"<S4294967295>/CH4","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2108"},{"RTWName":"<S156>/CH1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2110"},{"RTWName":"<S156>/CH2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2111"},{"RTWName":"<S156>/CH3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2112"},{"RTWName":"<S156>/CH4","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2113"},{"RTWName":"<S156>/ConstValid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2114"},{"RTWName":"<S156>/ConstValid1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2115"},{"RTWName":"<S156>/ConstValid2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2116"},{"RTWName":"<S156>/ConstValid3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2117"},{"RTWName":"<S156>/GroundDone","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2118"},{"RTWName":"<S156>/GroundDone1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2119"},{"RTWName":"<S156>/GroundDone2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2120"},{"RTWName":"<S156>/GroundDone3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2121"},{"RTWName":"<S157>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:244"},{"RTWName":"<S157>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:246"},{"RTWName":"<S157>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:245"},{"RTWName":"<S157>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:271"},{"RTWName":"<S157>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:358"},{"RTWName":"<S157>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:339"},{"RTWName":"<S157>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:340"},{"RTWName":"<S165>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:279"},{"RTWName":"<S165>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:280"},{"RTWName":"<S167>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:275"},{"RTWName":"<S167>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:360"},{"RTWName":"<S167>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:363"},{"RTWName":"<S167>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:355"},{"RTWName":"<S168>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:283"},{"RTWName":"<S168>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:284"},{"RTWName":"<S168>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:342"},{"RTWName":"<S168>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:343"},{"RTWName":"<S168>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:344"},{"RTWName":"<S168>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:345"},{"RTWName":"<S168>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:346"},{"RTWName":"<S168>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:365"},{"RTWName":"<S168>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:347"},{"RTWName":"<S168>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:364"},{"RTWName":"<S168>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:348"},{"RTWName":"<S168>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:349"},{"RTWName":"<S168>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:350"},{"RTWName":"<S168>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:351"},{"RTWName":"<S168>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:352"},{"RTWName":"<S168>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:285"},{"RTWName":"<S168>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:361"},{"RTWName":"<S165>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:281"},{"RTWName":"<S165>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:362"},{"RTWName":"<S166>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:249"},{"RTWName":"<S169>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:251"},{"RTWName":"<S169>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:253"},{"RTWName":"<S170>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:256"},{"RTWName":"<S170>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:257"},{"RTWName":"<S170>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:258"},{"RTWName":"<S170>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:259"},{"RTWName":"<S170>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:260"},{"RTWName":"<S166>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:261"},{"RTWName":"<S166>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:262"},{"RTWName":"<S157>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:264"},{"RTWName":"<S157>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:338"},{"RTWName":"<S157>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:270"},{"RTWName":"<S157>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:267"},{"RTWName":"<S157>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:272"},{"RTWName":"<S158>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:244"},{"RTWName":"<S158>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:246"},{"RTWName":"<S158>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:245"},{"RTWName":"<S158>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:271"},{"RTWName":"<S158>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:358"},{"RTWName":"<S158>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:339"},{"RTWName":"<S158>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:340"},{"RTWName":"<S171>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:279"},{"RTWName":"<S171>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:280"},{"RTWName":"<S173>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:275"},{"RTWName":"<S173>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:360"},{"RTWName":"<S173>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:363"},{"RTWName":"<S173>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:355"},{"RTWName":"<S174>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:283"},{"RTWName":"<S174>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:284"},{"RTWName":"<S174>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:342"},{"RTWName":"<S174>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:343"},{"RTWName":"<S174>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:344"},{"RTWName":"<S174>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:345"},{"RTWName":"<S174>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:346"},{"RTWName":"<S174>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:365"},{"RTWName":"<S174>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:347"},{"RTWName":"<S174>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:364"},{"RTWName":"<S174>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:348"},{"RTWName":"<S174>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:349"},{"RTWName":"<S174>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:350"},{"RTWName":"<S174>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:351"},{"RTWName":"<S174>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:352"},{"RTWName":"<S174>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:285"},{"RTWName":"<S174>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:361"},{"RTWName":"<S171>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:281"},{"RTWName":"<S171>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:362"},{"RTWName":"<S172>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:249"},{"RTWName":"<S175>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:251"},{"RTWName":"<S175>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:253"},{"RTWName":"<S176>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:256"},{"RTWName":"<S176>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:257"},{"RTWName":"<S176>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:258"},{"RTWName":"<S176>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:259"},{"RTWName":"<S176>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:260"},{"RTWName":"<S172>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:261"},{"RTWName":"<S172>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:262"},{"RTWName":"<S158>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:264"},{"RTWName":"<S158>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:338"},{"RTWName":"<S158>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:270"},{"RTWName":"<S158>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:267"},{"RTWName":"<S158>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:272"},{"RTWName":"<S159>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:244"},{"RTWName":"<S159>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:246"},{"RTWName":"<S159>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:245"},{"RTWName":"<S159>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:271"},{"RTWName":"<S159>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:358"},{"RTWName":"<S159>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:339"},{"RTWName":"<S159>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:340"},{"RTWName":"<S177>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:279"},{"RTWName":"<S177>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:280"},{"RTWName":"<S179>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:275"},{"RTWName":"<S179>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:360"},{"RTWName":"<S179>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:363"},{"RTWName":"<S179>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:355"},{"RTWName":"<S180>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:283"},{"RTWName":"<S180>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:284"},{"RTWName":"<S180>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:342"},{"RTWName":"<S180>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:343"},{"RTWName":"<S180>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:344"},{"RTWName":"<S180>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:345"},{"RTWName":"<S180>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:346"},{"RTWName":"<S180>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:365"},{"RTWName":"<S180>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:347"},{"RTWName":"<S180>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:364"},{"RTWName":"<S180>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:348"},{"RTWName":"<S180>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:349"},{"RTWName":"<S180>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:350"},{"RTWName":"<S180>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:351"},{"RTWName":"<S180>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:352"},{"RTWName":"<S180>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:285"},{"RTWName":"<S180>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:361"},{"RTWName":"<S177>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:281"},{"RTWName":"<S177>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:362"},{"RTWName":"<S178>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:249"},{"RTWName":"<S181>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:251"},{"RTWName":"<S181>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:253"},{"RTWName":"<S182>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:256"},{"RTWName":"<S182>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:257"},{"RTWName":"<S182>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:258"},{"RTWName":"<S182>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:259"},{"RTWName":"<S182>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:260"},{"RTWName":"<S178>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:261"},{"RTWName":"<S178>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:262"},{"RTWName":"<S159>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:264"},{"RTWName":"<S159>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:338"},{"RTWName":"<S159>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:270"},{"RTWName":"<S159>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:267"},{"RTWName":"<S159>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:272"},{"RTWName":"<S160>/Data","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:244"},{"RTWName":"<S160>/Length","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:246"},{"RTWName":"<S160>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:245"},{"RTWName":"<S160>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:271"},{"RTWName":"<S160>/Data Pack","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:358"},{"RTWName":"<S160>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:339"},{"RTWName":"<S160>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:340"},{"RTWName":"<S183>/Valid ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:279"},{"RTWName":"<S183>/Done ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:280"},{"RTWName":"<S185>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:275"},{"RTWName":"<S185>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:360"},{"RTWName":"<S185>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:363"},{"RTWName":"<S185>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:355"},{"RTWName":"<S186>/Valid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:283"},{"RTWName":"<S186>/Done","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:284"},{"RTWName":"<S186>/AND","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:342"},{"RTWName":"<S186>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:343"},{"RTWName":"<S186>/Constant2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:344"},{"RTWName":"<S186>/Constant3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:345"},{"RTWName":"<S186>/Constant4","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:346"},{"RTWName":"<S186>/Constant5","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:365"},{"RTWName":"<S186>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:347"},{"RTWName":"<S186>/GreaterThan","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:364"},{"RTWName":"<S186>/Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:348"},{"RTWName":"<S186>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:349"},{"RTWName":"<S186>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:350"},{"RTWName":"<S186>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:351"},{"RTWName":"<S186>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:352"},{"RTWName":"<S186>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:285"},{"RTWName":"<S186>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:361"},{"RTWName":"<S183>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:281"},{"RTWName":"<S183>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:362"},{"RTWName":"<S184>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:249"},{"RTWName":"<S187>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:251"},{"RTWName":"<S187>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:253"},{"RTWName":"<S188>/MsgIn ","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:256"},{"RTWName":"<S188>/Entity Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:257"},{"RTWName":"<S188>/Entity Replicator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:258"},{"RTWName":"<S188>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:259"},{"RTWName":"<S188>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:260"},{"RTWName":"<S184>/MsgOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:261"},{"RTWName":"<S184>/EventOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:262"},{"RTWName":"<S160>/Message Send","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:264"},{"RTWName":"<S160>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:338"},{"RTWName":"<S160>/Event","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:270"},{"RTWName":"<S160>/Msg","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:267"},{"RTWName":"<S160>/Ready","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:272"},{"RTWName":"<S161>/Duty","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2127"},{"RTWName":"<S161>/Bus\nCreator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2128"},{"RTWName":"<S161>/Data Type Conversion","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2129"},{"RTWName":"<S161>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2130"},{"RTWName":"<S161>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2131"},{"RTWName":"<S161>/Divide","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2132"},{"RTWName":"<S161>/DutyRef","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2133"},{"RTWName":"<S161>/Mux2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2134"},{"RTWName":"<S161>/Phase","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2135"},{"RTWName":"<S161>/Phase1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2136"},{"RTWName":"<S161>/isPeriodValid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2137"},{"RTWName":"<S161>/isPhaseValid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2138"},{"RTWName":"<S161>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2139"},{"RTWName":"<S162>/Duty","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2141"},{"RTWName":"<S162>/Bus\nCreator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2142"},{"RTWName":"<S162>/Data Type Conversion","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2143"},{"RTWName":"<S162>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2144"},{"RTWName":"<S162>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2145"},{"RTWName":"<S162>/Divide","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2146"},{"RTWName":"<S162>/DutyRef","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2147"},{"RTWName":"<S162>/Mux2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2148"},{"RTWName":"<S162>/Phase","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2149"},{"RTWName":"<S162>/Phase1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2150"},{"RTWName":"<S162>/isPeriodValid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2151"},{"RTWName":"<S162>/isPhaseValid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2152"},{"RTWName":"<S162>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2153"},{"RTWName":"<S163>/Duty","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2155"},{"RTWName":"<S163>/Bus\nCreator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2156"},{"RTWName":"<S163>/Data Type Conversion","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2157"},{"RTWName":"<S163>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2158"},{"RTWName":"<S163>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2159"},{"RTWName":"<S163>/Divide","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2160"},{"RTWName":"<S163>/DutyRef","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2161"},{"RTWName":"<S163>/Mux2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2162"},{"RTWName":"<S163>/Phase","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2163"},{"RTWName":"<S163>/Phase1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2164"},{"RTWName":"<S163>/isPeriodValid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2165"},{"RTWName":"<S163>/isPhaseValid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2166"},{"RTWName":"<S163>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2167"},{"RTWName":"<S164>/Duty","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2169"},{"RTWName":"<S164>/Bus\nCreator","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2170"},{"RTWName":"<S164>/Data Type Conversion","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2171"},{"RTWName":"<S164>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2172"},{"RTWName":"<S164>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2173"},{"RTWName":"<S164>/Divide","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2174"},{"RTWName":"<S164>/DutyRef","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2175"},{"RTWName":"<S164>/Mux2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2176"},{"RTWName":"<S164>/Phase","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2177"},{"RTWName":"<S164>/Phase1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2178"},{"RTWName":"<S164>/isPeriodValid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2179"},{"RTWName":"<S164>/isPhaseValid","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2180"},{"RTWName":"<S164>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2181"},{"RTWName":"<S156>/TerminateEvent","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2182"},{"RTWName":"<S156>/TerminateEvent1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2183"},{"RTWName":"<S156>/TerminateEvent2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2184"},{"RTWName":"<S156>/TerminateEvent3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2185"},{"RTWName":"<S156>/TerminateReady","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2186"},{"RTWName":"<S156>/TerminateReady1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2187"},{"RTWName":"<S156>/TerminateReady2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2188"},{"RTWName":"<S156>/TerminateReady3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2189"},{"RTWName":"<S156>/Width","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2190"},{"RTWName":"<S156>/Width1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2191"},{"RTWName":"<S156>/Width2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2192"},{"RTWName":"<S156>/Width3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2193"},{"RTWName":"<S156>/msg CH1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2194"},{"RTWName":"<S156>/msg CH2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2195"},{"RTWName":"<S156>/msg CH3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2196"},{"RTWName":"<S156>/msg CH4","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2197"},{"RTWName":"<S4294967295>/msg CH1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2198"},{"RTWName":"<S4294967295>/msg CH2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2199"},{"RTWName":"<S4294967295>/msg CH3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2200"},{"RTWName":"<S4294967295>/msg CH4","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2201"},{"RTWName":"<S20>/Switch4","SIDString":"mcb_open_loop_control_nucleo_f401re:3385"},{"RTWName":"<S20>/stop","SIDString":"mcb_open_loop_control_nucleo_f401re:3389"},{"RTWName":"<S14>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3645"},{"RTWName":"<S14>/Speed_ref","SIDString":"mcb_open_loop_control_nucleo_f401re:3283"},{"RTWName":"<S14>/LowerSaturation","SIDString":"mcb_open_loop_control_nucleo_f401re:3606"},{"RTWName":"<S27>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3644"},{"RTWName":"<S27>/Speed_Ref","SIDString":"mcb_open_loop_control_nucleo_f401re:3532"},{"RTWName":"<S27>/Product","SIDString":"mcb_open_loop_control_nucleo_f401re:3295"},{"RTWName":"<S29>/Ramp_Time","SIDString":"mcb_open_loop_control_nucleo_f401re:3297"},{"RTWName":"<S29>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3298"},{"RTWName":"<S29>/Divide","SIDString":"mcb_open_loop_control_nucleo_f401re:3299"},{"RTWName":"<S29>/NOT","SIDString":"mcb_open_loop_control_nucleo_f401re:3300"},{"RTWName":"<S29>/One","SIDString":"mcb_open_loop_control_nucleo_f401re:3301"},{"RTWName":"<S29>/Ramp Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3302"},{"RTWName":"<S29>/Sample_Time","SIDString":"mcb_open_loop_control_nucleo_f401re:3303"},{"RTWName":"<S29>/Ramp","SIDString":"mcb_open_loop_control_nucleo_f401re:3304"},{"RTWName":"<S27>/Ramp_Time (sec)","SIDString":"mcb_open_loop_control_nucleo_f401re:3305"},{"RTWName":"<S4294967295>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:370"},{"RTWName":"<S4294967295>/Data Type\nDuplicate","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:485"},{"RTWName":"<S4294967295>/Demux","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:496"},{"RTWName":"<S4294967295>/FilterConstant","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:478"},{"RTWName":"<S193>/x","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:348"},{"RTWName":"<S193>/A","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:392"},{"RTWName":"<S193>/OneMinusA","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:486"},{"RTWName":"<S194>/x","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:350"},{"RTWName":"<S194>/A","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:394"},{"RTWName":"<S194>/OneMinusA","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:489"},{"RTWName":"<S194>/IIR Low Pass Filter","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:395"},{"RTWName":"<S194>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:352"},{"RTWName":"<S194>/y","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:353"},{"RTWName":"<S195>/x","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:355"},{"RTWName":"<S195>/A","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:393"},{"RTWName":"<S195>/OneMinusA","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:487"},{"RTWName":"<S196>/Input","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:359"},{"RTWName":"<S196>/A","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:396"},{"RTWName":"<S196>/OneMinusA","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:488"},{"RTWName":"<S196>/Add1","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:360"},{"RTWName":"<S196>/Product","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:364"},{"RTWName":"<S196>/Product1","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:365"},{"RTWName":"<S196>/Unit Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:366"},{"RTWName":"<S196>/Output","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:367"},{"RTWName":"<S195>/y","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:357"},{"RTWName":"<S193>/y","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:358"},{"RTWName":"<S4294967295>/Mux","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:494"},{"RTWName":"<S4294967295>/Mux1","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:495"},{"RTWName":"<S4294967295>/One","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:479"},{"RTWName":"<S4294967295>/OneMinusFilterConstant","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:480"},{"RTWName":"<S4294967295>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:481"},{"RTWName":"<S4294967295>/Switch1","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:483"},{"RTWName":"<S4294967295>/UseInputPort","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:484"},{"RTWName":"<S4294967295>/a","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:844"},{"RTWName":"<S4294967295>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:381"},{"RTWName":"<S27>/rpm2freq","SIDString":"mcb_open_loop_control_nucleo_f401re:3314"},{"RTWName":"<S27>/Frequency","SIDString":"mcb_open_loop_control_nucleo_f401re:3533"},{"RTWName":"<S28>/Frequency","SIDString":"mcb_open_loop_control_nucleo_f401re:3535"},{"RTWName":"<S28>/LowerSaturation","SIDString":"mcb_open_loop_control_nucleo_f401re:3605"},{"RTWName":"<S30>/m","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1163"},{"RTWName":"<S30>/Theta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1162"},{"RTWName":"<S30>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1164"},{"RTWName":"<S30>/Data Type\nDuplicate","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1172"},{"RTWName":"<S33>/alpha","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:272"},{"RTWName":"<S33>/beta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:585"},{"RTWName":"<S4294967295>/alpha","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:534"},{"RTWName":"<S4294967295>/Demux","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:540"},{"RTWName":"<S4294967295>/Gain","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:543"},{"RTWName":"<S4294967295>/Gain1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:544"},{"RTWName":"<S4294967295>/Kabc","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:581"},{"RTWName":"<S4294967295>/Kc","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:571"},{"RTWName":"<S4294967295>/Mux","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:541"},{"RTWName":"<S4294967295>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:542"},{"RTWName":"<S4294967295>/Sum1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:545"},{"RTWName":"<S4294967295>/Sum2","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:546"},{"RTWName":"<S4294967295>/a","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:536"},{"RTWName":"<S36>/alpha","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:507"},{"RTWName":"<S36>/beta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:508"},{"RTWName":"<S36>/Data Type\nDuplicate","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:500"},{"RTWName":"<S36>/Ka","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:565"},{"RTWName":"<S36>/Kb","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:566"},{"RTWName":"<S36>/Kc","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:567"},{"RTWName":"<S36>/add_b","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:490"},{"RTWName":"<S36>/add_c","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:499"},{"RTWName":"<S36>/one_by_two","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:493"},{"RTWName":"<S36>/sqrt3_by_two","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:492"},{"RTWName":"<S36>/a","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:509"},{"RTWName":"<S36>/b","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:510"},{"RTWName":"<S36>/c","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:511"},{"RTWName":"<S33>/a","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:288"},{"RTWName":"<S33>/b","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:586"},{"RTWName":"<S33>/c","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:587"},{"RTWName":"<S34>/Ds","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:252"},{"RTWName":"<S34>/Qs","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:1014"},{"RTWName":"<S34>/Sin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:430"},{"RTWName":"<S34>/Cos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:1021"},{"RTWName":"<S4294967295>/Theta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:501"},{"RTWName":"<S208>/Theta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:517"},{"RTWName":"<S208>/SinCos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:518"},{"RTWName":"<S208>/thetaUnit","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:524"},{"RTWName":"<S208>/sin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:519"},{"RTWName":"<S208>/cos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:520"},{"RTWName":"<S209>/Theta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:458"},{"RTWName":"<S209>/Data Type\nDuplicate","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:545"},{"RTWName":"<S209>/Data Type\nPropagation","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:673"},{"RTWName":"<S209>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:653"},{"RTWName":"<S209>/Get_FractionVal","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:630"},{"RTWName":"<S209>/Get_Integer","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:608"},{"RTWName":"<S211>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:706"},{"RTWName":"<S211>/In2","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:707"},{"RTWName":"<S211>/Demux","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:613"},{"RTWName":"<S211>/Product","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:616"},{"RTWName":"<S211>/Product1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:621"},{"RTWName":"<S211>/Sum3","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:614"},{"RTWName":"<S211>/Sum4","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:615"},{"RTWName":"<S211>/Sum5","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:622"},{"RTWName":"<S211>/Sum6","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:623"},{"RTWName":"<S211>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:708"},{"RTWName":"<S211>/Out2","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:709"},{"RTWName":"<S209>/Lookup","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:557"},{"RTWName":"<S209>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:610"},{"RTWName":"<S209>/Sum2","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:612"},{"RTWName":"<S212>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:668"},{"RTWName":"<S212>/Compare\nTo Zero","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:692"},{"RTWName":"<S212>/Data Type Conversion","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:702"},{"RTWName":"<S212>/If","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:683"},{"RTWName":"<S214>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:685"},{"RTWName":"<S214>/Action Port","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:686"},{"RTWName":"<S214>/Convert_back","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:695"},{"RTWName":"<S214>/Convert_uint16","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:694"},{"RTWName":"<S214>/Data Type\nDuplicate","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:679"},{"RTWName":"<S214>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:693"},{"RTWName":"<S214>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:687"},{"RTWName":"<S215>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:689"},{"RTWName":"<S215>/Action Port","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:690"},{"RTWName":"<S215>/Convert_back","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:698"},{"RTWName":"<S215>/Convert_uint16","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:697"},{"RTWName":"<S215>/Data Type\nDuplicate","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:699"},{"RTWName":"<S215>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:700"},{"RTWName":"<S215>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:691"},{"RTWName":"<S212>/Merge","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:696"},{"RTWName":"<S212>/convert_pu","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:652"},{"RTWName":"<S212>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:669"},{"RTWName":"<S213>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:714"},{"RTWName":"<S216>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:716"},{"RTWName":"<S216>/Data Type Conversion","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:723"},{"RTWName":"<S216>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:717"},{"RTWName":"<S217>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:719"},{"RTWName":"<S217>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:720"},{"RTWName":"<S213>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:721"},{"RTWName":"<S209>/indexing","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:605"},{"RTWName":"<S209>/offset","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:657"},{"RTWName":"<S209>/sine_table_values","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:549"},{"RTWName":"<S209>/sin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:248"},{"RTWName":"<S209>/cos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:531"},{"RTWName":"<S210>/Theta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:529"},{"RTWName":"<S210>/Trig Fcn IQN","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:530"},{"RTWName":"<S210>/Trig Fcn IQN1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:533"},{"RTWName":"<S210>/sin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:531"},{"RTWName":"<S210>/cos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:532"},{"RTWName":"<S4294967295>/sin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:508"},{"RTWName":"<S4294967295>/cos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:510"},{"RTWName":"<S4294967295>/Ds","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:907"},{"RTWName":"<S4294967295>/sin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:905"},{"RTWName":"<S4294967295>/cos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:906"},{"RTWName":"<S4294967295>/Demux","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:933"},{"RTWName":"<S4294967295>/Mux","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:931"},{"RTWName":"<S218>/Ds","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:985"},{"RTWName":"<S218>/Qs","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:986"},{"RTWName":"<S218>/sin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:987"},{"RTWName":"<S218>/cos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:988"},{"RTWName":"<S218>/Data Type\nDuplicate","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:989"},{"RTWName":"<S218>/Data Type\nDuplicate1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:990"},{"RTWName":"<S219>/A","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:992"},{"RTWName":"<S219>/B","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:993"},{"RTWName":"<S219>/D_axis_aligned","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:994"},{"RTWName":"<S219>/Demux","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:995"},{"RTWName":"<S219>/Offset","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:996"},{"RTWName":"<S219>/Q_axis_aligned","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:997"},{"RTWName":"<S219>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:998"},{"RTWName":"<S219>/Unary_Minus","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:999"},{"RTWName":"<S219>/Alpha","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:1000"},{"RTWName":"<S219>/Beta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:1001"},{"RTWName":"<S218>/a16","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:1002"},{"RTWName":"<S218>/dcos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:1003"},{"RTWName":"<S218>/dsin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:1004"},{"RTWName":"<S218>/qcos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:1005"},{"RTWName":"<S218>/qsin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:1006"},{"RTWName":"<S218>/sum_alpha","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:1007"},{"RTWName":"<S218>/sum_beta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:1008"},{"RTWName":"<S218>/Alpha","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:1009"},{"RTWName":"<S218>/Beta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:1010"},{"RTWName":"<S4294967295>/Alpha","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:929"},{"RTWName":"<S37>/Ds","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:779"},{"RTWName":"<S37>/Qs","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:780"},{"RTWName":"<S37>/sin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:781"},{"RTWName":"<S37>/cos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:782"},{"RTWName":"<S37>/Data Type\nDuplicate","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:760"},{"RTWName":"<S37>/Data Type\nDuplicate1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:762"},{"RTWName":"<S38>/A","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:749"},{"RTWName":"<S38>/B","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:750"},{"RTWName":"<S38>/D_axis_aligned","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:751"},{"RTWName":"<S38>/Demux","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:752"},{"RTWName":"<S38>/Offset","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:753"},{"RTWName":"<S38>/Q_axis_aligned","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:754"},{"RTWName":"<S38>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:755"},{"RTWName":"<S38>/Unary_Minus","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:756"},{"RTWName":"<S38>/Alpha","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:757"},{"RTWName":"<S38>/Beta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:758"},{"RTWName":"<S37>/a16","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:761"},{"RTWName":"<S37>/dcos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:431"},{"RTWName":"<S37>/dsin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:435"},{"RTWName":"<S37>/qcos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:434"},{"RTWName":"<S37>/qsin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:433"},{"RTWName":"<S37>/sum_alpha","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:432"},{"RTWName":"<S37>/sum_beta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:436"},{"RTWName":"<S37>/Alpha","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:783"},{"RTWName":"<S37>/Beta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:784"},{"RTWName":"<S34>/Alpha","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:268"},{"RTWName":"<S34>/Beta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:1013"},{"RTWName":"<S35>/Theta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:501"},{"RTWName":"<S4294967295>/Theta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:517"},{"RTWName":"<S4294967295>/SinCos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:518"},{"RTWName":"<S4294967295>/thetaUnit","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:524"},{"RTWName":"<S4294967295>/sin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:519"},{"RTWName":"<S4294967295>/cos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:520"},{"RTWName":"<S39>/Theta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:458"},{"RTWName":"<S39>/Data Type\nDuplicate","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:545"},{"RTWName":"<S39>/Data Type\nPropagation","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:673"},{"RTWName":"<S39>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:653"},{"RTWName":"<S39>/Get_FractionVal","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:630"},{"RTWName":"<S39>/Get_Integer","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:608"},{"RTWName":"<S40>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:706"},{"RTWName":"<S40>/In2","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:707"},{"RTWName":"<S40>/Demux","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:613"},{"RTWName":"<S40>/Product","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:616"},{"RTWName":"<S40>/Product1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:621"},{"RTWName":"<S40>/Sum3","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:614"},{"RTWName":"<S40>/Sum4","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:615"},{"RTWName":"<S40>/Sum5","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:622"},{"RTWName":"<S40>/Sum6","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:623"},{"RTWName":"<S40>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:708"},{"RTWName":"<S40>/Out2","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:709"},{"RTWName":"<S39>/Lookup","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:557"},{"RTWName":"<S39>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:610"},{"RTWName":"<S39>/Sum2","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:612"},{"RTWName":"<S41>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:668"},{"RTWName":"<S43>/u","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:692:1"},{"RTWName":"<S43>/Compare","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:692:2"},{"RTWName":"<S43>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:692:3"},{"RTWName":"<S43>/y","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:692:5"},{"RTWName":"<S41>/Data Type Conversion","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:702"},{"RTWName":"<S41>/If","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:683"},{"RTWName":"<S44>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:685"},{"RTWName":"<S44>/Action Port","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:686"},{"RTWName":"<S44>/Convert_back","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:695"},{"RTWName":"<S44>/Convert_uint16","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:694"},{"RTWName":"<S44>/Data Type\nDuplicate","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:679"},{"RTWName":"<S44>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:693"},{"RTWName":"<S44>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:687"},{"RTWName":"<S45>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:689"},{"RTWName":"<S45>/Action Port","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:690"},{"RTWName":"<S45>/Convert_back","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:698"},{"RTWName":"<S45>/Convert_uint16","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:697"},{"RTWName":"<S45>/Data Type\nDuplicate","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:699"},{"RTWName":"<S45>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:700"},{"RTWName":"<S45>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:691"},{"RTWName":"<S41>/Merge","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:696"},{"RTWName":"<S41>/convert_pu","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:652"},{"RTWName":"<S41>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:669"},{"RTWName":"<S42>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:714"},{"RTWName":"<S4294967295>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:716"},{"RTWName":"<S4294967295>/Data Type Conversion","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:723"},{"RTWName":"<S4294967295>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:717"},{"RTWName":"<S46>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:719"},{"RTWName":"<S46>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:720"},{"RTWName":"<S42>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:721"},{"RTWName":"<S39>/indexing","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:605"},{"RTWName":"<S39>/offset","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:657"},{"RTWName":"<S39>/sine_table_values","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:549"},{"RTWName":"<S39>/sin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:248"},{"RTWName":"<S39>/cos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:531"},{"RTWName":"<S4294967295>/Theta","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:529"},{"RTWName":"<S4294967295>/Trig Fcn IQN","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:530"},{"RTWName":"<S4294967295>/Trig Fcn IQN1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:533"},{"RTWName":"<S4294967295>/sin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:531"},{"RTWName":"<S4294967295>/cos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:532"},{"RTWName":"<S35>/sin","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:508"},{"RTWName":"<S35>/cos","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:510"},{"RTWName":"<S30>/Unary Minus","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1174"},{"RTWName":"<S30>/Va","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1169"},{"RTWName":"<S30>/Vb","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1170"},{"RTWName":"<S30>/Vc","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1171"},{"RTWName":"<S28>/Abs","SIDString":"mcb_open_loop_control_nucleo_f401re:3620"},{"RTWName":"<S28>/Correction_Factor_sinePWM","SIDString":"mcb_open_loop_control_nucleo_f401re:3287"},{"RTWName":"<S28>/Mux1","SIDString":"mcb_open_loop_control_nucleo_f401re:3293"},{"RTWName":"<S31>/Theta","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1214"},{"RTWName":"<S47>/Theta","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1181"},{"RTWName":"<S47>/Theta_e_prev","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1194"},{"RTWName":"<S47>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1182"},{"RTWName":"<S47>/Add","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1183"},{"RTWName":"<S47>/Add1","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1184"},{"RTWName":"<S47>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1209"},{"RTWName":"<S47>/Data Type Conversion","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1195"},{"RTWName":"<S47>/Data Type Conversion1","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1215"},{"RTWName":"<S47>/Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1210"},{"RTWName":"<S48>/Input","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1211"},{"RTWName":"<S48>/Enable","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1207"},{"RTWName":"<S48>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1206"},{"RTWName":"<S47>/theta_e","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1188"},{"RTWName":"<S31>/Constant_Reset","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1216"},{"RTWName":"<S31>/Data Type\nDuplicate2","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1192"},{"RTWName":"<S31>/NOT","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1179"},{"RTWName":"<S31>/Unit Delay","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1187"},{"RTWName":"<S31>/scaleIn","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1202"},{"RTWName":"<S31>/scaleOut","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1189"},{"RTWName":"<S31>/eps","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:863"},{"RTWName":"<S32>/Lower Saturation","SIDString":"mcb_open_loop_control_nucleo_f401re:3592"},{"RTWName":"<S32>/Vamplitude","SIDString":"mcb_open_loop_control_nucleo_f401re:3591"},{"RTWName":"<S32>/Relational\nOperator","SIDString":"mcb_open_loop_control_nucleo_f401re:3610"},{"RTWName":"<S32>/Saturation","SIDString":"mcb_open_loop_control_nucleo_f401re:3603"},{"RTWName":"<S32>/Switch","SIDString":"mcb_open_loop_control_nucleo_f401re:3611"},{"RTWName":"<S32>/Amplitude","SIDString":"mcb_open_loop_control_nucleo_f401re:3604"},{"RTWName":"<S28>/V-by-f","SIDString":"mcb_open_loop_control_nucleo_f401re:3309"},{"RTWName":"<S28>/position_increment","SIDString":"mcb_open_loop_control_nucleo_f401re:3312"},{"RTWName":"<S28>/Vabc","SIDString":"mcb_open_loop_control_nucleo_f401re:3536"},{"RTWName":"<S14>/Vabc in PU","SIDString":"mcb_open_loop_control_nucleo_f401re:3316"},{"RTWName":"<S5>/Data Type Conversion","SIDString":"mcb_open_loop_control_nucleo_f401re:3393"},{"RTWName":"<S5>/From","SIDString":"mcb_open_loop_control_nucleo_f401re:3651"},{"RTWName":"<S5>/Goto","SIDString":"mcb_open_loop_control_nucleo_f401re:3650"},{"RTWName":"<S5>/Iab_measured_ADC","SIDString":"mcb_open_loop_control_nucleo_f401re:3639"},{"RTWName":"<S15>/PWM_Duty","SIDString":"mcb_open_loop_control_nucleo_f401re:3372"},{"RTWName":"<S15>/Constant","SIDString":"mcb_open_loop_control_nucleo_f401re:3373"},{"RTWName":"<S15>/Constant1","SIDString":"mcb_open_loop_control_nucleo_f401re:3668"},{"RTWName":"<S15>/Gain","SIDString":"mcb_open_loop_control_nucleo_f401re:3375"},{"RTWName":"<S15>/Product","SIDString":"mcb_open_loop_control_nucleo_f401re:3377"},{"RTWName":"<S15>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:3378"},{"RTWName":"<S15>/Duty Output","SIDString":"mcb_open_loop_control_nucleo_f401re:3379"},{"RTWName":"<S16>/Base Speed","SIDString":"mcb_open_loop_control_nucleo_f401re:3563"},{"RTWName":"<S16>/Data Type","SIDString":"mcb_open_loop_control_nucleo_f401re:3564"},{"RTWName":"<S16>/Event Listener","SIDString":"mcb_open_loop_control_nucleo_f401re:3612"},{"RTWName":"<S16>/Inverter","SIDString":"mcb_open_loop_control_nucleo_f401re:3586"},{"RTWName":"<S16>/Number of pole pairs","SIDString":"mcb_open_loop_control_nucleo_f401re:3565"},{"RTWName":"<S16>/PWM Frequency","SIDString":"mcb_open_loop_control_nucleo_f401re:3566"},{"RTWName":"<S16>/Terminator2","SIDString":"mcb_open_loop_control_nucleo_f401re:3569"},{"RTWName":"<S16>/Terminator3","SIDString":"mcb_open_loop_control_nucleo_f401re:3570"},{"RTWName":"<S16>/Terminator4","SIDString":"mcb_open_loop_control_nucleo_f401re:3571"},{"RTWName":"<S16>/Terminator5","SIDString":"mcb_open_loop_control_nucleo_f401re:3572"},{"RTWName":"<S16>/Terminator6","SIDString":"mcb_open_loop_control_nucleo_f401re:3587"},{"RTWName":"<S4294967295>/PWM Duty Cycle","SIDString":"mcb_open_loop_control_nucleo_f401re:3429"},{"RTWName":"<S4294967295>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3501"},{"RTWName":"<S5>/Variant Sink","SIDString":"mcb_open_loop_control_nucleo_f401re:3500"},{"RTWName":"<S5>/Vabc_PU","SIDString":"mcb_open_loop_control_nucleo_f401re:3396"},{"RTWName":"<S6>/In1","SIDString":"mcb_open_loop_control_nucleo_f401re:3994"},{"RTWName":"<S6>/In2","SIDString":"mcb_open_loop_control_nucleo_f401re:3995"},{"RTWName":"<S6>/Bitwise OR","SIDString":"mcb_open_loop_control_nucleo_f401re:3996"},{"RTWName":"<S6>/Data Type Conversion2","SIDString":"mcb_open_loop_control_nucleo_f401re:3997"},{"RTWName":"<S6>/Data Type Conversion3","SIDString":"mcb_open_loop_control_nucleo_f401re:3998"},{"RTWName":"<S49>/Input","SIDString":"mcb_open_loop_control_nucleo_f401re:4000"},{"RTWName":"<S49>/Data Type Conversion","SIDString":"mcb_open_loop_control_nucleo_f401re:4001"},{"RTWName":"<S49>/Display","SIDString":"mcb_open_loop_control_nucleo_f401re:4002"},{"RTWName":"<S50>:1","SIDString":"mcb_open_loop_control_nucleo_f401re:4003:1"},{"RTWName":"<S49>/Sum","SIDString":"mcb_open_loop_control_nucleo_f401re:4004"},{"RTWName":"<S49>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:4005"},{"RTWName":"<S49>/Out2","SIDString":"mcb_open_loop_control_nucleo_f401re:4006"},{"RTWName":"<S6>/Shift\nArithmetic","SIDString":"mcb_open_loop_control_nucleo_f401re:4007"},{"RTWName":"<S6>/Out1","SIDString":"mcb_open_loop_control_nucleo_f401re:4008"},{"RTWName":"<S6>/Out2","SIDString":"mcb_open_loop_control_nucleo_f401re:4009"},{"RTWName":"<S6>/Out3","SIDString":"mcb_open_loop_control_nucleo_f401re:4010"},{"RTWName":"<S6>/Out4","SIDString":"mcb_open_loop_control_nucleo_f401re:4011"},{"RTWName":"<Root>/Terminator","SIDString":"mcb_open_loop_control_nucleo_f401re:3735"},{"RTWName":"<Root>/CAN-BUS READ","SIDString":"mcb_open_loop_control_nucleo_f401re:3910"},{"RTWName":"<S1>/Bit Concat","SIDString":"mcb_open_loop_control_nucleo_f401re:3911"},{"RTWName":"<S1>/Extract Bits","SIDString":"mcb_open_loop_control_nucleo_f401re:3921"},{"RTWName":"<S1>/Extract Bits1","SIDString":"mcb_open_loop_control_nucleo_f401re:3922"},{"RTWName":"<Root>/CAN-BUS WRITE","SIDString":"mcb_open_loop_control_nucleo_f401re:3905"},{"RTWName":"<Root>/CONTROL RPM AND DIRECTION","SIDString":"mcb_open_loop_control_nucleo_f401re:3926"},{"RTWName":"<Root>/Hardware Interrupt","SIDString":"mcb_open_loop_control_nucleo_f401re:3773"},{"RTWName":"<S4>/ECSoC","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:513"},{"RTWName":"<S10>/ECSimCodegen","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:515"},{"RTWName":"<S10>/SoCSim","SIDString":"mcb_open_loop_control_nucleo_f401re:3773:520"},{"RTWName":"<Root>/Open Loop Control","SIDString":"mcb_open_loop_control_nucleo_f401re:3279"},{"RTWName":"<S5>/Analog to Digital Converter","SIDString":"mcb_open_loop_control_nucleo_f401re:3774"},{"RTWName":"<S12>/ECSoC","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:277"},{"RTWName":"<S17>/ECSimCodegen","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:279"},{"RTWName":"<S17>/SoCSim","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:284"},{"RTWName":"<S4294967295>/Sim","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1065"},{"RTWName":"<S22>/HWSW Message Receive","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069"},{"RTWName":"<S23>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:253"},{"RTWName":"<S24>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:256"},{"RTWName":"<S24>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3774:1069:250"},{"RTWName":"<S5>/Codegen","SIDString":"mcb_open_loop_control_nucleo_f401re:3426"},{"RTWName":"<S13>/Hardware Initialization","SIDString":"mcb_open_loop_control_nucleo_f401re:3362"},{"RTWName":"<S19>/Digital Port Write","SIDString":"mcb_open_loop_control_nucleo_f401re:3779"},{"RTWName":"<S21>/ECSoC","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:345"},{"RTWName":"<S22>/ECSimCodegen","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:350"},{"RTWName":"<S22>/SoCSim","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:356"},{"RTWName":"<S4294967295>/Sim","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:374"},{"RTWName":"<S32>/HWSW Pin 0","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443"},{"RTWName":"<S33>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:278"},{"RTWName":"<S50>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:274"},{"RTWName":"<S50>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:282"},{"RTWName":"<S33>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:248"},{"RTWName":"<S51>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:250"},{"RTWName":"<S51>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:443:255"},{"RTWName":"<S32>/HWSW Pin 1","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444"},{"RTWName":"<S34>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:278"},{"RTWName":"<S56>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:274"},{"RTWName":"<S56>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:282"},{"RTWName":"<S34>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:248"},{"RTWName":"<S57>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:250"},{"RTWName":"<S57>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:444:255"},{"RTWName":"<S32>/HWSW Pin 10","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445"},{"RTWName":"<S35>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:278"},{"RTWName":"<S62>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:274"},{"RTWName":"<S62>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:282"},{"RTWName":"<S35>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:248"},{"RTWName":"<S63>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:250"},{"RTWName":"<S63>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:445:255"},{"RTWName":"<S32>/HWSW Pin 11","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446"},{"RTWName":"<S36>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:278"},{"RTWName":"<S68>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:274"},{"RTWName":"<S68>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:282"},{"RTWName":"<S36>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:248"},{"RTWName":"<S69>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:250"},{"RTWName":"<S69>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:446:255"},{"RTWName":"<S32>/HWSW Pin 12","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447"},{"RTWName":"<S37>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:278"},{"RTWName":"<S74>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:274"},{"RTWName":"<S74>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:282"},{"RTWName":"<S37>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:248"},{"RTWName":"<S75>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:250"},{"RTWName":"<S75>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:447:255"},{"RTWName":"<S32>/HWSW Pin 13","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448"},{"RTWName":"<S38>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:278"},{"RTWName":"<S80>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:274"},{"RTWName":"<S80>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:282"},{"RTWName":"<S38>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:248"},{"RTWName":"<S81>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:250"},{"RTWName":"<S81>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:448:255"},{"RTWName":"<S32>/HWSW Pin 14","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449"},{"RTWName":"<S39>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:278"},{"RTWName":"<S86>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:274"},{"RTWName":"<S86>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:282"},{"RTWName":"<S39>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:248"},{"RTWName":"<S87>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:250"},{"RTWName":"<S87>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:449:255"},{"RTWName":"<S32>/HWSW Pin 15","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450"},{"RTWName":"<S40>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:278"},{"RTWName":"<S92>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:274"},{"RTWName":"<S92>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:282"},{"RTWName":"<S40>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:248"},{"RTWName":"<S93>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:250"},{"RTWName":"<S93>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:450:255"},{"RTWName":"<S32>/HWSW Pin 16","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451"},{"RTWName":"<S41>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:278"},{"RTWName":"<S98>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:274"},{"RTWName":"<S98>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:282"},{"RTWName":"<S41>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:248"},{"RTWName":"<S99>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:250"},{"RTWName":"<S99>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:451:255"},{"RTWName":"<S32>/HWSW Pin 2","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452"},{"RTWName":"<S42>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:278"},{"RTWName":"<S104>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:274"},{"RTWName":"<S104>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:282"},{"RTWName":"<S42>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:248"},{"RTWName":"<S105>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:250"},{"RTWName":"<S105>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:452:255"},{"RTWName":"<S32>/HWSW Pin 3","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453"},{"RTWName":"<S43>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:278"},{"RTWName":"<S110>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:274"},{"RTWName":"<S110>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:282"},{"RTWName":"<S43>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:248"},{"RTWName":"<S111>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:250"},{"RTWName":"<S111>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:453:255"},{"RTWName":"<S32>/HWSW Pin 4","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454"},{"RTWName":"<S44>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:278"},{"RTWName":"<S116>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:274"},{"RTWName":"<S116>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:282"},{"RTWName":"<S44>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:248"},{"RTWName":"<S117>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:250"},{"RTWName":"<S117>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:454:255"},{"RTWName":"<S32>/HWSW Pin 5","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455"},{"RTWName":"<S45>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:278"},{"RTWName":"<S122>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:274"},{"RTWName":"<S122>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:282"},{"RTWName":"<S45>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:248"},{"RTWName":"<S123>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:250"},{"RTWName":"<S123>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:455:255"},{"RTWName":"<S32>/HWSW Pin 6","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456"},{"RTWName":"<S46>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:278"},{"RTWName":"<S128>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:274"},{"RTWName":"<S128>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:282"},{"RTWName":"<S46>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:248"},{"RTWName":"<S129>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:250"},{"RTWName":"<S129>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:456:255"},{"RTWName":"<S32>/HWSW Pin 7","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457"},{"RTWName":"<S47>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:278"},{"RTWName":"<S134>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:274"},{"RTWName":"<S134>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:282"},{"RTWName":"<S47>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:248"},{"RTWName":"<S135>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:250"},{"RTWName":"<S135>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:457:255"},{"RTWName":"<S32>/HWSW Pin 8","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458"},{"RTWName":"<S48>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:278"},{"RTWName":"<S140>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:274"},{"RTWName":"<S140>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:282"},{"RTWName":"<S48>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:248"},{"RTWName":"<S141>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:250"},{"RTWName":"<S141>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:458:255"},{"RTWName":"<S32>/HWSW Pin 9","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459"},{"RTWName":"<S49>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:278"},{"RTWName":"<S146>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:274"},{"RTWName":"<S146>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:282"},{"RTWName":"<S49>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:248"},{"RTWName":"<S147>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:250"},{"RTWName":"<S147>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3779:459:255"},{"RTWName":"<S13>/PWM Output","SIDString":"mcb_open_loop_control_nucleo_f401re:3380"},{"RTWName":"<S20>/PWM Output1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778"},{"RTWName":"<S24>/ECSoC","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2099"},{"RTWName":"<S25>/ECSimCodegen","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2101"},{"RTWName":"<S25>/SoCSim","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2104"},{"RTWName":"<S4294967295>/Sim","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2109"},{"RTWName":"<S156>/HWSW CH1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122"},{"RTWName":"<S157>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:278"},{"RTWName":"<S165>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:274"},{"RTWName":"<S165>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:282"},{"RTWName":"<S157>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:248"},{"RTWName":"<S166>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:250"},{"RTWName":"<S166>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2122:255"},{"RTWName":"<S156>/HWSW CH2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123"},{"RTWName":"<S158>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:278"},{"RTWName":"<S171>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:274"},{"RTWName":"<S171>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:282"},{"RTWName":"<S158>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:248"},{"RTWName":"<S172>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:250"},{"RTWName":"<S172>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2123:255"},{"RTWName":"<S156>/HWSW CH3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124"},{"RTWName":"<S159>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:278"},{"RTWName":"<S177>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:274"},{"RTWName":"<S177>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:282"},{"RTWName":"<S159>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:248"},{"RTWName":"<S178>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:250"},{"RTWName":"<S178>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2124:255"},{"RTWName":"<S156>/HWSW CH4","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125"},{"RTWName":"<S160>/Done Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:278"},{"RTWName":"<S183>/Done Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:274"},{"RTWName":"<S183>/Done On","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:282"},{"RTWName":"<S160>/Event Variant","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:248"},{"RTWName":"<S184>/Event Off","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:250"},{"RTWName":"<S184>/Event On","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2125:255"},{"RTWName":"<S156>/Subsystem","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2126"},{"RTWName":"<S156>/Subsystem1","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2140"},{"RTWName":"<S156>/Subsystem2","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2154"},{"RTWName":"<S156>/Subsystem3","SIDString":"mcb_open_loop_control_nucleo_f401re:3778:2168"},{"RTWName":"<S5>/Control_System","SIDString":"mcb_open_loop_control_nucleo_f401re:3282"},{"RTWName":"<S14>/SpeedRefToFreq","SIDString":"mcb_open_loop_control_nucleo_f401re:3531"},{"RTWName":"<S27>/Ramp Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3296"},{"RTWName":"<S27>/Rate Limiter","SIDString":"mcb_open_loop_control_nucleo_f401re:3626"},{"RTWName":"<S4294967295>/IIR Filter","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:346"},{"RTWName":"<S193>/High-pass","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:349"},{"RTWName":"<S193>/Low-pass","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:354"},{"RTWName":"<S195>/IIR Low Pass Filter","SIDString":"mcb_open_loop_control_nucleo_f401re:3626:356"},{"RTWName":"<S14>/VabcCalc","SIDString":"mcb_open_loop_control_nucleo_f401re:3534"},{"RTWName":"<S28>/3-Phase Sine Voltage Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3502"},{"RTWName":"<S30>/Inverse Clarke Transform","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177"},{"RTWName":"<S33>/Three phase input","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:533"},{"RTWName":"<S33>/Two phase input","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1177:506"},{"RTWName":"<S30>/Inverse Park Transform","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176"},{"RTWName":"<S34>/Sine Cosine","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850"},{"RTWName":"<S4294967295>/SinCos_Subsystem","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:516"},{"RTWName":"<S4294967295>/Sine-Cosine Lookup","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76"},{"RTWName":"<S209>/Interpolation","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:705"},{"RTWName":"<S209>/WrapUp","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:667"},{"RTWName":"<S212>/If Action\nSubsystem","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:684"},{"RTWName":"<S212>/If Action\nSubsystem1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:688"},{"RTWName":"<S209>/datatype","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:713"},{"RTWName":"<S213>/datatype backpropogation","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:715"},{"RTWName":"<S213>/datatype no change","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:76:718"},{"RTWName":"<S4294967295>/Trig Fcn IQN","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:850:528"},{"RTWName":"<S34>/Three inputs","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:904"},{"RTWName":"<S4294967295>/Two inputs CRL","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:984"},{"RTWName":"<S218>/Switch_Axis","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:991"},{"RTWName":"<S34>/Two inputs CRL","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:778"},{"RTWName":"<S37>/Switch_Axis","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1176:748"},{"RTWName":"<S30>/Sine-Cosine Lookup","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180"},{"RTWName":"<S35>/SinCos_Subsystem","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:516"},{"RTWName":"<S35>/Sine-Cosine Lookup","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76"},{"RTWName":"<S39>/Interpolation","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:705"},{"RTWName":"<S39>/WrapUp","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:667"},{"RTWName":"<S41>/Compare\nTo Zero","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:692"},{"RTWName":"<S41>/If Action\nSubsystem","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:684"},{"RTWName":"<S41>/If Action\nSubsystem1","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:688"},{"RTWName":"<S39>/datatype","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:713"},{"RTWName":"<S42>/datatype backpropogation","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:715"},{"RTWName":"<S42>/datatype no change","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:76:718"},{"RTWName":"<S35>/Trig Fcn IQN","SIDString":"mcb_open_loop_control_nucleo_f401re:3502:1180:528"},{"RTWName":"<S28>/Position Generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3294"},{"RTWName":"<S31>/Accumulate","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1180"},{"RTWName":"<S47>/Subsystem","SIDString":"mcb_open_loop_control_nucleo_f401re:3294:1204"},{"RTWName":"<S28>/Saturate output to limits","SIDString":"mcb_open_loop_control_nucleo_f401re:3590"},{"RTWName":"<S5>/Output Scaling","SIDString":"mcb_open_loop_control_nucleo_f401re:3371"},{"RTWName":"<S5>/Parameters","SIDString":"mcb_open_loop_control_nucleo_f401re:3562"},{"RTWName":"<S5>/Sim","SIDString":"mcb_open_loop_control_nucleo_f401re:3428"},{"RTWName":"<Root>/Subsystem","SIDString":"mcb_open_loop_control_nucleo_f401re:3969"},{"RTWName":"<S6>/Safety code generator","SIDString":"mcb_open_loop_control_nucleo_f401re:3999"},{"RTWName":"<S49>/MATLAB Function","SIDString":"mcb_open_loop_control_nucleo_f401re:4003"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};